var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _js, _xr, _ks, _Sr, _vr, _Cr, _kr, _PDFWorker_instances, Ir_fn, Tr_fn, Fr_fn, Mr_fn, _PDFWorker_static, Er_get;
void 0 === globalThis.DOMMatrix && (globalThis.DOMMatrix = class {
}), void 0 === globalThis.FinalizationRegistry && (globalThis.FinalizationRegistry = class {
  register() {
  }
  unregister() {
  }
}), globalThis.navigator ??= {}, globalThis.navigator.platform ??= "", globalThis.navigator.userAgent ??= "", void 0 === Promise.withResolvers && (Promise.withResolvers = function() {
  let e2, t2;
  return { promise: new Promise((i2, n2) => {
    e2 = i2, t2 = n2;
  }), resolve: e2, reject: t2 };
});
const e = !("object" != typeof process || process + "" != "[object process]" || process.versions.nw || process.versions.electron && process.type && "browser" !== process.type), t = [1e-3, 0, 0, 1e-3, 0, 0], i = 1.35, n = 0.35, a = 0.25925925925925924, s = 1, r = 2, o = 4, l = 8, c = 16, h = 64, d = 128, u = 256, g = "pdfjs_internal_editor_", f = 3, p = 9, m = 13, b = 15, y = 101, w = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 }, x = 0, S = 4, v = 1, C = 2, k = 3, T = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 }, F = "Group", E = "R", M = 1, D = 2, O = 4, _ = 16, R = 32, N = 128, L = 512, U = 1, j = 2, $ = 4096, H = 8192, X = 32768, q = 65536, z = 131072, W = 1048576, G = 2097152, V = 8388608, K = 16777216, Y = 1, J = 2, Z = 3, Q = 4, ee = 5, te = { E: "Mouse Enter", X: "Mouse Exit", D: "Mouse Down", U: "Mouse Up", Fo: "Focus", Bl: "Blur", PO: "PageOpen", PC: "PageClose", PV: "PageVisible", PI: "PageInvisible", K: "Keystroke", F: "Format", V: "Validate", C: "Calculate" }, ie = { WC: "WillClose", WS: "WillSave", DS: "DidSave", WP: "WillPrint", DP: "DidPrint" }, ne = { O: "PageOpen", C: "PageClose" }, ae = 1, se = 5, re = 1, oe = 2, le = 3, ce = 4, he = 5, de = 6, ue = 7, ge = 8, fe = 9, pe = 10, me = 11, be = 12, ye = 13, we = 14, Ae = 15, xe = 16, Se = 17, ve = 18, Ce = 19, ke = 20, Te = 21, Fe = 22, Ie = 23, Ee = 24, Me = 25, De = 26, Oe = 27, _e = 28, Pe = 29, Re = 30, Be = 31, Ne = 32, Le = 33, Ue = 34, je = 35, $e = 36, He = 37, Xe = 38, qe = 39, ze = 40, We = 41, Ge = 42, Ve = 43, Ke = 44, Ye = 45, Je = 46, Ze = 47, Qe = 48, et = 49, tt = 50, it = 51, nt = 52, at = 53, st = 54, rt = 55, ot = 56, lt = 57, ct = 58, ht = 59, dt = 60, ut = 61, gt = 62, ft = 63, pt = 64, mt = 65, bt = 66, yt = 67, wt = 68, At = 69, xt = 70, St = 71, vt = 72, Ct = 73, kt = 74, Tt = 75, Ft = 76, It = 77, Et = 80, Mt = 81, Dt = 83, Ot = 84, _t = 85, Pt = 86, Rt = 87, Bt = 88, Nt = 89, Lt = 90, Ut = 91, jt = 92, $t = 93, Ht = 94, Xt = 0, qt = 1, zt = 2, Wt = 3, Gt = 1, Vt = 2;
let Kt = ae;
function info$1(e2) {
  Kt >= se && console.info(`Info: ${e2}`);
}
function warn$1(e2) {
  Kt >= ae && console.warn(`Warning: ${e2}`);
}
function unreachable$1(e2) {
  throw new Error(e2);
}
function assert$1(e2, t2) {
  e2 || unreachable$1(t2);
}
function createValidAbsoluteUrl$1(e2, t2 = null, i2 = null) {
  if (!e2) return null;
  if (i2 && "string" == typeof e2) {
    if (i2.addDefaultProtocol && e2.startsWith("www.")) {
      const t3 = e2.match(/\./g);
      t3?.length >= 2 && (e2 = `http://${e2}`);
    }
    if (i2.tryConvertEncoding) try {
      e2 = stringToUTF8String$1(e2);
    } catch {
    }
  }
  const n2 = t2 ? URL.parse(e2, t2) : URL.parse(e2);
  return (function(e3) {
    switch (e3?.protocol) {
      case "http:":
      case "https:":
      case "ftp:":
      case "mailto:":
      case "tel:":
        return true;
      default:
        return false;
    }
  })(n2) ? n2 : null;
}
function shadow$1(e2, t2, i2, n2 = false) {
  return Object.defineProperty(e2, t2, { value: i2, enumerable: !n2, configurable: true, writable: false }), i2;
}
const Yt = (function() {
  function BaseException(e2, t2) {
    this.message = e2, this.name = t2;
  }
  return BaseException.prototype = new Error(), BaseException.constructor = BaseException, BaseException;
})();
let Jt = class extends Yt {
  constructor(e2, t2) {
    super(e2, "PasswordException"), this.code = t2;
  }
}, Zt = class extends Yt {
  constructor(e2, t2) {
    super(e2, "UnknownErrorException"), this.details = t2;
  }
}, Qt = class extends Yt {
  constructor(e2) {
    super(e2, "InvalidPDFException");
  }
}, ei = class extends Yt {
  constructor(e2, t2, i2) {
    super(e2, "ResponseException"), this.status = t2, this.missing = i2;
  }
}, ti = class extends Yt {
  constructor(e2) {
    super(e2, "FormatError");
  }
}, ii = class extends Yt {
  constructor(e2) {
    super(e2, "AbortException");
  }
};
function bytesToString$1(e2) {
  "object" == typeof e2 && void 0 !== e2?.length || unreachable$1("Invalid argument for bytesToString");
  const t2 = e2.length, i2 = 8192;
  if (t2 < i2) return String.fromCharCode.apply(null, e2);
  const n2 = [];
  for (let a2 = 0; a2 < t2; a2 += i2) {
    const s2 = Math.min(a2 + i2, t2), r2 = e2.subarray(a2, s2);
    n2.push(String.fromCharCode.apply(null, r2));
  }
  return n2.join("");
}
function stringToBytes$1(e2) {
  "string" != typeof e2 && unreachable$1("Invalid argument for stringToBytes");
  const t2 = e2.length, i2 = new Uint8Array(t2);
  for (let n2 = 0; n2 < t2; ++n2) i2[n2] = 255 & e2.charCodeAt(n2);
  return i2;
}
function string32$1(e2) {
  return String.fromCharCode(e2 >> 24 & 255, e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2);
}
function objectSize(e2) {
  return Object.keys(e2).length;
}
class FeatureTest {
  static get isLittleEndian() {
    return shadow$1(this, "isLittleEndian", (function() {
      const e2 = new Uint8Array(4);
      return e2[0] = 1, 1 === new Uint32Array(e2.buffer, 0, 1)[0];
    })());
  }
  static get isEvalSupported() {
    return shadow$1(this, "isEvalSupported", (function() {
      try {
        return new Function(""), true;
      } catch {
        return false;
      }
    })());
  }
  static get isOffscreenCanvasSupported() {
    return shadow$1(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
  }
  static get isImageDecoderSupported() {
    return shadow$1(this, "isImageDecoderSupported", "undefined" != typeof ImageDecoder);
  }
  static get platform() {
    const { platform: e2, userAgent: t2 } = navigator;
    return shadow$1(this, "platform", { isAndroid: t2.includes("Android"), isLinux: e2.includes("Linux"), isMac: e2.includes("Mac"), isWindows: e2.includes("Win"), isFirefox: t2.includes("Firefox") });
  }
  static get isCSSRoundSupported() {
    return shadow$1(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
  }
}
const ni = Array.from(Array(256).keys(), (e2) => e2.toString(16).padStart(2, "0"));
let ai = class {
  static makeHexColor(e2, t2, i2) {
    return `#${ni[e2]}${ni[t2]}${ni[i2]}`;
  }
  static domMatrixToTransform(e2) {
    return [e2.a, e2.b, e2.c, e2.d, e2.e, e2.f];
  }
  static scaleMinMax(e2, t2) {
    let i2;
    e2[0] ? (e2[0] < 0 && (i2 = t2[0], t2[0] = t2[2], t2[2] = i2), t2[0] *= e2[0], t2[2] *= e2[0], e2[3] < 0 && (i2 = t2[1], t2[1] = t2[3], t2[3] = i2), t2[1] *= e2[3], t2[3] *= e2[3]) : (i2 = t2[0], t2[0] = t2[1], t2[1] = i2, i2 = t2[2], t2[2] = t2[3], t2[3] = i2, e2[1] < 0 && (i2 = t2[1], t2[1] = t2[3], t2[3] = i2), t2[1] *= e2[1], t2[3] *= e2[1], e2[2] < 0 && (i2 = t2[0], t2[0] = t2[2], t2[2] = i2), t2[0] *= e2[2], t2[2] *= e2[2]), t2[0] += e2[4], t2[1] += e2[5], t2[2] += e2[4], t2[3] += e2[5];
  }
  static transform(e2, t2) {
    return [e2[0] * t2[0] + e2[2] * t2[1], e2[1] * t2[0] + e2[3] * t2[1], e2[0] * t2[2] + e2[2] * t2[3], e2[1] * t2[2] + e2[3] * t2[3], e2[0] * t2[4] + e2[2] * t2[5] + e2[4], e2[1] * t2[4] + e2[3] * t2[5] + e2[5]];
  }
  static multiplyByDOMMatrix(e2, t2) {
    return [e2[0] * t2.a + e2[2] * t2.b, e2[1] * t2.a + e2[3] * t2.b, e2[0] * t2.c + e2[2] * t2.d, e2[1] * t2.c + e2[3] * t2.d, e2[0] * t2.e + e2[2] * t2.f + e2[4], e2[1] * t2.e + e2[3] * t2.f + e2[5]];
  }
  static applyTransform(e2, t2, i2 = 0) {
    const n2 = e2[i2], a2 = e2[i2 + 1];
    e2[i2] = n2 * t2[0] + a2 * t2[2] + t2[4], e2[i2 + 1] = n2 * t2[1] + a2 * t2[3] + t2[5];
  }
  static applyTransformToBezier(e2, t2, i2 = 0) {
    const n2 = t2[0], a2 = t2[1], s2 = t2[2], r2 = t2[3], o2 = t2[4], l2 = t2[5];
    for (let t3 = 0; t3 < 6; t3 += 2) {
      const c2 = e2[i2 + t3], h2 = e2[i2 + t3 + 1];
      e2[i2 + t3] = c2 * n2 + h2 * s2 + o2, e2[i2 + t3 + 1] = c2 * a2 + h2 * r2 + l2;
    }
  }
  static applyInverseTransform(e2, t2) {
    const i2 = e2[0], n2 = e2[1], a2 = t2[0] * t2[3] - t2[1] * t2[2];
    e2[0] = (i2 * t2[3] - n2 * t2[2] + t2[2] * t2[5] - t2[4] * t2[3]) / a2, e2[1] = (-i2 * t2[1] + n2 * t2[0] + t2[4] * t2[1] - t2[5] * t2[0]) / a2;
  }
  static axialAlignedBoundingBox(e2, t2, i2) {
    const n2 = t2[0], a2 = t2[1], s2 = t2[2], r2 = t2[3], o2 = t2[4], l2 = t2[5], c2 = e2[0], h2 = e2[1], d2 = e2[2], u2 = e2[3];
    let g2 = n2 * c2 + o2, f2 = g2, p2 = n2 * d2 + o2, m2 = p2, b2 = r2 * h2 + l2, y2 = b2, w2 = r2 * u2 + l2, x2 = w2;
    if (0 !== a2 || 0 !== s2) {
      const e3 = a2 * c2, t3 = a2 * d2, i3 = s2 * h2, n3 = s2 * u2;
      g2 += i3, m2 += i3, p2 += n3, f2 += n3, b2 += e3, x2 += e3, w2 += t3, y2 += t3;
    }
    i2[0] = Math.min(i2[0], g2, p2, f2, m2), i2[1] = Math.min(i2[1], b2, w2, y2, x2), i2[2] = Math.max(i2[2], g2, p2, f2, m2), i2[3] = Math.max(i2[3], b2, w2, y2, x2);
  }
  static inverseTransform(e2) {
    const t2 = e2[0] * e2[3] - e2[1] * e2[2];
    return [e2[3] / t2, -e2[1] / t2, -e2[2] / t2, e2[0] / t2, (e2[2] * e2[5] - e2[4] * e2[3]) / t2, (e2[4] * e2[1] - e2[5] * e2[0]) / t2];
  }
  static singularValueDecompose2dScale(e2, t2) {
    const i2 = e2[0], n2 = e2[1], a2 = e2[2], s2 = e2[3], r2 = i2 ** 2 + n2 ** 2, o2 = i2 * a2 + n2 * s2, l2 = a2 ** 2 + s2 ** 2, c2 = (r2 + l2) / 2, h2 = Math.sqrt(c2 ** 2 - (r2 * l2 - o2 ** 2));
    t2[0] = Math.sqrt(c2 + h2 || 1), t2[1] = Math.sqrt(c2 - h2 || 1);
  }
  static normalizeRect(e2) {
    const t2 = e2.slice(0);
    return e2[0] > e2[2] && (t2[0] = e2[2], t2[2] = e2[0]), e2[1] > e2[3] && (t2[1] = e2[3], t2[3] = e2[1]), t2;
  }
  static intersect(e2, t2) {
    const i2 = Math.max(Math.min(e2[0], e2[2]), Math.min(t2[0], t2[2])), n2 = Math.min(Math.max(e2[0], e2[2]), Math.max(t2[0], t2[2]));
    if (i2 > n2) return null;
    const a2 = Math.max(Math.min(e2[1], e2[3]), Math.min(t2[1], t2[3])), s2 = Math.min(Math.max(e2[1], e2[3]), Math.max(t2[1], t2[3]));
    return a2 > s2 ? null : [i2, a2, n2, s2];
  }
  static pointBoundingBox(e2, t2, i2) {
    i2[0] = Math.min(i2[0], e2), i2[1] = Math.min(i2[1], t2), i2[2] = Math.max(i2[2], e2), i2[3] = Math.max(i2[3], t2);
  }
  static rectBoundingBox(e2, t2, i2, n2, a2) {
    a2[0] = Math.min(a2[0], e2, i2), a2[1] = Math.min(a2[1], t2, n2), a2[2] = Math.max(a2[2], e2, i2), a2[3] = Math.max(a2[3], t2, n2);
  }
  static #e(e2, t2, i2, n2, a2, s2, r2, o2, l2, c2) {
    if (l2 <= 0 || l2 >= 1) return;
    const h2 = 1 - l2, d2 = l2 * l2, u2 = d2 * l2, g2 = h2 * (h2 * (h2 * e2 + 3 * l2 * t2) + 3 * d2 * i2) + u2 * n2, f2 = h2 * (h2 * (h2 * a2 + 3 * l2 * s2) + 3 * d2 * r2) + u2 * o2;
    c2[0] = Math.min(c2[0], g2), c2[1] = Math.min(c2[1], f2), c2[2] = Math.max(c2[2], g2), c2[3] = Math.max(c2[3], f2);
  }
  static #t(e2, t2, i2, n2, a2, s2, r2, o2, l2, c2, h2, d2) {
    if (Math.abs(l2) < 1e-12) return void (Math.abs(c2) >= 1e-12 && this.#e(e2, t2, i2, n2, a2, s2, r2, o2, -h2 / c2, d2));
    const u2 = c2 ** 2 - 4 * h2 * l2;
    if (u2 < 0) return;
    const g2 = Math.sqrt(u2), f2 = 2 * l2;
    this.#e(e2, t2, i2, n2, a2, s2, r2, o2, (-c2 + g2) / f2, d2), this.#e(e2, t2, i2, n2, a2, s2, r2, o2, (-c2 - g2) / f2, d2);
  }
  static bezierBoundingBox(e2, t2, i2, n2, a2, s2, r2, o2, l2) {
    l2[0] = Math.min(l2[0], e2, r2), l2[1] = Math.min(l2[1], t2, o2), l2[2] = Math.max(l2[2], e2, r2), l2[3] = Math.max(l2[3], t2, o2), this.#t(e2, i2, a2, r2, t2, n2, s2, o2, 3 * (3 * (i2 - a2) - e2 + r2), 6 * (e2 - 2 * i2 + a2), 3 * (i2 - e2), l2), this.#t(e2, i2, a2, r2, t2, n2, s2, o2, 3 * (3 * (n2 - s2) - t2 + o2), 6 * (t2 - 2 * n2 + s2), 3 * (n2 - t2), l2);
  }
};
const si = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
function stringToPDFString(e2, t2 = false) {
  if (e2[0] >= "ï") {
    let i3;
    if ("þ" === e2[0] && "ÿ" === e2[1] ? (i3 = "utf-16be", e2.length % 2 == 1 && (e2 = e2.slice(0, -1))) : "ÿ" === e2[0] && "þ" === e2[1] ? (i3 = "utf-16le", e2.length % 2 == 1 && (e2 = e2.slice(0, -1))) : "ï" === e2[0] && "»" === e2[1] && "¿" === e2[2] && (i3 = "utf-8"), i3) try {
      const n2 = new TextDecoder(i3, { fatal: true }), a2 = stringToBytes$1(e2), s2 = n2.decode(a2);
      return t2 || !s2.includes("\x1B") ? s2 : s2.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "");
    } catch (e3) {
      warn$1(`stringToPDFString: "${e3}".`);
    }
  }
  const i2 = [];
  for (let n2 = 0, a2 = e2.length; n2 < a2; n2++) {
    const s2 = e2.charCodeAt(n2);
    if (!t2 && 27 === s2) {
      for (; ++n2 < a2 && 27 !== e2.charCodeAt(n2); ) ;
      continue;
    }
    const r2 = si[s2];
    i2.push(r2 ? String.fromCharCode(r2) : e2.charAt(n2));
  }
  return i2.join("");
}
function stringToUTF8String$1(e2) {
  return decodeURIComponent(escape(e2));
}
function utf8StringToString(e2) {
  return unescape(encodeURIComponent(e2));
}
function isArrayEqual(e2, t2) {
  if (e2.length !== t2.length) return false;
  for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) if (e2[i2] !== t2[i2]) return false;
  return true;
}
function getModificationDate(e2 = /* @__PURE__ */ new Date()) {
  e2 instanceof Date || (e2 = new Date(e2));
  return [e2.getUTCFullYear().toString(), (e2.getUTCMonth() + 1).toString().padStart(2, "0"), e2.getUTCDate().toString().padStart(2, "0"), e2.getUTCHours().toString().padStart(2, "0"), e2.getUTCMinutes().toString().padStart(2, "0"), e2.getUTCSeconds().toString().padStart(2, "0")].join("");
}
let ri = null, oi = null;
function MathClamp$1(e2, t2, i2) {
  return Math.min(Math.max(e2, t2), i2);
}
function toHexUtil(e2) {
  return Uint8Array.prototype.toHex ? e2.toHex() : Array.from(e2, (e3) => ni[e3]).join("");
}
"function" != typeof Promise.try && (Promise.try = function(e2, ...t2) {
  return new Promise((i2) => {
    i2(e2(...t2));
  });
}), "function" != typeof Math.sumPrecise && (Math.sumPrecise = function(e2) {
  return e2.reduce((e3, t2) => e3 + t2, 0);
});
const li = Symbol("CIRCULAR_REF"), ci = Symbol("EOF");
let hi = /* @__PURE__ */ Object.create(null), di = /* @__PURE__ */ Object.create(null), ui = /* @__PURE__ */ Object.create(null);
class Name {
  constructor(e2) {
    this.name = e2;
  }
  static get(e2) {
    return di[e2] ||= new Name(e2);
  }
}
class Cmd {
  constructor(e2) {
    this.cmd = e2;
  }
  static get(e2) {
    return hi[e2] ||= new Cmd(e2);
  }
}
const nonSerializable = function() {
  return nonSerializable;
};
class Dict {
  constructor(e2 = null) {
    this._map = /* @__PURE__ */ new Map(), this.xref = e2, this.objId = null, this.suppressEncryption = false, this.__nonSerializable__ = nonSerializable;
  }
  assignXref(e2) {
    this.xref = e2;
  }
  get size() {
    return this._map.size;
  }
  get(e2, t2, i2) {
    let n2 = this._map.get(e2);
    return void 0 === n2 && void 0 !== t2 && (n2 = this._map.get(t2), void 0 === n2 && void 0 !== i2 && (n2 = this._map.get(i2))), n2 instanceof Ref && this.xref ? this.xref.fetch(n2, this.suppressEncryption) : n2;
  }
  async getAsync(e2, t2, i2) {
    let n2 = this._map.get(e2);
    return void 0 === n2 && void 0 !== t2 && (n2 = this._map.get(t2), void 0 === n2 && void 0 !== i2 && (n2 = this._map.get(i2))), n2 instanceof Ref && this.xref ? this.xref.fetchAsync(n2, this.suppressEncryption) : n2;
  }
  getArray(e2, t2, i2) {
    let n2 = this._map.get(e2);
    if (void 0 === n2 && void 0 !== t2 && (n2 = this._map.get(t2), void 0 === n2 && void 0 !== i2 && (n2 = this._map.get(i2))), n2 instanceof Ref && this.xref && (n2 = this.xref.fetch(n2, this.suppressEncryption)), Array.isArray(n2)) {
      n2 = n2.slice();
      for (let e3 = 0, t3 = n2.length; e3 < t3; e3++) n2[e3] instanceof Ref && this.xref && (n2[e3] = this.xref.fetch(n2[e3], this.suppressEncryption));
    }
    return n2;
  }
  getRaw(e2) {
    return this._map.get(e2);
  }
  getKeys() {
    return [...this._map.keys()];
  }
  getRawValues() {
    return [...this._map.values()];
  }
  set(e2, t2) {
    this._map.set(e2, t2);
  }
  setIfNotExists(e2, t2) {
    this.has(e2) || this.set(e2, t2);
  }
  setIfNumber(e2, t2) {
    "number" == typeof t2 && this.set(e2, t2);
  }
  setIfArray(e2, t2) {
    (Array.isArray(t2) || ArrayBuffer.isView(t2)) && this.set(e2, t2);
  }
  setIfDefined(e2, t2) {
    null != t2 && this.set(e2, t2);
  }
  setIfName(e2, t2) {
    "string" == typeof t2 ? this.set(e2, Name.get(t2)) : t2 instanceof Name && this.set(e2, t2);
  }
  has(e2) {
    return this._map.has(e2);
  }
  *[Symbol.iterator]() {
    for (const [e2, t2] of this._map) yield [e2, t2 instanceof Ref && this.xref ? this.xref.fetch(t2, this.suppressEncryption) : t2];
  }
  static get empty() {
    const e2 = new Dict(null);
    return e2.set = (e3, t2) => {
      unreachable$1("Should not call `set` on the empty dictionary.");
    }, shadow$1(this, "empty", e2);
  }
  static merge({ xref: e2, dictArray: t2, mergeSubDicts: i2 = false }) {
    const n2 = new Dict(e2), a2 = /* @__PURE__ */ new Map();
    for (const e3 of t2) if (e3 instanceof Dict) for (const [t3, n3] of e3._map) {
      let e4 = a2.get(t3);
      if (void 0 === e4) e4 = [], a2.set(t3, e4);
      else if (!(i2 && n3 instanceof Dict)) continue;
      e4.push(n3);
    }
    for (const [t3, i3] of a2) {
      if (1 === i3.length || !(i3[0] instanceof Dict)) {
        n2._map.set(t3, i3[0]);
        continue;
      }
      const a3 = new Dict(e2);
      for (const e3 of i3) for (const [t4, i4] of e3._map) a3._map.has(t4) || a3._map.set(t4, i4);
      a3.size > 0 && n2._map.set(t3, a3);
    }
    return a2.clear(), n2.size > 0 ? n2 : Dict.empty;
  }
  clone() {
    const e2 = new Dict(this.xref);
    for (const t2 of this.getKeys()) e2.set(t2, this.getRaw(t2));
    return e2;
  }
  delete(e2) {
    this._map.delete(e2);
  }
}
class Ref {
  constructor(e2, t2) {
    this.num = e2, this.gen = t2;
  }
  toString() {
    return 0 === this.gen ? `${this.num}R` : `${this.num}R${this.gen}`;
  }
  static fromString(e2) {
    const t2 = ui[e2];
    if (t2) return t2;
    const i2 = /^(\d+)R(\d*)$/.exec(e2);
    return i2 && "0" !== i2[1] ? ui[e2] = new Ref(parseInt(i2[1]), i2[2] ? parseInt(i2[2]) : 0) : null;
  }
  static get(e2, t2) {
    const i2 = 0 === t2 ? `${e2}R` : `${e2}R${t2}`;
    return ui[i2] ||= new Ref(e2, t2);
  }
}
class RefSet {
  constructor(e2 = null) {
    this._set = new Set(e2?._set);
  }
  has(e2) {
    return this._set.has(e2.toString());
  }
  put(e2) {
    this._set.add(e2.toString());
  }
  remove(e2) {
    this._set.delete(e2.toString());
  }
  [Symbol.iterator]() {
    return this._set.values();
  }
  clear() {
    this._set.clear();
  }
}
class RefSetCache {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._map.size;
  }
  get(e2) {
    return this._map.get(e2.toString());
  }
  has(e2) {
    return this._map.has(e2.toString());
  }
  put(e2, t2) {
    this._map.set(e2.toString(), t2);
  }
  putAlias(e2, t2) {
    this._map.set(e2.toString(), this.get(t2));
  }
  [Symbol.iterator]() {
    return this._map.values();
  }
  clear() {
    this._map.clear();
  }
  *values() {
    yield* this._map.values();
  }
  *items() {
    for (const [e2, t2] of this._map) yield [Ref.fromString(e2), t2];
  }
}
function isName(e2, t2) {
  return e2 instanceof Name && (void 0 === t2 || e2.name === t2);
}
function isCmd(e2, t2) {
  return e2 instanceof Cmd && (void 0 === t2 || e2.cmd === t2);
}
function isDict(e2, t2) {
  return e2 instanceof Dict && (void 0 === t2 || isName(e2.get("Type"), t2));
}
function isRefsEqual(e2, t2) {
  return e2.num === t2.num && e2.gen === t2.gen;
}
class BaseStream {
  get length() {
    unreachable$1("Abstract getter `length` accessed");
  }
  get isEmpty() {
    unreachable$1("Abstract getter `isEmpty` accessed");
  }
  get isDataLoaded() {
    return shadow$1(this, "isDataLoaded", true);
  }
  getByte() {
    unreachable$1("Abstract method `getByte` called");
  }
  getBytes(e2) {
    unreachable$1("Abstract method `getBytes` called");
  }
  async getImageData(e2, t2) {
    return this.getBytes(e2, t2);
  }
  async asyncGetBytes() {
    unreachable$1("Abstract method `asyncGetBytes` called");
  }
  get isAsync() {
    return false;
  }
  get isAsyncDecoder() {
    return false;
  }
  get canAsyncDecodeImageFromBuffer() {
    return false;
  }
  async getTransferableImage() {
    return null;
  }
  peekByte() {
    const e2 = this.getByte();
    return -1 !== e2 && this.pos--, e2;
  }
  peekBytes(e2) {
    const t2 = this.getBytes(e2);
    return this.pos -= t2.length, t2;
  }
  getUint16() {
    const e2 = this.getByte(), t2 = this.getByte();
    return -1 === e2 || -1 === t2 ? -1 : (e2 << 8) + t2;
  }
  getInt32() {
    return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte();
  }
  getByteRange(e2, t2) {
    unreachable$1("Abstract method `getByteRange` called");
  }
  getString(e2) {
    return bytesToString$1(this.getBytes(e2));
  }
  skip(e2) {
    this.pos += e2 || 1;
  }
  reset() {
    unreachable$1("Abstract method `reset` called");
  }
  moveStart() {
    unreachable$1("Abstract method `moveStart` called");
  }
  makeSubStream(e2, t2, i2 = null) {
    unreachable$1("Abstract method `makeSubStream` called");
  }
  getBaseStreams() {
    return null;
  }
}
const gi = /^[1-9]\.\d$/, fi = 2 ** 31 - 1, pi = [1, 0, 0, 1, 0, 0], mi = ["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"], bi = ["ExtGState", "Font", "Properties", "XObject"];
function getLookupTableFactory(e2) {
  let t2;
  return function() {
    return e2 && (t2 = /* @__PURE__ */ Object.create(null), e2(t2), e2 = null), t2;
  };
}
class MissingDataException extends Yt {
  constructor(e2, t2) {
    super(`Missing data [${e2}, ${t2})`, "MissingDataException"), this.begin = e2, this.end = t2;
  }
}
class ParserEOFException extends Yt {
  constructor(e2) {
    super(e2, "ParserEOFException");
  }
}
class XRefEntryException extends Yt {
  constructor(e2) {
    super(e2, "XRefEntryException");
  }
}
class XRefParseException extends Yt {
  constructor(e2) {
    super(e2, "XRefParseException");
  }
}
function arrayBuffersToBytes(e2) {
  const t2 = e2.length;
  if (0 === t2) return new Uint8Array(0);
  if (1 === t2) return new Uint8Array(e2[0]);
  let i2 = 0;
  for (let n3 = 0; n3 < t2; n3++) i2 += e2[n3].byteLength;
  const n2 = new Uint8Array(i2);
  let a2 = 0;
  for (let i3 = 0; i3 < t2; i3++) {
    const t3 = new Uint8Array(e2[i3]);
    n2.set(t3, a2), a2 += t3.byteLength;
  }
  return n2;
}
async function fetchBinaryData(e2) {
  const t2 = await fetch(e2);
  if (!t2.ok) throw new Error(`Failed to fetch file "${e2}" with "${t2.statusText}".`);
  return new Uint8Array(await t2.arrayBuffer());
}
function getInheritableProperty({ dict: e2, key: t2, getArray: i2 = false, stopWhenFound: n2 = true }) {
  let a2;
  const s2 = new RefSet();
  for (; e2 instanceof Dict && (!e2.objId || !s2.has(e2.objId)); ) {
    e2.objId && s2.put(e2.objId);
    const r2 = i2 ? e2.getArray(t2) : e2.get(t2);
    if (void 0 !== r2) {
      if (n2) return r2;
      (a2 ||= []).push(r2);
    }
    e2 = e2.get("Parent");
  }
  return a2;
}
const yi = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
function toRomanNumerals(e2, t2 = false) {
  assert$1(Number.isInteger(e2) && e2 > 0, "The number should be a positive integer.");
  const i2 = "M".repeat(e2 / 1e3 | 0) + yi[e2 % 1e3 / 100 | 0] + yi[10 + (e2 % 100 / 10 | 0)] + yi[20 + e2 % 10];
  return t2 ? i2.toLowerCase() : i2;
}
function log2(e2) {
  return e2 > 0 ? Math.ceil(Math.log2(e2)) : 0;
}
function readInt8(e2, t2) {
  return e2[t2] << 24 >> 24;
}
function readInt16(e2, t2) {
  return (e2[t2] << 24 | e2[t2 + 1] << 16) >> 16;
}
function readUint16(e2, t2) {
  return e2[t2] << 8 | e2[t2 + 1];
}
function readUint32(e2, t2) {
  return (e2[t2] << 24 | e2[t2 + 1] << 16 | e2[t2 + 2] << 8 | e2[t2 + 3]) >>> 0;
}
function isWhiteSpace(e2) {
  return 32 === e2 || 9 === e2 || 13 === e2 || 10 === e2;
}
function isNumberArray(e2, t2) {
  return Array.isArray(e2) ? (null === t2 || e2.length === t2) && e2.every((e3) => "number" == typeof e3) : ArrayBuffer.isView(e2) && !(e2 instanceof BigInt64Array || e2 instanceof BigUint64Array) && (null === t2 || e2.length === t2);
}
function lookupMatrix(e2, t2) {
  return isNumberArray(e2, 6) ? e2 : t2;
}
function lookupRect(e2, t2) {
  return isNumberArray(e2, 4) ? e2 : t2;
}
function lookupNormalRect(e2, t2) {
  return isNumberArray(e2, 4) ? ai.normalizeRect(e2) : t2;
}
function parseXFAPath(e2) {
  const t2 = /(.+)\[(\d+)\]$/;
  return e2.split(".").map((e3) => {
    const i2 = e3.match(t2);
    return i2 ? { name: i2[1], pos: parseInt(i2[2], 10) } : { name: e3, pos: 0 };
  });
}
function escapePDFName(e2) {
  const t2 = [];
  let i2 = 0;
  for (let n2 = 0, a2 = e2.length; n2 < a2; n2++) {
    const a3 = e2.charCodeAt(n2);
    (a3 < 33 || a3 > 126 || 35 === a3 || 40 === a3 || 41 === a3 || 60 === a3 || 62 === a3 || 91 === a3 || 93 === a3 || 123 === a3 || 125 === a3 || 47 === a3 || 37 === a3) && (i2 < n2 && t2.push(e2.substring(i2, n2)), t2.push(`#${a3.toString(16)}`), i2 = n2 + 1);
  }
  return 0 === t2.length ? e2 : (i2 < e2.length && t2.push(e2.substring(i2, e2.length)), t2.join(""));
}
function escapeString(e2) {
  return e2.replaceAll(/([()\\\n\r])/g, (e3) => "\n" === e3 ? "\\n" : "\r" === e3 ? "\\r" : `\\${e3}`);
}
function _collectJS(e2, t2, i2, n2) {
  if (!e2) return;
  let a2 = null;
  if (e2 instanceof Ref) {
    if (n2.has(e2)) return;
    a2 = e2, n2.put(a2), e2 = t2.fetch(e2);
  }
  if (Array.isArray(e2)) for (const a3 of e2) _collectJS(a3, t2, i2, n2);
  else if (e2 instanceof Dict) {
    if (isName(e2.get("S"), "JavaScript")) {
      const t3 = e2.get("JS");
      let n3;
      t3 instanceof BaseStream ? n3 = t3.getString() : "string" == typeof t3 && (n3 = t3), n3 &&= stringToPDFString(n3, true).replaceAll("\0", ""), n3 && i2.push(n3.trim());
    }
    _collectJS(e2.getRaw("Next"), t2, i2, n2);
  }
  a2 && n2.remove(a2);
}
function collectActions(e2, t2, i2) {
  const n2 = /* @__PURE__ */ Object.create(null), a2 = getInheritableProperty({ dict: t2, key: "AA", stopWhenFound: false });
  if (a2) for (let t3 = a2.length - 1; t3 >= 0; t3--) {
    const s2 = a2[t3];
    if (s2 instanceof Dict) for (const t4 of s2.getKeys()) {
      const a3 = i2[t4];
      if (!a3) continue;
      const r2 = [];
      _collectJS(s2.getRaw(t4), e2, r2, new RefSet()), r2.length > 0 && (n2[a3] = r2);
    }
  }
  if (t2.has("A")) {
    const i3 = [];
    _collectJS(t2.get("A"), e2, i3, new RefSet()), i3.length > 0 && (n2.Action = i3);
  }
  return objectSize(n2) > 0 ? n2 : null;
}
const wi = { 60: "&lt;", 62: "&gt;", 38: "&amp;", 34: "&quot;", 39: "&apos;" };
function* codePointIter(e2) {
  for (let t2 = 0, i2 = e2.length; t2 < i2; t2++) {
    const i3 = e2.codePointAt(t2);
    i3 > 55295 && (i3 < 57344 || i3 > 65533) && t2++, yield i3;
  }
}
function encodeToXmlString(e2) {
  const t2 = [];
  let i2 = 0;
  for (let n2 = 0, a2 = e2.length; n2 < a2; n2++) {
    const a3 = e2.codePointAt(n2);
    if (32 <= a3 && a3 <= 126) {
      const s2 = wi[a3];
      s2 && (i2 < n2 && t2.push(e2.substring(i2, n2)), t2.push(s2), i2 = n2 + 1);
    } else i2 < n2 && t2.push(e2.substring(i2, n2)), t2.push(`&#x${a3.toString(16).toUpperCase()};`), a3 > 55295 && (a3 < 57344 || a3 > 65533) && n2++, i2 = n2 + 1;
  }
  return 0 === t2.length ? e2 : (i2 < e2.length && t2.push(e2.substring(i2, e2.length)), t2.join(""));
}
function validateFontName(e2, t2 = false) {
  const i2 = /^("|').*("|')$/.exec(e2);
  if (i2 && i2[1] === i2[2]) {
    if (new RegExp(`[^\\\\]${i2[1]}`).test(e2.slice(1, -1))) return t2 && warn$1(`FontFamily contains unescaped ${i2[1]}: ${e2}.`), false;
  } else for (const i3 of e2.split(/[ \t]+/)) if (/^(\d|(-(\d|-)))/.test(i3) || !/^[\w-\\]+$/.test(i3)) return t2 && warn$1(`FontFamily contains invalid <custom-ident>: ${e2}.`), false;
  return true;
}
function validateCSSFont(e2) {
  const t2 = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]), { fontFamily: i2, fontWeight: n2, italicAngle: a2 } = e2;
  if (!validateFontName(i2, true)) return false;
  const s2 = n2 ? n2.toString() : "";
  e2.fontWeight = t2.has(s2) ? s2 : "400";
  const r2 = parseFloat(a2);
  return e2.italicAngle = isNaN(r2) || r2 < -90 || r2 > 90 ? "14" : a2.toString(), true;
}
function recoverJsURL(e2) {
  const t2 = new RegExp("^\\s*(" + ["app.launchURL", "window.open", "xfa.host.gotoURL"].join("|").replaceAll(".", "\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(e2);
  return t2?.[2] ? { url: t2[2], newWindow: "app.launchURL" === t2[1] && "true" === t2[3] } : null;
}
function numberToString(e2) {
  if (Number.isInteger(e2)) return e2.toString();
  const t2 = Math.round(100 * e2);
  return t2 % 100 == 0 ? (t2 / 100).toString() : t2 % 10 == 0 ? e2.toFixed(1) : e2.toFixed(2);
}
function getNewAnnotationsMap(e2) {
  if (!e2) return null;
  const t2 = /* @__PURE__ */ new Map();
  for (const [i2, n2] of e2) {
    if (!i2.startsWith(g)) continue;
    let e3 = t2.get(n2.pageIndex);
    e3 || (e3 = [], t2.set(n2.pageIndex, e3)), e3.push(n2);
  }
  return t2.size > 0 ? t2 : null;
}
function stringToAsciiOrUTF16BE(e2) {
  return null == e2 || (function(e3) {
    if ("string" != typeof e3) return false;
    return !e3 || /^[\x00-\x7F]*$/.test(e3);
  })(e2) ? e2 : stringToUTF16String(e2, true);
}
function stringToUTF16HexString(e2) {
  const t2 = [];
  for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) {
    const n3 = e2.charCodeAt(i2);
    t2.push(ni[n3 >> 8 & 255], ni[255 & n3]);
  }
  return t2.join("");
}
function stringToUTF16String(e2, t2 = false) {
  const i2 = [];
  t2 && i2.push("þÿ");
  for (let t3 = 0, n2 = e2.length; t3 < n2; t3++) {
    const n3 = e2.charCodeAt(t3);
    i2.push(String.fromCharCode(n3 >> 8 & 255), String.fromCharCode(255 & n3));
  }
  return i2.join("");
}
function getRotationMatrix(e2, t2, i2) {
  switch (e2) {
    case 90:
      return [0, 1, -1, 0, t2, 0];
    case 180:
      return [-1, 0, 0, -1, t2, i2];
    case 270:
      return [0, -1, 1, 0, 0, i2];
    default:
      throw new Error("Invalid rotation");
  }
}
function getSizeInBytes(e2) {
  return Math.ceil(Math.ceil(Math.log2(1 + e2)) / 8);
}
class QCMS {
  static #i = null;
  static _memory = null;
  static _mustAddAlpha = false;
  static _destBuffer = null;
  static _destOffset = 0;
  static _destLength = 0;
  static _cssColor = "";
  static _makeHexColor = null;
  static get _memoryArray() {
    const e2 = this.#i;
    return e2?.byteLength ? e2 : this.#i = new Uint8Array(this._memory.buffer);
  }
}
let Ai;
const xi = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
"undefined" != typeof TextDecoder && xi.decode();
let Si = null;
function getUint8ArrayMemory0() {
  return null !== Si && 0 !== Si.byteLength || (Si = new Uint8Array(Ai.memory.buffer)), Si;
}
let vi = 0;
function passArray8ToWasm0(e2, t2) {
  const i2 = t2(1 * e2.length, 1) >>> 0;
  return getUint8ArrayMemory0().set(e2, i2 / 1), vi = e2.length, i2;
}
const Ci = Object.freeze({ RGB8: 0, 0: "RGB8", RGBA8: 1, 1: "RGBA8", BGRA8: 2, 2: "BGRA8", Gray8: 3, 3: "Gray8", GrayA8: 4, 4: "GrayA8", CMYK: 5, 5: "CMYK" }), ki = Object.freeze({ Perceptual: 0, 0: "Perceptual", RelativeColorimetric: 1, 1: "RelativeColorimetric", Saturation: 2, 2: "Saturation", AbsoluteColorimetric: 3, 3: "AbsoluteColorimetric" });
function __wbg_get_imports() {
  const e2 = { wbg: {} };
  return e2.wbg.__wbg_copyresult_b08ee7d273f295dd = function(e3, t2) {
    !(function(e4, t3) {
      const { _mustAddAlpha: i2, _destBuffer: n2, _destOffset: a2, _destLength: s2, _memoryArray: r2 } = QCMS;
      if (t3 !== s2) if (i2) for (let i3 = e4, s3 = e4 + t3, o2 = a2; i3 < s3; i3 += 3, o2 += 4) n2[o2] = r2[i3], n2[o2 + 1] = r2[i3 + 1], n2[o2 + 2] = r2[i3 + 2], n2[o2 + 3] = 255;
      else for (let i3 = e4, s3 = e4 + t3, o2 = a2; i3 < s3; i3 += 3, o2 += 4) n2[o2] = r2[i3], n2[o2 + 1] = r2[i3 + 1], n2[o2 + 2] = r2[i3 + 2];
      else n2.set(r2.subarray(e4, e4 + t3), a2);
    })(e3 >>> 0, t2 >>> 0);
  }, e2.wbg.__wbg_copyrgb_d60ce17bb05d9b67 = function(e3) {
    !(function(e4) {
      const { _destBuffer: t2, _destOffset: i2, _memoryArray: n2 } = QCMS;
      t2[i2] = n2[e4], t2[i2 + 1] = n2[e4 + 1], t2[i2 + 2] = n2[e4 + 2];
    })(e3 >>> 0);
  }, e2.wbg.__wbg_makecssRGB_893bf0cd9fdb302d = function(e3) {
    !(function(e4) {
      const { _memoryArray: t2 } = QCMS;
      QCMS._cssColor = QCMS._makeHexColor(t2[e4], t2[e4 + 1], t2[e4 + 2]);
    })(e3 >>> 0);
  }, e2.wbg.__wbindgen_init_externref_table = function() {
    const e3 = Ai.__wbindgen_export_0, t2 = e3.grow(4);
    e3.set(0, void 0), e3.set(t2 + 0, void 0), e3.set(t2 + 1, null), e3.set(t2 + 2, true), e3.set(t2 + 3, false);
  }, e2.wbg.__wbindgen_throw = function(e3, t2) {
    throw new Error((i2 = e3, n2 = t2, i2 >>>= 0, xi.decode(getUint8ArrayMemory0().subarray(i2, i2 + n2))));
    var i2, n2;
  }, e2;
}
function initSync(e2) {
  if (void 0 !== Ai) return Ai;
  void 0 !== e2 && (Object.getPrototypeOf(e2) === Object.prototype ? { module: e2 } = e2 : console.warn("using deprecated parameters for `initSync()`; pass a single object instead"));
  const t2 = __wbg_get_imports();
  e2 instanceof WebAssembly.Module || (e2 = new WebAssembly.Module(e2));
  return (function(e3) {
    return Ai = e3.exports, Si = null, Ai.__wbindgen_start(), Ai;
  })(new WebAssembly.Instance(e2, t2));
}
class ColorSpace {
  static #n = new Uint8ClampedArray(3);
  constructor(e2, t2) {
    this.name = e2, this.numComps = t2;
  }
  getRgb(e2, t2, i2 = new Uint8ClampedArray(3)) {
    return this.getRgbItem(e2, t2, i2, 0), i2;
  }
  getRgbHex(e2, t2) {
    const i2 = this.getRgb(e2, t2, ColorSpace.#n);
    return ai.makeHexColor(i2[0], i2[1], i2[2]);
  }
  getRgbItem(e2, t2, i2, n2) {
    unreachable$1("Should not call ColorSpace.getRgbItem");
  }
  getRgbBuffer(e2, t2, i2, n2, a2, s2, r2) {
    unreachable$1("Should not call ColorSpace.getRgbBuffer");
  }
  getOutputLength(e2, t2) {
    unreachable$1("Should not call ColorSpace.getOutputLength");
  }
  isPassthrough(e2) {
    return false;
  }
  isDefaultDecode(e2, t2) {
    return ColorSpace.isDefaultDecode(e2, this.numComps);
  }
  fillRgb(e2, t2, i2, n2, a2, s2, r2, o2, l2) {
    const c2 = t2 * i2;
    let h2 = null;
    const d2 = 1 << r2, u2 = i2 !== a2 || t2 !== n2;
    if (this.isPassthrough(r2)) h2 = o2;
    else if (1 === this.numComps && c2 > d2 && "DeviceGray" !== this.name && "DeviceRGB" !== this.name) {
      const t3 = r2 <= 8 ? new Uint8Array(d2) : new Uint16Array(d2);
      for (let e3 = 0; e3 < d2; e3++) t3[e3] = e3;
      const i3 = new Uint8ClampedArray(3 * d2);
      if (this.getRgbBuffer(t3, 0, d2, i3, 0, r2, 0), u2) {
        h2 = new Uint8Array(3 * c2);
        let e3 = 0;
        for (let t4 = 0; t4 < c2; ++t4) {
          const n3 = 3 * o2[t4];
          h2[e3++] = i3[n3], h2[e3++] = i3[n3 + 1], h2[e3++] = i3[n3 + 2];
        }
      } else {
        let t4 = 0;
        for (let n3 = 0; n3 < c2; ++n3) {
          const a3 = 3 * o2[n3];
          e2[t4++] = i3[a3], e2[t4++] = i3[a3 + 1], e2[t4++] = i3[a3 + 2], t4 += l2;
        }
      }
    } else u2 ? (h2 = new Uint8ClampedArray(3 * c2), this.getRgbBuffer(o2, 0, c2, h2, 0, r2, 0)) : this.getRgbBuffer(o2, 0, n2 * s2, e2, 0, r2, l2);
    if (h2) if (u2) !(function(e3, t3, i3, n3, a3, s3, r3) {
      r3 = 1 !== r3 ? 0 : r3;
      const o3 = i3 / a3, l3 = n3 / s3;
      let c3, h3 = 0;
      const d3 = new Uint16Array(a3), u3 = 3 * i3;
      for (let e4 = 0; e4 < a3; e4++) d3[e4] = 3 * Math.floor(e4 * o3);
      for (let i4 = 0; i4 < s3; i4++) {
        const n4 = Math.floor(i4 * l3) * u3;
        for (let i5 = 0; i5 < a3; i5++) c3 = n4 + d3[i5], t3[h3++] = e3[c3++], t3[h3++] = e3[c3++], t3[h3++] = e3[c3++], h3 += r3;
      }
    })(h2, e2, t2, i2, n2, a2, l2);
    else {
      let t3 = 0, i3 = 0;
      for (let a3 = 0, r3 = n2 * s2; a3 < r3; a3++) e2[t3++] = h2[i3++], e2[t3++] = h2[i3++], e2[t3++] = h2[i3++], t3 += l2;
    }
  }
  get usesZeroToOneRange() {
    return shadow$1(this, "usesZeroToOneRange", true);
  }
  static isDefaultDecode(e2, t2) {
    if (!Array.isArray(e2)) return true;
    if (2 * t2 !== e2.length) return warn$1("The decode map is not the correct length"), true;
    for (let t3 = 0, i2 = e2.length; t3 < i2; t3 += 2) if (0 !== e2[t3] || 1 !== e2[t3 + 1]) return false;
    return true;
  }
}
class AlternateCS extends ColorSpace {
  constructor(e2, t2, i2) {
    super("Alternate", e2), this.base = t2, this.tintFn = i2, this.tmpBuf = new Float32Array(t2.numComps);
  }
  getRgbItem(e2, t2, i2, n2) {
    const a2 = this.tmpBuf;
    this.tintFn(e2, t2, a2, 0), this.base.getRgbItem(a2, 0, i2, n2);
  }
  getRgbBuffer(e2, t2, i2, n2, a2, s2, r2) {
    const o2 = this.tintFn, l2 = this.base, c2 = 1 / ((1 << s2) - 1), h2 = l2.numComps, d2 = l2.usesZeroToOneRange, u2 = (l2.isPassthrough(8) || !d2) && 0 === r2;
    let g2 = u2 ? a2 : 0;
    const f2 = u2 ? n2 : new Uint8ClampedArray(h2 * i2), p2 = this.numComps, m2 = new Float32Array(p2), b2 = new Float32Array(h2);
    let y2, w2;
    for (y2 = 0; y2 < i2; y2++) {
      for (w2 = 0; w2 < p2; w2++) m2[w2] = e2[t2++] * c2;
      if (o2(m2, 0, b2, 0), d2) for (w2 = 0; w2 < h2; w2++) f2[g2++] = 255 * b2[w2];
      else l2.getRgbItem(b2, 0, f2, g2), g2 += h2;
    }
    u2 || l2.getRgbBuffer(f2, 0, i2, n2, a2, 8, r2);
  }
  getOutputLength(e2, t2) {
    return this.base.getOutputLength(e2 * this.base.numComps / this.numComps, t2);
  }
}
class PatternCS extends ColorSpace {
  constructor(e2) {
    super("Pattern", null), this.base = e2;
  }
  isDefaultDecode(e2, t2) {
    unreachable$1("Should not call PatternCS.isDefaultDecode");
  }
}
class IndexedCS extends ColorSpace {
  constructor(e2, t2, i2) {
    super("Indexed", 1), this.base = e2, this.highVal = t2;
    const n2 = e2.numComps * (t2 + 1);
    if (this.lookup = new Uint8Array(n2), i2 instanceof BaseStream) {
      const e3 = i2.getBytes(n2);
      this.lookup.set(e3);
    } else {
      if ("string" != typeof i2) throw new ti(`IndexedCS - unrecognized lookup table: ${i2}`);
      for (let e3 = 0; e3 < n2; ++e3) this.lookup[e3] = 255 & i2.charCodeAt(e3);
    }
  }
  getRgbItem(e2, t2, i2, n2) {
    const { base: a2, highVal: s2, lookup: r2 } = this, o2 = MathClamp$1(Math.round(e2[t2]), 0, s2) * a2.numComps;
    a2.getRgbBuffer(r2, o2, 1, i2, n2, 8, 0);
  }
  getRgbBuffer(e2, t2, i2, n2, a2, s2, r2) {
    const { base: o2, highVal: l2, lookup: c2 } = this, { numComps: h2 } = o2, d2 = o2.getOutputLength(h2, r2);
    for (let s3 = 0; s3 < i2; ++s3) {
      const i3 = MathClamp$1(Math.round(e2[t2++]), 0, l2) * h2;
      o2.getRgbBuffer(c2, i3, 1, n2, a2, 8, r2), a2 += d2;
    }
  }
  getOutputLength(e2, t2) {
    return this.base.getOutputLength(e2 * this.base.numComps, t2);
  }
  isDefaultDecode(e2, t2) {
    return !Array.isArray(e2) || (2 !== e2.length ? (warn$1("Decode map length is not correct"), true) : !Number.isInteger(t2) || t2 < 1 ? (warn$1("Bits per component is not correct"), true) : 0 === e2[0] && e2[1] === (1 << t2) - 1);
  }
}
class DeviceGrayCS extends ColorSpace {
  constructor() {
    super("DeviceGray", 1);
  }
  getRgbItem(e2, t2, i2, n2) {
    const a2 = 255 * e2[t2];
    i2[n2] = i2[n2 + 1] = i2[n2 + 2] = a2;
  }
  getRgbBuffer(e2, t2, i2, n2, a2, s2, r2) {
    const o2 = 255 / ((1 << s2) - 1);
    let l2 = t2, c2 = a2;
    for (let t3 = 0; t3 < i2; ++t3) {
      const t4 = o2 * e2[l2++];
      n2[c2++] = t4, n2[c2++] = t4, n2[c2++] = t4, c2 += r2;
    }
  }
  getOutputLength(e2, t2) {
    return e2 * (3 + t2);
  }
}
class DeviceRgbCS extends ColorSpace {
  constructor() {
    super("DeviceRGB", 3);
  }
  getRgbItem(e2, t2, i2, n2) {
    i2[n2] = 255 * e2[t2], i2[n2 + 1] = 255 * e2[t2 + 1], i2[n2 + 2] = 255 * e2[t2 + 2];
  }
  getRgbBuffer(e2, t2, i2, n2, a2, s2, r2) {
    if (8 === s2 && 0 === r2) return void n2.set(e2.subarray(t2, t2 + 3 * i2), a2);
    const o2 = 255 / ((1 << s2) - 1);
    let l2 = t2, c2 = a2;
    for (let t3 = 0; t3 < i2; ++t3) n2[c2++] = o2 * e2[l2++], n2[c2++] = o2 * e2[l2++], n2[c2++] = o2 * e2[l2++], c2 += r2;
  }
  getOutputLength(e2, t2) {
    return e2 * (3 + t2) / 3 | 0;
  }
  isPassthrough(e2) {
    return 8 === e2;
  }
}
class DeviceRgbaCS extends ColorSpace {
  constructor() {
    super("DeviceRGBA", 4);
  }
  getOutputLength(e2, t2) {
    return 4 * e2;
  }
  isPassthrough(e2) {
    return 8 === e2;
  }
  fillRgb(e2, t2, i2, n2, a2, s2, r2, o2, l2) {
    i2 !== a2 || t2 !== n2 ? (function(e3, t3, i3, n3, a3, s3, r3) {
      const o3 = i3 / a3, l3 = n3 / s3;
      let c2 = 0;
      const h2 = new Uint16Array(a3);
      if (1 === r3) {
        for (let e4 = 0; e4 < a3; e4++) h2[e4] = Math.floor(e4 * o3);
        const n4 = new Uint32Array(e3.buffer), r4 = new Uint32Array(t3.buffer), d2 = FeatureTest.isLittleEndian ? 16777215 : 4294967040;
        for (let e4 = 0; e4 < s3; e4++) {
          const t4 = n4.subarray(Math.floor(e4 * l3) * i3);
          for (let e5 = 0; e5 < a3; e5++) r4[c2++] |= t4[h2[e5]] & d2;
        }
      } else {
        const n4 = 4, r4 = i3 * n4;
        for (let e4 = 0; e4 < a3; e4++) h2[e4] = Math.floor(e4 * o3) * n4;
        for (let i4 = 0; i4 < s3; i4++) {
          const n5 = e3.subarray(Math.floor(i4 * l3) * r4);
          for (let e4 = 0; e4 < a3; e4++) {
            const i5 = h2[e4];
            t3[c2++] = n5[i5], t3[c2++] = n5[i5 + 1], t3[c2++] = n5[i5 + 2];
          }
        }
      }
    })(o2, e2, t2, i2, n2, a2, l2) : (function(e3, t3, i3) {
      if (1 === i3) {
        const i4 = new Uint32Array(e3.buffer), n3 = new Uint32Array(t3.buffer), a3 = FeatureTest.isLittleEndian ? 16777215 : 4294967040;
        for (let e4 = 0, t4 = i4.length; e4 < t4; e4++) n3[e4] |= i4[e4] & a3;
      } else {
        let i4 = 0;
        for (let n3 = 0, a3 = e3.length; n3 < a3; n3 += 4) t3[i4++] = e3[n3], t3[i4++] = e3[n3 + 1], t3[i4++] = e3[n3 + 2];
      }
    })(o2, e2, l2);
  }
}
class DeviceCmykCS extends ColorSpace {
  constructor() {
    super("DeviceCMYK", 4);
  }
  #a(e2, t2, i2, n2, a2) {
    const s2 = e2[t2] * i2, r2 = e2[t2 + 1] * i2, o2 = e2[t2 + 2] * i2, l2 = e2[t2 + 3] * i2;
    n2[a2] = 255 + s2 * (-4.387332384609988 * s2 + 54.48615194189176 * r2 + 18.82290502165302 * o2 + 212.25662451639585 * l2 - 285.2331026137004) + r2 * (1.7149763477362134 * r2 - 5.6096736904047315 * o2 + -17.873870861415444 * l2 - 5.497006427196366) + o2 * (-2.5217340131683033 * o2 - 21.248923337353073 * l2 + 17.5119270841813) + l2 * (-21.86122147463605 * l2 - 189.48180835922747), n2[a2 + 1] = 255 + s2 * (8.841041422036149 * s2 + 60.118027045597366 * r2 + 6.871425592049007 * o2 + 31.159100130055922 * l2 - 79.2970844816548) + r2 * (-15.310361306967817 * r2 + 17.575251261109482 * o2 + 131.35250912493976 * l2 - 190.9453302588951) + o2 * (4.444339102852739 * o2 + 9.8632861493405 * l2 - 24.86741582555878) + l2 * (-20.737325471181034 * l2 - 187.80453709719578), n2[a2 + 2] = 255 + s2 * (0.8842522430003296 * s2 + 8.078677503112928 * r2 + 30.89978309703729 * o2 - 0.23883238689178934 * l2 - 14.183576799673286) + r2 * (10.49593273432072 * r2 + 63.02378494754052 * o2 + 50.606957656360734 * l2 - 112.23884253719248) + o2 * (0.03296041114873217 * o2 + 115.60384449646641 * l2 - 193.58209356861505) + l2 * (-22.33816807309886 * l2 - 180.12613974708367);
  }
  getRgbItem(e2, t2, i2, n2) {
    this.#a(e2, t2, 1, i2, n2);
  }
  getRgbBuffer(e2, t2, i2, n2, a2, s2, r2) {
    const o2 = 1 / ((1 << s2) - 1);
    for (let s3 = 0; s3 < i2; s3++) this.#a(e2, t2, o2, n2, a2), t2 += 4, a2 += 3 + r2;
  }
  getOutputLength(e2, t2) {
    return e2 / 4 * (3 + t2) | 0;
  }
}
class CalGrayCS extends ColorSpace {
  constructor(e2, t2, i2) {
    if (super("CalGray", 1), !e2) throw new ti("WhitePoint missing - required for color space CalGray");
    if ([this.XW, this.YW, this.ZW] = e2, [this.XB, this.YB, this.ZB] = t2 || [0, 0, 0], this.G = i2 || 1, this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new ti(`Invalid WhitePoint components for ${this.name}, no fallback available`);
    (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (info$1(`Invalid BlackPoint for ${this.name}, falling back to default.`), this.XB = this.YB = this.ZB = 0), 0 === this.XB && 0 === this.YB && 0 === this.ZB || warn$1(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`), this.G < 1 && (info$1(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`), this.G = 1);
  }
  #a(e2, t2, i2, n2, a2) {
    const s2 = (e2[t2] * a2) ** this.G, r2 = this.YW * s2, o2 = Math.max(295.8 * r2 ** 0.3333333333333333 - 40.8, 0);
    i2[n2] = o2, i2[n2 + 1] = o2, i2[n2 + 2] = o2;
  }
  getRgbItem(e2, t2, i2, n2) {
    this.#a(e2, t2, i2, n2, 1);
  }
  getRgbBuffer(e2, t2, i2, n2, a2, s2, r2) {
    const o2 = 1 / ((1 << s2) - 1);
    for (let s3 = 0; s3 < i2; ++s3) this.#a(e2, t2, n2, a2, o2), t2 += 1, a2 += 3 + r2;
  }
  getOutputLength(e2, t2) {
    return e2 * (3 + t2);
  }
}
class CalRGBCS extends ColorSpace {
  static #s = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
  static #r = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]);
  static #o = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]);
  static #l = new Float32Array([1, 1, 1]);
  static #c = new Float32Array(3);
  static #h = new Float32Array(3);
  static #d = new Float32Array(3);
  static #u = (24 / 116) ** 3 / 8;
  constructor(e2, t2, i2, n2) {
    if (super("CalRGB", 3), !e2) throw new ti("WhitePoint missing - required for color space CalRGB");
    const [a2, s2, r2] = this.whitePoint = e2, [o2, l2, c2] = this.blackPoint = t2 || new Float32Array(3);
    if ([this.GR, this.GG, this.GB] = i2 || new Float32Array([1, 1, 1]), [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = n2 || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), a2 < 0 || r2 < 0 || 1 !== s2) throw new ti(`Invalid WhitePoint components for ${this.name}, no fallback available`);
    (o2 < 0 || l2 < 0 || c2 < 0) && (info$1(`Invalid BlackPoint for ${this.name} [${o2}, ${l2}, ${c2}], falling back to default.`), this.blackPoint = new Float32Array(3)), (this.GR < 0 || this.GG < 0 || this.GB < 0) && (info$1(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`), this.GR = this.GG = this.GB = 1);
  }
  #g(e2, t2, i2) {
    i2[0] = e2[0] * t2[0] + e2[1] * t2[1] + e2[2] * t2[2], i2[1] = e2[3] * t2[0] + e2[4] * t2[1] + e2[5] * t2[2], i2[2] = e2[6] * t2[0] + e2[7] * t2[1] + e2[8] * t2[2];
  }
  #f(e2, t2, i2) {
    i2[0] = 1 * t2[0] / e2[0], i2[1] = 1 * t2[1] / e2[1], i2[2] = 1 * t2[2] / e2[2];
  }
  #p(e2, t2, i2) {
    i2[0] = 0.95047 * t2[0] / e2[0], i2[1] = 1 * t2[1] / e2[1], i2[2] = 1.08883 * t2[2] / e2[2];
  }
  #m(e2) {
    return e2 <= 31308e-7 ? MathClamp$1(12.92 * e2, 0, 1) : e2 >= 0.99554525 ? 1 : MathClamp$1(1.055 * e2 ** (1 / 2.4) - 0.055, 0, 1);
  }
  #b(e2) {
    return e2 < 0 ? -this.#b(-e2) : e2 > 8 ? ((e2 + 16) / 116) ** 3 : e2 * CalRGBCS.#u;
  }
  #y(e2, t2, i2) {
    if (0 === e2[0] && 0 === e2[1] && 0 === e2[2]) return i2[0] = t2[0], i2[1] = t2[1], void (i2[2] = t2[2]);
    const n2 = this.#b(0), a2 = (1 - n2) / (1 - this.#b(e2[0])), s2 = 1 - a2, r2 = (1 - n2) / (1 - this.#b(e2[1])), o2 = 1 - r2, l2 = (1 - n2) / (1 - this.#b(e2[2])), c2 = 1 - l2;
    i2[0] = t2[0] * a2 + s2, i2[1] = t2[1] * r2 + o2, i2[2] = t2[2] * l2 + c2;
  }
  #w(e2, t2, i2) {
    if (1 === e2[0] && 1 === e2[2]) return i2[0] = t2[0], i2[1] = t2[1], void (i2[2] = t2[2]);
    const n2 = i2;
    this.#g(CalRGBCS.#s, t2, n2);
    const a2 = CalRGBCS.#c;
    this.#f(e2, n2, a2), this.#g(CalRGBCS.#r, a2, i2);
  }
  #A(e2, t2, i2) {
    const n2 = i2;
    this.#g(CalRGBCS.#s, t2, n2);
    const a2 = CalRGBCS.#c;
    this.#p(e2, n2, a2), this.#g(CalRGBCS.#r, a2, i2);
  }
  #a(e2, t2, i2, n2, a2) {
    const s2 = MathClamp$1(e2[t2] * a2, 0, 1), r2 = MathClamp$1(e2[t2 + 1] * a2, 0, 1), o2 = MathClamp$1(e2[t2 + 2] * a2, 0, 1), l2 = 1 === s2 ? 1 : s2 ** this.GR, c2 = 1 === r2 ? 1 : r2 ** this.GG, h2 = 1 === o2 ? 1 : o2 ** this.GB, d2 = this.MXA * l2 + this.MXB * c2 + this.MXC * h2, u2 = this.MYA * l2 + this.MYB * c2 + this.MYC * h2, g2 = this.MZA * l2 + this.MZB * c2 + this.MZC * h2, f2 = CalRGBCS.#h;
    f2[0] = d2, f2[1] = u2, f2[2] = g2;
    const p2 = CalRGBCS.#d;
    this.#w(this.whitePoint, f2, p2);
    const m2 = CalRGBCS.#h;
    this.#y(this.blackPoint, p2, m2);
    const b2 = CalRGBCS.#d;
    this.#A(CalRGBCS.#l, m2, b2);
    const y2 = CalRGBCS.#h;
    this.#g(CalRGBCS.#o, b2, y2), i2[n2] = 255 * this.#m(y2[0]), i2[n2 + 1] = 255 * this.#m(y2[1]), i2[n2 + 2] = 255 * this.#m(y2[2]);
  }
  getRgbItem(e2, t2, i2, n2) {
    this.#a(e2, t2, i2, n2, 1);
  }
  getRgbBuffer(e2, t2, i2, n2, a2, s2, r2) {
    const o2 = 1 / ((1 << s2) - 1);
    for (let s3 = 0; s3 < i2; ++s3) this.#a(e2, t2, n2, a2, o2), t2 += 3, a2 += 3 + r2;
  }
  getOutputLength(e2, t2) {
    return e2 * (3 + t2) / 3 | 0;
  }
}
class LabCS extends ColorSpace {
  constructor(e2, t2, i2) {
    if (super("Lab", 3), !e2) throw new ti("WhitePoint missing - required for color space Lab");
    if ([this.XW, this.YW, this.ZW] = e2, [this.amin, this.amax, this.bmin, this.bmax] = i2 || [-100, 100, -100, 100], [this.XB, this.YB, this.ZB] = t2 || [0, 0, 0], this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new ti("Invalid WhitePoint components, no fallback available");
    (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (info$1("Invalid BlackPoint, falling back to default"), this.XB = this.YB = this.ZB = 0), (this.amin > this.amax || this.bmin > this.bmax) && (info$1("Invalid Range, falling back to defaults"), this.amin = -100, this.amax = 100, this.bmin = -100, this.bmax = 100);
  }
  #x(e2) {
    return e2 >= 6 / 29 ? e2 ** 3 : 108 / 841 * (e2 - 4 / 29);
  }
  #S(e2, t2, i2, n2) {
    return i2 + e2 * (n2 - i2) / t2;
  }
  #a(e2, t2, i2, n2, a2) {
    let s2 = e2[t2], r2 = e2[t2 + 1], o2 = e2[t2 + 2];
    false !== i2 && (s2 = this.#S(s2, i2, 0, 100), r2 = this.#S(r2, i2, this.amin, this.amax), o2 = this.#S(o2, i2, this.bmin, this.bmax)), r2 > this.amax ? r2 = this.amax : r2 < this.amin && (r2 = this.amin), o2 > this.bmax ? o2 = this.bmax : o2 < this.bmin && (o2 = this.bmin);
    const l2 = (s2 + 16) / 116, c2 = l2 + r2 / 500, h2 = l2 - o2 / 200, d2 = this.XW * this.#x(c2), u2 = this.YW * this.#x(l2), g2 = this.ZW * this.#x(h2);
    let f2, p2, m2;
    this.ZW < 1 ? (f2 = 3.1339 * d2 + -1.617 * u2 + -0.4906 * g2, p2 = -0.9785 * d2 + 1.916 * u2 + 0.0333 * g2, m2 = 0.072 * d2 + -0.229 * u2 + 1.4057 * g2) : (f2 = 3.2406 * d2 + -1.5372 * u2 + -0.4986 * g2, p2 = -0.9689 * d2 + 1.8758 * u2 + 0.0415 * g2, m2 = 0.0557 * d2 + -0.204 * u2 + 1.057 * g2), n2[a2] = 255 * Math.sqrt(f2), n2[a2 + 1] = 255 * Math.sqrt(p2), n2[a2 + 2] = 255 * Math.sqrt(m2);
  }
  getRgbItem(e2, t2, i2, n2) {
    this.#a(e2, t2, false, i2, n2);
  }
  getRgbBuffer(e2, t2, i2, n2, a2, s2, r2) {
    const o2 = (1 << s2) - 1;
    for (let s3 = 0; s3 < i2; s3++) this.#a(e2, t2, o2, n2, a2), t2 += 3, a2 += 3 + r2;
  }
  getOutputLength(e2, t2) {
    return e2 * (3 + t2) / 3 | 0;
  }
  isDefaultDecode(e2, t2) {
    return true;
  }
  get usesZeroToOneRange() {
    return shadow$1(this, "usesZeroToOneRange", false);
  }
}
function fetchSync(e2) {
  const t2 = new XMLHttpRequest();
  return t2.open("GET", e2, false), t2.responseType = "arraybuffer", t2.send(null), t2.response;
}
class IccColorSpace extends ColorSpace {
  #v;
  #C;
  static #k = true;
  static #T = null;
  static #F = null;
  constructor(e2, t2, i2) {
    if (!IccColorSpace.isUsable) throw new Error("No ICC color space support");
    let n2;
    switch (super(t2, i2), i2) {
      case 1:
        n2 = Ci.Gray8, this.#C = (e3, t3, i3) => (function(e4, t4, i4) {
          Ai.qcms_convert_one(e4, t4, i4);
        })(this.#v, 255 * e3[t3], i3);
        break;
      case 3:
        n2 = Ci.RGB8, this.#C = (e3, t3, i3) => (function(e4, t4, i4, n3, a2) {
          Ai.qcms_convert_three(e4, t4, i4, n3, a2);
        })(this.#v, 255 * e3[t3], 255 * e3[t3 + 1], 255 * e3[t3 + 2], i3);
        break;
      case 4:
        n2 = Ci.CMYK, this.#C = (e3, t3, i3) => (function(e4, t4, i4, n3, a2, s2) {
          Ai.qcms_convert_four(e4, t4, i4, n3, a2, s2);
        })(this.#v, 255 * e3[t3], 255 * e3[t3 + 1], 255 * e3[t3 + 2], 255 * e3[t3 + 3], i3);
        break;
      default:
        throw new Error(`Unsupported number of components: ${i2}`);
    }
    if (this.#v = (function(e3, t3, i3) {
      const n3 = passArray8ToWasm0(e3, Ai.__wbindgen_malloc), a2 = vi;
      return Ai.qcms_transformer_from_memory(n3, a2, t3, i3) >>> 0;
    })(e2, n2, ki.Perceptual), !this.#v) throw new Error("Failed to create ICC color space");
    IccColorSpace.#F ||= new FinalizationRegistry((e3) => {
      !(function(e4) {
        Ai.qcms_drop_transformer(e4);
      })(e3);
    }), IccColorSpace.#F.register(this, this.#v);
  }
  getRgbHex(e2, t2) {
    return this.#C(e2, t2, true), QCMS._cssColor;
  }
  getRgbItem(e2, t2, i2, n2) {
    QCMS._destBuffer = i2, QCMS._destOffset = n2, QCMS._destLength = 3, this.#C(e2, t2, false), QCMS._destBuffer = null;
  }
  getRgbBuffer(e2, t2, i2, n2, a2, s2, r2) {
    if (e2 = e2.subarray(t2, t2 + i2 * this.numComps), 8 !== s2) {
      const t3 = 255 / ((1 << s2) - 1);
      for (let i3 = 0, n3 = e2.length; i3 < n3; i3++) e2[i3] *= t3;
    }
    QCMS._mustAddAlpha = r2 && n2.buffer === e2.buffer, QCMS._destBuffer = n2, QCMS._destOffset = a2, QCMS._destLength = i2 * (3 + r2), (function(e3, t3) {
      const i3 = passArray8ToWasm0(t3, Ai.__wbindgen_malloc), n3 = vi;
      Ai.qcms_convert_array(e3, i3, n3);
    })(this.#v, e2), QCMS._mustAddAlpha = false, QCMS._destBuffer = null;
  }
  getOutputLength(e2, t2) {
    return e2 / this.numComps * (3 + t2) | 0;
  }
  static setOptions({ useWasm: e2, useWorkerFetch: t2, wasmUrl: i2 }) {
    t2 ? (this.#k = e2, this.#T = i2) : this.#k = false;
  }
  static get isUsable() {
    let e2 = false;
    if (this.#k) if (this.#T) try {
      this._module = initSync({ module: fetchSync(`${this.#T}qcms_bg.wasm`) }), e2 = !!this._module, QCMS._memory = this._module.memory, QCMS._makeHexColor = ai.makeHexColor;
    } catch (e3) {
      warn$1(`ICCBased color space: "${e3}".`);
    }
    else warn$1("No ICC color space support due to missing `wasmUrl` API option");
    return shadow$1(this, "isUsable", e2);
  }
}
class CmykICCBasedCS extends IccColorSpace {
  static #I;
  constructor() {
    super(new Uint8Array(fetchSync(`${CmykICCBasedCS.#I}CGATS001Compat-v2-micro.icc`)), "DeviceCMYK", 4);
  }
  static setOptions({ iccUrl: e2 }) {
    this.#I = e2;
  }
  static get isUsable() {
    let e2 = false;
    return IccColorSpace.isUsable && (this.#I ? e2 = true : warn$1("No CMYK ICC profile support due to missing `iccUrl` API option")), shadow$1(this, "isUsable", e2);
  }
}
class Stream extends BaseStream {
  constructor(e2, t2, i2, n2) {
    super(), this.bytes = e2 instanceof Uint8Array ? e2 : new Uint8Array(e2), this.start = t2 || 0, this.pos = this.start, this.end = t2 + i2 || this.bytes.length, this.dict = n2;
  }
  get length() {
    return this.end - this.start;
  }
  get isEmpty() {
    return 0 === this.length;
  }
  getByte() {
    return this.pos >= this.end ? -1 : this.bytes[this.pos++];
  }
  getBytes(e2) {
    const t2 = this.bytes, i2 = this.pos, n2 = this.end;
    if (!e2) return t2.subarray(i2, n2);
    let a2 = i2 + e2;
    return a2 > n2 && (a2 = n2), this.pos = a2, t2.subarray(i2, a2);
  }
  getByteRange(e2, t2) {
    return e2 < 0 && (e2 = 0), t2 > this.end && (t2 = this.end), this.bytes.subarray(e2, t2);
  }
  reset() {
    this.pos = this.start;
  }
  moveStart() {
    this.start = this.pos;
  }
  makeSubStream(e2, t2, i2 = null) {
    return new Stream(this.bytes.buffer, e2, t2, i2);
  }
}
class StringStream extends Stream {
  constructor(e2) {
    super(stringToBytes$1(e2));
  }
}
class NullStream extends Stream {
  constructor() {
    super(new Uint8Array(0));
  }
}
class ChunkedStream extends Stream {
  constructor(e2, t2, i2) {
    super(new Uint8Array(e2), 0, e2, null), this.chunkSize = t2, this._loadedChunks = /* @__PURE__ */ new Set(), this.numChunks = Math.ceil(e2 / t2), this.manager = i2, this.progressiveDataLength = 0, this.lastSuccessfulEnsureByteChunk = -1;
  }
  getMissingChunks() {
    const e2 = [];
    for (let t2 = 0, i2 = this.numChunks; t2 < i2; ++t2) this._loadedChunks.has(t2) || e2.push(t2);
    return e2;
  }
  get numChunksLoaded() {
    return this._loadedChunks.size;
  }
  get isDataLoaded() {
    return this.numChunksLoaded === this.numChunks;
  }
  onReceiveData(e2, t2) {
    const i2 = this.chunkSize;
    if (e2 % i2 !== 0) throw new Error(`Bad begin offset: ${e2}`);
    const n2 = e2 + t2.byteLength;
    if (n2 % i2 !== 0 && n2 !== this.bytes.length) throw new Error(`Bad end offset: ${n2}`);
    this.bytes.set(new Uint8Array(t2), e2);
    const a2 = Math.floor(e2 / i2), s2 = Math.floor((n2 - 1) / i2) + 1;
    for (let e3 = a2; e3 < s2; ++e3) this._loadedChunks.add(e3);
  }
  onReceiveProgressiveData(e2) {
    let t2 = this.progressiveDataLength;
    const i2 = Math.floor(t2 / this.chunkSize);
    this.bytes.set(new Uint8Array(e2), t2), t2 += e2.byteLength, this.progressiveDataLength = t2;
    const n2 = t2 >= this.end ? this.numChunks : Math.floor(t2 / this.chunkSize);
    for (let e3 = i2; e3 < n2; ++e3) this._loadedChunks.add(e3);
  }
  ensureByte(e2) {
    if (e2 < this.progressiveDataLength) return;
    const t2 = Math.floor(e2 / this.chunkSize);
    if (!(t2 > this.numChunks) && t2 !== this.lastSuccessfulEnsureByteChunk) {
      if (!this._loadedChunks.has(t2)) throw new MissingDataException(e2, e2 + 1);
      this.lastSuccessfulEnsureByteChunk = t2;
    }
  }
  ensureRange(e2, t2) {
    if (e2 >= t2) return;
    if (t2 <= this.progressiveDataLength) return;
    const i2 = Math.floor(e2 / this.chunkSize);
    if (i2 > this.numChunks) return;
    const n2 = Math.min(Math.floor((t2 - 1) / this.chunkSize) + 1, this.numChunks);
    for (let a2 = i2; a2 < n2; ++a2) if (!this._loadedChunks.has(a2)) throw new MissingDataException(e2, t2);
  }
  nextEmptyChunk(e2) {
    const t2 = this.numChunks;
    for (let i2 = 0; i2 < t2; ++i2) {
      const n2 = (e2 + i2) % t2;
      if (!this._loadedChunks.has(n2)) return n2;
    }
    return null;
  }
  hasChunk(e2) {
    return this._loadedChunks.has(e2);
  }
  getByte() {
    const e2 = this.pos;
    return e2 >= this.end ? -1 : (e2 >= this.progressiveDataLength && this.ensureByte(e2), this.bytes[this.pos++]);
  }
  getBytes(e2) {
    const t2 = this.bytes, i2 = this.pos, n2 = this.end;
    if (!e2) return n2 > this.progressiveDataLength && this.ensureRange(i2, n2), t2.subarray(i2, n2);
    let a2 = i2 + e2;
    return a2 > n2 && (a2 = n2), a2 > this.progressiveDataLength && this.ensureRange(i2, a2), this.pos = a2, t2.subarray(i2, a2);
  }
  getByteRange(e2, t2) {
    return e2 < 0 && (e2 = 0), t2 > this.end && (t2 = this.end), t2 > this.progressiveDataLength && this.ensureRange(e2, t2), this.bytes.subarray(e2, t2);
  }
  makeSubStream(e2, t2, i2 = null) {
    function ChunkedStreamSubstream() {
    }
    t2 ? e2 + t2 > this.progressiveDataLength && this.ensureRange(e2, e2 + t2) : e2 >= this.progressiveDataLength && this.ensureByte(e2), ChunkedStreamSubstream.prototype = Object.create(this), ChunkedStreamSubstream.prototype.getMissingChunks = function() {
      const e3 = this.chunkSize, t3 = Math.floor(this.start / e3), i3 = Math.floor((this.end - 1) / e3) + 1, n3 = [];
      for (let e4 = t3; e4 < i3; ++e4) this._loadedChunks.has(e4) || n3.push(e4);
      return n3;
    }, Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", { get() {
      return this.numChunksLoaded === this.numChunks || 0 === this.getMissingChunks().length;
    }, configurable: true });
    const n2 = new ChunkedStreamSubstream();
    return n2.pos = n2.start = e2, n2.end = e2 + t2 || this.end, n2.dict = i2, n2;
  }
  getBaseStreams() {
    return [this];
  }
}
class ChunkedStreamManager {
  constructor(e2, t2) {
    this.length = t2.length, this.chunkSize = t2.rangeChunkSize, this.stream = new ChunkedStream(this.length, this.chunkSize, this), this.pdfNetworkStream = e2, this.disableAutoFetch = t2.disableAutoFetch, this.msgHandler = t2.msgHandler, this.currRequestId = 0, this._chunksNeededByRequest = /* @__PURE__ */ new Map(), this._requestsByChunk = /* @__PURE__ */ new Map(), this._promisesByRequest = /* @__PURE__ */ new Map(), this.progressiveDataLength = 0, this.aborted = false, this._loadedStreamCapability = Promise.withResolvers();
  }
  sendRequest(e2, t2) {
    const i2 = this.pdfNetworkStream.getRangeReader(e2, t2);
    i2.isStreamingSupported || (i2.onProgress = this.onProgress.bind(this));
    let n2 = [], a2 = 0;
    return new Promise((e3, t3) => {
      const readChunk = ({ value: s2, done: r2 }) => {
        try {
          if (r2) {
            const t4 = arrayBuffersToBytes(n2);
            return n2 = null, void e3(t4);
          }
          a2 += s2.byteLength, i2.isStreamingSupported && this.onProgress({ loaded: a2 }), n2.push(s2), i2.read().then(readChunk, t3);
        } catch (e4) {
          t3(e4);
        }
      };
      i2.read().then(readChunk, t3);
    }).then((t3) => {
      this.aborted || this.onReceiveData({ chunk: t3, begin: e2 });
    });
  }
  requestAllChunks(e2 = false) {
    if (!e2) {
      const e3 = this.stream.getMissingChunks();
      this._requestChunks(e3);
    }
    return this._loadedStreamCapability.promise;
  }
  _requestChunks(e2) {
    const t2 = this.currRequestId++, i2 = /* @__PURE__ */ new Set();
    this._chunksNeededByRequest.set(t2, i2);
    for (const t3 of e2) this.stream.hasChunk(t3) || i2.add(t3);
    if (0 === i2.size) return Promise.resolve();
    const n2 = Promise.withResolvers();
    this._promisesByRequest.set(t2, n2);
    const a2 = [];
    for (const e3 of i2) {
      let i3 = this._requestsByChunk.get(e3);
      i3 || (i3 = [], this._requestsByChunk.set(e3, i3), a2.push(e3)), i3.push(t2);
    }
    if (a2.length > 0) {
      const e3 = this.groupChunks(a2);
      for (const t3 of e3) {
        const e4 = t3.beginChunk * this.chunkSize, i3 = Math.min(t3.endChunk * this.chunkSize, this.length);
        this.sendRequest(e4, i3).catch(n2.reject);
      }
    }
    return n2.promise.catch((e3) => {
      if (!this.aborted) throw e3;
    });
  }
  getStream() {
    return this.stream;
  }
  requestRange(e2, t2) {
    t2 = Math.min(t2, this.length);
    const i2 = this.getBeginChunk(e2), n2 = this.getEndChunk(t2), a2 = [];
    for (let e3 = i2; e3 < n2; ++e3) a2.push(e3);
    return this._requestChunks(a2);
  }
  requestRanges(e2 = []) {
    const t2 = [];
    for (const i2 of e2) {
      const e3 = this.getBeginChunk(i2.begin), n2 = this.getEndChunk(i2.end);
      for (let i3 = e3; i3 < n2; ++i3) t2.includes(i3) || t2.push(i3);
    }
    return t2.sort((e3, t3) => e3 - t3), this._requestChunks(t2);
  }
  groupChunks(e2) {
    const t2 = [];
    let i2 = -1, n2 = -1;
    for (let a2 = 0, s2 = e2.length; a2 < s2; ++a2) {
      const s3 = e2[a2];
      i2 < 0 && (i2 = s3), n2 >= 0 && n2 + 1 !== s3 && (t2.push({ beginChunk: i2, endChunk: n2 + 1 }), i2 = s3), a2 + 1 === e2.length && t2.push({ beginChunk: i2, endChunk: s3 + 1 }), n2 = s3;
    }
    return t2;
  }
  onProgress(e2) {
    this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize + e2.loaded, total: this.length });
  }
  onReceiveData(e2) {
    const t2 = e2.chunk, i2 = void 0 === e2.begin, n2 = i2 ? this.progressiveDataLength : e2.begin, a2 = n2 + t2.byteLength, s2 = Math.floor(n2 / this.chunkSize), r2 = a2 < this.length ? Math.floor(a2 / this.chunkSize) : Math.ceil(a2 / this.chunkSize);
    i2 ? (this.stream.onReceiveProgressiveData(t2), this.progressiveDataLength = a2) : this.stream.onReceiveData(n2, t2), this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
    const o2 = [];
    for (let e3 = s2; e3 < r2; ++e3) {
      const t3 = this._requestsByChunk.get(e3);
      if (t3) {
        this._requestsByChunk.delete(e3);
        for (const i3 of t3) {
          const t4 = this._chunksNeededByRequest.get(i3);
          t4.has(e3) && t4.delete(e3), t4.size > 0 || o2.push(i3);
        }
      }
    }
    if (!this.disableAutoFetch && 0 === this._requestsByChunk.size) {
      let e3;
      if (1 === this.stream.numChunksLoaded) {
        const t3 = this.stream.numChunks - 1;
        this.stream.hasChunk(t3) || (e3 = t3);
      } else e3 = this.stream.nextEmptyChunk(r2);
      Number.isInteger(e3) && this._requestChunks([e3]);
    }
    for (const e3 of o2) {
      const t3 = this._promisesByRequest.get(e3);
      this._promisesByRequest.delete(e3), t3.resolve();
    }
    this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize, total: this.length });
  }
  onError(e2) {
    this._loadedStreamCapability.reject(e2);
  }
  getBeginChunk(e2) {
    return Math.floor(e2 / this.chunkSize);
  }
  getEndChunk(e2) {
    return Math.floor((e2 - 1) / this.chunkSize) + 1;
  }
  abort(e2) {
    this.aborted = true, this.pdfNetworkStream?.cancelAllRequests(e2);
    for (const t2 of this._promisesByRequest.values()) t2.reject(e2);
  }
}
function convertToRGBA(e2) {
  switch (e2.kind) {
    case v:
      return convertBlackAndWhiteToRGBA$1(e2);
    case C:
      return (function({ src: e3, srcPos: t2 = 0, dest: i2, destPos: n2 = 0, width: a2, height: s2 }) {
        let r2 = 0;
        const o2 = a2 * s2 * 3, l2 = o2 >> 2, c2 = new Uint32Array(e3.buffer, t2, l2);
        if (FeatureTest.isLittleEndian) {
          for (; r2 < l2 - 2; r2 += 3, n2 += 4) {
            const e4 = c2[r2], t3 = c2[r2 + 1], a3 = c2[r2 + 2];
            i2[n2] = 4278190080 | e4, i2[n2 + 1] = e4 >>> 24 | t3 << 8 | 4278190080, i2[n2 + 2] = t3 >>> 16 | a3 << 16 | 4278190080, i2[n2 + 3] = a3 >>> 8 | 4278190080;
          }
          for (let a3 = 4 * r2, s3 = t2 + o2; a3 < s3; a3 += 3) i2[n2++] = e3[a3] | e3[a3 + 1] << 8 | e3[a3 + 2] << 16 | 4278190080;
        } else {
          for (; r2 < l2 - 2; r2 += 3, n2 += 4) {
            const e4 = c2[r2], t3 = c2[r2 + 1], a3 = c2[r2 + 2];
            i2[n2] = 255 | e4, i2[n2 + 1] = e4 << 24 | t3 >>> 8 | 255, i2[n2 + 2] = t3 << 16 | a3 >>> 16 | 255, i2[n2 + 3] = a3 << 8 | 255;
          }
          for (let a3 = 4 * r2, s3 = t2 + o2; a3 < s3; a3 += 3) i2[n2++] = e3[a3] << 24 | e3[a3 + 1] << 16 | e3[a3 + 2] << 8 | 255;
        }
        return { srcPos: t2 + o2, destPos: n2 };
      })(e2);
  }
  return null;
}
function convertBlackAndWhiteToRGBA$1({ src: e2, srcPos: t2 = 0, dest: i2, width: n2, height: a2, nonBlackColor: s2 = 4294967295, inverseDecode: r2 = false }) {
  const o2 = FeatureTest.isLittleEndian ? 4278190080 : 255, [l2, c2] = r2 ? [s2, o2] : [o2, s2], h2 = n2 >> 3, d2 = 7 & n2, u2 = e2.length;
  i2 = new Uint32Array(i2.buffer);
  let g2 = 0;
  for (let n3 = 0; n3 < a2; n3++) {
    for (const n5 = t2 + h2; t2 < n5; t2++) {
      const n6 = t2 < u2 ? e2[t2] : 255;
      i2[g2++] = 128 & n6 ? c2 : l2, i2[g2++] = 64 & n6 ? c2 : l2, i2[g2++] = 32 & n6 ? c2 : l2, i2[g2++] = 16 & n6 ? c2 : l2, i2[g2++] = 8 & n6 ? c2 : l2, i2[g2++] = 4 & n6 ? c2 : l2, i2[g2++] = 2 & n6 ? c2 : l2, i2[g2++] = 1 & n6 ? c2 : l2;
    }
    if (0 === d2) continue;
    const n4 = t2 < u2 ? e2[t2++] : 255;
    for (let e3 = 0; e3 < d2; e3++) i2[g2++] = n4 & 1 << 7 - e3 ? c2 : l2;
  }
  return { srcPos: t2, destPos: g2 };
}
class ImageResizer {
  static #E = 2048;
  static #M = FeatureTest.isImageDecoderSupported;
  constructor(e2, t2) {
    this._imgData = e2, this._isMask = t2;
  }
  static get canUseImageDecoder() {
    return shadow$1(this, "canUseImageDecoder", this.#M ? ImageDecoder.isTypeSupported("image/bmp") : Promise.resolve(false));
  }
  static needsToBeResized(e2, t2) {
    if (e2 <= this.#E && t2 <= this.#E) return false;
    const { MAX_DIM: i2 } = this;
    if (e2 > i2 || t2 > i2) return true;
    const n2 = e2 * t2;
    if (this._hasMaxArea) return n2 > this.MAX_AREA;
    if (n2 < this.#E ** 2) return false;
    if (this._areGoodDims(e2, t2)) return this.#E = Math.max(this.#E, Math.floor(Math.sqrt(e2 * t2))), false;
    this.#E = this._guessMax(this.#E, i2, 128, 0);
    return n2 > (this.MAX_AREA = this.#E ** 2);
  }
  static getReducePowerForJPX(e2, t2, i2) {
    const n2 = e2 * t2, a2 = 2 ** 30 / (4 * i2);
    if (!this.needsToBeResized(e2, t2)) return n2 > a2 ? Math.ceil(Math.log2(n2 / a2)) : 0;
    const { MAX_DIM: s2, MAX_AREA: r2 } = this, o2 = Math.max(e2 / s2, t2 / s2, Math.sqrt(n2 / Math.min(a2, r2)));
    return Math.ceil(Math.log2(o2));
  }
  static get MAX_DIM() {
    return shadow$1(this, "MAX_DIM", this._guessMax(2048, 65537, 0, 1));
  }
  static get MAX_AREA() {
    return this._hasMaxArea = true, shadow$1(this, "MAX_AREA", this._guessMax(this.#E, this.MAX_DIM, 128, 0) ** 2);
  }
  static set MAX_AREA(e2) {
    e2 >= 0 && (this._hasMaxArea = true, shadow$1(this, "MAX_AREA", e2));
  }
  static setOptions({ canvasMaxAreaInBytes: e2 = -1, isImageDecoderSupported: t2 = false }) {
    this._hasMaxArea || (this.MAX_AREA = e2 >> 2), this.#M = t2;
  }
  static _areGoodDims(e2, t2) {
    try {
      const i2 = new OffscreenCanvas(e2, t2), n2 = i2.getContext("2d");
      n2.fillRect(0, 0, 1, 1);
      const a2 = n2.getImageData(0, 0, 1, 1).data[3];
      return i2.width = i2.height = 1, 0 !== a2;
    } catch {
      return false;
    }
  }
  static _guessMax(e2, t2, i2, n2) {
    for (; e2 + i2 + 1 < t2; ) {
      const i3 = Math.floor((e2 + t2) / 2), a2 = n2 || i3;
      this._areGoodDims(i3, a2) ? e2 = i3 : t2 = i3;
    }
    return e2;
  }
  static async createImage(e2, t2 = false) {
    return new ImageResizer(e2, t2)._createImage();
  }
  async _createImage() {
    const { _imgData: e2 } = this, { width: t2, height: i2 } = e2;
    if (t2 * i2 * 4 > fi) {
      const e3 = this.#D();
      if (e3) return e3;
    }
    const n2 = this._encodeBMP();
    let a2, s2;
    await ImageResizer.canUseImageDecoder ? (a2 = new ImageDecoder({ data: n2, type: "image/bmp", preferAnimation: false, transfer: [n2.buffer] }), s2 = a2.decode().catch((e3) => (warn$1(`BMP image decoding failed: ${e3}`), createImageBitmap(new Blob([this._encodeBMP().buffer], { type: "image/bmp" })))).finally(() => {
      a2.close();
    })) : s2 = createImageBitmap(new Blob([n2.buffer], { type: "image/bmp" }));
    const { MAX_AREA: r2, MAX_DIM: o2 } = ImageResizer, l2 = Math.max(t2 / o2, i2 / o2, Math.sqrt(t2 * i2 / r2)), c2 = Math.max(l2, 2), h2 = Math.round(10 * (l2 + 1.25)) / 10 / c2, d2 = Math.floor(Math.log2(h2)), u2 = new Array(d2 + 2).fill(2);
    u2[0] = c2, u2.splice(-1, 1, h2 / (1 << d2));
    let g2 = t2, f2 = i2;
    const p2 = await s2;
    let m2 = p2.image || p2;
    for (const e3 of u2) {
      const t3 = g2, i3 = f2;
      g2 = Math.floor(g2 / e3) - 1, f2 = Math.floor(f2 / e3) - 1;
      const n3 = new OffscreenCanvas(g2, f2);
      n3.getContext("2d").drawImage(m2, 0, 0, t3, i3, 0, 0, g2, f2), m2.close(), m2 = n3.transferToImageBitmap();
    }
    return e2.data = null, e2.bitmap = m2, e2.width = g2, e2.height = f2, e2;
  }
  #D() {
    const { _imgData: e2 } = this, { data: t2, width: i2, height: n2, kind: a2 } = e2, s2 = i2 * n2 * 4, r2 = Math.ceil(Math.log2(s2 / fi)), o2 = i2 >> r2, l2 = n2 >> r2;
    let c2, h2 = n2;
    try {
      c2 = new Uint8Array(s2);
    } catch {
      let e3 = Math.floor(Math.log2(s2 + 1));
      for (; ; ) try {
        c2 = new Uint8Array(2 ** e3 - 1);
        break;
      } catch {
        e3 -= 1;
      }
      h2 = Math.floor((2 ** e3 - 1) / (4 * i2));
      const t3 = i2 * h2 * 4;
      t3 < c2.length && (c2 = new Uint8Array(t3));
    }
    const d2 = new Uint32Array(c2.buffer), u2 = new Uint32Array(o2 * l2);
    let g2 = 0, f2 = 0;
    const p2 = Math.ceil(n2 / h2), m2 = n2 % h2 === 0 ? n2 : n2 % h2;
    for (let e3 = 0; e3 < p2; e3++) {
      const n3 = e3 < p2 - 1 ? h2 : m2;
      ({ srcPos: g2 } = convertToRGBA({ kind: a2, src: t2, dest: d2, width: i2, height: n3, inverseDecode: this._isMask, srcPos: g2 }));
      for (let e4 = 0, t3 = n3 >> r2; e4 < t3; e4++) {
        const t4 = d2.subarray((e4 << r2) * i2);
        for (let e5 = 0; e5 < o2; e5++) u2[f2++] = t4[e5 << r2];
      }
    }
    if (ImageResizer.needsToBeResized(o2, l2)) return e2.data = u2, e2.width = o2, e2.height = l2, e2.kind = k, null;
    const b2 = new OffscreenCanvas(o2, l2);
    return b2.getContext("2d", { willReadFrequently: true }).putImageData(new ImageData(new Uint8ClampedArray(u2.buffer), o2, l2), 0, 0), e2.data = null, e2.bitmap = b2.transferToImageBitmap(), e2.width = o2, e2.height = l2, e2;
  }
  _encodeBMP() {
    const { width: e2, height: t2, kind: i2 } = this._imgData;
    let n2, a2 = this._imgData.data, s2 = new Uint8Array(0), r2 = s2, o2 = 0;
    switch (i2) {
      case v: {
        n2 = 1, s2 = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);
        const i4 = e2 + 7 >> 3, r3 = i4 + 3 & -4;
        if (i4 !== r3) {
          const e3 = new Uint8Array(r3 * t2);
          let n3 = 0;
          for (let s3 = 0, o3 = t2 * i4; s3 < o3; s3 += i4, n3 += r3) e3.set(a2.subarray(s3, s3 + i4), n3);
          a2 = e3;
        }
        break;
      }
      case C:
        if (n2 = 24, 3 & e2) {
          const i4 = 3 * e2, n3 = i4 + 3 & -4, s3 = n3 - i4, r3 = new Uint8Array(n3 * t2);
          let o3 = 0;
          for (let e3 = 0, n4 = t2 * i4; e3 < n4; e3 += i4) {
            const t3 = a2.subarray(e3, e3 + i4);
            for (let e4 = 0; e4 < i4; e4 += 3) r3[o3++] = t3[e4 + 2], r3[o3++] = t3[e4 + 1], r3[o3++] = t3[e4];
            o3 += s3;
          }
          a2 = r3;
        } else for (let e3 = 0, t3 = a2.length; e3 < t3; e3 += 3) {
          const t4 = a2[e3];
          a2[e3] = a2[e3 + 2], a2[e3 + 2] = t4;
        }
        break;
      case k:
        n2 = 32, o2 = 3, r2 = new Uint8Array(68);
        const i3 = new DataView(r2.buffer);
        FeatureTest.isLittleEndian ? (i3.setUint32(0, 255, true), i3.setUint32(4, 65280, true), i3.setUint32(8, 16711680, true), i3.setUint32(12, 4278190080, true)) : (i3.setUint32(0, 4278190080, true), i3.setUint32(4, 16711680, true), i3.setUint32(8, 65280, true), i3.setUint32(12, 255, true));
        break;
      default:
        throw new Error("invalid format");
    }
    let l2 = 0;
    const c2 = 40 + r2.length, h2 = 14 + c2 + s2.length + a2.length, d2 = new Uint8Array(h2), u2 = new DataView(d2.buffer);
    return u2.setUint16(l2, 19778, true), l2 += 2, u2.setUint32(l2, h2, true), l2 += 4, u2.setUint32(l2, 0, true), l2 += 4, u2.setUint32(l2, 14 + c2 + s2.length, true), l2 += 4, u2.setUint32(l2, c2, true), l2 += 4, u2.setInt32(l2, e2, true), l2 += 4, u2.setInt32(l2, -t2, true), l2 += 4, u2.setUint16(l2, 1, true), l2 += 2, u2.setUint16(l2, n2, true), l2 += 2, u2.setUint32(l2, o2, true), l2 += 4, u2.setUint32(l2, 0, true), l2 += 4, u2.setInt32(l2, 0, true), l2 += 4, u2.setInt32(l2, 0, true), l2 += 4, u2.setUint32(l2, s2.length / 4, true), l2 += 4, u2.setUint32(l2, 0, true), l2 += 4, d2.set(r2, l2), l2 += r2.length, d2.set(s2, l2), l2 += s2.length, d2.set(a2, l2), d2;
  }
}
const Ti = new Uint8Array(0);
class DecodeStream extends BaseStream {
  constructor(e2) {
    if (super(), this._rawMinBufferLength = e2 || 0, this.pos = 0, this.bufferLength = 0, this.eof = false, this.buffer = Ti, this.minBufferLength = 512, e2) for (; this.minBufferLength < e2; ) this.minBufferLength *= 2;
  }
  get isEmpty() {
    for (; !this.eof && 0 === this.bufferLength; ) this.readBlock();
    return 0 === this.bufferLength;
  }
  ensureBuffer(e2) {
    const t2 = this.buffer;
    if (e2 <= t2.byteLength) return t2;
    let i2 = this.minBufferLength;
    for (; i2 < e2; ) i2 *= 2;
    const n2 = new Uint8Array(i2);
    return n2.set(t2), this.buffer = n2;
  }
  getByte() {
    const e2 = this.pos;
    for (; this.bufferLength <= e2; ) {
      if (this.eof) return -1;
      this.readBlock();
    }
    return this.buffer[this.pos++];
  }
  getBytes(e2, t2 = null) {
    const i2 = this.pos;
    let n2;
    if (e2) {
      for (this.ensureBuffer(i2 + e2), n2 = i2 + e2; !this.eof && this.bufferLength < n2; ) this.readBlock(t2);
      const a2 = this.bufferLength;
      n2 > a2 && (n2 = a2);
    } else {
      for (; !this.eof; ) this.readBlock(t2);
      n2 = this.bufferLength;
    }
    return this.pos = n2, this.buffer.subarray(i2, n2);
  }
  async getImageData(e2, t2) {
    if (!this.canAsyncDecodeImageFromBuffer) return this.isAsyncDecoder ? this.decodeImage(null, t2) : this.getBytes(e2, t2);
    const i2 = await this.stream.asyncGetBytes();
    return this.decodeImage(i2, t2);
  }
  reset() {
    this.pos = 0;
  }
  makeSubStream(e2, t2, i2 = null) {
    if (void 0 === t2) for (; !this.eof; ) this.readBlock();
    else {
      const i3 = e2 + t2;
      for (; this.bufferLength <= i3 && !this.eof; ) this.readBlock();
    }
    return new Stream(this.buffer, e2, t2, i2);
  }
  getBaseStreams() {
    return this.str ? this.str.getBaseStreams() : null;
  }
}
class StreamsSequenceStream extends DecodeStream {
  constructor(e2, t2 = null) {
    e2 = e2.filter((e3) => e3 instanceof BaseStream);
    let i2 = 0;
    for (const t3 of e2) i2 += t3 instanceof DecodeStream ? t3._rawMinBufferLength : t3.length;
    super(i2), this.streams = e2, this._onError = t2;
  }
  readBlock() {
    const e2 = this.streams;
    if (0 === e2.length) return void (this.eof = true);
    const t2 = e2.shift();
    let i2;
    try {
      i2 = t2.getBytes();
    } catch (e3) {
      if (this._onError) return void this._onError(e3, t2.dict?.objId);
      throw e3;
    }
    const n2 = this.bufferLength, a2 = n2 + i2.length;
    this.ensureBuffer(a2).set(i2, n2), this.bufferLength = a2;
  }
  getBaseStreams() {
    const e2 = [];
    for (const t2 of this.streams) {
      const i2 = t2.getBaseStreams();
      i2 && e2.push(...i2);
    }
    return e2.length > 0 ? e2 : null;
  }
}
class ColorSpaceUtils {
  static parse({ cs: e2, xref: t2, resources: i2 = null, pdfFunctionFactory: n2, globalColorSpaceCache: a2, localColorSpaceCache: s2, asyncIfNotCached: r2 = false }) {
    const o2 = { xref: t2, resources: i2, pdfFunctionFactory: n2, globalColorSpaceCache: a2, localColorSpaceCache: s2 };
    let l2, c2, h2;
    if (e2 instanceof Ref) {
      c2 = e2;
      const i3 = a2.getByRef(c2) || s2.getByRef(c2);
      if (i3) return i3;
      e2 = t2.fetch(e2);
    }
    if (e2 instanceof Name) {
      l2 = e2.name;
      const t3 = s2.getByName(l2);
      if (t3) return t3;
    }
    try {
      h2 = this.#O(e2, o2);
    } catch (e3) {
      if (r2 && !(e3 instanceof MissingDataException)) return Promise.reject(e3);
      throw e3;
    }
    return (l2 || c2) && (s2.set(l2, c2, h2), c2 && a2.set(null, c2, h2)), r2 ? Promise.resolve(h2) : h2;
  }
  static #_(e2, t2) {
    const { globalColorSpaceCache: i2 } = t2;
    let n2;
    if (e2 instanceof Ref) {
      n2 = e2;
      const t3 = i2.getByRef(n2);
      if (t3) return t3;
    }
    const a2 = this.#O(e2, t2);
    return n2 && i2.set(null, n2, a2), a2;
  }
  static #O(e2, t2) {
    const { xref: i2, resources: n2, pdfFunctionFactory: a2, globalColorSpaceCache: s2 } = t2;
    if ((e2 = i2.fetchIfRef(e2)) instanceof Name) switch (e2.name) {
      case "G":
      case "DeviceGray":
        return this.gray;
      case "RGB":
      case "DeviceRGB":
        return this.rgb;
      case "DeviceRGBA":
        return this.rgba;
      case "CMYK":
      case "DeviceCMYK":
        return this.cmyk;
      case "Pattern":
        return new PatternCS(null);
      default:
        if (n2 instanceof Dict) {
          const i3 = n2.get("ColorSpace");
          if (i3 instanceof Dict) {
            const n3 = i3.get(e2.name);
            if (n3) {
              if (n3 instanceof Name) return this.#O(n3, t2);
              e2 = n3;
              break;
            }
          }
        }
        return warn$1(`Unrecognized ColorSpace: ${e2.name}`), this.gray;
    }
    if (Array.isArray(e2)) {
      const n3 = i2.fetchIfRef(e2[0]).name;
      let r2, o2, l2, c2, h2, d2;
      switch (n3) {
        case "G":
        case "DeviceGray":
          return this.gray;
        case "RGB":
        case "DeviceRGB":
          return this.rgb;
        case "CMYK":
        case "DeviceCMYK":
          return this.cmyk;
        case "CalGray":
          return r2 = i2.fetchIfRef(e2[1]), c2 = r2.getArray("WhitePoint"), h2 = r2.getArray("BlackPoint"), d2 = r2.get("Gamma"), new CalGrayCS(c2, h2, d2);
        case "CalRGB":
          r2 = i2.fetchIfRef(e2[1]), c2 = r2.getArray("WhitePoint"), h2 = r2.getArray("BlackPoint"), d2 = r2.getArray("Gamma");
          const u2 = r2.getArray("Matrix");
          return new CalRGBCS(c2, h2, d2, u2);
        case "ICCBased":
          const g2 = e2[1] instanceof Ref;
          if (g2) {
            const t3 = s2.getByRef(e2[1]);
            if (t3) return t3;
          }
          const f2 = i2.fetchIfRef(e2[1]), p2 = f2.dict;
          if (o2 = p2.get("N"), IccColorSpace.isUsable) try {
            const t3 = new IccColorSpace(f2.getBytes(), "ICCBased", o2);
            return g2 && s2.set(null, e2[1], t3), t3;
          } catch (t3) {
            if (t3 instanceof MissingDataException) throw t3;
            warn$1(`ICCBased color space (${e2[1]}): "${t3}".`);
          }
          const m2 = p2.getRaw("Alternate");
          if (m2) {
            const e3 = this.#_(m2, t2);
            if (e3.numComps === o2) return e3;
            warn$1("ICCBased color space: Ignoring incorrect /Alternate entry.");
          }
          if (1 === o2) return this.gray;
          if (3 === o2) return this.rgb;
          if (4 === o2) return this.cmyk;
          break;
        case "Pattern":
          return l2 = e2[1] || null, l2 && (l2 = this.#_(l2, t2)), new PatternCS(l2);
        case "I":
        case "Indexed":
          l2 = this.#_(e2[1], t2);
          const b2 = MathClamp$1(i2.fetchIfRef(e2[2]), 0, 255), y2 = i2.fetchIfRef(e2[3]);
          return new IndexedCS(l2, b2, y2);
        case "Separation":
        case "DeviceN":
          const w2 = i2.fetchIfRef(e2[1]);
          o2 = Array.isArray(w2) ? w2.length : 1, l2 = this.#_(e2[2], t2);
          const x2 = a2.create(e2[3]);
          return new AlternateCS(o2, l2, x2);
        case "Lab":
          r2 = i2.fetchIfRef(e2[1]), c2 = r2.getArray("WhitePoint"), h2 = r2.getArray("BlackPoint");
          const S2 = r2.getArray("Range");
          return new LabCS(c2, h2, S2);
        default:
          return warn$1(`Unimplemented ColorSpace object: ${n3}`), this.gray;
      }
    }
    return warn$1(`Unrecognized ColorSpace object: ${e2}`), this.gray;
  }
  static get gray() {
    return shadow$1(this, "gray", new DeviceGrayCS());
  }
  static get rgb() {
    return shadow$1(this, "rgb", new DeviceRgbCS());
  }
  static get rgba() {
    return shadow$1(this, "rgba", new DeviceRgbaCS());
  }
  static get cmyk() {
    if (CmykICCBasedCS.isUsable) try {
      return shadow$1(this, "cmyk", new CmykICCBasedCS());
    } catch {
      warn$1("CMYK fallback: DeviceCMYK");
    }
    return shadow$1(this, "cmyk", new DeviceCmykCS());
  }
}
class JpegError extends Yt {
  constructor(e2) {
    super(e2, "JpegError");
  }
}
class DNLMarkerError extends Yt {
  constructor(e2, t2) {
    super(e2, "DNLMarkerError"), this.scanLines = t2;
  }
}
class EOIMarkerError extends Yt {
  constructor(e2) {
    super(e2, "EOIMarkerError");
  }
}
const Fi = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), Ii = 4017, Ei = 799, Mi = 3406, Di = 2276, Oi = 1567, _i = 3784, Pi = 5793, Ri = 2896;
function buildHuffmanTable(e2, t2) {
  let i2, n2, a2 = 0, s2 = 16;
  for (; s2 > 0 && !e2[s2 - 1]; ) s2--;
  const r2 = [{ children: [], index: 0 }];
  let o2, l2 = r2[0];
  for (i2 = 0; i2 < s2; i2++) {
    for (n2 = 0; n2 < e2[i2]; n2++) {
      for (l2 = r2.pop(), l2.children[l2.index] = t2[a2]; l2.index > 0; ) l2 = r2.pop();
      for (l2.index++, r2.push(l2); r2.length <= i2; ) r2.push(o2 = { children: [], index: 0 }), l2.children[l2.index] = o2.children, l2 = o2;
      a2++;
    }
    i2 + 1 < s2 && (r2.push(o2 = { children: [], index: 0 }), l2.children[l2.index] = o2.children, l2 = o2);
  }
  return r2[0].children;
}
function getBlockBufferOffset(e2, t2, i2) {
  return 64 * ((e2.blocksPerLine + 1) * t2 + i2);
}
function decodeScan(e2, t2, i2, n2, a2, s2, r2, o2, l2, c2 = false) {
  const h2 = i2.mcusPerLine, d2 = i2.progressive, u2 = t2;
  let g2 = 0, f2 = 0;
  function readBit() {
    if (f2 > 0) return f2--, g2 >> f2 & 1;
    if (g2 = e2[t2++], 255 === g2) {
      const n3 = e2[t2++];
      if (n3) {
        if (220 === n3 && c2) {
          const n4 = readUint16(e2, t2 += 2);
          if (t2 += 2, n4 > 0 && n4 !== i2.scanLines) throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", n4);
        } else if (217 === n3) {
          if (c2) {
            const e3 = y2 * (8 === i2.precision ? 8 : 0);
            if (e3 > 0 && Math.round(i2.scanLines / e3) >= 5) throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", e3);
          }
          throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
        }
        throw new JpegError(`unexpected marker ${(g2 << 8 | n3).toString(16)}`);
      }
    }
    return f2 = 7, g2 >>> 7;
  }
  function decodeHuffman(e3) {
    let t3 = e3;
    for (; ; ) {
      switch (t3 = t3[readBit()], typeof t3) {
        case "number":
          return t3;
        case "object":
          continue;
      }
      throw new JpegError("invalid huffman sequence");
    }
  }
  function receive(e3) {
    let t3 = 0;
    for (; e3 > 0; ) t3 = t3 << 1 | readBit(), e3--;
    return t3;
  }
  function receiveAndExtend(e3) {
    if (1 === e3) return 1 === readBit() ? 1 : -1;
    const t3 = receive(e3);
    return t3 >= 1 << e3 - 1 ? t3 : t3 + (-1 << e3) + 1;
  }
  let p2 = 0;
  let m2, b2 = 0;
  let y2 = 0;
  function decodeMcu(e3, t3, i3, n3, a3) {
    const s3 = i3 % h2;
    y2 = (i3 / h2 | 0) * e3.v + n3;
    const r3 = s3 * e3.h + a3;
    t3(e3, getBlockBufferOffset(e3, y2, r3));
  }
  function decodeBlock(e3, t3, i3) {
    y2 = i3 / e3.blocksPerLine | 0;
    const n3 = i3 % e3.blocksPerLine;
    t3(e3, getBlockBufferOffset(e3, y2, n3));
  }
  const w2 = n2.length;
  let x2, S2, v2, C2, k2, T2;
  T2 = d2 ? 0 === s2 ? 0 === o2 ? function(e3, t3) {
    const i3 = decodeHuffman(e3.huffmanTableDC), n3 = 0 === i3 ? 0 : receiveAndExtend(i3) << l2;
    e3.blockData[t3] = e3.pred += n3;
  } : function(e3, t3) {
    e3.blockData[t3] |= readBit() << l2;
  } : 0 === o2 ? function(e3, t3) {
    if (p2 > 0) return void p2--;
    let i3 = s2;
    const n3 = r2;
    for (; i3 <= n3; ) {
      const n4 = decodeHuffman(e3.huffmanTableAC), a3 = 15 & n4, s3 = n4 >> 4;
      if (0 === a3) {
        if (s3 < 15) {
          p2 = receive(s3) + (1 << s3) - 1;
          break;
        }
        i3 += 16;
        continue;
      }
      i3 += s3;
      const r3 = Fi[i3];
      e3.blockData[t3 + r3] = receiveAndExtend(a3) * (1 << l2), i3++;
    }
  } : function(e3, t3) {
    let i3 = s2;
    const n3 = r2;
    let a3, o3, c3 = 0;
    for (; i3 <= n3; ) {
      const n4 = t3 + Fi[i3], s3 = e3.blockData[n4] < 0 ? -1 : 1;
      switch (b2) {
        case 0:
          if (o3 = decodeHuffman(e3.huffmanTableAC), a3 = 15 & o3, c3 = o3 >> 4, 0 === a3) c3 < 15 ? (p2 = receive(c3) + (1 << c3), b2 = 4) : (c3 = 16, b2 = 1);
          else {
            if (1 !== a3) throw new JpegError("invalid ACn encoding");
            m2 = receiveAndExtend(a3), b2 = c3 ? 2 : 3;
          }
          continue;
        case 1:
        case 2:
          e3.blockData[n4] ? e3.blockData[n4] += s3 * (readBit() << l2) : (c3--, 0 === c3 && (b2 = 2 === b2 ? 3 : 0));
          break;
        case 3:
          e3.blockData[n4] ? e3.blockData[n4] += s3 * (readBit() << l2) : (e3.blockData[n4] = m2 << l2, b2 = 0);
          break;
        case 4:
          e3.blockData[n4] && (e3.blockData[n4] += s3 * (readBit() << l2));
      }
      i3++;
    }
    4 === b2 && (p2--, 0 === p2 && (b2 = 0));
  } : function(e3, t3) {
    const i3 = decodeHuffman(e3.huffmanTableDC), n3 = 0 === i3 ? 0 : receiveAndExtend(i3);
    e3.blockData[t3] = e3.pred += n3;
    let a3 = 1;
    for (; a3 < 64; ) {
      const i4 = decodeHuffman(e3.huffmanTableAC), n4 = 15 & i4, s3 = i4 >> 4;
      if (0 === n4) {
        if (s3 < 15) break;
        a3 += 16;
        continue;
      }
      a3 += s3;
      const r3 = Fi[a3];
      e3.blockData[t3 + r3] = receiveAndExtend(n4), a3++;
    }
  };
  let F2, E2 = 0;
  const M2 = 1 === w2 ? n2[0].blocksPerLine * n2[0].blocksPerColumn : h2 * i2.mcusPerColumn;
  let D2, O2;
  for (; E2 <= M2; ) {
    const i3 = a2 ? Math.min(M2 - E2, a2) : M2;
    if (i3 > 0) {
      for (S2 = 0; S2 < w2; S2++) n2[S2].pred = 0;
      if (p2 = 0, 1 === w2) for (x2 = n2[0], k2 = 0; k2 < i3; k2++) decodeBlock(x2, T2, E2), E2++;
      else for (k2 = 0; k2 < i3; k2++) {
        for (S2 = 0; S2 < w2; S2++) for (x2 = n2[S2], D2 = x2.h, O2 = x2.v, v2 = 0; v2 < O2; v2++) for (C2 = 0; C2 < D2; C2++) decodeMcu(x2, T2, E2, v2, C2);
        E2++;
      }
    }
    if (f2 = 0, F2 = findNextFileMarker(e2, t2), !F2) break;
    if (F2.invalid) {
      warn$1(`decodeScan - ${i3 > 0 ? "unexpected" : "excessive"} MCU data, current marker is: ${F2.invalid}`), t2 = F2.offset;
    }
    if (!(F2.marker >= 65488 && F2.marker <= 65495)) break;
    t2 += 2;
  }
  return t2 - u2;
}
function quantizeAndInverse(e2, t2, i2) {
  const n2 = e2.quantizationTable, a2 = e2.blockData;
  let s2, r2, o2, l2, c2, h2, d2, u2, g2, f2, p2, m2, b2, y2, w2, x2, S2;
  if (!n2) throw new JpegError("missing required Quantization Table.");
  for (let e3 = 0; e3 < 64; e3 += 8) g2 = a2[t2 + e3], f2 = a2[t2 + e3 + 1], p2 = a2[t2 + e3 + 2], m2 = a2[t2 + e3 + 3], b2 = a2[t2 + e3 + 4], y2 = a2[t2 + e3 + 5], w2 = a2[t2 + e3 + 6], x2 = a2[t2 + e3 + 7], g2 *= n2[e3], 0 !== (f2 | p2 | m2 | b2 | y2 | w2 | x2) ? (f2 *= n2[e3 + 1], p2 *= n2[e3 + 2], m2 *= n2[e3 + 3], b2 *= n2[e3 + 4], y2 *= n2[e3 + 5], w2 *= n2[e3 + 6], x2 *= n2[e3 + 7], s2 = Pi * g2 + 128 >> 8, r2 = Pi * b2 + 128 >> 8, o2 = p2, l2 = w2, c2 = Ri * (f2 - x2) + 128 >> 8, u2 = Ri * (f2 + x2) + 128 >> 8, h2 = m2 << 4, d2 = y2 << 4, s2 = s2 + r2 + 1 >> 1, r2 = s2 - r2, S2 = o2 * _i + l2 * Oi + 128 >> 8, o2 = o2 * Oi - l2 * _i + 128 >> 8, l2 = S2, c2 = c2 + d2 + 1 >> 1, d2 = c2 - d2, u2 = u2 + h2 + 1 >> 1, h2 = u2 - h2, s2 = s2 + l2 + 1 >> 1, l2 = s2 - l2, r2 = r2 + o2 + 1 >> 1, o2 = r2 - o2, S2 = c2 * Di + u2 * Mi + 2048 >> 12, c2 = c2 * Mi - u2 * Di + 2048 >> 12, u2 = S2, S2 = h2 * Ei + d2 * Ii + 2048 >> 12, h2 = h2 * Ii - d2 * Ei + 2048 >> 12, d2 = S2, i2[e3] = s2 + u2, i2[e3 + 7] = s2 - u2, i2[e3 + 1] = r2 + d2, i2[e3 + 6] = r2 - d2, i2[e3 + 2] = o2 + h2, i2[e3 + 5] = o2 - h2, i2[e3 + 3] = l2 + c2, i2[e3 + 4] = l2 - c2) : (S2 = Pi * g2 + 512 >> 10, i2[e3] = S2, i2[e3 + 1] = S2, i2[e3 + 2] = S2, i2[e3 + 3] = S2, i2[e3 + 4] = S2, i2[e3 + 5] = S2, i2[e3 + 6] = S2, i2[e3 + 7] = S2);
  for (let e3 = 0; e3 < 8; ++e3) g2 = i2[e3], f2 = i2[e3 + 8], p2 = i2[e3 + 16], m2 = i2[e3 + 24], b2 = i2[e3 + 32], y2 = i2[e3 + 40], w2 = i2[e3 + 48], x2 = i2[e3 + 56], 0 !== (f2 | p2 | m2 | b2 | y2 | w2 | x2) ? (s2 = Pi * g2 + 2048 >> 12, r2 = Pi * b2 + 2048 >> 12, o2 = p2, l2 = w2, c2 = Ri * (f2 - x2) + 2048 >> 12, u2 = Ri * (f2 + x2) + 2048 >> 12, h2 = m2, d2 = y2, s2 = 4112 + (s2 + r2 + 1 >> 1), r2 = s2 - r2, S2 = o2 * _i + l2 * Oi + 2048 >> 12, o2 = o2 * Oi - l2 * _i + 2048 >> 12, l2 = S2, c2 = c2 + d2 + 1 >> 1, d2 = c2 - d2, u2 = u2 + h2 + 1 >> 1, h2 = u2 - h2, s2 = s2 + l2 + 1 >> 1, l2 = s2 - l2, r2 = r2 + o2 + 1 >> 1, o2 = r2 - o2, S2 = c2 * Di + u2 * Mi + 2048 >> 12, c2 = c2 * Mi - u2 * Di + 2048 >> 12, u2 = S2, S2 = h2 * Ei + d2 * Ii + 2048 >> 12, h2 = h2 * Ii - d2 * Ei + 2048 >> 12, d2 = S2, g2 = s2 + u2, x2 = s2 - u2, f2 = r2 + d2, w2 = r2 - d2, p2 = o2 + h2, y2 = o2 - h2, m2 = l2 + c2, b2 = l2 - c2, g2 < 16 ? g2 = 0 : g2 >= 4080 ? g2 = 255 : g2 >>= 4, f2 < 16 ? f2 = 0 : f2 >= 4080 ? f2 = 255 : f2 >>= 4, p2 < 16 ? p2 = 0 : p2 >= 4080 ? p2 = 255 : p2 >>= 4, m2 < 16 ? m2 = 0 : m2 >= 4080 ? m2 = 255 : m2 >>= 4, b2 < 16 ? b2 = 0 : b2 >= 4080 ? b2 = 255 : b2 >>= 4, y2 < 16 ? y2 = 0 : y2 >= 4080 ? y2 = 255 : y2 >>= 4, w2 < 16 ? w2 = 0 : w2 >= 4080 ? w2 = 255 : w2 >>= 4, x2 < 16 ? x2 = 0 : x2 >= 4080 ? x2 = 255 : x2 >>= 4, a2[t2 + e3] = g2, a2[t2 + e3 + 8] = f2, a2[t2 + e3 + 16] = p2, a2[t2 + e3 + 24] = m2, a2[t2 + e3 + 32] = b2, a2[t2 + e3 + 40] = y2, a2[t2 + e3 + 48] = w2, a2[t2 + e3 + 56] = x2) : (S2 = Pi * g2 + 8192 >> 14, S2 = S2 < -2040 ? 0 : S2 >= 2024 ? 255 : S2 + 2056 >> 4, a2[t2 + e3] = S2, a2[t2 + e3 + 8] = S2, a2[t2 + e3 + 16] = S2, a2[t2 + e3 + 24] = S2, a2[t2 + e3 + 32] = S2, a2[t2 + e3 + 40] = S2, a2[t2 + e3 + 48] = S2, a2[t2 + e3 + 56] = S2);
}
function buildComponentData(e2, t2) {
  const i2 = t2.blocksPerLine, n2 = t2.blocksPerColumn, a2 = new Int16Array(64);
  for (let e3 = 0; e3 < n2; e3++) for (let n3 = 0; n3 < i2; n3++) {
    quantizeAndInverse(t2, getBlockBufferOffset(t2, e3, n3), a2);
  }
  return t2.blockData;
}
function findNextFileMarker(e2, t2, i2 = t2) {
  const n2 = e2.length - 1;
  let a2 = i2 < t2 ? i2 : t2;
  if (t2 >= n2) return null;
  const s2 = readUint16(e2, t2);
  if (s2 >= 65472 && s2 <= 65534) return { invalid: null, marker: s2, offset: t2 };
  let r2 = readUint16(e2, a2);
  for (; !(r2 >= 65472 && r2 <= 65534); ) {
    if (++a2 >= n2) return null;
    r2 = readUint16(e2, a2);
  }
  return { invalid: s2.toString(16), marker: r2, offset: a2 };
}
function prepareComponents(e2) {
  const t2 = Math.ceil(e2.samplesPerLine / 8 / e2.maxH), i2 = Math.ceil(e2.scanLines / 8 / e2.maxV);
  for (const n2 of e2.components) {
    const a2 = Math.ceil(Math.ceil(e2.samplesPerLine / 8) * n2.h / e2.maxH), s2 = Math.ceil(Math.ceil(e2.scanLines / 8) * n2.v / e2.maxV), r2 = t2 * n2.h, o2 = 64 * (i2 * n2.v) * (r2 + 1);
    n2.blockData = new Int16Array(o2), n2.blocksPerLine = a2, n2.blocksPerColumn = s2;
  }
  e2.mcusPerLine = t2, e2.mcusPerColumn = i2;
}
function readDataBlock(e2, t2) {
  const i2 = readUint16(e2, t2);
  let n2 = (t2 += 2) + i2 - 2;
  const a2 = findNextFileMarker(e2, n2, t2);
  a2?.invalid && (warn$1("readDataBlock - incorrect length, current marker is: " + a2.invalid), n2 = a2.offset);
  const s2 = e2.subarray(t2, n2);
  return { appData: s2, oldOffset: t2, newOffset: t2 + s2.length };
}
function skipData(e2, t2) {
  const i2 = readUint16(e2, t2), n2 = (t2 += 2) + i2 - 2, a2 = findNextFileMarker(e2, n2, t2);
  return a2?.invalid ? a2.offset : n2;
}
class JpegImage {
  constructor({ decodeTransform: e2 = null, colorTransform: t2 = -1 } = {}) {
    this._decodeTransform = e2, this._colorTransform = t2;
  }
  static canUseImageDecoder(e2, t2 = -1) {
    let i2 = null, n2 = 0, a2 = null, s2 = readUint16(e2, n2);
    if (n2 += 2, 65496 !== s2) throw new JpegError("SOI not found");
    s2 = readUint16(e2, n2), n2 += 2;
    e: for (; 65497 !== s2; ) {
      switch (s2) {
        case 65505:
          const { appData: t3, oldOffset: r2, newOffset: o2 } = readDataBlock(e2, n2);
          if (n2 = o2, 69 === t3[0] && 120 === t3[1] && 105 === t3[2] && 102 === t3[3] && 0 === t3[4] && 0 === t3[5]) {
            if (i2) throw new JpegError("Duplicate EXIF-blocks found.");
            i2 = { exifStart: r2 + 6, exifEnd: o2 };
          }
          s2 = readUint16(e2, n2), n2 += 2;
          continue;
        case 65472:
        case 65473:
        case 65474:
          a2 = e2[n2 + 7];
          break e;
        case 65535:
          255 !== e2[n2] && n2--;
      }
      n2 = skipData(e2, n2), s2 = readUint16(e2, n2), n2 += 2;
    }
    return 4 === a2 || 3 === a2 && 0 === t2 ? null : i2 || {};
  }
  parse(e2, { dnlScanLines: t2 = null } = {}) {
    let i2, n2, a2 = 0, s2 = null, r2 = null, o2 = 0;
    const l2 = [], c2 = [], h2 = [];
    let d2 = readUint16(e2, a2);
    if (a2 += 2, 65496 !== d2) throw new JpegError("SOI not found");
    d2 = readUint16(e2, a2), a2 += 2;
    e: for (; 65497 !== d2; ) {
      let u2, g2, f2;
      switch (d2) {
        case 65504:
        case 65505:
        case 65506:
        case 65507:
        case 65508:
        case 65509:
        case 65510:
        case 65511:
        case 65512:
        case 65513:
        case 65514:
        case 65515:
        case 65516:
        case 65517:
        case 65518:
        case 65519:
        case 65534:
          const { appData: p2, newOffset: m2 } = readDataBlock(e2, a2);
          a2 = m2, 65504 === d2 && 74 === p2[0] && 70 === p2[1] && 73 === p2[2] && 70 === p2[3] && 0 === p2[4] && (s2 = { version: { major: p2[5], minor: p2[6] }, densityUnits: p2[7], xDensity: p2[8] << 8 | p2[9], yDensity: p2[10] << 8 | p2[11], thumbWidth: p2[12], thumbHeight: p2[13], thumbData: p2.subarray(14, 14 + 3 * p2[12] * p2[13]) }), 65518 === d2 && 65 === p2[0] && 100 === p2[1] && 111 === p2[2] && 98 === p2[3] && 101 === p2[4] && (r2 = { version: p2[5] << 8 | p2[6], flags0: p2[7] << 8 | p2[8], flags1: p2[9] << 8 | p2[10], transformCode: p2[11] });
          break;
        case 65499:
          const b2 = readUint16(e2, a2);
          a2 += 2;
          const y2 = b2 + a2 - 2;
          let w2;
          for (; a2 < y2; ) {
            const t3 = e2[a2++], i3 = new Uint16Array(64);
            if (t3 >> 4) {
              if (t3 >> 4 != 1) throw new JpegError("DQT - invalid table spec");
              for (g2 = 0; g2 < 64; g2++) w2 = Fi[g2], i3[w2] = readUint16(e2, a2), a2 += 2;
            } else for (g2 = 0; g2 < 64; g2++) w2 = Fi[g2], i3[w2] = e2[a2++];
            l2[15 & t3] = i3;
          }
          break;
        case 65472:
        case 65473:
        case 65474:
          if (i2) throw new JpegError("Only single frame JPEGs supported");
          a2 += 2, i2 = {}, i2.extended = 65473 === d2, i2.progressive = 65474 === d2, i2.precision = e2[a2++];
          const x2 = readUint16(e2, a2);
          a2 += 2, i2.scanLines = t2 || x2, i2.samplesPerLine = readUint16(e2, a2), a2 += 2, i2.components = [], i2.componentIds = {};
          const S2 = e2[a2++];
          let v2 = 0, C2 = 0;
          for (u2 = 0; u2 < S2; u2++) {
            const t3 = e2[a2], n3 = e2[a2 + 1] >> 4, s3 = 15 & e2[a2 + 1];
            v2 < n3 && (v2 = n3), C2 < s3 && (C2 = s3);
            const r3 = e2[a2 + 2];
            f2 = i2.components.push({ h: n3, v: s3, quantizationId: r3, quantizationTable: null }), i2.componentIds[t3] = f2 - 1, a2 += 3;
          }
          i2.maxH = v2, i2.maxV = C2, prepareComponents(i2);
          break;
        case 65476:
          const k2 = readUint16(e2, a2);
          for (a2 += 2, u2 = 2; u2 < k2; ) {
            const t3 = e2[a2++], i3 = new Uint8Array(16);
            let n3 = 0;
            for (g2 = 0; g2 < 16; g2++, a2++) n3 += i3[g2] = e2[a2];
            const s3 = new Uint8Array(n3);
            for (g2 = 0; g2 < n3; g2++, a2++) s3[g2] = e2[a2];
            u2 += 17 + n3, (t3 >> 4 ? c2 : h2)[15 & t3] = buildHuffmanTable(i3, s3);
          }
          break;
        case 65501:
          a2 += 2, n2 = readUint16(e2, a2), a2 += 2;
          break;
        case 65498:
          const T2 = 1 === ++o2 && !t2;
          a2 += 2;
          const F2 = e2[a2++], E2 = [];
          for (u2 = 0; u2 < F2; u2++) {
            const t3 = e2[a2++], n3 = i2.componentIds[t3], s3 = i2.components[n3];
            s3.index = t3;
            const r3 = e2[a2++];
            s3.huffmanTableDC = h2[r3 >> 4], s3.huffmanTableAC = c2[15 & r3], E2.push(s3);
          }
          const M2 = e2[a2++], D2 = e2[a2++], O2 = e2[a2++];
          try {
            a2 += decodeScan(e2, a2, i2, E2, n2, M2, D2, O2 >> 4, 15 & O2, T2);
          } catch (t3) {
            if (t3 instanceof DNLMarkerError) return warn$1(`${t3.message} -- attempting to re-parse the JPEG image.`), this.parse(e2, { dnlScanLines: t3.scanLines });
            if (t3 instanceof EOIMarkerError) {
              warn$1(`${t3.message} -- ignoring the rest of the image data.`);
              break e;
            }
            throw t3;
          }
          break;
        case 65500:
          a2 += 4;
          break;
        case 65535:
          255 !== e2[a2] && a2--;
          break;
        default:
          const _2 = findNextFileMarker(e2, a2 - 2, a2 - 3);
          if (_2?.invalid) {
            warn$1("JpegImage.parse - unexpected data, current marker is: " + _2.invalid), a2 = _2.offset;
            break;
          }
          if (!_2 || a2 >= e2.length - 1) {
            warn$1("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
            break e;
          }
          throw new JpegError("JpegImage.parse - unknown marker: " + d2.toString(16));
      }
      d2 = readUint16(e2, a2), a2 += 2;
    }
    if (!i2) throw new JpegError("JpegImage.parse - no frame data found.");
    this.width = i2.samplesPerLine, this.height = i2.scanLines, this.jfif = s2, this.adobe = r2, this.components = [];
    for (const e3 of i2.components) {
      const t3 = l2[e3.quantizationId];
      t3 && (e3.quantizationTable = t3), this.components.push({ index: e3.index, output: buildComponentData(0, e3), scaleX: e3.h / i2.maxH, scaleY: e3.v / i2.maxV, blocksPerLine: e3.blocksPerLine, blocksPerColumn: e3.blocksPerColumn });
    }
    this.numComponents = this.components.length;
  }
  _getLinearizedBlockData(e2, t2, i2 = false) {
    const n2 = this.width / e2, a2 = this.height / t2;
    let s2, r2, o2, l2, c2, h2, d2, u2, g2, f2, p2, m2 = 0;
    const b2 = this.components.length, y2 = e2 * t2 * b2, w2 = new Uint8ClampedArray(y2), x2 = new Uint32Array(e2), S2 = 4294967288;
    let v2;
    for (d2 = 0; d2 < b2; d2++) {
      if (s2 = this.components[d2], r2 = s2.scaleX * n2, o2 = s2.scaleY * a2, m2 = d2, p2 = s2.output, l2 = s2.blocksPerLine + 1 << 3, r2 !== v2) {
        for (c2 = 0; c2 < e2; c2++) u2 = 0 | c2 * r2, x2[c2] = (u2 & S2) << 3 | 7 & u2;
        v2 = r2;
      }
      for (h2 = 0; h2 < t2; h2++) for (u2 = 0 | h2 * o2, f2 = l2 * (u2 & S2) | (7 & u2) << 3, c2 = 0; c2 < e2; c2++) w2[m2] = p2[f2 + x2[c2]], m2 += b2;
    }
    let C2 = this._decodeTransform;
    if (i2 || 4 !== b2 || C2 || (C2 = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), C2) for (d2 = 0; d2 < y2; ) for (u2 = 0, g2 = 0; u2 < b2; u2++, d2++, g2 += 2) w2[d2] = (w2[d2] * C2[g2] >> 8) + C2[g2 + 1];
    return w2;
  }
  get _isColorConversionNeeded() {
    return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this._colorTransform && (82 !== this.components[0].index || 71 !== this.components[1].index || 66 !== this.components[2].index) : 1 === this._colorTransform;
  }
  _convertYccToRgb(e2) {
    let t2, i2, n2;
    for (let a2 = 0, s2 = e2.length; a2 < s2; a2 += 3) t2 = e2[a2], i2 = e2[a2 + 1], n2 = e2[a2 + 2], e2[a2] = t2 - 179.456 + 1.402 * n2, e2[a2 + 1] = t2 + 135.459 - 0.344 * i2 - 0.714 * n2, e2[a2 + 2] = t2 - 226.816 + 1.772 * i2;
    return e2;
  }
  _convertYccToRgba(e2, t2) {
    for (let i2 = 0, n2 = 0, a2 = e2.length; i2 < a2; i2 += 3, n2 += 4) {
      const a3 = e2[i2], s2 = e2[i2 + 1], r2 = e2[i2 + 2];
      t2[n2] = a3 - 179.456 + 1.402 * r2, t2[n2 + 1] = a3 + 135.459 - 0.344 * s2 - 0.714 * r2, t2[n2 + 2] = a3 - 226.816 + 1.772 * s2, t2[n2 + 3] = 255;
    }
    return t2;
  }
  _convertYcckToRgb(e2) {
    return this._convertYcckToCmyk(e2), this._convertCmykToRgb(e2);
  }
  _convertYcckToRgba(e2) {
    return this._convertYcckToCmyk(e2), this._convertCmykToRgba(e2);
  }
  _convertYcckToCmyk(e2) {
    let t2, i2, n2;
    for (let a2 = 0, s2 = e2.length; a2 < s2; a2 += 4) t2 = e2[a2], i2 = e2[a2 + 1], n2 = e2[a2 + 2], e2[a2] = 434.456 - t2 - 1.402 * n2, e2[a2 + 1] = 119.541 - t2 + 0.344 * i2 + 0.714 * n2, e2[a2 + 2] = 481.816 - t2 - 1.772 * i2;
    return e2;
  }
  _convertCmykToRgb(e2) {
    const t2 = e2.length / 4;
    return ColorSpaceUtils.cmyk.getRgbBuffer(e2, 0, t2, e2, 0, 8, 0), e2.subarray(0, 3 * t2);
  }
  _convertCmykToRgba(e2) {
    if (ColorSpaceUtils.cmyk.getRgbBuffer(e2, 0, e2.length / 4, e2, 0, 8, 1), ColorSpaceUtils.cmyk instanceof DeviceCmykCS) for (let t2 = 3, i2 = e2.length; t2 < i2; t2 += 4) e2[t2] = 255;
    return e2;
  }
  getData({ width: e2, height: t2, forceRGBA: i2 = false, forceRGB: n2 = false, isSourcePDF: a2 = false }) {
    if (this.numComponents > 4) throw new JpegError("Unsupported color mode");
    const s2 = this._getLinearizedBlockData(e2, t2, a2);
    if (1 === this.numComponents && (i2 || n2)) {
      const e3 = s2.length * (i2 ? 4 : 3), t3 = new Uint8ClampedArray(e3);
      let n3 = 0;
      if (i2) !(function(e4, t4) {
        if (FeatureTest.isLittleEndian) for (let i3 = 0, n4 = e4.length; i3 < n4; i3++) t4[i3] = 65793 * e4[i3] | 4278190080;
        else for (let i3 = 0, n4 = e4.length; i3 < n4; i3++) t4[i3] = 16843008 * e4[i3] | 255;
      })(s2, new Uint32Array(t3.buffer));
      else for (const e4 of s2) t3[n3++] = e4, t3[n3++] = e4, t3[n3++] = e4;
      return t3;
    }
    if (3 === this.numComponents && this._isColorConversionNeeded) {
      if (i2) {
        const e3 = new Uint8ClampedArray(s2.length / 3 * 4);
        return this._convertYccToRgba(s2, e3);
      }
      return this._convertYccToRgb(s2);
    }
    if (4 === this.numComponents) {
      if (this._isColorConversionNeeded) return i2 ? this._convertYcckToRgba(s2) : n2 ? this._convertYcckToRgb(s2) : this._convertYcckToCmyk(s2);
      if (i2) return this._convertCmykToRgba(s2);
      if (n2) return this._convertCmykToRgb(s2);
    }
    return s2;
  }
}
class JpegStream extends DecodeStream {
  static #M = FeatureTest.isImageDecoderSupported;
  constructor(e2, t2, i2) {
    super(t2), this.stream = e2, this.dict = e2.dict, this.maybeLength = t2, this.params = i2;
  }
  static get canUseImageDecoder() {
    return shadow$1(this, "canUseImageDecoder", this.#M ? ImageDecoder.isTypeSupported("image/jpeg") : Promise.resolve(false));
  }
  static setOptions({ isImageDecoderSupported: e2 = false }) {
    this.#M = e2;
  }
  get bytes() {
    return shadow$1(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(e2) {
  }
  readBlock() {
    this.decodeImage();
  }
  get jpegOptions() {
    const e2 = { decodeTransform: void 0, colorTransform: void 0 }, t2 = this.dict.getArray("D", "Decode");
    if ((this.forceRGBA || this.forceRGB) && Array.isArray(t2)) {
      const i2 = this.dict.get("BPC", "BitsPerComponent") || 8, n2 = t2.length, a2 = new Int32Array(n2);
      let s2 = false;
      const r2 = (1 << i2) - 1;
      for (let e3 = 0; e3 < n2; e3 += 2) a2[e3] = 256 * (t2[e3 + 1] - t2[e3]) | 0, a2[e3 + 1] = t2[e3] * r2 | 0, 256 === a2[e3] && 0 === a2[e3 + 1] || (s2 = true);
      s2 && (e2.decodeTransform = a2);
    }
    if (this.params instanceof Dict) {
      const t3 = this.params.get("ColorTransform");
      Number.isInteger(t3) && (e2.colorTransform = t3);
    }
    return shadow$1(this, "jpegOptions", e2);
  }
  #P(e2) {
    for (let t2 = 0, i2 = e2.length - 1; t2 < i2; t2++) if (255 === e2[t2] && 216 === e2[t2 + 1]) {
      t2 > 0 && (e2 = e2.subarray(t2));
      break;
    }
    return e2;
  }
  decodeImage(e2) {
    if (this.eof) return this.buffer;
    e2 = this.#P(e2 || this.bytes);
    const t2 = new JpegImage(this.jpegOptions);
    t2.parse(e2);
    const i2 = t2.getData({ width: this.drawWidth, height: this.drawHeight, forceRGBA: this.forceRGBA, forceRGB: this.forceRGB, isSourcePDF: true });
    return this.buffer = i2, this.bufferLength = i2.length, this.eof = true, this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
  async getTransferableImage() {
    if (!await JpegStream.canUseImageDecoder) return null;
    const e2 = this.jpegOptions;
    if (e2.decodeTransform) return null;
    let t2;
    try {
      const i2 = this.canAsyncDecodeImageFromBuffer && await this.stream.asyncGetBytes() || this.bytes;
      if (!i2) return null;
      let n2 = this.#P(i2);
      const a2 = JpegImage.canUseImageDecoder(n2, e2.colorTransform);
      return a2 ? (a2.exifStart && (n2 = n2.slice(), n2.fill(0, a2.exifStart, a2.exifEnd)), t2 = new ImageDecoder({ data: n2, type: "image/jpeg", preferAnimation: false }), (await t2.decode()).image) : null;
    } catch (e3) {
      return warn$1(`getTransferableImage - failed: "${e3}".`), null;
    } finally {
      t2?.close();
    }
  }
}
class JpxError extends Yt {
  constructor(e2) {
    super(e2, "JpxError");
  }
}
class JpxImage {
  static #R = null;
  static #B = null;
  static #N = null;
  static #k = true;
  static #L = true;
  static #T = null;
  static setOptions({ handler: e2, useWasm: t2, useWorkerFetch: i2, wasmUrl: n2 }) {
    this.#k = t2, this.#L = i2, this.#T = n2, i2 || (this.#B = e2);
  }
  static async #U(e2) {
  }
  static async #j(e2, t2, i2) {
  }
  static async decode(e2, { numComponents: t2 = 4, isIndexedColormap: i2 = false, smaskInData: n2 = false, reducePower: a2 = 0 } = {}) {
    const s2 = await this.#N;
    if (!s2) throw new JpxError("OpenJPEG failed to initialize");
    let r2;
    try {
      const o2 = e2.length;
      r2 = s2._malloc(o2), s2.writeArrayToMemory(e2, r2);
      if (s2._jp2_decode(r2, o2, t2 > 0 ? t2 : 0, !!i2, !!n2, a2)) {
        const { errorMessages: e3 } = s2;
        if (e3) throw delete s2.errorMessages, new JpxError(e3);
        throw new JpxError("Unknown error");
      }
      const { imageData: l2 } = s2;
      return s2.imageData = null, l2;
    } finally {
      r2 && s2._free(r2);
    }
  }
  static cleanup() {
    this.#N = null;
  }
  static parseImageProperties(e2) {
    let t2 = e2.getByte();
    for (; t2 >= 0; ) {
      const i2 = t2;
      t2 = e2.getByte();
      if (65361 === (i2 << 8 | t2)) {
        e2.skip(4);
        const t3 = e2.getInt32() >>> 0, i3 = e2.getInt32() >>> 0, n2 = e2.getInt32() >>> 0, a2 = e2.getInt32() >>> 0;
        e2.skip(16);
        return { width: t3 - n2, height: i3 - a2, bitsPerComponent: 8, componentsCount: e2.getUint16() };
      }
    }
    throw new JpxError("No size marker found in JPX stream");
  }
}
function addState(e2, t2, i2, n2, a2) {
  let s2 = e2;
  for (let e3 = 0, i3 = t2.length - 1; e3 < i3; e3++) {
    const i4 = t2[e3];
    s2 = s2[i4] ||= [];
  }
  s2[t2.at(-1)] = { checkFn: i2, iterateFn: n2, processFn: a2 };
}
const Bi = [];
addState(Bi, [pe, be, Pt, me], null, function(e2, t2) {
  const i2 = e2.fnArray, n2 = (t2 - (e2.iCurr - 3)) % 4;
  switch (n2) {
    case 0:
      return i2[t2] === pe;
    case 1:
      return i2[t2] === be;
    case 2:
      return i2[t2] === Pt;
    case 3:
      return i2[t2] === me;
  }
  throw new Error(`iterateInlineImageGroup - invalid pos: ${n2}`);
}, function(e2, t2) {
  const i2 = e2.fnArray, n2 = e2.argsArray, a2 = e2.iCurr, s2 = a2 - 3, r2 = a2 - 2, o2 = a2 - 1, l2 = Math.min(Math.floor((t2 - s2) / 4), 200);
  if (l2 < 10) return t2 - (t2 - s2) % 4;
  let c2 = 0;
  const h2 = [];
  let d2 = 0, u2 = 1, g2 = 1;
  for (let e3 = 0; e3 < l2; e3++) {
    const t3 = n2[r2 + (e3 << 2)], i3 = n2[o2 + (e3 << 2)][0];
    u2 + i3.width > 1e3 && (c2 = Math.max(c2, u2), g2 += d2 + 2, u2 = 0, d2 = 0), h2.push({ transform: t3, x: u2, y: g2, w: i3.width, h: i3.height }), u2 += i3.width + 2, d2 = Math.max(d2, i3.height);
  }
  const f2 = Math.max(c2, u2) + 1, p2 = g2 + d2 + 1, m2 = new Uint8Array(f2 * p2 * 4), b2 = f2 << 2;
  for (let e3 = 0; e3 < l2; e3++) {
    const t3 = n2[o2 + (e3 << 2)][0].data, i3 = h2[e3].w << 2;
    let a3 = 0, s3 = h2[e3].x + h2[e3].y * f2 << 2;
    m2.set(t3.subarray(0, i3), s3 - b2);
    for (let n3 = 0, r3 = h2[e3].h; n3 < r3; n3++) m2.set(t3.subarray(a3, a3 + i3), s3), a3 += i3, s3 += b2;
    for (m2.set(t3.subarray(a3 - i3, a3), s3); s3 >= 0; ) t3[s3 - 4] = t3[s3], t3[s3 - 3] = t3[s3 + 1], t3[s3 - 2] = t3[s3 + 2], t3[s3 - 1] = t3[s3 + 3], t3[s3 + i3] = t3[s3 + i3 - 4], t3[s3 + i3 + 1] = t3[s3 + i3 - 3], t3[s3 + i3 + 2] = t3[s3 + i3 - 2], t3[s3 + i3 + 3] = t3[s3 + i3 - 1], s3 -= b2;
  }
  const y2 = { width: f2, height: p2 };
  if (e2.isOffscreenCanvasSupported) {
    const e3 = new OffscreenCanvas(f2, p2);
    e3.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(m2.buffer), f2, p2), 0, 0), y2.bitmap = e3.transferToImageBitmap(), y2.data = null;
  } else y2.kind = k, y2.data = m2;
  return i2.splice(s2, 4 * l2, Rt), n2.splice(s2, 4 * l2, [y2, h2]), s2 + 1;
}), addState(Bi, [pe, be, Dt, me], null, function(e2, t2) {
  const i2 = e2.fnArray, n2 = (t2 - (e2.iCurr - 3)) % 4;
  switch (n2) {
    case 0:
      return i2[t2] === pe;
    case 1:
      return i2[t2] === be;
    case 2:
      return i2[t2] === Dt;
    case 3:
      return i2[t2] === me;
  }
  throw new Error(`iterateImageMaskGroup - invalid pos: ${n2}`);
}, function(e2, t2) {
  const i2 = e2.fnArray, n2 = e2.argsArray, a2 = e2.iCurr, s2 = a2 - 3, r2 = a2 - 2, o2 = a2 - 1;
  let l2 = Math.floor((t2 - s2) / 4);
  if (l2 < 10) return t2 - (t2 - s2) % 4;
  let c2, h2, d2 = false;
  const u2 = n2[o2][0], g2 = n2[r2][0], f2 = n2[r2][1], p2 = n2[r2][2], m2 = n2[r2][3];
  if (f2 === p2) {
    d2 = true, c2 = r2 + 4;
    let e3 = o2 + 4;
    for (let t3 = 1; t3 < l2; t3++, c2 += 4, e3 += 4) if (h2 = n2[c2], n2[e3][0] !== u2 || h2[0] !== g2 || h2[1] !== f2 || h2[2] !== p2 || h2[3] !== m2) {
      t3 < 10 ? d2 = false : l2 = t3;
      break;
    }
  }
  if (d2) {
    l2 = Math.min(l2, 1e3);
    const e3 = new Float32Array(2 * l2);
    c2 = r2;
    for (let t3 = 0; t3 < l2; t3++, c2 += 4) h2 = n2[c2], e3[t3 << 1] = h2[4], e3[1 + (t3 << 1)] = h2[5];
    i2.splice(s2, 4 * l2, Nt), n2.splice(s2, 4 * l2, [u2, g2, f2, p2, m2, e3]);
  } else {
    l2 = Math.min(l2, 100);
    const e3 = [];
    for (let t3 = 0; t3 < l2; t3++) {
      h2 = n2[r2 + (t3 << 2)];
      const i3 = n2[o2 + (t3 << 2)][0];
      e3.push({ data: i3.data, width: i3.width, height: i3.height, interpolate: i3.interpolate, count: i3.count, transform: h2 });
    }
    i2.splice(s2, 4 * l2, Ot), n2.splice(s2, 4 * l2, [e3]);
  }
  return s2 + 1;
}), addState(Bi, [pe, be, _t, me], function(e2) {
  const t2 = e2.argsArray, i2 = e2.iCurr - 2;
  return 0 === t2[i2][1] && 0 === t2[i2][2];
}, function(e2, t2) {
  const i2 = e2.fnArray, n2 = e2.argsArray, a2 = (t2 - (e2.iCurr - 3)) % 4;
  switch (a2) {
    case 0:
      return i2[t2] === pe;
    case 1:
      if (i2[t2] !== be) return false;
      const a3 = e2.iCurr - 2, s2 = n2[a3][0], r2 = n2[a3][3];
      return n2[t2][0] === s2 && 0 === n2[t2][1] && 0 === n2[t2][2] && n2[t2][3] === r2;
    case 2:
      if (i2[t2] !== _t) return false;
      const o2 = n2[e2.iCurr - 1][0];
      return n2[t2][0] === o2;
    case 3:
      return i2[t2] === me;
  }
  throw new Error(`iterateImageGroup - invalid pos: ${a2}`);
}, function(e2, t2) {
  const i2 = e2.fnArray, n2 = e2.argsArray, a2 = e2.iCurr, s2 = a2 - 3, r2 = a2 - 2, o2 = n2[a2 - 1][0], l2 = n2[r2][0], c2 = n2[r2][3], h2 = Math.min(Math.floor((t2 - s2) / 4), 1e3);
  if (h2 < 3) return t2 - (t2 - s2) % 4;
  const d2 = new Float32Array(2 * h2);
  let u2 = r2;
  for (let e3 = 0; e3 < h2; e3++, u2 += 4) {
    const t3 = n2[u2];
    d2[e3 << 1] = t3[4], d2[1 + (e3 << 1)] = t3[5];
  }
  const g2 = [o2, l2, c2, d2];
  return i2.splice(s2, 4 * h2, Bt), n2.splice(s2, 4 * h2, g2), s2 + 1;
}), addState(Bi, [Be, He, Ge, Ke, Ne], null, function(e2, t2) {
  const i2 = e2.fnArray, n2 = e2.argsArray, a2 = (t2 - (e2.iCurr - 4)) % 5;
  switch (a2) {
    case 0:
      return i2[t2] === Be;
    case 1:
      return i2[t2] === He;
    case 2:
      return i2[t2] === Ge;
    case 3:
      if (i2[t2] !== Ke) return false;
      const a3 = e2.iCurr - 3, s2 = n2[a3][0], r2 = n2[a3][1];
      return n2[t2][0] === s2 && n2[t2][1] === r2;
    case 4:
      return i2[t2] === Ne;
  }
  throw new Error(`iterateShowTextGroup - invalid pos: ${a2}`);
}, function(e2, t2) {
  const i2 = e2.fnArray, n2 = e2.argsArray, a2 = e2.iCurr, s2 = a2 - 4, r2 = a2 - 3, o2 = a2 - 2, l2 = a2 - 1, c2 = a2, h2 = n2[r2][0], d2 = n2[r2][1];
  let u2 = Math.min(Math.floor((t2 - s2) / 5), 1e3);
  if (u2 < 3) return t2 - (t2 - s2) % 5;
  let g2 = s2;
  s2 >= 4 && i2[s2 - 4] === i2[r2] && i2[s2 - 3] === i2[o2] && i2[s2 - 2] === i2[l2] && i2[s2 - 1] === i2[c2] && n2[s2 - 4][0] === h2 && n2[s2 - 4][1] === d2 && (u2++, g2 -= 5);
  let f2 = g2 + 4;
  for (let e3 = 1; e3 < u2; e3++) i2.splice(f2, 3), n2.splice(f2, 3), f2 += 2;
  return f2 + 1;
}), addState(Bi, [pe, be, Ut, me], (e2) => {
  const t2 = e2.argsArray, i2 = t2[e2.iCurr - 1][0];
  if (i2 !== ke && i2 !== Te && i2 !== Ee && i2 !== Me && i2 !== De && i2 !== Oe) return true;
  const n2 = t2[e2.iCurr - 2];
  return 1 === n2[0] && 0 === n2[1] && 0 === n2[2] && 1 === n2[3];
}, () => false, (e2, t2) => {
  const { fnArray: i2, argsArray: n2 } = e2, a2 = e2.iCurr, s2 = a2 - 3, r2 = a2 - 2, o2 = n2[a2 - 1], l2 = n2[r2], [, [c2], h2] = o2;
  if (h2) {
    ai.scaleMinMax(l2, h2);
    for (let e3 = 0, t3 = c2.length; e3 < t3; ) switch (c2[e3++]) {
      case Xt:
      case qt:
        ai.applyTransform(c2, l2, e3), e3 += 2;
        break;
      case zt:
        ai.applyTransformToBezier(c2, l2, e3), e3 += 6;
    }
  }
  return i2.splice(s2, 4, Ut), n2.splice(s2, 4, o2), s2 + 1;
});
class NullOptimizer {
  constructor(e2) {
    this.queue = e2;
  }
  _optimize() {
  }
  push(e2, t2) {
    this.queue.fnArray.push(e2), this.queue.argsArray.push(t2), this._optimize();
  }
  flush() {
  }
  reset() {
  }
}
class QueueOptimizer extends NullOptimizer {
  constructor(e2) {
    super(e2), this.state = null, this.context = { iCurr: 0, fnArray: e2.fnArray, argsArray: e2.argsArray, isOffscreenCanvasSupported: OperatorList.isOffscreenCanvasSupported }, this.match = null, this.lastProcessed = 0;
  }
  _optimize() {
    const e2 = this.queue.fnArray;
    let t2 = this.lastProcessed, i2 = e2.length, n2 = this.state, a2 = this.match;
    if (!n2 && !a2 && t2 + 1 === i2 && !Bi[e2[t2]]) return void (this.lastProcessed = i2);
    const s2 = this.context;
    for (; t2 < i2; ) {
      if (a2) {
        if ((0, a2.iterateFn)(s2, t2)) {
          t2++;
          continue;
        }
        if (t2 = (0, a2.processFn)(s2, t2 + 1), i2 = e2.length, a2 = null, n2 = null, t2 >= i2) break;
      }
      n2 = (n2 || Bi)[e2[t2]], n2 && !Array.isArray(n2) ? (s2.iCurr = t2, t2++, !n2.checkFn || (0, n2.checkFn)(s2) ? (a2 = n2, n2 = null) : n2 = null) : t2++;
    }
    this.state = n2, this.match = a2, this.lastProcessed = t2;
  }
  flush() {
    for (; this.match; ) {
      const e2 = this.queue.fnArray.length;
      this.lastProcessed = (0, this.match.processFn)(this.context, e2), this.match = null, this.state = null, this._optimize();
    }
  }
  reset() {
    this.state = null, this.match = null, this.lastProcessed = 0;
  }
}
class OperatorList {
  static CHUNK_SIZE = 1e3;
  static CHUNK_SIZE_ABOUT = this.CHUNK_SIZE - 5;
  static isOffscreenCanvasSupported = false;
  constructor(e2 = 0, t2) {
    this._streamSink = t2, this.fnArray = [], this.argsArray = [], this.optimizer = !t2 || e2 & u ? new NullOptimizer(this) : new QueueOptimizer(this), this.dependencies = /* @__PURE__ */ new Set(), this._totalLength = 0, this.weight = 0, this._resolved = t2 ? null : Promise.resolve();
  }
  static setOptions({ isOffscreenCanvasSupported: e2 }) {
    this.isOffscreenCanvasSupported = e2;
  }
  get length() {
    return this.argsArray.length;
  }
  get ready() {
    return this._resolved || this._streamSink.ready;
  }
  get totalLength() {
    return this._totalLength + this.length;
  }
  addOp(e2, t2) {
    this.optimizer.push(e2, t2), this.weight++, this._streamSink && (this.weight >= OperatorList.CHUNK_SIZE || this.weight >= OperatorList.CHUNK_SIZE_ABOUT && (e2 === me || e2 === Ne)) && this.flush();
  }
  addImageOps(e2, t2, i2, n2 = false) {
    n2 && (this.addOp(pe), this.addOp(fe, [[["SMask", false]]])), void 0 !== i2 && this.addOp(xt, ["OC", i2]), this.addOp(e2, t2), void 0 !== i2 && this.addOp(St, []), n2 && this.addOp(me);
  }
  addDependency(e2) {
    this.dependencies.has(e2) || (this.dependencies.add(e2), this.addOp(re, [e2]));
  }
  addDependencies(e2) {
    for (const t2 of e2) this.addDependency(t2);
  }
  addOpList(e2) {
    if (e2 instanceof OperatorList) {
      for (const t2 of e2.dependencies) this.dependencies.add(t2);
      for (let t2 = 0, i2 = e2.length; t2 < i2; t2++) this.addOp(e2.fnArray[t2], e2.argsArray[t2]);
    } else warn$1('addOpList - ignoring invalid "opList" parameter.');
  }
  getIR() {
    return { fnArray: this.fnArray, argsArray: this.argsArray, length: this.length };
  }
  get _transfers() {
    const e2 = [], { fnArray: t2, argsArray: i2, length: n2 } = this;
    for (let a2 = 0; a2 < n2; a2++) switch (t2[a2]) {
      case Pt:
      case Rt:
      case Dt: {
        const { bitmap: t4, data: n4 } = i2[a2][0];
        (t4 || n4?.buffer) && e2.push(t4 || n4.buffer);
        break;
      }
      case Ut: {
        const [, [t4], n4] = i2[a2];
        t4 && e2.push(t4.buffer, n4.buffer);
        break;
      }
      case kt:
        const [t3, n3] = i2[a2];
        t3 && e2.push(t3.buffer), n3 && e2.push(n3.buffer);
        break;
      case Ge:
        e2.push(i2[a2][0].buffer);
    }
    return e2;
  }
  flush(e2 = false, t2 = null) {
    this.optimizer.flush();
    const i2 = this.length;
    this._totalLength += i2, this._streamSink.enqueue({ fnArray: this.fnArray, argsArray: this.argsArray, lastChunk: e2, separateAnnots: t2, length: i2 }, 1, this._transfers), this.dependencies.clear(), this.fnArray.length = 0, this.argsArray.length = 0, this.weight = 0, this.optimizer.reset();
  }
}
function hexToInt(e2, t2) {
  let i2 = 0;
  for (let n2 = 0; n2 <= t2; n2++) i2 = i2 << 8 | e2[n2];
  return i2 >>> 0;
}
function hexToStr(e2, t2) {
  return 1 === t2 ? String.fromCharCode(e2[0], e2[1]) : 3 === t2 ? String.fromCharCode(e2[0], e2[1], e2[2], e2[3]) : String.fromCharCode(...e2.subarray(0, t2 + 1));
}
function addHex(e2, t2, i2) {
  let n2 = 0;
  for (let a2 = i2; a2 >= 0; a2--) n2 += e2[a2] + t2[a2], e2[a2] = 255 & n2, n2 >>= 8;
}
function incHex(e2, t2) {
  let i2 = 1;
  for (let n2 = t2; n2 >= 0 && i2 > 0; n2--) i2 += e2[n2], e2[n2] = 255 & i2, i2 >>= 8;
}
const Ni = 16;
class BinaryCMapStream {
  constructor(e2) {
    this.buffer = e2, this.pos = 0, this.end = e2.length, this.tmpBuf = new Uint8Array(19);
  }
  readByte() {
    return this.pos >= this.end ? -1 : this.buffer[this.pos++];
  }
  readNumber() {
    let e2, t2 = 0;
    do {
      const i2 = this.readByte();
      if (i2 < 0) throw new ti("unexpected EOF in bcmap");
      e2 = !(128 & i2), t2 = t2 << 7 | 127 & i2;
    } while (!e2);
    return t2;
  }
  readSigned() {
    const e2 = this.readNumber();
    return 1 & e2 ? ~(e2 >>> 1) : e2 >>> 1;
  }
  readHex(e2, t2) {
    e2.set(this.buffer.subarray(this.pos, this.pos + t2 + 1)), this.pos += t2 + 1;
  }
  readHexNumber(e2, t2) {
    let i2;
    const n2 = this.tmpBuf;
    let a2 = 0;
    do {
      const e3 = this.readByte();
      if (e3 < 0) throw new ti("unexpected EOF in bcmap");
      i2 = !(128 & e3), n2[a2++] = 127 & e3;
    } while (!i2);
    let s2 = t2, r2 = 0, o2 = 0;
    for (; s2 >= 0; ) {
      for (; o2 < 8 && n2.length > 0; ) r2 |= n2[--a2] << o2, o2 += 7;
      e2[s2] = 255 & r2, s2--, r2 >>= 8, o2 -= 8;
    }
  }
  readHexSigned(e2, t2) {
    this.readHexNumber(e2, t2);
    const i2 = 1 & e2[t2] ? 255 : 0;
    let n2 = 0;
    for (let a2 = 0; a2 <= t2; a2++) n2 = (1 & n2) << 8 | e2[a2], e2[a2] = n2 >> 1 ^ i2;
  }
  readString() {
    const e2 = this.readNumber(), t2 = new Array(e2);
    for (let i2 = 0; i2 < e2; i2++) t2[i2] = this.readNumber();
    return String.fromCharCode(...t2);
  }
}
class BinaryCMapReader {
  async process(e2, t2, i2) {
    const n2 = new BinaryCMapStream(e2), a2 = n2.readByte();
    t2.vertical = !!(1 & a2);
    let s2 = null;
    const r2 = new Uint8Array(Ni), o2 = new Uint8Array(Ni), l2 = new Uint8Array(Ni), c2 = new Uint8Array(Ni), h2 = new Uint8Array(Ni);
    let d2, u2;
    for (; (u2 = n2.readByte()) >= 0; ) {
      const e3 = u2 >> 5;
      if (7 === e3) {
        switch (31 & u2) {
          case 0:
            n2.readString();
            break;
          case 1:
            s2 = n2.readString();
        }
        continue;
      }
      const i3 = !!(16 & u2), a3 = 15 & u2;
      if (a3 + 1 > Ni) throw new Error("BinaryCMapReader.process: Invalid dataSize.");
      const g2 = 1, f2 = n2.readNumber();
      switch (e3) {
        case 0:
          n2.readHex(r2, a3), n2.readHexNumber(o2, a3), addHex(o2, r2, a3), t2.addCodespaceRange(a3 + 1, hexToInt(r2, a3), hexToInt(o2, a3));
          for (let e4 = 1; e4 < f2; e4++) incHex(o2, a3), n2.readHexNumber(r2, a3), addHex(r2, o2, a3), n2.readHexNumber(o2, a3), addHex(o2, r2, a3), t2.addCodespaceRange(a3 + 1, hexToInt(r2, a3), hexToInt(o2, a3));
          break;
        case 1:
          n2.readHex(r2, a3), n2.readHexNumber(o2, a3), addHex(o2, r2, a3), n2.readNumber();
          for (let e4 = 1; e4 < f2; e4++) incHex(o2, a3), n2.readHexNumber(r2, a3), addHex(r2, o2, a3), n2.readHexNumber(o2, a3), addHex(o2, r2, a3), n2.readNumber();
          break;
        case 2:
          n2.readHex(l2, a3), d2 = n2.readNumber(), t2.mapOne(hexToInt(l2, a3), d2);
          for (let e4 = 1; e4 < f2; e4++) incHex(l2, a3), i3 || (n2.readHexNumber(h2, a3), addHex(l2, h2, a3)), d2 = n2.readSigned() + (d2 + 1), t2.mapOne(hexToInt(l2, a3), d2);
          break;
        case 3:
          n2.readHex(r2, a3), n2.readHexNumber(o2, a3), addHex(o2, r2, a3), d2 = n2.readNumber(), t2.mapCidRange(hexToInt(r2, a3), hexToInt(o2, a3), d2);
          for (let e4 = 1; e4 < f2; e4++) incHex(o2, a3), i3 ? r2.set(o2) : (n2.readHexNumber(r2, a3), addHex(r2, o2, a3)), n2.readHexNumber(o2, a3), addHex(o2, r2, a3), d2 = n2.readNumber(), t2.mapCidRange(hexToInt(r2, a3), hexToInt(o2, a3), d2);
          break;
        case 4:
          n2.readHex(l2, g2), n2.readHex(c2, a3), t2.mapOne(hexToInt(l2, g2), hexToStr(c2, a3));
          for (let e4 = 1; e4 < f2; e4++) incHex(l2, g2), i3 || (n2.readHexNumber(h2, g2), addHex(l2, h2, g2)), incHex(c2, a3), n2.readHexSigned(h2, a3), addHex(c2, h2, a3), t2.mapOne(hexToInt(l2, g2), hexToStr(c2, a3));
          break;
        case 5:
          n2.readHex(r2, g2), n2.readHexNumber(o2, g2), addHex(o2, r2, g2), n2.readHex(c2, a3), t2.mapBfRange(hexToInt(r2, g2), hexToInt(o2, g2), hexToStr(c2, a3));
          for (let e4 = 1; e4 < f2; e4++) incHex(o2, g2), i3 ? r2.set(o2) : (n2.readHexNumber(r2, g2), addHex(r2, o2, g2)), n2.readHexNumber(o2, g2), addHex(o2, r2, g2), n2.readHex(c2, a3), t2.mapBfRange(hexToInt(r2, g2), hexToInt(o2, g2), hexToStr(c2, a3));
          break;
        default:
          throw new Error(`BinaryCMapReader.process - unknown type: ${e3}`);
      }
    }
    return s2 ? i2(s2) : t2;
  }
}
class Ascii85Stream extends DecodeStream {
  constructor(e2, t2) {
    t2 && (t2 *= 0.8), super(t2), this.str = e2, this.dict = e2.dict, this.input = new Uint8Array(5);
  }
  readBlock() {
    const e2 = this.str;
    let t2 = e2.getByte();
    for (; isWhiteSpace(t2); ) t2 = e2.getByte();
    if (-1 === t2 || 126 === t2) return void (this.eof = true);
    const i2 = this.bufferLength;
    let n2, a2;
    if (122 === t2) {
      for (n2 = this.ensureBuffer(i2 + 4), a2 = 0; a2 < 4; ++a2) n2[i2 + a2] = 0;
      this.bufferLength += 4;
    } else {
      const s2 = this.input;
      for (s2[0] = t2, a2 = 1; a2 < 5; ++a2) {
        for (t2 = e2.getByte(); isWhiteSpace(t2); ) t2 = e2.getByte();
        if (s2[a2] = t2, -1 === t2 || 126 === t2) break;
      }
      if (n2 = this.ensureBuffer(i2 + a2 - 1), this.bufferLength += a2 - 1, a2 < 5) {
        for (; a2 < 5; ++a2) s2[a2] = 117;
        this.eof = true;
      }
      let r2 = 0;
      for (a2 = 0; a2 < 5; ++a2) r2 = 85 * r2 + (s2[a2] - 33);
      for (a2 = 3; a2 >= 0; --a2) n2[i2 + a2] = 255 & r2, r2 >>= 8;
    }
  }
}
class AsciiHexStream extends DecodeStream {
  constructor(e2, t2) {
    t2 && (t2 *= 0.5), super(t2), this.str = e2, this.dict = e2.dict, this.firstDigit = -1;
  }
  readBlock() {
    const e2 = this.str.getBytes(8e3);
    if (!e2.length) return void (this.eof = true);
    const t2 = e2.length + 1 >> 1, i2 = this.ensureBuffer(this.bufferLength + t2);
    let n2 = this.bufferLength, a2 = this.firstDigit;
    for (const t3 of e2) {
      let e3;
      if (t3 >= 48 && t3 <= 57) e3 = 15 & t3;
      else {
        if (!(t3 >= 65 && t3 <= 70 || t3 >= 97 && t3 <= 102)) {
          if (62 === t3) {
            this.eof = true;
            break;
          }
          continue;
        }
        e3 = 9 + (15 & t3);
      }
      a2 < 0 ? a2 = e3 : (i2[n2++] = a2 << 4 | e3, a2 = -1);
    }
    a2 >= 0 && this.eof && (i2[n2++] = a2 << 4, a2 = -1), this.firstDigit = a2, this.bufferLength = n2;
  }
}
const ji = -1, $i = [[-1, -1], [-1, -1], [7, 8], [7, 7], [6, 6], [6, 6], [6, 5], [6, 5], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]], Hi = [[-1, -1], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]], Xi = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]], qi = [[-1, -1], [-1, -1], [12, -2], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]], zi = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]], Wi = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
class CCITTFaxDecoder {
  constructor(e2, t2 = {}) {
    if ("function" != typeof e2?.next) throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
    let i2;
    for (this.source = e2, this.eof = false, this.encoding = t2.K || 0, this.eoline = t2.EndOfLine || false, this.byteAlign = t2.EncodedByteAlign || false, this.columns = t2.Columns || 1728, this.rows = t2.Rows || 0, this.eoblock = t2.EndOfBlock ?? true, this.black = t2.BlackIs1 || false, this.codingLine = new Uint32Array(this.columns + 1), this.refLine = new Uint32Array(this.columns + 2), this.codingLine[0] = this.columns, this.codingPos = 0, this.row = 0, this.nextLine2D = this.encoding < 0, this.inputBits = 0, this.inputBuf = 0, this.outputBits = 0, this.rowsDone = false; 0 === (i2 = this._lookBits(12)); ) this._eatBits(1);
    1 === i2 && this._eatBits(12), this.encoding > 0 && (this.nextLine2D = !this._lookBits(1), this._eatBits(1));
  }
  readNextChar() {
    if (this.eof) return -1;
    const e2 = this.refLine, t2 = this.codingLine, i2 = this.columns;
    let n2, a2, s2, r2, o2;
    if (0 === this.outputBits) {
      if (this.rowsDone && (this.eof = true), this.eof) return -1;
      let s3, o3, l2;
      if (this.err = false, this.nextLine2D) {
        for (r2 = 0; t2[r2] < i2; ++r2) e2[r2] = t2[r2];
        for (e2[r2++] = i2, e2[r2] = i2, t2[0] = 0, this.codingPos = 0, n2 = 0, a2 = 0; t2[this.codingPos] < i2; ) switch (s3 = this._getTwoDimCode(), s3) {
          case 0:
            this._addPixels(e2[n2 + 1], a2), e2[n2 + 1] < i2 && (n2 += 2);
            break;
          case 1:
            if (s3 = o3 = 0, a2) {
              do {
                s3 += l2 = this._getBlackCode();
              } while (l2 >= 64);
              do {
                o3 += l2 = this._getWhiteCode();
              } while (l2 >= 64);
            } else {
              do {
                s3 += l2 = this._getWhiteCode();
              } while (l2 >= 64);
              do {
                o3 += l2 = this._getBlackCode();
              } while (l2 >= 64);
            }
            for (this._addPixels(t2[this.codingPos] + s3, a2), t2[this.codingPos] < i2 && this._addPixels(t2[this.codingPos] + o3, 1 ^ a2); e2[n2] <= t2[this.codingPos] && e2[n2] < i2; ) n2 += 2;
            break;
          case 7:
            if (this._addPixels(e2[n2] + 3, a2), a2 ^= 1, t2[this.codingPos] < i2) for (++n2; e2[n2] <= t2[this.codingPos] && e2[n2] < i2; ) n2 += 2;
            break;
          case 5:
            if (this._addPixels(e2[n2] + 2, a2), a2 ^= 1, t2[this.codingPos] < i2) for (++n2; e2[n2] <= t2[this.codingPos] && e2[n2] < i2; ) n2 += 2;
            break;
          case 3:
            if (this._addPixels(e2[n2] + 1, a2), a2 ^= 1, t2[this.codingPos] < i2) for (++n2; e2[n2] <= t2[this.codingPos] && e2[n2] < i2; ) n2 += 2;
            break;
          case 2:
            if (this._addPixels(e2[n2], a2), a2 ^= 1, t2[this.codingPos] < i2) for (++n2; e2[n2] <= t2[this.codingPos] && e2[n2] < i2; ) n2 += 2;
            break;
          case 8:
            if (this._addPixelsNeg(e2[n2] - 3, a2), a2 ^= 1, t2[this.codingPos] < i2) for (n2 > 0 ? --n2 : ++n2; e2[n2] <= t2[this.codingPos] && e2[n2] < i2; ) n2 += 2;
            break;
          case 6:
            if (this._addPixelsNeg(e2[n2] - 2, a2), a2 ^= 1, t2[this.codingPos] < i2) for (n2 > 0 ? --n2 : ++n2; e2[n2] <= t2[this.codingPos] && e2[n2] < i2; ) n2 += 2;
            break;
          case 4:
            if (this._addPixelsNeg(e2[n2] - 1, a2), a2 ^= 1, t2[this.codingPos] < i2) for (n2 > 0 ? --n2 : ++n2; e2[n2] <= t2[this.codingPos] && e2[n2] < i2; ) n2 += 2;
            break;
          case ji:
            this._addPixels(i2, 0), this.eof = true;
            break;
          default:
            info$1("bad 2d code"), this._addPixels(i2, 0), this.err = true;
        }
      } else for (t2[0] = 0, this.codingPos = 0, a2 = 0; t2[this.codingPos] < i2; ) {
        if (s3 = 0, a2) do {
          s3 += l2 = this._getBlackCode();
        } while (l2 >= 64);
        else do {
          s3 += l2 = this._getWhiteCode();
        } while (l2 >= 64);
        this._addPixels(t2[this.codingPos] + s3, a2), a2 ^= 1;
      }
      let c2 = false;
      if (this.byteAlign && (this.inputBits &= -8), this.eoblock || this.row !== this.rows - 1) {
        if (s3 = this._lookBits(12), this.eoline) for (; s3 !== ji && 1 !== s3; ) this._eatBits(1), s3 = this._lookBits(12);
        else for (; 0 === s3; ) this._eatBits(1), s3 = this._lookBits(12);
        1 === s3 ? (this._eatBits(12), c2 = true) : s3 === ji && (this.eof = true);
      } else this.rowsDone = true;
      if (!this.eof && this.encoding > 0 && !this.rowsDone && (this.nextLine2D = !this._lookBits(1), this._eatBits(1)), this.eoblock && c2 && this.byteAlign) {
        if (s3 = this._lookBits(12), 1 === s3) {
          if (this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1)), this.encoding >= 0) for (r2 = 0; r2 < 4; ++r2) s3 = this._lookBits(12), 1 !== s3 && info$1("bad rtc code: " + s3), this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1));
          this.eof = true;
        }
      } else if (this.err && this.eoline) {
        for (; ; ) {
          if (s3 = this._lookBits(13), s3 === ji) return this.eof = true, -1;
          if (s3 >> 1 == 1) break;
          this._eatBits(1);
        }
        this._eatBits(12), this.encoding > 0 && (this._eatBits(1), this.nextLine2D = !(1 & s3));
      }
      this.outputBits = t2[0] > 0 ? t2[this.codingPos = 0] : t2[this.codingPos = 1], this.row++;
    }
    if (this.outputBits >= 8) o2 = 1 & this.codingPos ? 0 : 255, this.outputBits -= 8, 0 === this.outputBits && t2[this.codingPos] < i2 && (this.codingPos++, this.outputBits = t2[this.codingPos] - t2[this.codingPos - 1]);
    else {
      s2 = 8, o2 = 0;
      do {
        if ("number" != typeof this.outputBits) throw new ti('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
        this.outputBits > s2 ? (o2 <<= s2, 1 & this.codingPos || (o2 |= 255 >> 8 - s2), this.outputBits -= s2, s2 = 0) : (o2 <<= this.outputBits, 1 & this.codingPos || (o2 |= 255 >> 8 - this.outputBits), s2 -= this.outputBits, this.outputBits = 0, t2[this.codingPos] < i2 ? (this.codingPos++, this.outputBits = t2[this.codingPos] - t2[this.codingPos - 1]) : s2 > 0 && (o2 <<= s2, s2 = 0));
      } while (s2);
    }
    return this.black && (o2 ^= 255), o2;
  }
  _addPixels(e2, t2) {
    const i2 = this.codingLine;
    let n2 = this.codingPos;
    e2 > i2[n2] && (e2 > this.columns && (info$1("row is wrong length"), this.err = true, e2 = this.columns), 1 & n2 ^ t2 && ++n2, i2[n2] = e2), this.codingPos = n2;
  }
  _addPixelsNeg(e2, t2) {
    const i2 = this.codingLine;
    let n2 = this.codingPos;
    if (e2 > i2[n2]) e2 > this.columns && (info$1("row is wrong length"), this.err = true, e2 = this.columns), 1 & n2 ^ t2 && ++n2, i2[n2] = e2;
    else if (e2 < i2[n2]) {
      for (e2 < 0 && (info$1("invalid code"), this.err = true, e2 = 0); n2 > 0 && e2 < i2[n2 - 1]; ) --n2;
      i2[n2] = e2;
    }
    this.codingPos = n2;
  }
  _findTableCode(e2, t2, i2, n2) {
    const a2 = n2 || 0;
    for (let n3 = e2; n3 <= t2; ++n3) {
      let e3 = this._lookBits(n3);
      if (e3 === ji) return [true, 1, false];
      if (n3 < t2 && (e3 <<= t2 - n3), !a2 || e3 >= a2) {
        const t3 = i2[e3 - a2];
        if (t3[0] === n3) return this._eatBits(n3), [true, t3[1], true];
      }
    }
    return [false, 0, false];
  }
  _getTwoDimCode() {
    let e2, t2 = 0;
    if (this.eoblock) {
      if (t2 = this._lookBits(7), e2 = $i[t2], e2?.[0] > 0) return this._eatBits(e2[0]), e2[1];
    } else {
      const e3 = this._findTableCode(1, 7, $i);
      if (e3[0] && e3[2]) return e3[1];
    }
    return info$1("Bad two dim code"), ji;
  }
  _getWhiteCode() {
    let e2, t2 = 0;
    if (this.eoblock) {
      if (t2 = this._lookBits(12), t2 === ji) return 1;
      if (e2 = t2 >> 5 ? Xi[t2 >> 3] : Hi[t2], e2[0] > 0) return this._eatBits(e2[0]), e2[1];
    } else {
      let e3 = this._findTableCode(1, 9, Xi);
      if (e3[0]) return e3[1];
      if (e3 = this._findTableCode(11, 12, Hi), e3[0]) return e3[1];
    }
    return info$1("bad white code"), this._eatBits(1), 1;
  }
  _getBlackCode() {
    let e2, t2;
    if (this.eoblock) {
      if (e2 = this._lookBits(13), e2 === ji) return 1;
      if (t2 = e2 >> 7 ? !(e2 >> 9) && e2 >> 7 ? zi[(e2 >> 1) - 64] : Wi[e2 >> 7] : qi[e2], t2[0] > 0) return this._eatBits(t2[0]), t2[1];
    } else {
      let e3 = this._findTableCode(2, 6, Wi);
      if (e3[0]) return e3[1];
      if (e3 = this._findTableCode(7, 12, zi, 64), e3[0]) return e3[1];
      if (e3 = this._findTableCode(10, 13, qi), e3[0]) return e3[1];
    }
    return info$1("bad black code"), this._eatBits(1), 1;
  }
  _lookBits(e2) {
    let t2;
    for (; this.inputBits < e2; ) {
      if (-1 === (t2 = this.source.next())) return 0 === this.inputBits ? ji : this.inputBuf << e2 - this.inputBits & 65535 >> 16 - e2;
      this.inputBuf = this.inputBuf << 8 | t2, this.inputBits += 8;
    }
    return this.inputBuf >> this.inputBits - e2 & 65535 >> 16 - e2;
  }
  _eatBits(e2) {
    (this.inputBits -= e2) < 0 && (this.inputBits = 0);
  }
}
class CCITTFaxStream extends DecodeStream {
  constructor(e2, t2, i2) {
    super(t2), this.str = e2, this.dict = e2.dict, i2 instanceof Dict || (i2 = Dict.empty);
    const n2 = { next: () => e2.getByte() };
    this.ccittFaxDecoder = new CCITTFaxDecoder(n2, { K: i2.get("K"), EndOfLine: i2.get("EndOfLine"), EncodedByteAlign: i2.get("EncodedByteAlign"), Columns: i2.get("Columns"), Rows: i2.get("Rows"), EndOfBlock: i2.get("EndOfBlock"), BlackIs1: i2.get("BlackIs1") });
  }
  readBlock() {
    for (; !this.eof; ) {
      const e2 = this.ccittFaxDecoder.readNextChar();
      if (-1 === e2) return void (this.eof = true);
      this.ensureBuffer(this.bufferLength + 1), this.buffer[this.bufferLength++] = e2;
    }
  }
}
const Gi = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Vi = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), Ki = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), Yi = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], Ji = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
class FlateStream extends DecodeStream {
  constructor(e2, t2) {
    super(t2), this.str = e2, this.dict = e2.dict;
    const i2 = e2.getByte(), n2 = e2.getByte();
    if (-1 === i2 || -1 === n2) throw new ti(`Invalid header in flate stream: ${i2}, ${n2}`);
    if (8 != (15 & i2)) throw new ti(`Unknown compression method in flate stream: ${i2}, ${n2}`);
    if (((i2 << 8) + n2) % 31 != 0) throw new ti(`Bad FCHECK in flate stream: ${i2}, ${n2}`);
    if (32 & n2) throw new ti(`FDICT bit set in flate stream: ${i2}, ${n2}`);
    this.codeSize = 0, this.codeBuf = 0;
  }
  async getImageData(e2, t2) {
    const i2 = await this.asyncGetBytes();
    return i2 ? i2.length <= e2 ? i2 : i2.subarray(0, e2) : this.getBytes(e2);
  }
  async asyncGetBytes() {
    this.str.reset();
    const e2 = this.str.getBytes();
    try {
      const { readable: t2, writable: i2 } = new DecompressionStream("deflate"), n2 = i2.getWriter();
      await n2.ready, n2.write(e2).then(async () => {
        await n2.ready, await n2.close();
      }).catch(() => {
      });
      const a2 = [];
      let s2 = 0;
      for await (const e3 of t2) a2.push(e3), s2 += e3.byteLength;
      const r2 = new Uint8Array(s2);
      let o2 = 0;
      for (const e3 of a2) r2.set(e3, o2), o2 += e3.byteLength;
      return r2;
    } catch {
      return this.str = new Stream(e2, 2, e2.length, this.str.dict), this.reset(), null;
    }
  }
  get isAsync() {
    return true;
  }
  getBits(e2) {
    const t2 = this.str;
    let i2, n2 = this.codeSize, a2 = this.codeBuf;
    for (; n2 < e2; ) {
      if (-1 === (i2 = t2.getByte())) throw new ti("Bad encoding in flate stream");
      a2 |= i2 << n2, n2 += 8;
    }
    return i2 = a2 & (1 << e2) - 1, this.codeBuf = a2 >> e2, this.codeSize = n2 -= e2, i2;
  }
  getCode(e2) {
    const t2 = this.str, i2 = e2[0], n2 = e2[1];
    let a2, s2 = this.codeSize, r2 = this.codeBuf;
    for (; s2 < n2 && -1 !== (a2 = t2.getByte()); ) r2 |= a2 << s2, s2 += 8;
    const o2 = i2[r2 & (1 << n2) - 1], l2 = o2 >> 16, c2 = 65535 & o2;
    if (l2 < 1 || s2 < l2) throw new ti("Bad encoding in flate stream");
    return this.codeBuf = r2 >> l2, this.codeSize = s2 - l2, c2;
  }
  generateHuffmanTable(e2) {
    const t2 = e2.length;
    let i2, n2 = 0;
    for (i2 = 0; i2 < t2; ++i2) e2[i2] > n2 && (n2 = e2[i2]);
    const a2 = 1 << n2, s2 = new Int32Array(a2);
    for (let r2 = 1, o2 = 0, l2 = 2; r2 <= n2; ++r2, o2 <<= 1, l2 <<= 1) for (let n3 = 0; n3 < t2; ++n3) if (e2[n3] === r2) {
      let e3 = 0, t3 = o2;
      for (i2 = 0; i2 < r2; ++i2) e3 = e3 << 1 | 1 & t3, t3 >>= 1;
      for (i2 = e3; i2 < a2; i2 += l2) s2[i2] = r2 << 16 | n3;
      ++o2;
    }
    return [s2, n2];
  }
  #$(e2) {
    info$1(e2), this.eof = true;
  }
  readBlock() {
    let e2, t2, i2;
    const n2 = this.str;
    try {
      t2 = this.getBits(3);
    } catch (e3) {
      return void this.#$(e3.message);
    }
    if (1 & t2 && (this.eof = true), t2 >>= 1, 0 === t2) {
      let t3;
      if (-1 === (t3 = n2.getByte())) return void this.#$("Bad block header in flate stream");
      let i3 = t3;
      if (-1 === (t3 = n2.getByte())) return void this.#$("Bad block header in flate stream");
      if (i3 |= t3 << 8, -1 === (t3 = n2.getByte())) return void this.#$("Bad block header in flate stream");
      let a3 = t3;
      if (-1 === (t3 = n2.getByte())) return void this.#$("Bad block header in flate stream");
      if (a3 |= t3 << 8, a3 !== (65535 & ~i3) && (0 !== i3 || 0 !== a3)) throw new ti("Bad uncompressed block length in flate stream");
      this.codeBuf = 0, this.codeSize = 0;
      const s3 = this.bufferLength, r3 = s3 + i3;
      if (e2 = this.ensureBuffer(r3), this.bufferLength = r3, 0 === i3) -1 === n2.peekByte() && (this.eof = true);
      else {
        const t4 = n2.getBytes(i3);
        e2.set(t4, s3), t4.length < i3 && (this.eof = true);
      }
      return;
    }
    let a2, s2;
    if (1 === t2) a2 = Yi, s2 = Ji;
    else {
      if (2 !== t2) throw new ti("Unknown block type in flate stream");
      {
        const e3 = this.getBits(5) + 257, t3 = this.getBits(5) + 1, n3 = this.getBits(4) + 4, r3 = new Uint8Array(Gi.length);
        let o3;
        for (o3 = 0; o3 < n3; ++o3) r3[Gi[o3]] = this.getBits(3);
        const l2 = this.generateHuffmanTable(r3);
        i2 = 0, o3 = 0;
        const c2 = e3 + t3, h2 = new Uint8Array(c2);
        let d2, u2, g2;
        for (; o3 < c2; ) {
          const e4 = this.getCode(l2);
          if (16 === e4) d2 = 2, u2 = 3, g2 = i2;
          else if (17 === e4) d2 = 3, u2 = 3, g2 = i2 = 0;
          else {
            if (18 !== e4) {
              h2[o3++] = i2 = e4;
              continue;
            }
            d2 = 7, u2 = 11, g2 = i2 = 0;
          }
          let t4 = this.getBits(d2) + u2;
          for (; t4-- > 0; ) h2[o3++] = g2;
        }
        a2 = this.generateHuffmanTable(h2.subarray(0, e3)), s2 = this.generateHuffmanTable(h2.subarray(e3, c2));
      }
    }
    e2 = this.buffer;
    let r2 = e2 ? e2.length : 0, o2 = this.bufferLength;
    for (; ; ) {
      let t3 = this.getCode(a2);
      if (t3 < 256) {
        o2 + 1 >= r2 && (e2 = this.ensureBuffer(o2 + 1), r2 = e2.length), e2[o2++] = t3;
        continue;
      }
      if (256 === t3) return void (this.bufferLength = o2);
      t3 -= 257, t3 = Vi[t3];
      let n3 = t3 >> 16;
      n3 > 0 && (n3 = this.getBits(n3)), i2 = (65535 & t3) + n3, t3 = this.getCode(s2), t3 = Ki[t3], n3 = t3 >> 16, n3 > 0 && (n3 = this.getBits(n3));
      const l2 = (65535 & t3) + n3;
      o2 + i2 >= r2 && (e2 = this.ensureBuffer(o2 + i2), r2 = e2.length);
      for (let t4 = 0; t4 < i2; ++t4, ++o2) e2[o2] = e2[o2 - l2];
    }
  }
}
const Zi = [{ qe: 22017, nmps: 1, nlps: 1, switchFlag: 1 }, { qe: 13313, nmps: 2, nlps: 6, switchFlag: 0 }, { qe: 6145, nmps: 3, nlps: 9, switchFlag: 0 }, { qe: 2753, nmps: 4, nlps: 12, switchFlag: 0 }, { qe: 1313, nmps: 5, nlps: 29, switchFlag: 0 }, { qe: 545, nmps: 38, nlps: 33, switchFlag: 0 }, { qe: 22017, nmps: 7, nlps: 6, switchFlag: 1 }, { qe: 21505, nmps: 8, nlps: 14, switchFlag: 0 }, { qe: 18433, nmps: 9, nlps: 14, switchFlag: 0 }, { qe: 14337, nmps: 10, nlps: 14, switchFlag: 0 }, { qe: 12289, nmps: 11, nlps: 17, switchFlag: 0 }, { qe: 9217, nmps: 12, nlps: 18, switchFlag: 0 }, { qe: 7169, nmps: 13, nlps: 20, switchFlag: 0 }, { qe: 5633, nmps: 29, nlps: 21, switchFlag: 0 }, { qe: 22017, nmps: 15, nlps: 14, switchFlag: 1 }, { qe: 21505, nmps: 16, nlps: 14, switchFlag: 0 }, { qe: 20737, nmps: 17, nlps: 15, switchFlag: 0 }, { qe: 18433, nmps: 18, nlps: 16, switchFlag: 0 }, { qe: 14337, nmps: 19, nlps: 17, switchFlag: 0 }, { qe: 13313, nmps: 20, nlps: 18, switchFlag: 0 }, { qe: 12289, nmps: 21, nlps: 19, switchFlag: 0 }, { qe: 10241, nmps: 22, nlps: 19, switchFlag: 0 }, { qe: 9217, nmps: 23, nlps: 20, switchFlag: 0 }, { qe: 8705, nmps: 24, nlps: 21, switchFlag: 0 }, { qe: 7169, nmps: 25, nlps: 22, switchFlag: 0 }, { qe: 6145, nmps: 26, nlps: 23, switchFlag: 0 }, { qe: 5633, nmps: 27, nlps: 24, switchFlag: 0 }, { qe: 5121, nmps: 28, nlps: 25, switchFlag: 0 }, { qe: 4609, nmps: 29, nlps: 26, switchFlag: 0 }, { qe: 4353, nmps: 30, nlps: 27, switchFlag: 0 }, { qe: 2753, nmps: 31, nlps: 28, switchFlag: 0 }, { qe: 2497, nmps: 32, nlps: 29, switchFlag: 0 }, { qe: 2209, nmps: 33, nlps: 30, switchFlag: 0 }, { qe: 1313, nmps: 34, nlps: 31, switchFlag: 0 }, { qe: 1089, nmps: 35, nlps: 32, switchFlag: 0 }, { qe: 673, nmps: 36, nlps: 33, switchFlag: 0 }, { qe: 545, nmps: 37, nlps: 34, switchFlag: 0 }, { qe: 321, nmps: 38, nlps: 35, switchFlag: 0 }, { qe: 273, nmps: 39, nlps: 36, switchFlag: 0 }, { qe: 133, nmps: 40, nlps: 37, switchFlag: 0 }, { qe: 73, nmps: 41, nlps: 38, switchFlag: 0 }, { qe: 37, nmps: 42, nlps: 39, switchFlag: 0 }, { qe: 21, nmps: 43, nlps: 40, switchFlag: 0 }, { qe: 9, nmps: 44, nlps: 41, switchFlag: 0 }, { qe: 5, nmps: 45, nlps: 42, switchFlag: 0 }, { qe: 1, nmps: 45, nlps: 43, switchFlag: 0 }, { qe: 22017, nmps: 46, nlps: 46, switchFlag: 0 }];
class ArithmeticDecoder {
  constructor(e2, t2, i2) {
    this.data = e2, this.bp = t2, this.dataEnd = i2, this.chigh = e2[t2], this.clow = 0, this.byteIn(), this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127, this.clow = this.clow << 7 & 65535, this.ct -= 7, this.a = 32768;
  }
  byteIn() {
    const e2 = this.data;
    let t2 = this.bp;
    255 === e2[t2] ? e2[t2 + 1] > 143 ? (this.clow += 65280, this.ct = 8) : (t2++, this.clow += e2[t2] << 9, this.ct = 7, this.bp = t2) : (t2++, this.clow += t2 < this.dataEnd ? e2[t2] << 8 : 65280, this.ct = 8, this.bp = t2), this.clow > 65535 && (this.chigh += this.clow >> 16, this.clow &= 65535);
  }
  readBit(e2, t2) {
    let i2 = e2[t2] >> 1, n2 = 1 & e2[t2];
    const a2 = Zi[i2], s2 = a2.qe;
    let r2, o2 = this.a - s2;
    if (this.chigh < s2) o2 < s2 ? (o2 = s2, r2 = n2, i2 = a2.nmps) : (o2 = s2, r2 = 1 ^ n2, 1 === a2.switchFlag && (n2 = r2), i2 = a2.nlps);
    else {
      if (this.chigh -= s2, 32768 & o2) return this.a = o2, n2;
      o2 < s2 ? (r2 = 1 ^ n2, 1 === a2.switchFlag && (n2 = r2), i2 = a2.nlps) : (r2 = n2, i2 = a2.nmps);
    }
    do {
      0 === this.ct && this.byteIn(), o2 <<= 1, this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1, this.clow = this.clow << 1 & 65535, this.ct--;
    } while (!(32768 & o2));
    return this.a = o2, e2[t2] = i2 << 1 | n2, r2;
  }
}
class Jbig2Error extends Yt {
  constructor(e2) {
    super(e2, "Jbig2Error");
  }
}
class ContextCache {
  getContexts(e2) {
    return e2 in this ? this[e2] : this[e2] = new Int8Array(65536);
  }
}
class DecodingContext {
  constructor(e2, t2, i2) {
    this.data = e2, this.start = t2, this.end = i2;
  }
  get decoder() {
    return shadow$1(this, "decoder", new ArithmeticDecoder(this.data, this.start, this.end));
  }
  get contextCache() {
    return shadow$1(this, "contextCache", new ContextCache());
  }
}
function decodeInteger(e2, t2, i2) {
  const n2 = e2.getContexts(t2);
  let a2 = 1;
  function readBits(e3) {
    let t3 = 0;
    for (let s3 = 0; s3 < e3; s3++) {
      const e4 = i2.readBit(n2, a2);
      a2 = a2 < 256 ? a2 << 1 | e4 : 511 & (a2 << 1 | e4) | 256, t3 = t3 << 1 | e4;
    }
    return t3 >>> 0;
  }
  const s2 = readBits(1), r2 = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
  let o2;
  return 0 === s2 ? o2 = r2 : r2 > 0 && (o2 = -r2), o2 >= -2147483648 && o2 <= fi ? o2 : null;
}
function decodeIAID(e2, t2, i2) {
  const n2 = e2.getContexts("IAID");
  let a2 = 1;
  for (let e3 = 0; e3 < i2; e3++) {
    a2 = a2 << 1 | t2.readBit(n2, a2);
  }
  return i2 < 31 ? a2 & (1 << i2) - 1 : 2147483647 & a2;
}
const Qi = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"], en = [[{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: 2, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -3, y: -1 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }]], tn = [{ coding: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }, { coding: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }], nn = [39717, 1941, 229, 405];
function decodeBitmap(e2, t2, i2, n2, a2, s2, r2, o2) {
  if (e2) {
    return decodeMMRBitmap(new Reader(o2.data, o2.start, o2.end), t2, i2, false);
  }
  if (0 === n2 && !a2 && 4 === r2.length && 3 === r2[0].x && -1 === r2[0].y && -3 === r2[1].x && -1 === r2[1].y && 2 === r2[2].x && -2 === r2[2].y && -2 === r2[3].x && -2 === r2[3].y) return (function(e3, t3, i3) {
    const n3 = i3.decoder, a3 = i3.contextCache.getContexts("GB"), s3 = [];
    let r3, o3, l3, c3, h3, d3, u3;
    for (o3 = 0; o3 < t3; o3++) for (h3 = s3[o3] = new Uint8Array(e3), d3 = o3 < 1 ? h3 : s3[o3 - 1], u3 = o3 < 2 ? h3 : s3[o3 - 2], r3 = u3[0] << 13 | u3[1] << 12 | u3[2] << 11 | d3[0] << 7 | d3[1] << 6 | d3[2] << 5 | d3[3] << 4, l3 = 0; l3 < e3; l3++) h3[l3] = c3 = n3.readBit(a3, r3), r3 = (31735 & r3) << 1 | (l3 + 3 < e3 ? u3[l3 + 3] << 11 : 0) | (l3 + 4 < e3 ? d3[l3 + 4] << 4 : 0) | c3;
    return s3;
  })(t2, i2, o2);
  const l2 = en[n2].concat(r2);
  l2.sort((e3, t3) => e3.y - t3.y || e3.x - t3.x);
  const c2 = l2.length, h2 = new Int8Array(c2), d2 = new Int8Array(c2), u2 = [];
  let g2, f2, p2 = 0, m2 = 0, b2 = 0, y2 = 0;
  for (f2 = 0; f2 < c2; f2++) h2[f2] = l2[f2].x, d2[f2] = l2[f2].y, m2 = Math.min(m2, l2[f2].x), b2 = Math.max(b2, l2[f2].x), y2 = Math.min(y2, l2[f2].y), f2 < c2 - 1 && l2[f2].y === l2[f2 + 1].y && l2[f2].x === l2[f2 + 1].x - 1 ? p2 |= 1 << c2 - 1 - f2 : u2.push(f2);
  const w2 = u2.length, x2 = new Int8Array(w2), S2 = new Int8Array(w2), v2 = new Uint16Array(w2);
  for (g2 = 0; g2 < w2; g2++) f2 = u2[g2], x2[g2] = l2[f2].x, S2[g2] = l2[f2].y, v2[g2] = 1 << c2 - 1 - f2;
  const C2 = -m2, k2 = -y2, T2 = t2 - b2, F2 = nn[n2];
  let E2 = new Uint8Array(t2);
  const M2 = [], D2 = o2.decoder, O2 = o2.contextCache.getContexts("GB");
  let _2, R2, N2, L2, U2, j2 = 0, $2 = 0;
  for (let e3 = 0; e3 < i2; e3++) {
    if (a2) {
      if (j2 ^= D2.readBit(O2, F2), j2) {
        M2.push(E2);
        continue;
      }
    }
    for (E2 = new Uint8Array(E2), M2.push(E2), _2 = 0; _2 < t2; _2++) {
      if (_2 >= C2 && _2 < T2 && e3 >= k2) for ($2 = $2 << 1 & p2, f2 = 0; f2 < w2; f2++) R2 = e3 + S2[f2], N2 = _2 + x2[f2], L2 = M2[R2][N2], L2 && (L2 = v2[f2], $2 |= L2);
      else for ($2 = 0, U2 = c2 - 1, f2 = 0; f2 < c2; f2++, U2--) N2 = _2 + h2[f2], N2 >= 0 && N2 < t2 && (R2 = e3 + d2[f2], R2 >= 0 && (L2 = M2[R2][N2], L2 && ($2 |= L2 << U2)));
      const i3 = D2.readBit(O2, $2);
      E2[_2] = i3;
    }
  }
  return M2;
}
function decodeRefinement(e2, t2, i2, n2, a2, s2, r2, o2, l2) {
  let c2 = tn[i2].coding;
  0 === i2 && (c2 = c2.concat([o2[0]]));
  const h2 = c2.length, d2 = new Int32Array(h2), u2 = new Int32Array(h2);
  let g2;
  for (g2 = 0; g2 < h2; g2++) d2[g2] = c2[g2].x, u2[g2] = c2[g2].y;
  let f2 = tn[i2].reference;
  0 === i2 && (f2 = f2.concat([o2[1]]));
  const p2 = f2.length, m2 = new Int32Array(p2), b2 = new Int32Array(p2);
  for (g2 = 0; g2 < p2; g2++) m2[g2] = f2[g2].x, b2[g2] = f2[g2].y;
  const y2 = n2[0].length, w2 = n2.length, x2 = [], S2 = l2.decoder, v2 = l2.contextCache.getContexts("GR");
  for (let i3 = 0; i3 < t2; i3++) {
    const t3 = new Uint8Array(e2);
    x2.push(t3);
    for (let r3 = 0; r3 < e2; r3++) {
      let o3, l3, c3 = 0;
      for (g2 = 0; g2 < h2; g2++) o3 = i3 + u2[g2], l3 = r3 + d2[g2], o3 < 0 || l3 < 0 || l3 >= e2 ? c3 <<= 1 : c3 = c3 << 1 | x2[o3][l3];
      for (g2 = 0; g2 < p2; g2++) o3 = i3 + b2[g2] - s2, l3 = r3 + m2[g2] - a2, o3 < 0 || o3 >= w2 || l3 < 0 || l3 >= y2 ? c3 <<= 1 : c3 = c3 << 1 | n2[o3][l3];
      const f3 = S2.readBit(v2, c3);
      t3[r3] = f3;
    }
  }
  return x2;
}
function decodeTextRegion(e2, t2, i2, n2, a2, s2, r2, o2, l2, c2, h2, d2, u2, g2, f2, p2, m2, b2, y2) {
  if (e2 && t2) throw new Jbig2Error("refinement with Huffman is not supported");
  const w2 = [];
  let x2, S2;
  for (x2 = 0; x2 < n2; x2++) S2 = new Uint8Array(i2), a2 && S2.fill(a2), w2.push(S2);
  const v2 = m2.decoder, C2 = m2.contextCache;
  let k2 = e2 ? -g2.tableDeltaT.decode(y2) : -decodeInteger(C2, "IADT", v2), T2 = 0;
  for (x2 = 0; x2 < s2; ) {
    k2 += e2 ? g2.tableDeltaT.decode(y2) : decodeInteger(C2, "IADT", v2);
    T2 += e2 ? g2.tableFirstS.decode(y2) : decodeInteger(C2, "IAFS", v2);
    let n3 = T2;
    for (; ; ) {
      let a3 = 0;
      r2 > 1 && (a3 = e2 ? y2.readBits(b2) : decodeInteger(C2, "IAIT", v2));
      const s3 = r2 * k2 + a3, T3 = e2 ? g2.symbolIDTable.decode(y2) : decodeIAID(C2, v2, l2), F2 = t2 && (e2 ? y2.readBit() : decodeInteger(C2, "IARI", v2));
      let E2 = o2[T3], M2 = E2[0].length, D2 = E2.length;
      if (F2) {
        const e3 = decodeInteger(C2, "IARDW", v2), t3 = decodeInteger(C2, "IARDH", v2);
        M2 += e3, D2 += t3, E2 = decodeRefinement(M2, D2, f2, E2, (e3 >> 1) + decodeInteger(C2, "IARDX", v2), (t3 >> 1) + decodeInteger(C2, "IARDY", v2), 0, p2, m2);
      }
      let O2 = 0;
      c2 ? 1 & d2 ? O2 = D2 - 1 : n3 += D2 - 1 : d2 > 1 ? n3 += M2 - 1 : O2 = M2 - 1;
      const _2 = s3 - (1 & d2 ? 0 : D2 - 1), R2 = n3 - (2 & d2 ? M2 - 1 : 0);
      let N2, L2, U2;
      if (c2) for (N2 = 0; N2 < D2; N2++) {
        if (S2 = w2[R2 + N2], !S2) continue;
        U2 = E2[N2];
        const e3 = Math.min(i2 - _2, M2);
        switch (u2) {
          case 0:
            for (L2 = 0; L2 < e3; L2++) S2[_2 + L2] |= U2[L2];
            break;
          case 2:
            for (L2 = 0; L2 < e3; L2++) S2[_2 + L2] ^= U2[L2];
            break;
          default:
            throw new Jbig2Error(`operator ${u2} is not supported`);
        }
      }
      else for (L2 = 0; L2 < D2; L2++) if (S2 = w2[_2 + L2], S2) switch (U2 = E2[L2], u2) {
        case 0:
          for (N2 = 0; N2 < M2; N2++) S2[R2 + N2] |= U2[N2];
          break;
        case 2:
          for (N2 = 0; N2 < M2; N2++) S2[R2 + N2] ^= U2[N2];
          break;
        default:
          throw new Jbig2Error(`operator ${u2} is not supported`);
      }
      x2++;
      const j2 = e2 ? g2.tableDeltaS.decode(y2) : decodeInteger(C2, "IADS", v2);
      if (null === j2) break;
      n3 += O2 + j2 + h2;
    }
  }
  return w2;
}
function readSegmentHeader(e2, t2) {
  const i2 = {};
  i2.number = readUint32(e2, t2);
  const n2 = e2[t2 + 4], a2 = 63 & n2;
  if (!Qi[a2]) throw new Jbig2Error("invalid segment type: " + a2);
  i2.type = a2, i2.typeName = Qi[a2], i2.deferredNonRetain = !!(128 & n2);
  const s2 = !!(64 & n2), r2 = e2[t2 + 5];
  let o2 = r2 >> 5 & 7;
  const l2 = [31 & r2];
  let c2 = t2 + 6;
  if (7 === r2) {
    o2 = 536870911 & readUint32(e2, c2 - 1), c2 += 3;
    let t3 = o2 + 7 >> 3;
    for (l2[0] = e2[c2++]; --t3 > 0; ) l2.push(e2[c2++]);
  } else if (5 === r2 || 6 === r2) throw new Jbig2Error("invalid referred-to flags");
  i2.retainBits = l2;
  let h2 = 4;
  i2.number <= 256 ? h2 = 1 : i2.number <= 65536 && (h2 = 2);
  const d2 = [];
  let u2, g2;
  for (u2 = 0; u2 < o2; u2++) {
    let t3;
    t3 = 1 === h2 ? e2[c2] : 2 === h2 ? readUint16(e2, c2) : readUint32(e2, c2), d2.push(t3), c2 += h2;
  }
  if (i2.referredTo = d2, s2 ? (i2.pageAssociation = readUint32(e2, c2), c2 += 4) : i2.pageAssociation = e2[c2++], i2.length = readUint32(e2, c2), c2 += 4, 4294967295 === i2.length) {
    if (38 !== a2) throw new Jbig2Error("invalid unknown segment length");
    {
      const t3 = readRegionSegmentInformation(e2, c2), n3 = !!(1 & e2[c2 + an]), a3 = 6, s3 = new Uint8Array(a3);
      for (n3 || (s3[0] = 255, s3[1] = 172), s3[2] = t3.height >>> 24 & 255, s3[3] = t3.height >> 16 & 255, s3[4] = t3.height >> 8 & 255, s3[5] = 255 & t3.height, u2 = c2, g2 = e2.length; u2 < g2; u2++) {
        let t4 = 0;
        for (; t4 < a3 && s3[t4] === e2[u2 + t4]; ) t4++;
        if (t4 === a3) {
          i2.length = u2 + a3;
          break;
        }
      }
      if (4294967295 === i2.length) throw new Jbig2Error("segment end was not found");
    }
  }
  return i2.headerEnd = c2, i2;
}
function readSegments(e2, t2, i2, n2) {
  const a2 = [];
  let s2 = i2;
  for (; s2 < n2; ) {
    const i3 = readSegmentHeader(t2, s2);
    s2 = i3.headerEnd;
    const n3 = { header: i3, data: t2 };
    if (e2.randomAccess || (n3.start = s2, s2 += i3.length, n3.end = s2), a2.push(n3), 51 === i3.type) break;
  }
  if (e2.randomAccess) for (let e3 = 0, t3 = a2.length; e3 < t3; e3++) a2[e3].start = s2, s2 += a2[e3].header.length, a2[e3].end = s2;
  return a2;
}
function readRegionSegmentInformation(e2, t2) {
  return { width: readUint32(e2, t2), height: readUint32(e2, t2 + 4), x: readUint32(e2, t2 + 8), y: readUint32(e2, t2 + 12), combinationOperator: 7 & e2[t2 + 16] };
}
const an = 17;
function processSegment(e2, t2) {
  const i2 = e2.header, n2 = e2.data, a2 = e2.end;
  let s2, r2, o2, l2, c2 = e2.start;
  switch (i2.type) {
    case 0:
      const e3 = {}, t3 = readUint16(n2, c2);
      if (e3.huffman = !!(1 & t3), e3.refinement = !!(2 & t3), e3.huffmanDHSelector = t3 >> 2 & 3, e3.huffmanDWSelector = t3 >> 4 & 3, e3.bitmapSizeSelector = t3 >> 6 & 1, e3.aggregationInstancesSelector = t3 >> 7 & 1, e3.bitmapCodingContextUsed = !!(256 & t3), e3.bitmapCodingContextRetained = !!(512 & t3), e3.template = t3 >> 10 & 3, e3.refinementTemplate = t3 >> 12 & 1, c2 += 2, !e3.huffman) {
        for (l2 = 0 === e3.template ? 4 : 1, r2 = [], o2 = 0; o2 < l2; o2++) r2.push({ x: readInt8(n2, c2), y: readInt8(n2, c2 + 1) }), c2 += 2;
        e3.at = r2;
      }
      if (e3.refinement && !e3.refinementTemplate) {
        for (r2 = [], o2 = 0; o2 < 2; o2++) r2.push({ x: readInt8(n2, c2), y: readInt8(n2, c2 + 1) }), c2 += 2;
        e3.refinementAt = r2;
      }
      e3.numberOfExportedSymbols = readUint32(n2, c2), c2 += 4, e3.numberOfNewSymbols = readUint32(n2, c2), c2 += 4, s2 = [e3, i2.number, i2.referredTo, n2, c2, a2];
      break;
    case 6:
    case 7:
      const h3 = {};
      h3.info = readRegionSegmentInformation(n2, c2), c2 += an;
      const d2 = readUint16(n2, c2);
      if (c2 += 2, h3.huffman = !!(1 & d2), h3.refinement = !!(2 & d2), h3.logStripSize = d2 >> 2 & 3, h3.stripSize = 1 << h3.logStripSize, h3.referenceCorner = d2 >> 4 & 3, h3.transposed = !!(64 & d2), h3.combinationOperator = d2 >> 7 & 3, h3.defaultPixelValue = d2 >> 9 & 1, h3.dsOffset = d2 << 17 >> 27, h3.refinementTemplate = d2 >> 15 & 1, h3.huffman) {
        const e4 = readUint16(n2, c2);
        c2 += 2, h3.huffmanFS = 3 & e4, h3.huffmanDS = e4 >> 2 & 3, h3.huffmanDT = e4 >> 4 & 3, h3.huffmanRefinementDW = e4 >> 6 & 3, h3.huffmanRefinementDH = e4 >> 8 & 3, h3.huffmanRefinementDX = e4 >> 10 & 3, h3.huffmanRefinementDY = e4 >> 12 & 3, h3.huffmanRefinementSizeSelector = !!(16384 & e4);
      }
      if (h3.refinement && !h3.refinementTemplate) {
        for (r2 = [], o2 = 0; o2 < 2; o2++) r2.push({ x: readInt8(n2, c2), y: readInt8(n2, c2 + 1) }), c2 += 2;
        h3.refinementAt = r2;
      }
      h3.numberOfSymbolInstances = readUint32(n2, c2), c2 += 4, s2 = [h3, i2.referredTo, n2, c2, a2];
      break;
    case 16:
      const u2 = {}, g2 = n2[c2++];
      u2.mmr = !!(1 & g2), u2.template = g2 >> 1 & 3, u2.patternWidth = n2[c2++], u2.patternHeight = n2[c2++], u2.maxPatternIndex = readUint32(n2, c2), c2 += 4, s2 = [u2, i2.number, n2, c2, a2];
      break;
    case 22:
    case 23:
      const f2 = {};
      f2.info = readRegionSegmentInformation(n2, c2), c2 += an;
      const p2 = n2[c2++];
      f2.mmr = !!(1 & p2), f2.template = p2 >> 1 & 3, f2.enableSkip = !!(8 & p2), f2.combinationOperator = p2 >> 4 & 7, f2.defaultPixelValue = p2 >> 7 & 1, f2.gridWidth = readUint32(n2, c2), c2 += 4, f2.gridHeight = readUint32(n2, c2), c2 += 4, f2.gridOffsetX = 4294967295 & readUint32(n2, c2), c2 += 4, f2.gridOffsetY = 4294967295 & readUint32(n2, c2), c2 += 4, f2.gridVectorX = readUint16(n2, c2), c2 += 2, f2.gridVectorY = readUint16(n2, c2), c2 += 2, s2 = [f2, i2.referredTo, n2, c2, a2];
      break;
    case 38:
    case 39:
      const m2 = {};
      m2.info = readRegionSegmentInformation(n2, c2), c2 += an;
      const b2 = n2[c2++];
      if (m2.mmr = !!(1 & b2), m2.template = b2 >> 1 & 3, m2.prediction = !!(8 & b2), !m2.mmr) {
        for (l2 = 0 === m2.template ? 4 : 1, r2 = [], o2 = 0; o2 < l2; o2++) r2.push({ x: readInt8(n2, c2), y: readInt8(n2, c2 + 1) }), c2 += 2;
        m2.at = r2;
      }
      s2 = [m2, n2, c2, a2];
      break;
    case 48:
      const y2 = { width: readUint32(n2, c2), height: readUint32(n2, c2 + 4), resolutionX: readUint32(n2, c2 + 8), resolutionY: readUint32(n2, c2 + 12) };
      4294967295 === y2.height && delete y2.height;
      const w2 = n2[c2 + 16];
      readUint16(n2, c2 + 17), y2.lossless = !!(1 & w2), y2.refinement = !!(2 & w2), y2.defaultPixelValue = w2 >> 2 & 1, y2.combinationOperator = w2 >> 3 & 3, y2.requiresBuffer = !!(32 & w2), y2.combinationOperatorOverride = !!(64 & w2), s2 = [y2];
      break;
    case 49:
    case 50:
    case 51:
    case 62:
      break;
    case 53:
      s2 = [i2.number, n2, c2, a2];
      break;
    default:
      throw new Jbig2Error(`segment type ${i2.typeName}(${i2.type}) is not implemented`);
  }
  const h2 = "on" + i2.typeName;
  h2 in t2 && t2[h2].apply(t2, s2);
}
function processSegments(e2, t2) {
  for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) processSegment(e2[i2], t2);
}
class SimpleSegmentVisitor {
  onPageInformation(e2) {
    this.currentPageInfo = e2;
    const t2 = e2.width + 7 >> 3, i2 = new Uint8ClampedArray(t2 * e2.height);
    e2.defaultPixelValue && i2.fill(255), this.buffer = i2;
  }
  drawBitmap(e2, t2) {
    const i2 = this.currentPageInfo, n2 = e2.width, a2 = e2.height, s2 = i2.width + 7 >> 3, r2 = i2.combinationOperatorOverride ? e2.combinationOperator : i2.combinationOperator, o2 = this.buffer, l2 = 128 >> (7 & e2.x);
    let c2, h2, d2, u2, g2 = e2.y * s2 + (e2.x >> 3);
    switch (r2) {
      case 0:
        for (c2 = 0; c2 < a2; c2++) {
          for (d2 = l2, u2 = g2, h2 = 0; h2 < n2; h2++) t2[c2][h2] && (o2[u2] |= d2), d2 >>= 1, d2 || (d2 = 128, u2++);
          g2 += s2;
        }
        break;
      case 2:
        for (c2 = 0; c2 < a2; c2++) {
          for (d2 = l2, u2 = g2, h2 = 0; h2 < n2; h2++) t2[c2][h2] && (o2[u2] ^= d2), d2 >>= 1, d2 || (d2 = 128, u2++);
          g2 += s2;
        }
        break;
      default:
        throw new Jbig2Error(`operator ${r2} is not supported`);
    }
  }
  onImmediateGenericRegion(e2, t2, i2, n2) {
    const a2 = e2.info, s2 = new DecodingContext(t2, i2, n2), r2 = decodeBitmap(e2.mmr, a2.width, a2.height, e2.template, e2.prediction, 0, e2.at, s2);
    this.drawBitmap(a2, r2);
  }
  onImmediateLosslessGenericRegion() {
    this.onImmediateGenericRegion(...arguments);
  }
  onSymbolDictionary(e2, t2, i2, n2, a2, s2) {
    let r2, o2;
    e2.huffman && (r2 = (function(e3, t3, i3) {
      let n3, a3, s3, r3, o3 = 0;
      switch (e3.huffmanDHSelector) {
        case 0:
        case 1:
          n3 = getStandardTable(e3.huffmanDHSelector + 4);
          break;
        case 3:
          n3 = getCustomHuffmanTable(o3, t3, i3), o3++;
          break;
        default:
          throw new Jbig2Error("invalid Huffman DH selector");
      }
      switch (e3.huffmanDWSelector) {
        case 0:
        case 1:
          a3 = getStandardTable(e3.huffmanDWSelector + 2);
          break;
        case 3:
          a3 = getCustomHuffmanTable(o3, t3, i3), o3++;
          break;
        default:
          throw new Jbig2Error("invalid Huffman DW selector");
      }
      e3.bitmapSizeSelector ? (s3 = getCustomHuffmanTable(o3, t3, i3), o3++) : s3 = getStandardTable(1);
      r3 = e3.aggregationInstancesSelector ? getCustomHuffmanTable(o3, t3, i3) : getStandardTable(1);
      return { tableDeltaHeight: n3, tableDeltaWidth: a3, tableBitmapSize: s3, tableAggregateInstances: r3 };
    })(e2, i2, this.customTables), o2 = new Reader(n2, a2, s2));
    let l2 = this.symbols;
    l2 || (this.symbols = l2 = {});
    const c2 = [];
    for (const e3 of i2) {
      const t3 = l2[e3];
      t3 && c2.push(...t3);
    }
    const h2 = new DecodingContext(n2, a2, s2);
    l2[t2] = (function(e3, t3, i3, n3, a3, s3, r3, o3, l3, c3, h3, d2) {
      if (e3 && t3) throw new Jbig2Error("symbol refinement with Huffman is not supported");
      const u2 = [];
      let g2 = 0, f2 = log2(i3.length + n3);
      const p2 = h3.decoder, m2 = h3.contextCache;
      let b2, y2;
      for (e3 && (b2 = getStandardTable(1), y2 = [], f2 = Math.max(f2, 1)); u2.length < n3; ) {
        g2 += e3 ? s3.tableDeltaHeight.decode(d2) : decodeInteger(m2, "IADH", p2);
        let n4 = 0, a4 = 0;
        const b3 = e3 ? y2.length : 0;
        for (; ; ) {
          const b4 = e3 ? s3.tableDeltaWidth.decode(d2) : decodeInteger(m2, "IADW", p2);
          if (null === b4) break;
          let w3;
          if (n4 += b4, a4 += n4, t3) {
            const a5 = decodeInteger(m2, "IAAI", p2);
            if (a5 > 1) w3 = decodeTextRegion(e3, t3, n4, g2, 0, a5, 1, i3.concat(u2), f2, 0, 0, 1, 0, s3, l3, c3, h3, 0, d2);
            else {
              const e4 = decodeIAID(m2, p2, f2), t4 = decodeInteger(m2, "IARDX", p2), a6 = decodeInteger(m2, "IARDY", p2);
              w3 = decodeRefinement(n4, g2, l3, e4 < i3.length ? i3[e4] : u2[e4 - i3.length], t4, a6, 0, c3, h3);
            }
            u2.push(w3);
          } else e3 ? y2.push(n4) : (w3 = decodeBitmap(false, n4, g2, r3, false, 0, o3, h3), u2.push(w3));
        }
        if (e3 && !t3) {
          const e4 = s3.tableBitmapSize.decode(d2);
          let t4;
          if (d2.byteAlign(), 0 === e4) t4 = readUncompressedBitmap(d2, a4, g2);
          else {
            const i5 = d2.end, n5 = d2.position + e4;
            d2.end = n5, t4 = decodeMMRBitmap(d2, a4, g2, false), d2.end = i5, d2.position = n5;
          }
          const i4 = y2.length;
          if (b3 === i4 - 1) u2.push(t4);
          else {
            let e5, n5, a5, s4, r4, o4 = 0;
            for (e5 = b3; e5 < i4; e5++) {
              for (s4 = y2[e5], a5 = o4 + s4, r4 = [], n5 = 0; n5 < g2; n5++) r4.push(t4[n5].subarray(o4, a5));
              u2.push(r4), o4 = a5;
            }
          }
        }
      }
      const w2 = [], x2 = [];
      let S2, v2, C2 = false;
      const k2 = i3.length + n3;
      for (; x2.length < k2; ) {
        let t4 = e3 ? b2.decode(d2) : decodeInteger(m2, "IAEX", p2);
        for (; t4--; ) x2.push(C2);
        C2 = !C2;
      }
      for (S2 = 0, v2 = i3.length; S2 < v2; S2++) x2[S2] && w2.push(i3[S2]);
      for (let e4 = 0; e4 < n3; S2++, e4++) x2[S2] && w2.push(u2[e4]);
      return w2;
    })(e2.huffman, e2.refinement, c2, e2.numberOfNewSymbols, e2.numberOfExportedSymbols, r2, e2.template, e2.at, e2.refinementTemplate, e2.refinementAt, h2, o2);
  }
  onImmediateTextRegion(e2, t2, i2, n2, a2) {
    const s2 = e2.info;
    let r2, o2;
    const l2 = this.symbols, c2 = [];
    for (const e3 of t2) {
      const t3 = l2[e3];
      t3 && c2.push(...t3);
    }
    const h2 = log2(c2.length);
    e2.huffman && (o2 = new Reader(i2, n2, a2), r2 = (function(e3, t3, i3, n3, a3) {
      const s3 = [];
      for (let e4 = 0; e4 <= 34; e4++) {
        const t4 = a3.readBits(4);
        s3.push(new HuffmanLine([e4, t4, 0, 0]));
      }
      const r3 = new HuffmanTable(s3, false);
      s3.length = 0;
      for (let e4 = 0; e4 < n3; ) {
        const t4 = r3.decode(a3);
        if (t4 >= 32) {
          let i4, n4, r4;
          switch (t4) {
            case 32:
              if (0 === e4) throw new Jbig2Error("no previous value in symbol ID table");
              n4 = a3.readBits(2) + 3, i4 = s3[e4 - 1].prefixLength;
              break;
            case 33:
              n4 = a3.readBits(3) + 3, i4 = 0;
              break;
            case 34:
              n4 = a3.readBits(7) + 11, i4 = 0;
              break;
            default:
              throw new Jbig2Error("invalid code length in symbol ID table");
          }
          for (r4 = 0; r4 < n4; r4++) s3.push(new HuffmanLine([e4, i4, 0, 0])), e4++;
        } else s3.push(new HuffmanLine([e4, t4, 0, 0])), e4++;
      }
      a3.byteAlign();
      const o3 = new HuffmanTable(s3, false);
      let l3, c3, h3, d3 = 0;
      switch (e3.huffmanFS) {
        case 0:
        case 1:
          l3 = getStandardTable(e3.huffmanFS + 6);
          break;
        case 3:
          l3 = getCustomHuffmanTable(d3, t3, i3), d3++;
          break;
        default:
          throw new Jbig2Error("invalid Huffman FS selector");
      }
      switch (e3.huffmanDS) {
        case 0:
        case 1:
        case 2:
          c3 = getStandardTable(e3.huffmanDS + 8);
          break;
        case 3:
          c3 = getCustomHuffmanTable(d3, t3, i3), d3++;
          break;
        default:
          throw new Jbig2Error("invalid Huffman DS selector");
      }
      switch (e3.huffmanDT) {
        case 0:
        case 1:
        case 2:
          h3 = getStandardTable(e3.huffmanDT + 11);
          break;
        case 3:
          h3 = getCustomHuffmanTable(d3, t3, i3), d3++;
          break;
        default:
          throw new Jbig2Error("invalid Huffman DT selector");
      }
      if (e3.refinement) throw new Jbig2Error("refinement with Huffman is not supported");
      return { symbolIDTable: o3, tableFirstS: l3, tableDeltaS: c3, tableDeltaT: h3 };
    })(e2, t2, this.customTables, c2.length, o2));
    const d2 = new DecodingContext(i2, n2, a2), u2 = decodeTextRegion(e2.huffman, e2.refinement, s2.width, s2.height, e2.defaultPixelValue, e2.numberOfSymbolInstances, e2.stripSize, c2, h2, e2.transposed, e2.dsOffset, e2.referenceCorner, e2.combinationOperator, r2, e2.refinementTemplate, e2.refinementAt, d2, e2.logStripSize, o2);
    this.drawBitmap(s2, u2);
  }
  onImmediateLosslessTextRegion() {
    this.onImmediateTextRegion(...arguments);
  }
  onPatternDictionary(e2, t2, i2, n2, a2) {
    let s2 = this.patterns;
    s2 || (this.patterns = s2 = {});
    const r2 = new DecodingContext(i2, n2, a2);
    s2[t2] = (function(e3, t3, i3, n3, a3, s3) {
      const r3 = [];
      e3 || (r3.push({ x: -t3, y: 0 }), 0 === a3 && r3.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 }));
      const o2 = decodeBitmap(e3, (n3 + 1) * t3, i3, a3, false, 0, r3, s3), l2 = [];
      for (let e4 = 0; e4 <= n3; e4++) {
        const n4 = [], a4 = t3 * e4, s4 = a4 + t3;
        for (let e5 = 0; e5 < i3; e5++) n4.push(o2[e5].subarray(a4, s4));
        l2.push(n4);
      }
      return l2;
    })(e2.mmr, e2.patternWidth, e2.patternHeight, e2.maxPatternIndex, e2.template, r2);
  }
  onImmediateHalftoneRegion(e2, t2, i2, n2, a2) {
    const s2 = this.patterns[t2[0]], r2 = e2.info, o2 = new DecodingContext(i2, n2, a2), l2 = (function(e3, t3, i3, n3, a3, s3, r3, o3, l3, c2, h2, d2, u2, g2, f2) {
      if (r3) throw new Jbig2Error("skip is not supported");
      if (0 !== o3) throw new Jbig2Error(`operator "${o3}" is not supported in halftone region`);
      const p2 = [];
      let m2, b2, y2;
      for (m2 = 0; m2 < a3; m2++) y2 = new Uint8Array(n3), s3 && y2.fill(s3), p2.push(y2);
      const w2 = t3.length, x2 = t3[0], S2 = x2[0].length, v2 = x2.length, C2 = log2(w2), k2 = [];
      e3 || (k2.push({ x: i3 <= 1 ? 3 : 2, y: -1 }), 0 === i3 && k2.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 }));
      const T2 = [];
      let F2, E2, M2, D2, O2, _2, R2, N2, L2, U2, j2;
      for (e3 && (F2 = new Reader(f2.data, f2.start, f2.end)), m2 = C2 - 1; m2 >= 0; m2--) E2 = e3 ? decodeMMRBitmap(F2, l3, c2, true) : decodeBitmap(false, l3, c2, i3, false, 0, k2, f2), T2[m2] = E2;
      for (M2 = 0; M2 < c2; M2++) for (D2 = 0; D2 < l3; D2++) {
        for (O2 = 0, _2 = 0, b2 = C2 - 1; b2 >= 0; b2--) O2 ^= T2[b2][M2][D2], _2 |= O2 << b2;
        if (R2 = t3[_2], N2 = h2 + M2 * g2 + D2 * u2 >> 8, L2 = d2 + M2 * u2 - D2 * g2 >> 8, N2 >= 0 && N2 + S2 <= n3 && L2 >= 0 && L2 + v2 <= a3) for (m2 = 0; m2 < v2; m2++) for (j2 = p2[L2 + m2], U2 = R2[m2], b2 = 0; b2 < S2; b2++) j2[N2 + b2] |= U2[b2];
        else {
          let e4, t4;
          for (m2 = 0; m2 < v2; m2++) if (t4 = L2 + m2, !(t4 < 0 || t4 >= a3)) for (j2 = p2[t4], U2 = R2[m2], b2 = 0; b2 < S2; b2++) e4 = N2 + b2, e4 >= 0 && e4 < n3 && (j2[e4] |= U2[b2]);
        }
      }
      return p2;
    })(e2.mmr, s2, e2.template, r2.width, r2.height, e2.defaultPixelValue, e2.enableSkip, e2.combinationOperator, e2.gridWidth, e2.gridHeight, e2.gridOffsetX, e2.gridOffsetY, e2.gridVectorX, e2.gridVectorY, o2);
    this.drawBitmap(r2, l2);
  }
  onImmediateLosslessHalftoneRegion() {
    this.onImmediateHalftoneRegion(...arguments);
  }
  onTables(e2, t2, i2, n2) {
    let a2 = this.customTables;
    a2 || (this.customTables = a2 = {}), a2[e2] = (function(e3, t3, i3) {
      const n3 = e3[t3], a3 = 4294967295 & readUint32(e3, t3 + 1), s2 = 4294967295 & readUint32(e3, t3 + 5), r2 = new Reader(e3, t3 + 9, i3), o2 = 1 + (n3 >> 1 & 7), l2 = 1 + (n3 >> 4 & 7), c2 = [];
      let h2, d2, u2 = a3;
      do {
        h2 = r2.readBits(o2), d2 = r2.readBits(l2), c2.push(new HuffmanLine([u2, h2, d2, 0])), u2 += 1 << d2;
      } while (u2 < s2);
      h2 = r2.readBits(o2), c2.push(new HuffmanLine([a3 - 1, h2, 32, 0, "lower"])), h2 = r2.readBits(o2), c2.push(new HuffmanLine([s2, h2, 32, 0])), 1 & n3 && (h2 = r2.readBits(o2), c2.push(new HuffmanLine([h2, 0])));
      return new HuffmanTable(c2, false);
    })(t2, i2, n2);
  }
}
class HuffmanLine {
  constructor(e2) {
    2 === e2.length ? (this.isOOB = true, this.rangeLow = 0, this.prefixLength = e2[0], this.rangeLength = 0, this.prefixCode = e2[1], this.isLowerRange = false) : (this.isOOB = false, this.rangeLow = e2[0], this.prefixLength = e2[1], this.rangeLength = e2[2], this.prefixCode = e2[3], this.isLowerRange = "lower" === e2[4]);
  }
}
class HuffmanTreeNode {
  constructor(e2) {
    this.children = [], e2 ? (this.isLeaf = true, this.rangeLength = e2.rangeLength, this.rangeLow = e2.rangeLow, this.isLowerRange = e2.isLowerRange, this.isOOB = e2.isOOB) : this.isLeaf = false;
  }
  buildTree(e2, t2) {
    const i2 = e2.prefixCode >> t2 & 1;
    if (t2 <= 0) this.children[i2] = new HuffmanTreeNode(e2);
    else {
      let n2 = this.children[i2];
      n2 || (this.children[i2] = n2 = new HuffmanTreeNode(null)), n2.buildTree(e2, t2 - 1);
    }
  }
  decodeNode(e2) {
    if (this.isLeaf) {
      if (this.isOOB) return null;
      const t3 = e2.readBits(this.rangeLength);
      return this.rangeLow + (this.isLowerRange ? -t3 : t3);
    }
    const t2 = this.children[e2.readBit()];
    if (!t2) throw new Jbig2Error("invalid Huffman data");
    return t2.decodeNode(e2);
  }
}
class HuffmanTable {
  constructor(e2, t2) {
    t2 || this.assignPrefixCodes(e2), this.rootNode = new HuffmanTreeNode(null);
    for (let t3 = 0, i2 = e2.length; t3 < i2; t3++) {
      const i3 = e2[t3];
      i3.prefixLength > 0 && this.rootNode.buildTree(i3, i3.prefixLength - 1);
    }
  }
  decode(e2) {
    return this.rootNode.decodeNode(e2);
  }
  assignPrefixCodes(e2) {
    const t2 = e2.length;
    let i2 = 0;
    for (let n3 = 0; n3 < t2; n3++) i2 = Math.max(i2, e2[n3].prefixLength);
    const n2 = new Uint32Array(i2 + 1);
    for (let i3 = 0; i3 < t2; i3++) n2[e2[i3].prefixLength]++;
    let a2, s2, r2, o2 = 1, l2 = 0;
    for (n2[0] = 0; o2 <= i2; ) {
      for (l2 = l2 + n2[o2 - 1] << 1, a2 = l2, s2 = 0; s2 < t2; ) r2 = e2[s2], r2.prefixLength === o2 && (r2.prefixCode = a2, a2++), s2++;
      o2++;
    }
  }
}
const sn = {};
function getStandardTable(e2) {
  let t2, i2 = sn[e2];
  if (i2) return i2;
  switch (e2) {
    case 1:
      t2 = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
      break;
    case 2:
      t2 = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
      break;
    case 3:
      t2 = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
      break;
    case 4:
      t2 = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
      break;
    case 5:
      t2 = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
      break;
    case 6:
      t2 = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
      break;
    case 7:
      t2 = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
      break;
    case 8:
      t2 = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
      break;
    case 9:
      t2 = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
      break;
    case 10:
      t2 = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
      break;
    case 11:
      t2 = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 12:
      t2 = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
      break;
    case 13:
      t2 = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 14:
      t2 = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
      break;
    case 15:
      t2 = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
      break;
    default:
      throw new Jbig2Error(`standard table B.${e2} does not exist`);
  }
  for (let e3 = 0, i3 = t2.length; e3 < i3; e3++) t2[e3] = new HuffmanLine(t2[e3]);
  return i2 = new HuffmanTable(t2, true), sn[e2] = i2, i2;
}
class Reader {
  constructor(e2, t2, i2) {
    this.data = e2, this.start = t2, this.end = i2, this.position = t2, this.shift = -1, this.currentByte = 0;
  }
  readBit() {
    if (this.shift < 0) {
      if (this.position >= this.end) throw new Jbig2Error("end of data while reading bit");
      this.currentByte = this.data[this.position++], this.shift = 7;
    }
    const e2 = this.currentByte >> this.shift & 1;
    return this.shift--, e2;
  }
  readBits(e2) {
    let t2, i2 = 0;
    for (t2 = e2 - 1; t2 >= 0; t2--) i2 |= this.readBit() << t2;
    return i2;
  }
  byteAlign() {
    this.shift = -1;
  }
  next() {
    return this.position >= this.end ? -1 : this.data[this.position++];
  }
}
function getCustomHuffmanTable(e2, t2, i2) {
  let n2 = 0;
  for (let a2 = 0, s2 = t2.length; a2 < s2; a2++) {
    const s3 = i2[t2[a2]];
    if (s3) {
      if (e2 === n2) return s3;
      n2++;
    }
  }
  throw new Jbig2Error("can't find custom Huffman table");
}
function readUncompressedBitmap(e2, t2, i2) {
  const n2 = [];
  for (let a2 = 0; a2 < i2; a2++) {
    const i3 = new Uint8Array(t2);
    n2.push(i3);
    for (let n3 = 0; n3 < t2; n3++) i3[n3] = e2.readBit();
    e2.byteAlign();
  }
  return n2;
}
function decodeMMRBitmap(e2, t2, i2, n2) {
  const a2 = new CCITTFaxDecoder(e2, { K: -1, Columns: t2, Rows: i2, BlackIs1: true, EndOfBlock: n2 }), s2 = [];
  let r2, o2 = false;
  for (let e3 = 0; e3 < i2; e3++) {
    const e4 = new Uint8Array(t2);
    s2.push(e4);
    let i3 = -1;
    for (let n3 = 0; n3 < t2; n3++) i3 < 0 && (r2 = a2.readNextChar(), -1 === r2 && (r2 = 0, o2 = true), i3 = 7), e4[n3] = r2 >> i3 & 1, i3--;
  }
  if (n2 && !o2) {
    const e3 = 5;
    for (let t3 = 0; t3 < e3 && -1 !== a2.readNextChar(); t3++) ;
  }
  return s2;
}
class Jbig2Image {
  parseChunks(e2) {
    return (function(e3) {
      const t2 = new SimpleSegmentVisitor();
      for (let i2 = 0, n2 = e3.length; i2 < n2; i2++) {
        const n3 = e3[i2];
        processSegments(readSegments({}, n3.data, n3.start, n3.end), t2);
      }
      return t2.buffer;
    })(e2);
  }
  parse(e2) {
    throw new Error("Not implemented: Jbig2Image.parse");
  }
}
class Jbig2Stream extends DecodeStream {
  constructor(e2, t2, i2) {
    super(t2), this.stream = e2, this.dict = e2.dict, this.maybeLength = t2, this.params = i2;
  }
  get bytes() {
    return shadow$1(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(e2) {
  }
  readBlock() {
    this.decodeImage();
  }
  decodeImage(e2) {
    if (this.eof) return this.buffer;
    e2 ||= this.bytes;
    const t2 = new Jbig2Image(), i2 = [];
    if (this.params instanceof Dict) {
      const e3 = this.params.get("JBIG2Globals");
      if (e3 instanceof BaseStream) {
        const t3 = e3.getBytes();
        i2.push({ data: t3, start: 0, end: t3.length });
      }
    }
    i2.push({ data: e2, start: 0, end: e2.length });
    const n2 = t2.parseChunks(i2), a2 = n2.length;
    for (let e3 = 0; e3 < a2; e3++) n2[e3] ^= 255;
    return this.buffer = n2, this.bufferLength = a2, this.eof = true, this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
}
class JpxStream extends DecodeStream {
  constructor(e2, t2, i2) {
    super(t2), this.stream = e2, this.dict = e2.dict, this.maybeLength = t2, this.params = i2;
  }
  get bytes() {
    return shadow$1(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(e2) {
  }
  readBlock(e2) {
    unreachable$1("JpxStream.readBlock");
  }
  get isAsyncDecoder() {
    return true;
  }
  async decodeImage(e2, t2) {
    return this.eof || (e2 ||= this.bytes, this.buffer = await JpxImage.decode(e2, t2), this.bufferLength = this.buffer.length, this.eof = true), this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
}
class LZWStream extends DecodeStream {
  constructor(e2, t2, i2) {
    super(t2), this.str = e2, this.dict = e2.dict, this.cachedData = 0, this.bitsCached = 0;
    const n2 = 4096, a2 = { earlyChange: i2, codeLength: 9, nextCode: 258, dictionaryValues: new Uint8Array(n2), dictionaryLengths: new Uint16Array(n2), dictionaryPrevCodes: new Uint16Array(n2), currentSequence: new Uint8Array(n2), currentSequenceLength: 0 };
    for (let e3 = 0; e3 < 256; ++e3) a2.dictionaryValues[e3] = e3, a2.dictionaryLengths[e3] = 1;
    this.lzwState = a2;
  }
  readBits(e2) {
    let t2 = this.bitsCached, i2 = this.cachedData;
    for (; t2 < e2; ) {
      const e3 = this.str.getByte();
      if (-1 === e3) return this.eof = true, null;
      i2 = i2 << 8 | e3, t2 += 8;
    }
    return this.bitsCached = t2 -= e2, this.cachedData = i2, this.lastCode = null, i2 >>> t2 & (1 << e2) - 1;
  }
  readBlock() {
    let e2, t2, i2, n2 = 1024;
    const a2 = this.lzwState;
    if (!a2) return;
    const s2 = a2.earlyChange;
    let r2 = a2.nextCode;
    const o2 = a2.dictionaryValues, l2 = a2.dictionaryLengths, c2 = a2.dictionaryPrevCodes;
    let h2 = a2.codeLength, d2 = a2.prevCode;
    const u2 = a2.currentSequence;
    let g2 = a2.currentSequenceLength, f2 = 0, p2 = this.bufferLength, m2 = this.ensureBuffer(this.bufferLength + n2);
    for (e2 = 0; e2 < 512; e2++) {
      const e3 = this.readBits(h2), a3 = g2 > 0;
      if (e3 < 256) u2[0] = e3, g2 = 1;
      else {
        if (!(e3 >= 258)) {
          if (256 === e3) {
            h2 = 9, r2 = 258, g2 = 0;
            continue;
          }
          this.eof = true, delete this.lzwState;
          break;
        }
        if (e3 < r2) for (g2 = l2[e3], t2 = g2 - 1, i2 = e3; t2 >= 0; t2--) u2[t2] = o2[i2], i2 = c2[i2];
        else u2[g2++] = u2[0];
      }
      if (a3 && (c2[r2] = d2, l2[r2] = l2[d2] + 1, o2[r2] = u2[0], r2++, h2 = r2 + s2 & r2 + s2 - 1 ? h2 : 0 | Math.min(Math.log(r2 + s2) / 0.6931471805599453 + 1, 12)), d2 = e3, f2 += g2, n2 < f2) {
        do {
          n2 += 512;
        } while (n2 < f2);
        m2 = this.ensureBuffer(this.bufferLength + n2);
      }
      for (t2 = 0; t2 < g2; t2++) m2[p2++] = u2[t2];
    }
    a2.nextCode = r2, a2.codeLength = h2, a2.prevCode = d2, a2.currentSequenceLength = g2, this.bufferLength = p2;
  }
}
class PredictorStream extends DecodeStream {
  constructor(e2, t2, i2) {
    if (super(t2), !(i2 instanceof Dict)) return e2;
    const n2 = this.predictor = i2.get("Predictor") || 1;
    if (n2 <= 1) return e2;
    if (2 !== n2 && (n2 < 10 || n2 > 15)) throw new ti(`Unsupported predictor: ${n2}`);
    this.readBlock = 2 === n2 ? this.readBlockTiff : this.readBlockPng, this.str = e2, this.dict = e2.dict;
    const a2 = this.colors = i2.get("Colors") || 1, s2 = this.bits = i2.get("BPC", "BitsPerComponent") || 8, r2 = this.columns = i2.get("Columns") || 1;
    return this.pixBytes = a2 * s2 + 7 >> 3, this.rowBytes = r2 * a2 * s2 + 7 >> 3, this;
  }
  readBlockTiff() {
    const e2 = this.rowBytes, t2 = this.bufferLength, i2 = this.ensureBuffer(t2 + e2), n2 = this.bits, a2 = this.colors, s2 = this.str.getBytes(e2);
    if (this.eof = !s2.length, this.eof) return;
    let r2, o2 = 0, l2 = 0, c2 = 0, h2 = 0, d2 = t2;
    if (1 === n2 && 1 === a2) for (r2 = 0; r2 < e2; ++r2) {
      let e3 = s2[r2] ^ o2;
      e3 ^= e3 >> 1, e3 ^= e3 >> 2, e3 ^= e3 >> 4, o2 = (1 & e3) << 7, i2[d2++] = e3;
    }
    else if (8 === n2) {
      for (r2 = 0; r2 < a2; ++r2) i2[d2++] = s2[r2];
      for (; r2 < e2; ++r2) i2[d2] = i2[d2 - a2] + s2[r2], d2++;
    } else if (16 === n2) {
      const t3 = 2 * a2;
      for (r2 = 0; r2 < t3; ++r2) i2[d2++] = s2[r2];
      for (; r2 < e2; r2 += 2) {
        const e3 = ((255 & s2[r2]) << 8) + (255 & s2[r2 + 1]) + ((255 & i2[d2 - t3]) << 8) + (255 & i2[d2 - t3 + 1]);
        i2[d2++] = e3 >> 8 & 255, i2[d2++] = 255 & e3;
      }
    } else {
      const e3 = new Uint8Array(a2 + 1), d3 = (1 << n2) - 1;
      let u2 = 0, g2 = t2;
      const f2 = this.columns;
      for (r2 = 0; r2 < f2; ++r2) for (let t3 = 0; t3 < a2; ++t3) c2 < n2 && (o2 = o2 << 8 | 255 & s2[u2++], c2 += 8), e3[t3] = e3[t3] + (o2 >> c2 - n2) & d3, c2 -= n2, l2 = l2 << n2 | e3[t3], h2 += n2, h2 >= 8 && (i2[g2++] = l2 >> h2 - 8 & 255, h2 -= 8);
      h2 > 0 && (i2[g2++] = (l2 << 8 - h2) + (o2 & (1 << 8 - h2) - 1));
    }
    this.bufferLength += e2;
  }
  readBlockPng() {
    const e2 = this.rowBytes, t2 = this.pixBytes, i2 = this.str.getByte(), n2 = this.str.getBytes(e2);
    if (this.eof = !n2.length, this.eof) return;
    const a2 = this.bufferLength, s2 = this.ensureBuffer(a2 + e2);
    let r2 = s2.subarray(a2 - e2, a2);
    0 === r2.length && (r2 = new Uint8Array(e2));
    let o2, l2, c2, h2 = a2;
    switch (i2) {
      case 0:
        for (o2 = 0; o2 < e2; ++o2) s2[h2++] = n2[o2];
        break;
      case 1:
        for (o2 = 0; o2 < t2; ++o2) s2[h2++] = n2[o2];
        for (; o2 < e2; ++o2) s2[h2] = s2[h2 - t2] + n2[o2] & 255, h2++;
        break;
      case 2:
        for (o2 = 0; o2 < e2; ++o2) s2[h2++] = r2[o2] + n2[o2] & 255;
        break;
      case 3:
        for (o2 = 0; o2 < t2; ++o2) s2[h2++] = (r2[o2] >> 1) + n2[o2];
        for (; o2 < e2; ++o2) s2[h2] = (r2[o2] + s2[h2 - t2] >> 1) + n2[o2] & 255, h2++;
        break;
      case 4:
        for (o2 = 0; o2 < t2; ++o2) l2 = r2[o2], c2 = n2[o2], s2[h2++] = l2 + c2;
        for (; o2 < e2; ++o2) {
          l2 = r2[o2];
          const e3 = r2[o2 - t2], i3 = s2[h2 - t2], a3 = i3 + l2 - e3;
          let d2 = a3 - i3;
          d2 < 0 && (d2 = -d2);
          let u2 = a3 - l2;
          u2 < 0 && (u2 = -u2);
          let g2 = a3 - e3;
          g2 < 0 && (g2 = -g2), c2 = n2[o2], s2[h2++] = d2 <= u2 && d2 <= g2 ? i3 + c2 : u2 <= g2 ? l2 + c2 : e3 + c2;
        }
        break;
      default:
        throw new ti(`Unsupported predictor: ${i2}`);
    }
    this.bufferLength += e2;
  }
}
class RunLengthStream extends DecodeStream {
  constructor(e2, t2) {
    super(t2), this.str = e2, this.dict = e2.dict;
  }
  readBlock() {
    const e2 = this.str.getBytes(2);
    if (!e2 || e2.length < 2 || 128 === e2[0]) return void (this.eof = true);
    let t2, i2 = this.bufferLength, n2 = e2[0];
    if (n2 < 128) {
      if (t2 = this.ensureBuffer(i2 + n2 + 1), t2[i2++] = e2[1], n2 > 0) {
        const e3 = this.str.getBytes(n2);
        t2.set(e3, i2), i2 += n2;
      }
    } else n2 = 257 - n2, t2 = this.ensureBuffer(i2 + n2 + 1), t2.fill(e2[1], i2, i2 + n2), i2 += n2;
    this.bufferLength = i2;
  }
}
class Parser {
  constructor({ lexer: e2, xref: t2, allowStreams: i2 = false, recoveryMode: n2 = false }) {
    this.lexer = e2, this.xref = t2, this.allowStreams = i2, this.recoveryMode = n2, this.imageCache = /* @__PURE__ */ Object.create(null), this._imageId = 0, this.refill();
  }
  refill() {
    this.buf1 = this.lexer.getObj(), this.buf2 = this.lexer.getObj();
  }
  shift() {
    this.buf2 instanceof Cmd && "ID" === this.buf2.cmd ? (this.buf1 = this.buf2, this.buf2 = null) : (this.buf1 = this.buf2, this.buf2 = this.lexer.getObj());
  }
  tryShift() {
    try {
      return this.shift(), true;
    } catch (e2) {
      if (e2 instanceof MissingDataException) throw e2;
      return false;
    }
  }
  getObj(e2 = null) {
    const t2 = this.buf1;
    if (this.shift(), t2 instanceof Cmd) switch (t2.cmd) {
      case "BI":
        return this.makeInlineImage(e2);
      case "[":
        const i2 = [];
        for (; !isCmd(this.buf1, "]") && this.buf1 !== ci; ) i2.push(this.getObj(e2));
        if (this.buf1 === ci) {
          if (this.recoveryMode) return i2;
          throw new ParserEOFException("End of file inside array.");
        }
        return this.shift(), i2;
      case "<<":
        const n2 = new Dict(this.xref);
        for (; !isCmd(this.buf1, ">>") && this.buf1 !== ci; ) {
          if (!(this.buf1 instanceof Name)) {
            info$1("Malformed dictionary: key must be a name object"), this.shift();
            continue;
          }
          const t3 = this.buf1.name;
          if (this.shift(), this.buf1 === ci) break;
          n2.set(t3, this.getObj(e2));
        }
        if (this.buf1 === ci) {
          if (this.recoveryMode) return n2;
          throw new ParserEOFException("End of file inside dictionary.");
        }
        return isCmd(this.buf2, "stream") ? this.allowStreams ? this.makeStream(n2, e2) : n2 : (this.shift(), n2);
      default:
        return t2;
    }
    if (Number.isInteger(t2)) {
      if (Number.isInteger(this.buf1) && isCmd(this.buf2, "R")) {
        const e3 = Ref.get(t2, this.buf1);
        return this.shift(), this.shift(), e3;
      }
      return t2;
    }
    return "string" == typeof t2 && e2 ? e2.decryptString(t2) : t2;
  }
  findDefaultInlineStreamEnd(e2) {
    const { knownCommands: t2 } = this.lexer, i2 = e2.pos;
    let n2, a2, s2 = 0;
    for (; -1 !== (n2 = e2.getByte()); ) if (0 === s2) s2 = 69 === n2 ? 1 : 0;
    else if (1 === s2) s2 = 73 === n2 ? 2 : 0;
    else if (32 === n2 || 10 === n2 || 13 === n2) {
      a2 = e2.pos;
      const i3 = e2.peekBytes(15), r3 = i3.length;
      if (0 === r3) break;
      for (let e3 = 0; e3 < r3; e3++) if (n2 = i3[e3], (0 !== n2 || 0 === i3[e3 + 1]) && 10 !== n2 && 13 !== n2 && (n2 < 32 || n2 > 127)) {
        s2 = 0;
        break;
      }
      if (2 !== s2) continue;
      if (!t2) {
        warn$1("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
        continue;
      }
      const o2 = new Lexer(new Stream(e2.peekBytes(75)), t2);
      o2._hexStringWarn = () => {
      };
      let l2 = 0;
      for (; ; ) {
        const e3 = o2.getObj();
        if (e3 === ci) {
          s2 = 0;
          break;
        }
        if (e3 instanceof Cmd) {
          const i4 = t2[e3.cmd];
          if (!i4) {
            s2 = 0;
            break;
          }
          if (i4.variableArgs ? l2 <= i4.numArgs : l2 === i4.numArgs) break;
          l2 = 0;
          continue;
        }
        l2++;
      }
      if (2 === s2) break;
    } else s2 = 0;
    -1 === n2 && (warn$1("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker"), a2 && (warn$1('... trying to recover by using the last "EI" occurrence.'), e2.skip(-(e2.pos - a2))));
    let r2 = 4;
    return e2.skip(-r2), n2 = e2.peekByte(), e2.skip(r2), isWhiteSpace(n2) || r2--, e2.pos - r2 - i2;
  }
  findDCTDecodeInlineStreamEnd(e2) {
    const t2 = e2.pos;
    let i2, n2, a2 = false;
    for (; -1 !== (i2 = e2.getByte()); ) if (255 === i2) {
      switch (e2.getByte()) {
        case 0:
          break;
        case 255:
          e2.skip(-1);
          break;
        case 217:
          a2 = true;
          break;
        case 192:
        case 193:
        case 194:
        case 195:
        case 197:
        case 198:
        case 199:
        case 201:
        case 202:
        case 203:
        case 205:
        case 206:
        case 207:
        case 196:
        case 204:
        case 218:
        case 219:
        case 220:
        case 221:
        case 222:
        case 223:
        case 224:
        case 225:
        case 226:
        case 227:
        case 228:
        case 229:
        case 230:
        case 231:
        case 232:
        case 233:
        case 234:
        case 235:
        case 236:
        case 237:
        case 238:
        case 239:
        case 254:
          n2 = e2.getUint16(), n2 > 2 ? e2.skip(n2 - 2) : e2.skip(-2);
      }
      if (a2) break;
    }
    const s2 = e2.pos - t2;
    return -1 === i2 ? (warn$1("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead."), e2.skip(-s2), this.findDefaultInlineStreamEnd(e2)) : (this.inlineStreamSkipEI(e2), s2);
  }
  findASCII85DecodeInlineStreamEnd(e2) {
    const t2 = e2.pos;
    let i2;
    for (; -1 !== (i2 = e2.getByte()); ) if (126 === i2) {
      const t3 = e2.pos;
      for (i2 = e2.peekByte(); isWhiteSpace(i2); ) e2.skip(), i2 = e2.peekByte();
      if (62 === i2) {
        e2.skip();
        break;
      }
      if (e2.pos > t3) {
        const t4 = e2.peekBytes(2);
        if (69 === t4[0] && 73 === t4[1]) break;
      }
    }
    const n2 = e2.pos - t2;
    return -1 === i2 ? (warn$1("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead."), e2.skip(-n2), this.findDefaultInlineStreamEnd(e2)) : (this.inlineStreamSkipEI(e2), n2);
  }
  findASCIIHexDecodeInlineStreamEnd(e2) {
    const t2 = e2.pos;
    let i2;
    for (; -1 !== (i2 = e2.getByte()) && 62 !== i2; ) ;
    const n2 = e2.pos - t2;
    return -1 === i2 ? (warn$1("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead."), e2.skip(-n2), this.findDefaultInlineStreamEnd(e2)) : (this.inlineStreamSkipEI(e2), n2);
  }
  inlineStreamSkipEI(e2) {
    let t2, i2 = 0;
    for (; -1 !== (t2 = e2.getByte()); ) if (0 === i2) i2 = 69 === t2 ? 1 : 0;
    else if (1 === i2) i2 = 73 === t2 ? 2 : 0;
    else if (2 === i2) break;
  }
  makeInlineImage(e2) {
    const t2 = this.lexer, i2 = t2.stream, n2 = /* @__PURE__ */ Object.create(null);
    let a2;
    for (; !isCmd(this.buf1, "ID") && this.buf1 !== ci; ) {
      if (!(this.buf1 instanceof Name)) throw new ti("Dictionary key must be a name object");
      const t3 = this.buf1.name;
      if (this.shift(), this.buf1 === ci) break;
      n2[t3] = this.getObj(e2);
    }
    -1 !== t2.beginInlineImagePos && (a2 = i2.pos - t2.beginInlineImagePos);
    const s2 = this.xref.fetchIfRef(n2.F || n2.Filter);
    let r2;
    if (s2 instanceof Name) r2 = s2.name;
    else if (Array.isArray(s2)) {
      const e3 = this.xref.fetchIfRef(s2[0]);
      e3 instanceof Name && (r2 = e3.name);
    }
    const o2 = i2.pos;
    let l2, c2;
    switch (r2) {
      case "DCT":
      case "DCTDecode":
        l2 = this.findDCTDecodeInlineStreamEnd(i2);
        break;
      case "A85":
      case "ASCII85Decode":
        l2 = this.findASCII85DecodeInlineStreamEnd(i2);
        break;
      case "AHx":
      case "ASCIIHexDecode":
        l2 = this.findASCIIHexDecodeInlineStreamEnd(i2);
        break;
      default:
        l2 = this.findDefaultInlineStreamEnd(i2);
    }
    if (l2 < 1e3 && a2 > 0) {
      const e3 = i2.pos;
      i2.pos = t2.beginInlineImagePos, c2 = (function(e4) {
        const t3 = [], i3 = e4.length;
        let n4 = 0;
        for (; n4 < i3 - 1; ) t3.push(e4[n4++] << 8 | e4[n4++]);
        return n4 < i3 && t3.push(e4[n4]), i3 + "_" + String.fromCharCode.apply(null, t3);
      })(i2.getBytes(a2 + l2)), i2.pos = e3;
      const n3 = this.imageCache[c2];
      if (void 0 !== n3) return this.buf2 = Cmd.get("EI"), this.shift(), n3.reset(), n3;
    }
    const h2 = new Dict(this.xref);
    for (const e3 in n2) h2.set(e3, n2[e3]);
    let d2 = i2.makeSubStream(o2, l2, h2);
    return e2 && (d2 = e2.createStream(d2, l2)), d2 = this.filter(d2, h2, l2), d2.dict = h2, void 0 !== c2 && (d2.cacheKey = "inline_img_" + ++this._imageId, this.imageCache[c2] = d2), this.buf2 = Cmd.get("EI"), this.shift(), d2;
  }
  #H(e2) {
    const { stream: t2 } = this.lexer;
    t2.pos = e2;
    const i2 = new Uint8Array([101, 110, 100]), n2 = i2.length, a2 = [new Uint8Array([115, 116, 114, 101, 97, 109]), new Uint8Array([115, 116, 101, 97, 109]), new Uint8Array([115, 116, 114, 101, 97])], s2 = 9 - n2;
    for (; t2.pos < t2.end; ) {
      const r2 = t2.peekBytes(2048), o2 = r2.length - 9;
      if (o2 <= 0) break;
      let l2 = 0;
      for (; l2 < o2; ) {
        let o3 = 0;
        for (; o3 < n2 && r2[l2 + o3] === i2[o3]; ) o3++;
        if (o3 >= n2) {
          let n3 = false;
          for (const e3 of a2) {
            const t3 = e3.length;
            let a3 = 0;
            for (; a3 < t3 && r2[l2 + o3 + a3] === e3[a3]; ) a3++;
            if (a3 >= s2) {
              n3 = true;
              break;
            }
            if (a3 >= t3) {
              isWhiteSpace(r2[l2 + o3 + a3]) && (info$1(`Found "${bytesToString$1([...i2, ...e3])}" when searching for endstream command.`), n3 = true);
              break;
            }
          }
          if (n3) return t2.pos += l2, t2.pos - e2;
        }
        l2++;
      }
      t2.pos += o2;
    }
    return -1;
  }
  makeStream(e2, t2) {
    const i2 = this.lexer;
    let n2 = i2.stream;
    i2.skipToNextLine();
    const a2 = n2.pos - 1;
    let s2 = e2.get("Length");
    if (Number.isInteger(s2) || (info$1(`Bad length "${s2 && s2.toString()}" in stream.`), s2 = 0), n2.pos = a2 + s2, i2.nextChar(), this.tryShift() && isCmd(this.buf2, "endstream")) this.shift();
    else {
      if (s2 = this.#H(a2), s2 < 0) throw new ti("Missing endstream command.");
      i2.nextChar(), this.shift(), this.shift();
    }
    return this.shift(), n2 = n2.makeSubStream(a2, s2, e2), t2 && (n2 = t2.createStream(n2, s2)), n2 = this.filter(n2, e2, s2), n2.dict = e2, n2;
  }
  filter(e2, t2, i2) {
    let n2 = t2.get("F", "Filter"), a2 = t2.get("DP", "DecodeParms");
    if (n2 instanceof Name) return Array.isArray(a2) && warn$1("/DecodeParms should not be an Array, when /Filter is a Name."), this.makeFilter(e2, n2.name, i2, a2);
    let s2 = i2;
    if (Array.isArray(n2)) {
      const t3 = n2, i3 = a2;
      for (let r2 = 0, o2 = t3.length; r2 < o2; ++r2) {
        if (n2 = this.xref.fetchIfRef(t3[r2]), !(n2 instanceof Name)) throw new ti(`Bad filter name "${n2}"`);
        a2 = null, Array.isArray(i3) && r2 in i3 && (a2 = this.xref.fetchIfRef(i3[r2])), e2 = this.makeFilter(e2, n2.name, s2, a2), s2 = null;
      }
    }
    return e2;
  }
  makeFilter(e2, t2, i2, n2) {
    if (0 === i2) return warn$1(`Empty "${t2}" stream.`), new NullStream();
    try {
      switch (t2) {
        case "Fl":
        case "FlateDecode":
          return n2 ? new PredictorStream(new FlateStream(e2, i2), i2, n2) : new FlateStream(e2, i2);
        case "LZW":
        case "LZWDecode":
          let t3 = 1;
          return n2 ? (n2.has("EarlyChange") && (t3 = n2.get("EarlyChange")), new PredictorStream(new LZWStream(e2, i2, t3), i2, n2)) : new LZWStream(e2, i2, t3);
        case "DCT":
        case "DCTDecode":
          return new JpegStream(e2, i2, n2);
        case "JPX":
        case "JPXDecode":
          return new JpxStream(e2, i2, n2);
        case "A85":
        case "ASCII85Decode":
          return new Ascii85Stream(e2, i2);
        case "AHx":
        case "ASCIIHexDecode":
          return new AsciiHexStream(e2, i2);
        case "CCF":
        case "CCITTFaxDecode":
          return new CCITTFaxStream(e2, i2, n2);
        case "RL":
        case "RunLengthDecode":
          return new RunLengthStream(e2, i2);
        case "JBIG2Decode":
          return new Jbig2Stream(e2, i2, n2);
      }
      return warn$1(`Filter "${t2}" is not supported.`), e2;
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      return warn$1(`Invalid stream: "${e3}"`), new NullStream();
    }
  }
}
const rn = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
function toHexDigit(e2) {
  return e2 >= 48 && e2 <= 57 ? 15 & e2 : e2 >= 65 && e2 <= 70 || e2 >= 97 && e2 <= 102 ? 9 + (15 & e2) : -1;
}
class Lexer {
  constructor(e2, t2 = null) {
    this.stream = e2, this.nextChar(), this.strBuf = [], this.knownCommands = t2, this._hexStringNumWarn = 0, this.beginInlineImagePos = -1;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  peekChar() {
    return this.stream.peekByte();
  }
  getNumber() {
    let e2 = this.currentChar, t2 = false, i2 = 0, n2 = 1;
    if (45 === e2 ? (n2 = -1, e2 = this.nextChar(), 45 === e2 && (e2 = this.nextChar())) : 43 === e2 && (e2 = this.nextChar()), 10 === e2 || 13 === e2) do {
      e2 = this.nextChar();
    } while (10 === e2 || 13 === e2);
    if (46 === e2 && (i2 = 10, e2 = this.nextChar()), e2 < 48 || e2 > 57) {
      const t3 = `Invalid number: ${String.fromCharCode(e2)} (charCode ${e2})`;
      if (isWhiteSpace(e2) || 40 === e2 || 60 === e2 || -1 === e2) return info$1(`Lexer.getNumber - "${t3}".`), 0;
      throw new ti(t3);
    }
    let a2 = e2 - 48, s2 = 0, r2 = 1;
    for (; (e2 = this.nextChar()) >= 0; ) if (e2 >= 48 && e2 <= 57) {
      const n3 = e2 - 48;
      t2 ? s2 = 10 * s2 + n3 : (0 !== i2 && (i2 *= 10), a2 = 10 * a2 + n3);
    } else if (46 === e2) {
      if (0 !== i2) break;
      i2 = 1;
    } else if (45 === e2) warn$1("Badly formatted number: minus sign in the middle");
    else {
      if (69 !== e2 && 101 !== e2) break;
      if (e2 = this.peekChar(), 43 === e2 || 45 === e2) r2 = 45 === e2 ? -1 : 1, this.nextChar();
      else if (e2 < 48 || e2 > 57) break;
      t2 = true;
    }
    return 0 !== i2 && (a2 /= i2), t2 && (a2 *= 10 ** (r2 * s2)), n2 * a2;
  }
  getString() {
    let e2 = 1, t2 = false;
    const i2 = this.strBuf;
    i2.length = 0;
    let n2 = this.nextChar();
    for (; ; ) {
      let a2 = false;
      switch (0 | n2) {
        case -1:
          warn$1("Unterminated string"), t2 = true;
          break;
        case 40:
          ++e2, i2.push("(");
          break;
        case 41:
          0 === --e2 ? (this.nextChar(), t2 = true) : i2.push(")");
          break;
        case 92:
          switch (n2 = this.nextChar(), n2) {
            case -1:
              warn$1("Unterminated string"), t2 = true;
              break;
            case 110:
              i2.push("\n");
              break;
            case 114:
              i2.push("\r");
              break;
            case 116:
              i2.push("	");
              break;
            case 98:
              i2.push("\b");
              break;
            case 102:
              i2.push("\f");
              break;
            case 92:
            case 40:
            case 41:
              i2.push(String.fromCharCode(n2));
              break;
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
              let e3 = 15 & n2;
              n2 = this.nextChar(), a2 = true, n2 >= 48 && n2 <= 55 && (e3 = (e3 << 3) + (15 & n2), n2 = this.nextChar(), n2 >= 48 && n2 <= 55 && (a2 = false, e3 = (e3 << 3) + (15 & n2))), i2.push(String.fromCharCode(e3));
              break;
            case 13:
              10 === this.peekChar() && this.nextChar();
              break;
            case 10:
              break;
            default:
              i2.push(String.fromCharCode(n2));
          }
          break;
        default:
          i2.push(String.fromCharCode(n2));
      }
      if (t2) break;
      a2 || (n2 = this.nextChar());
    }
    return i2.join("");
  }
  getName() {
    let e2, t2;
    const i2 = this.strBuf;
    for (i2.length = 0; (e2 = this.nextChar()) >= 0 && !rn[e2]; ) if (35 === e2) {
      if (e2 = this.nextChar(), rn[e2]) {
        warn$1("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number."), i2.push("#");
        break;
      }
      const n2 = toHexDigit(e2);
      if (-1 !== n2) {
        t2 = e2, e2 = this.nextChar();
        const a2 = toHexDigit(e2);
        if (-1 === a2) {
          if (warn$1(`Lexer_getName: Illegal digit (${String.fromCharCode(e2)}) in hexadecimal number.`), i2.push("#", String.fromCharCode(t2)), rn[e2]) break;
          i2.push(String.fromCharCode(e2));
          continue;
        }
        i2.push(String.fromCharCode(n2 << 4 | a2));
      } else i2.push("#", String.fromCharCode(e2));
    } else i2.push(String.fromCharCode(e2));
    return i2.length > 127 && warn$1(`Name token is longer than allowed by the spec: ${i2.length}`), Name.get(i2.join(""));
  }
  _hexStringWarn(e2) {
    5 !== this._hexStringNumWarn++ ? this._hexStringNumWarn > 5 || warn$1(`getHexString - ignoring invalid character: ${e2}`) : warn$1("getHexString - ignoring additional invalid characters.");
  }
  getHexString() {
    const e2 = this.strBuf;
    e2.length = 0;
    let t2 = this.currentChar, i2 = -1, n2 = -1;
    for (this._hexStringNumWarn = 0; ; ) {
      if (t2 < 0) {
        warn$1("Unterminated hex string");
        break;
      }
      if (62 === t2) {
        this.nextChar();
        break;
      }
      1 !== rn[t2] ? (n2 = toHexDigit(t2), -1 === n2 ? this._hexStringWarn(t2) : -1 === i2 ? i2 = n2 : (e2.push(String.fromCharCode(i2 << 4 | n2)), i2 = -1), t2 = this.nextChar()) : t2 = this.nextChar();
    }
    return -1 !== i2 && e2.push(String.fromCharCode(i2 << 4)), e2.join("");
  }
  getObj() {
    let e2 = false, t2 = this.currentChar;
    for (; ; ) {
      if (t2 < 0) return ci;
      if (e2) 10 !== t2 && 13 !== t2 || (e2 = false);
      else if (37 === t2) e2 = true;
      else if (1 !== rn[t2]) break;
      t2 = this.nextChar();
    }
    switch (0 | t2) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 43:
      case 45:
      case 46:
        return this.getNumber();
      case 40:
        return this.getString();
      case 47:
        return this.getName();
      case 91:
        return this.nextChar(), Cmd.get("[");
      case 93:
        return this.nextChar(), Cmd.get("]");
      case 60:
        return t2 = this.nextChar(), 60 === t2 ? (this.nextChar(), Cmd.get("<<")) : this.getHexString();
      case 62:
        return t2 = this.nextChar(), 62 === t2 ? (this.nextChar(), Cmd.get(">>")) : Cmd.get(">");
      case 123:
        return this.nextChar(), Cmd.get("{");
      case 125:
        return this.nextChar(), Cmd.get("}");
      case 41:
        throw this.nextChar(), new ti(`Illegal character: ${t2}`);
    }
    let i2 = String.fromCharCode(t2);
    if (t2 < 32 || t2 > 127) {
      const e3 = this.peekChar();
      if (e3 >= 32 && e3 <= 127) return this.nextChar(), Cmd.get(i2);
    }
    const n2 = this.knownCommands;
    let a2 = void 0 !== n2?.[i2];
    for (; (t2 = this.nextChar()) >= 0 && !rn[t2]; ) {
      const e3 = i2 + String.fromCharCode(t2);
      if (a2 && void 0 === n2[e3]) break;
      if (128 === i2.length) throw new ti(`Command token too long: ${i2.length}`);
      i2 = e3, a2 = void 0 !== n2?.[i2];
    }
    return "true" === i2 || "false" !== i2 && ("null" === i2 ? null : ("BI" === i2 && (this.beginInlineImagePos = this.stream.pos), Cmd.get(i2)));
  }
  skipToNextLine() {
    let e2 = this.currentChar;
    for (; e2 >= 0; ) {
      if (13 === e2) {
        e2 = this.nextChar(), 10 === e2 && this.nextChar();
        break;
      }
      if (10 === e2) {
        this.nextChar();
        break;
      }
      e2 = this.nextChar();
    }
  }
}
class Linearization {
  static create(e2) {
    function getInt(e3, t3, i3 = false) {
      const n3 = e3.get(t3);
      if (Number.isInteger(n3) && (i3 ? n3 >= 0 : n3 > 0)) return n3;
      throw new Error(`The "${t3}" parameter in the linearization dictionary is invalid.`);
    }
    const t2 = new Parser({ lexer: new Lexer(e2), xref: null }), i2 = t2.getObj(), n2 = t2.getObj(), a2 = t2.getObj(), s2 = t2.getObj();
    let r2, o2;
    if (!(Number.isInteger(i2) && Number.isInteger(n2) && isCmd(a2, "obj") && s2 instanceof Dict && "number" == typeof (r2 = s2.get("Linearized")) && r2 > 0)) return null;
    if ((o2 = getInt(s2, "L")) !== e2.length) throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
    return { length: o2, hints: (function(e3) {
      const t3 = e3.get("H");
      let i3;
      if (Array.isArray(t3) && (2 === (i3 = t3.length) || 4 === i3)) {
        for (let e4 = 0; e4 < i3; e4++) {
          const i4 = t3[e4];
          if (!(Number.isInteger(i4) && i4 > 0)) throw new Error(`Hint (${e4}) in the linearization dictionary is invalid.`);
        }
        return t3;
      }
      throw new Error("Hint array in the linearization dictionary is invalid.");
    })(s2), objectNumberFirst: getInt(s2, "O"), endFirst: getInt(s2, "E"), numPages: getInt(s2, "N"), mainXRefEntriesOffset: getInt(s2, "T"), pageFirst: s2.has("P") ? getInt(s2, "P", true) : 0 };
  }
}
const on = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"], ln = 2 ** 24 - 1;
class CMap {
  constructor(e2 = false) {
    this.codespaceRanges = [[], [], [], []], this.numCodespaceRanges = 0, this._map = [], this.name = "", this.vertical = false, this.useCMap = null, this.builtInCMap = e2;
  }
  addCodespaceRange(e2, t2, i2) {
    this.codespaceRanges[e2 - 1].push(t2, i2), this.numCodespaceRanges++;
  }
  mapCidRange(e2, t2, i2) {
    if (t2 - e2 > ln) throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
    for (; e2 <= t2; ) this._map[e2++] = i2++;
  }
  mapBfRange(e2, t2, i2) {
    if (t2 - e2 > ln) throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
    const n2 = i2.length - 1;
    for (; e2 <= t2; ) {
      this._map[e2++] = i2;
      const t3 = i2.charCodeAt(n2) + 1;
      t3 > 255 ? i2 = i2.substring(0, n2 - 1) + String.fromCharCode(i2.charCodeAt(n2 - 1) + 1) + "\0" : i2 = i2.substring(0, n2) + String.fromCharCode(t3);
    }
  }
  mapBfRangeToArray(e2, t2, i2) {
    if (t2 - e2 > ln) throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
    const n2 = i2.length;
    let a2 = 0;
    for (; e2 <= t2 && a2 < n2; ) this._map[e2] = i2[a2++], ++e2;
  }
  mapOne(e2, t2) {
    this._map[e2] = t2;
  }
  lookup(e2) {
    return this._map[e2];
  }
  contains(e2) {
    return void 0 !== this._map[e2];
  }
  forEach(e2) {
    const t2 = this._map, i2 = t2.length;
    if (i2 <= 65536) for (let n2 = 0; n2 < i2; n2++) void 0 !== t2[n2] && e2(n2, t2[n2]);
    else for (const i3 in t2) e2(i3, t2[i3]);
  }
  charCodeOf(e2) {
    const t2 = this._map;
    if (t2.length <= 65536) return t2.indexOf(e2);
    for (const i2 in t2) if (t2[i2] === e2) return 0 | i2;
    return -1;
  }
  getMap() {
    return this._map;
  }
  readCharCode(e2, t2, i2) {
    let n2 = 0;
    const a2 = this.codespaceRanges;
    for (let s2 = 0, r2 = a2.length; s2 < r2; s2++) {
      n2 = (n2 << 8 | e2.charCodeAt(t2 + s2)) >>> 0;
      const r3 = a2[s2];
      for (let e3 = 0, t3 = r3.length; e3 < t3; ) {
        const t4 = r3[e3++], a3 = r3[e3++];
        if (n2 >= t4 && n2 <= a3) return i2.charcode = n2, void (i2.length = s2 + 1);
      }
    }
    i2.charcode = 0, i2.length = 1;
  }
  getCharCodeLength(e2) {
    const t2 = this.codespaceRanges;
    for (let i2 = 0, n2 = t2.length; i2 < n2; i2++) {
      const n3 = t2[i2];
      for (let t3 = 0, a2 = n3.length; t3 < a2; ) {
        const a3 = n3[t3++], s2 = n3[t3++];
        if (e2 >= a3 && e2 <= s2) return i2 + 1;
      }
    }
    return 1;
  }
  get length() {
    return this._map.length;
  }
  get isIdentityCMap() {
    if ("Identity-H" !== this.name && "Identity-V" !== this.name) return false;
    if (65536 !== this._map.length) return false;
    for (let e2 = 0; e2 < 65536; e2++) if (this._map[e2] !== e2) return false;
    return true;
  }
}
class IdentityCMap extends CMap {
  constructor(e2, t2) {
    super(), this.vertical = e2, this.addCodespaceRange(t2, 0, 65535);
  }
  mapCidRange(e2, t2, i2) {
    unreachable$1("should not call mapCidRange");
  }
  mapBfRange(e2, t2, i2) {
    unreachable$1("should not call mapBfRange");
  }
  mapBfRangeToArray(e2, t2, i2) {
    unreachable$1("should not call mapBfRangeToArray");
  }
  mapOne(e2, t2) {
    unreachable$1("should not call mapCidOne");
  }
  lookup(e2) {
    return Number.isInteger(e2) && e2 <= 65535 ? e2 : void 0;
  }
  contains(e2) {
    return Number.isInteger(e2) && e2 <= 65535;
  }
  forEach(e2) {
    for (let t2 = 0; t2 <= 65535; t2++) e2(t2, t2);
  }
  charCodeOf(e2) {
    return Number.isInteger(e2) && e2 <= 65535 ? e2 : -1;
  }
  getMap() {
    const e2 = new Array(65536);
    for (let t2 = 0; t2 <= 65535; t2++) e2[t2] = t2;
    return e2;
  }
  get length() {
    return 65536;
  }
  get isIdentityCMap() {
    unreachable$1("should not access .isIdentityCMap");
  }
}
function strToInt(e2) {
  let t2 = 0;
  for (let i2 = 0; i2 < e2.length; i2++) t2 = t2 << 8 | e2.charCodeAt(i2);
  return t2 >>> 0;
}
function expectString(e2) {
  if ("string" != typeof e2) throw new ti("Malformed CMap: expected string.");
}
function expectInt(e2) {
  if (!Number.isInteger(e2)) throw new ti("Malformed CMap: expected int.");
}
function parseBfChar(e2, t2) {
  for (; ; ) {
    let i2 = t2.getObj();
    if (i2 === ci) break;
    if (isCmd(i2, "endbfchar")) return;
    expectString(i2);
    const n2 = strToInt(i2);
    i2 = t2.getObj(), expectString(i2);
    const a2 = i2;
    e2.mapOne(n2, a2);
  }
}
function parseBfRange(e2, t2) {
  for (; ; ) {
    let i2 = t2.getObj();
    if (i2 === ci) break;
    if (isCmd(i2, "endbfrange")) return;
    expectString(i2);
    const n2 = strToInt(i2);
    i2 = t2.getObj(), expectString(i2);
    const a2 = strToInt(i2);
    if (i2 = t2.getObj(), Number.isInteger(i2) || "string" == typeof i2) {
      const t3 = Number.isInteger(i2) ? String.fromCharCode(i2) : i2;
      e2.mapBfRange(n2, a2, t3);
    } else {
      if (!isCmd(i2, "[")) break;
      {
        i2 = t2.getObj();
        const s2 = [];
        for (; !isCmd(i2, "]") && i2 !== ci; ) s2.push(i2), i2 = t2.getObj();
        e2.mapBfRangeToArray(n2, a2, s2);
      }
    }
  }
  throw new ti("Invalid bf range.");
}
function parseCidChar(e2, t2) {
  for (; ; ) {
    let i2 = t2.getObj();
    if (i2 === ci) break;
    if (isCmd(i2, "endcidchar")) return;
    expectString(i2);
    const n2 = strToInt(i2);
    i2 = t2.getObj(), expectInt(i2);
    const a2 = i2;
    e2.mapOne(n2, a2);
  }
}
function parseCidRange(e2, t2) {
  for (; ; ) {
    let i2 = t2.getObj();
    if (i2 === ci) break;
    if (isCmd(i2, "endcidrange")) return;
    expectString(i2);
    const n2 = strToInt(i2);
    i2 = t2.getObj(), expectString(i2);
    const a2 = strToInt(i2);
    i2 = t2.getObj(), expectInt(i2);
    const s2 = i2;
    e2.mapCidRange(n2, a2, s2);
  }
}
function parseCodespaceRange(e2, t2) {
  for (; ; ) {
    let i2 = t2.getObj();
    if (i2 === ci) break;
    if (isCmd(i2, "endcodespacerange")) return;
    if ("string" != typeof i2) break;
    const n2 = strToInt(i2);
    if (i2 = t2.getObj(), "string" != typeof i2) break;
    const a2 = strToInt(i2);
    e2.addCodespaceRange(i2.length, n2, a2);
  }
  throw new ti("Invalid codespace range.");
}
function parseWMode(e2, t2) {
  const i2 = t2.getObj();
  Number.isInteger(i2) && (e2.vertical = !!i2);
}
function parseCMapName(e2, t2) {
  const i2 = t2.getObj();
  i2 instanceof Name && (e2.name = i2.name);
}
async function parseCMap(e2, t2, i2, n2) {
  let a2, s2;
  e: for (; ; ) try {
    const i3 = t2.getObj();
    if (i3 === ci) break;
    if (i3 instanceof Name) "WMode" === i3.name ? parseWMode(e2, t2) : "CMapName" === i3.name && parseCMapName(e2, t2), a2 = i3;
    else if (i3 instanceof Cmd) switch (i3.cmd) {
      case "endcmap":
        break e;
      case "usecmap":
        a2 instanceof Name && (s2 = a2.name);
        break;
      case "begincodespacerange":
        parseCodespaceRange(e2, t2);
        break;
      case "beginbfchar":
        parseBfChar(e2, t2);
        break;
      case "begincidchar":
        parseCidChar(e2, t2);
        break;
      case "beginbfrange":
        parseBfRange(e2, t2);
        break;
      case "begincidrange":
        parseCidRange(e2, t2);
    }
  } catch (e3) {
    if (e3 instanceof MissingDataException) throw e3;
    warn$1("Invalid cMap data: " + e3);
    continue;
  }
  return !n2 && s2 && (n2 = s2), n2 ? extendCMap(e2, i2, n2) : e2;
}
async function extendCMap(e2, t2, i2) {
  if (e2.useCMap = await createBuiltInCMap(i2, t2), 0 === e2.numCodespaceRanges) {
    const t3 = e2.useCMap.codespaceRanges;
    for (let i3 = 0; i3 < t3.length; i3++) e2.codespaceRanges[i3] = t3[i3].slice();
    e2.numCodespaceRanges = e2.useCMap.numCodespaceRanges;
  }
  return e2.useCMap.forEach(function(t3, i3) {
    e2.contains(t3) || e2.mapOne(t3, i3);
  }), e2;
}
async function createBuiltInCMap(e2, t2) {
  if ("Identity-H" === e2) return new IdentityCMap(false, 2);
  if ("Identity-V" === e2) return new IdentityCMap(true, 2);
  if (!on.includes(e2)) throw new Error("Unknown CMap name: " + e2);
  if (!t2) throw new Error("Built-in CMap parameters are not provided.");
  const { cMapData: i2, isCompressed: n2 } = await t2(e2), a2 = new CMap(true);
  if (n2) return new BinaryCMapReader().process(i2, a2, (e3) => extendCMap(a2, t2, e3));
  const s2 = new Lexer(new Stream(i2));
  return parseCMap(a2, s2, t2, null);
}
class CMapFactory {
  static async create({ encoding: e2, fetchBuiltInCMap: t2, useCMap: i2 }) {
    if (e2 instanceof Name) return createBuiltInCMap(e2.name, t2);
    if (e2 instanceof BaseStream) {
      const n2 = await parseCMap(new CMap(), new Lexer(e2), t2, i2);
      return n2.isIdentityCMap ? createBuiltInCMap(n2.name, t2) : n2;
    }
    throw new Error("Encoding required.");
  }
}
const cn = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"], hn = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""], dn = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"], un = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""], gn = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"], fn = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""], pn = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
function getEncoding(e2) {
  switch (e2) {
    case "WinAnsiEncoding":
      return gn;
    case "StandardEncoding":
      return un;
    case "MacRomanEncoding":
      return dn;
    case "SymbolSetEncoding":
      return fn;
    case "ZapfDingbatsEncoding":
      return pn;
    case "ExpertEncoding":
      return cn;
    case "MacExpertEncoding":
      return hn;
    default:
      return null;
  }
}
const mn = getLookupTableFactory(function(e2) {
  e2.A = 65, e2.AE = 198, e2.AEacute = 508, e2.AEmacron = 482, e2.AEsmall = 63462, e2.Aacute = 193, e2.Aacutesmall = 63457, e2.Abreve = 258, e2.Abreveacute = 7854, e2.Abrevecyrillic = 1232, e2.Abrevedotbelow = 7862, e2.Abrevegrave = 7856, e2.Abrevehookabove = 7858, e2.Abrevetilde = 7860, e2.Acaron = 461, e2.Acircle = 9398, e2.Acircumflex = 194, e2.Acircumflexacute = 7844, e2.Acircumflexdotbelow = 7852, e2.Acircumflexgrave = 7846, e2.Acircumflexhookabove = 7848, e2.Acircumflexsmall = 63458, e2.Acircumflextilde = 7850, e2.Acute = 63177, e2.Acutesmall = 63412, e2.Acyrillic = 1040, e2.Adblgrave = 512, e2.Adieresis = 196, e2.Adieresiscyrillic = 1234, e2.Adieresismacron = 478, e2.Adieresissmall = 63460, e2.Adotbelow = 7840, e2.Adotmacron = 480, e2.Agrave = 192, e2.Agravesmall = 63456, e2.Ahookabove = 7842, e2.Aiecyrillic = 1236, e2.Ainvertedbreve = 514, e2.Alpha = 913, e2.Alphatonos = 902, e2.Amacron = 256, e2.Amonospace = 65313, e2.Aogonek = 260, e2.Aring = 197, e2.Aringacute = 506, e2.Aringbelow = 7680, e2.Aringsmall = 63461, e2.Asmall = 63329, e2.Atilde = 195, e2.Atildesmall = 63459, e2.Aybarmenian = 1329, e2.B = 66, e2.Bcircle = 9399, e2.Bdotaccent = 7682, e2.Bdotbelow = 7684, e2.Becyrillic = 1041, e2.Benarmenian = 1330, e2.Beta = 914, e2.Bhook = 385, e2.Blinebelow = 7686, e2.Bmonospace = 65314, e2.Brevesmall = 63220, e2.Bsmall = 63330, e2.Btopbar = 386, e2.C = 67, e2.Caarmenian = 1342, e2.Cacute = 262, e2.Caron = 63178, e2.Caronsmall = 63221, e2.Ccaron = 268, e2.Ccedilla = 199, e2.Ccedillaacute = 7688, e2.Ccedillasmall = 63463, e2.Ccircle = 9400, e2.Ccircumflex = 264, e2.Cdot = 266, e2.Cdotaccent = 266, e2.Cedillasmall = 63416, e2.Chaarmenian = 1353, e2.Cheabkhasiancyrillic = 1212, e2.Checyrillic = 1063, e2.Chedescenderabkhasiancyrillic = 1214, e2.Chedescendercyrillic = 1206, e2.Chedieresiscyrillic = 1268, e2.Cheharmenian = 1347, e2.Chekhakassiancyrillic = 1227, e2.Cheverticalstrokecyrillic = 1208, e2.Chi = 935, e2.Chook = 391, e2.Circumflexsmall = 63222, e2.Cmonospace = 65315, e2.Coarmenian = 1361, e2.Csmall = 63331, e2.D = 68, e2.DZ = 497, e2.DZcaron = 452, e2.Daarmenian = 1332, e2.Dafrican = 393, e2.Dcaron = 270, e2.Dcedilla = 7696, e2.Dcircle = 9401, e2.Dcircumflexbelow = 7698, e2.Dcroat = 272, e2.Ddotaccent = 7690, e2.Ddotbelow = 7692, e2.Decyrillic = 1044, e2.Deicoptic = 1006, e2.Delta = 8710, e2.Deltagreek = 916, e2.Dhook = 394, e2.Dieresis = 63179, e2.DieresisAcute = 63180, e2.DieresisGrave = 63181, e2.Dieresissmall = 63400, e2.Digammagreek = 988, e2.Djecyrillic = 1026, e2.Dlinebelow = 7694, e2.Dmonospace = 65316, e2.Dotaccentsmall = 63223, e2.Dslash = 272, e2.Dsmall = 63332, e2.Dtopbar = 395, e2.Dz = 498, e2.Dzcaron = 453, e2.Dzeabkhasiancyrillic = 1248, e2.Dzecyrillic = 1029, e2.Dzhecyrillic = 1039, e2.E = 69, e2.Eacute = 201, e2.Eacutesmall = 63465, e2.Ebreve = 276, e2.Ecaron = 282, e2.Ecedillabreve = 7708, e2.Echarmenian = 1333, e2.Ecircle = 9402, e2.Ecircumflex = 202, e2.Ecircumflexacute = 7870, e2.Ecircumflexbelow = 7704, e2.Ecircumflexdotbelow = 7878, e2.Ecircumflexgrave = 7872, e2.Ecircumflexhookabove = 7874, e2.Ecircumflexsmall = 63466, e2.Ecircumflextilde = 7876, e2.Ecyrillic = 1028, e2.Edblgrave = 516, e2.Edieresis = 203, e2.Edieresissmall = 63467, e2.Edot = 278, e2.Edotaccent = 278, e2.Edotbelow = 7864, e2.Efcyrillic = 1060, e2.Egrave = 200, e2.Egravesmall = 63464, e2.Eharmenian = 1335, e2.Ehookabove = 7866, e2.Eightroman = 8551, e2.Einvertedbreve = 518, e2.Eiotifiedcyrillic = 1124, e2.Elcyrillic = 1051, e2.Elevenroman = 8554, e2.Emacron = 274, e2.Emacronacute = 7702, e2.Emacrongrave = 7700, e2.Emcyrillic = 1052, e2.Emonospace = 65317, e2.Encyrillic = 1053, e2.Endescendercyrillic = 1186, e2.Eng = 330, e2.Enghecyrillic = 1188, e2.Enhookcyrillic = 1223, e2.Eogonek = 280, e2.Eopen = 400, e2.Epsilon = 917, e2.Epsilontonos = 904, e2.Ercyrillic = 1056, e2.Ereversed = 398, e2.Ereversedcyrillic = 1069, e2.Escyrillic = 1057, e2.Esdescendercyrillic = 1194, e2.Esh = 425, e2.Esmall = 63333, e2.Eta = 919, e2.Etarmenian = 1336, e2.Etatonos = 905, e2.Eth = 208, e2.Ethsmall = 63472, e2.Etilde = 7868, e2.Etildebelow = 7706, e2.Euro = 8364, e2.Ezh = 439, e2.Ezhcaron = 494, e2.Ezhreversed = 440, e2.F = 70, e2.Fcircle = 9403, e2.Fdotaccent = 7710, e2.Feharmenian = 1366, e2.Feicoptic = 996, e2.Fhook = 401, e2.Fitacyrillic = 1138, e2.Fiveroman = 8548, e2.Fmonospace = 65318, e2.Fourroman = 8547, e2.Fsmall = 63334, e2.G = 71, e2.GBsquare = 13191, e2.Gacute = 500, e2.Gamma = 915, e2.Gammaafrican = 404, e2.Gangiacoptic = 1002, e2.Gbreve = 286, e2.Gcaron = 486, e2.Gcedilla = 290, e2.Gcircle = 9404, e2.Gcircumflex = 284, e2.Gcommaaccent = 290, e2.Gdot = 288, e2.Gdotaccent = 288, e2.Gecyrillic = 1043, e2.Ghadarmenian = 1346, e2.Ghemiddlehookcyrillic = 1172, e2.Ghestrokecyrillic = 1170, e2.Gheupturncyrillic = 1168, e2.Ghook = 403, e2.Gimarmenian = 1331, e2.Gjecyrillic = 1027, e2.Gmacron = 7712, e2.Gmonospace = 65319, e2.Grave = 63182, e2.Gravesmall = 63328, e2.Gsmall = 63335, e2.Gsmallhook = 667, e2.Gstroke = 484, e2.H = 72, e2.H18533 = 9679, e2.H18543 = 9642, e2.H18551 = 9643, e2.H22073 = 9633, e2.HPsquare = 13259, e2.Haabkhasiancyrillic = 1192, e2.Hadescendercyrillic = 1202, e2.Hardsigncyrillic = 1066, e2.Hbar = 294, e2.Hbrevebelow = 7722, e2.Hcedilla = 7720, e2.Hcircle = 9405, e2.Hcircumflex = 292, e2.Hdieresis = 7718, e2.Hdotaccent = 7714, e2.Hdotbelow = 7716, e2.Hmonospace = 65320, e2.Hoarmenian = 1344, e2.Horicoptic = 1e3, e2.Hsmall = 63336, e2.Hungarumlaut = 63183, e2.Hungarumlautsmall = 63224, e2.Hzsquare = 13200, e2.I = 73, e2.IAcyrillic = 1071, e2.IJ = 306, e2.IUcyrillic = 1070, e2.Iacute = 205, e2.Iacutesmall = 63469, e2.Ibreve = 300, e2.Icaron = 463, e2.Icircle = 9406, e2.Icircumflex = 206, e2.Icircumflexsmall = 63470, e2.Icyrillic = 1030, e2.Idblgrave = 520, e2.Idieresis = 207, e2.Idieresisacute = 7726, e2.Idieresiscyrillic = 1252, e2.Idieresissmall = 63471, e2.Idot = 304, e2.Idotaccent = 304, e2.Idotbelow = 7882, e2.Iebrevecyrillic = 1238, e2.Iecyrillic = 1045, e2.Ifraktur = 8465, e2.Igrave = 204, e2.Igravesmall = 63468, e2.Ihookabove = 7880, e2.Iicyrillic = 1048, e2.Iinvertedbreve = 522, e2.Iishortcyrillic = 1049, e2.Imacron = 298, e2.Imacroncyrillic = 1250, e2.Imonospace = 65321, e2.Iniarmenian = 1339, e2.Iocyrillic = 1025, e2.Iogonek = 302, e2.Iota = 921, e2.Iotaafrican = 406, e2.Iotadieresis = 938, e2.Iotatonos = 906, e2.Ismall = 63337, e2.Istroke = 407, e2.Itilde = 296, e2.Itildebelow = 7724, e2.Izhitsacyrillic = 1140, e2.Izhitsadblgravecyrillic = 1142, e2.J = 74, e2.Jaarmenian = 1345, e2.Jcircle = 9407, e2.Jcircumflex = 308, e2.Jecyrillic = 1032, e2.Jheharmenian = 1355, e2.Jmonospace = 65322, e2.Jsmall = 63338, e2.K = 75, e2.KBsquare = 13189, e2.KKsquare = 13261, e2.Kabashkircyrillic = 1184, e2.Kacute = 7728, e2.Kacyrillic = 1050, e2.Kadescendercyrillic = 1178, e2.Kahookcyrillic = 1219, e2.Kappa = 922, e2.Kastrokecyrillic = 1182, e2.Kaverticalstrokecyrillic = 1180, e2.Kcaron = 488, e2.Kcedilla = 310, e2.Kcircle = 9408, e2.Kcommaaccent = 310, e2.Kdotbelow = 7730, e2.Keharmenian = 1364, e2.Kenarmenian = 1343, e2.Khacyrillic = 1061, e2.Kheicoptic = 998, e2.Khook = 408, e2.Kjecyrillic = 1036, e2.Klinebelow = 7732, e2.Kmonospace = 65323, e2.Koppacyrillic = 1152, e2.Koppagreek = 990, e2.Ksicyrillic = 1134, e2.Ksmall = 63339, e2.L = 76, e2.LJ = 455, e2.LL = 63167, e2.Lacute = 313, e2.Lambda = 923, e2.Lcaron = 317, e2.Lcedilla = 315, e2.Lcircle = 9409, e2.Lcircumflexbelow = 7740, e2.Lcommaaccent = 315, e2.Ldot = 319, e2.Ldotaccent = 319, e2.Ldotbelow = 7734, e2.Ldotbelowmacron = 7736, e2.Liwnarmenian = 1340, e2.Lj = 456, e2.Ljecyrillic = 1033, e2.Llinebelow = 7738, e2.Lmonospace = 65324, e2.Lslash = 321, e2.Lslashsmall = 63225, e2.Lsmall = 63340, e2.M = 77, e2.MBsquare = 13190, e2.Macron = 63184, e2.Macronsmall = 63407, e2.Macute = 7742, e2.Mcircle = 9410, e2.Mdotaccent = 7744, e2.Mdotbelow = 7746, e2.Menarmenian = 1348, e2.Mmonospace = 65325, e2.Msmall = 63341, e2.Mturned = 412, e2.Mu = 924, e2.N = 78, e2.NJ = 458, e2.Nacute = 323, e2.Ncaron = 327, e2.Ncedilla = 325, e2.Ncircle = 9411, e2.Ncircumflexbelow = 7754, e2.Ncommaaccent = 325, e2.Ndotaccent = 7748, e2.Ndotbelow = 7750, e2.Nhookleft = 413, e2.Nineroman = 8552, e2.Nj = 459, e2.Njecyrillic = 1034, e2.Nlinebelow = 7752, e2.Nmonospace = 65326, e2.Nowarmenian = 1350, e2.Nsmall = 63342, e2.Ntilde = 209, e2.Ntildesmall = 63473, e2.Nu = 925, e2.O = 79, e2.OE = 338, e2.OEsmall = 63226, e2.Oacute = 211, e2.Oacutesmall = 63475, e2.Obarredcyrillic = 1256, e2.Obarreddieresiscyrillic = 1258, e2.Obreve = 334, e2.Ocaron = 465, e2.Ocenteredtilde = 415, e2.Ocircle = 9412, e2.Ocircumflex = 212, e2.Ocircumflexacute = 7888, e2.Ocircumflexdotbelow = 7896, e2.Ocircumflexgrave = 7890, e2.Ocircumflexhookabove = 7892, e2.Ocircumflexsmall = 63476, e2.Ocircumflextilde = 7894, e2.Ocyrillic = 1054, e2.Odblacute = 336, e2.Odblgrave = 524, e2.Odieresis = 214, e2.Odieresiscyrillic = 1254, e2.Odieresissmall = 63478, e2.Odotbelow = 7884, e2.Ogoneksmall = 63227, e2.Ograve = 210, e2.Ogravesmall = 63474, e2.Oharmenian = 1365, e2.Ohm = 8486, e2.Ohookabove = 7886, e2.Ohorn = 416, e2.Ohornacute = 7898, e2.Ohorndotbelow = 7906, e2.Ohorngrave = 7900, e2.Ohornhookabove = 7902, e2.Ohorntilde = 7904, e2.Ohungarumlaut = 336, e2.Oi = 418, e2.Oinvertedbreve = 526, e2.Omacron = 332, e2.Omacronacute = 7762, e2.Omacrongrave = 7760, e2.Omega = 8486, e2.Omegacyrillic = 1120, e2.Omegagreek = 937, e2.Omegaroundcyrillic = 1146, e2.Omegatitlocyrillic = 1148, e2.Omegatonos = 911, e2.Omicron = 927, e2.Omicrontonos = 908, e2.Omonospace = 65327, e2.Oneroman = 8544, e2.Oogonek = 490, e2.Oogonekmacron = 492, e2.Oopen = 390, e2.Oslash = 216, e2.Oslashacute = 510, e2.Oslashsmall = 63480, e2.Osmall = 63343, e2.Ostrokeacute = 510, e2.Otcyrillic = 1150, e2.Otilde = 213, e2.Otildeacute = 7756, e2.Otildedieresis = 7758, e2.Otildesmall = 63477, e2.P = 80, e2.Pacute = 7764, e2.Pcircle = 9413, e2.Pdotaccent = 7766, e2.Pecyrillic = 1055, e2.Peharmenian = 1354, e2.Pemiddlehookcyrillic = 1190, e2.Phi = 934, e2.Phook = 420, e2.Pi = 928, e2.Piwrarmenian = 1363, e2.Pmonospace = 65328, e2.Psi = 936, e2.Psicyrillic = 1136, e2.Psmall = 63344, e2.Q = 81, e2.Qcircle = 9414, e2.Qmonospace = 65329, e2.Qsmall = 63345, e2.R = 82, e2.Raarmenian = 1356, e2.Racute = 340, e2.Rcaron = 344, e2.Rcedilla = 342, e2.Rcircle = 9415, e2.Rcommaaccent = 342, e2.Rdblgrave = 528, e2.Rdotaccent = 7768, e2.Rdotbelow = 7770, e2.Rdotbelowmacron = 7772, e2.Reharmenian = 1360, e2.Rfraktur = 8476, e2.Rho = 929, e2.Ringsmall = 63228, e2.Rinvertedbreve = 530, e2.Rlinebelow = 7774, e2.Rmonospace = 65330, e2.Rsmall = 63346, e2.Rsmallinverted = 641, e2.Rsmallinvertedsuperior = 694, e2.S = 83, e2.SF010000 = 9484, e2.SF020000 = 9492, e2.SF030000 = 9488, e2.SF040000 = 9496, e2.SF050000 = 9532, e2.SF060000 = 9516, e2.SF070000 = 9524, e2.SF080000 = 9500, e2.SF090000 = 9508, e2.SF100000 = 9472, e2.SF110000 = 9474, e2.SF190000 = 9569, e2.SF200000 = 9570, e2.SF210000 = 9558, e2.SF220000 = 9557, e2.SF230000 = 9571, e2.SF240000 = 9553, e2.SF250000 = 9559, e2.SF260000 = 9565, e2.SF270000 = 9564, e2.SF280000 = 9563, e2.SF360000 = 9566, e2.SF370000 = 9567, e2.SF380000 = 9562, e2.SF390000 = 9556, e2.SF400000 = 9577, e2.SF410000 = 9574, e2.SF420000 = 9568, e2.SF430000 = 9552, e2.SF440000 = 9580, e2.SF450000 = 9575, e2.SF460000 = 9576, e2.SF470000 = 9572, e2.SF480000 = 9573, e2.SF490000 = 9561, e2.SF500000 = 9560, e2.SF510000 = 9554, e2.SF520000 = 9555, e2.SF530000 = 9579, e2.SF540000 = 9578, e2.Sacute = 346, e2.Sacutedotaccent = 7780, e2.Sampigreek = 992, e2.Scaron = 352, e2.Scarondotaccent = 7782, e2.Scaronsmall = 63229, e2.Scedilla = 350, e2.Schwa = 399, e2.Schwacyrillic = 1240, e2.Schwadieresiscyrillic = 1242, e2.Scircle = 9416, e2.Scircumflex = 348, e2.Scommaaccent = 536, e2.Sdotaccent = 7776, e2.Sdotbelow = 7778, e2.Sdotbelowdotaccent = 7784, e2.Seharmenian = 1357, e2.Sevenroman = 8550, e2.Shaarmenian = 1351, e2.Shacyrillic = 1064, e2.Shchacyrillic = 1065, e2.Sheicoptic = 994, e2.Shhacyrillic = 1210, e2.Shimacoptic = 1004, e2.Sigma = 931, e2.Sixroman = 8549, e2.Smonospace = 65331, e2.Softsigncyrillic = 1068, e2.Ssmall = 63347, e2.Stigmagreek = 986, e2.T = 84, e2.Tau = 932, e2.Tbar = 358, e2.Tcaron = 356, e2.Tcedilla = 354, e2.Tcircle = 9417, e2.Tcircumflexbelow = 7792, e2.Tcommaaccent = 354, e2.Tdotaccent = 7786, e2.Tdotbelow = 7788, e2.Tecyrillic = 1058, e2.Tedescendercyrillic = 1196, e2.Tenroman = 8553, e2.Tetsecyrillic = 1204, e2.Theta = 920, e2.Thook = 428, e2.Thorn = 222, e2.Thornsmall = 63486, e2.Threeroman = 8546, e2.Tildesmall = 63230, e2.Tiwnarmenian = 1359, e2.Tlinebelow = 7790, e2.Tmonospace = 65332, e2.Toarmenian = 1337, e2.Tonefive = 444, e2.Tonesix = 388, e2.Tonetwo = 423, e2.Tretroflexhook = 430, e2.Tsecyrillic = 1062, e2.Tshecyrillic = 1035, e2.Tsmall = 63348, e2.Twelveroman = 8555, e2.Tworoman = 8545, e2.U = 85, e2.Uacute = 218, e2.Uacutesmall = 63482, e2.Ubreve = 364, e2.Ucaron = 467, e2.Ucircle = 9418, e2.Ucircumflex = 219, e2.Ucircumflexbelow = 7798, e2.Ucircumflexsmall = 63483, e2.Ucyrillic = 1059, e2.Udblacute = 368, e2.Udblgrave = 532, e2.Udieresis = 220, e2.Udieresisacute = 471, e2.Udieresisbelow = 7794, e2.Udieresiscaron = 473, e2.Udieresiscyrillic = 1264, e2.Udieresisgrave = 475, e2.Udieresismacron = 469, e2.Udieresissmall = 63484, e2.Udotbelow = 7908, e2.Ugrave = 217, e2.Ugravesmall = 63481, e2.Uhookabove = 7910, e2.Uhorn = 431, e2.Uhornacute = 7912, e2.Uhorndotbelow = 7920, e2.Uhorngrave = 7914, e2.Uhornhookabove = 7916, e2.Uhorntilde = 7918, e2.Uhungarumlaut = 368, e2.Uhungarumlautcyrillic = 1266, e2.Uinvertedbreve = 534, e2.Ukcyrillic = 1144, e2.Umacron = 362, e2.Umacroncyrillic = 1262, e2.Umacrondieresis = 7802, e2.Umonospace = 65333, e2.Uogonek = 370, e2.Upsilon = 933, e2.Upsilon1 = 978, e2.Upsilonacutehooksymbolgreek = 979, e2.Upsilonafrican = 433, e2.Upsilondieresis = 939, e2.Upsilondieresishooksymbolgreek = 980, e2.Upsilonhooksymbol = 978, e2.Upsilontonos = 910, e2.Uring = 366, e2.Ushortcyrillic = 1038, e2.Usmall = 63349, e2.Ustraightcyrillic = 1198, e2.Ustraightstrokecyrillic = 1200, e2.Utilde = 360, e2.Utildeacute = 7800, e2.Utildebelow = 7796, e2.V = 86, e2.Vcircle = 9419, e2.Vdotbelow = 7806, e2.Vecyrillic = 1042, e2.Vewarmenian = 1358, e2.Vhook = 434, e2.Vmonospace = 65334, e2.Voarmenian = 1352, e2.Vsmall = 63350, e2.Vtilde = 7804, e2.W = 87, e2.Wacute = 7810, e2.Wcircle = 9420, e2.Wcircumflex = 372, e2.Wdieresis = 7812, e2.Wdotaccent = 7814, e2.Wdotbelow = 7816, e2.Wgrave = 7808, e2.Wmonospace = 65335, e2.Wsmall = 63351, e2.X = 88, e2.Xcircle = 9421, e2.Xdieresis = 7820, e2.Xdotaccent = 7818, e2.Xeharmenian = 1341, e2.Xi = 926, e2.Xmonospace = 65336, e2.Xsmall = 63352, e2.Y = 89, e2.Yacute = 221, e2.Yacutesmall = 63485, e2.Yatcyrillic = 1122, e2.Ycircle = 9422, e2.Ycircumflex = 374, e2.Ydieresis = 376, e2.Ydieresissmall = 63487, e2.Ydotaccent = 7822, e2.Ydotbelow = 7924, e2.Yericyrillic = 1067, e2.Yerudieresiscyrillic = 1272, e2.Ygrave = 7922, e2.Yhook = 435, e2.Yhookabove = 7926, e2.Yiarmenian = 1349, e2.Yicyrillic = 1031, e2.Yiwnarmenian = 1362, e2.Ymonospace = 65337, e2.Ysmall = 63353, e2.Ytilde = 7928, e2.Yusbigcyrillic = 1130, e2.Yusbigiotifiedcyrillic = 1132, e2.Yuslittlecyrillic = 1126, e2.Yuslittleiotifiedcyrillic = 1128, e2.Z = 90, e2.Zaarmenian = 1334, e2.Zacute = 377, e2.Zcaron = 381, e2.Zcaronsmall = 63231, e2.Zcircle = 9423, e2.Zcircumflex = 7824, e2.Zdot = 379, e2.Zdotaccent = 379, e2.Zdotbelow = 7826, e2.Zecyrillic = 1047, e2.Zedescendercyrillic = 1176, e2.Zedieresiscyrillic = 1246, e2.Zeta = 918, e2.Zhearmenian = 1338, e2.Zhebrevecyrillic = 1217, e2.Zhecyrillic = 1046, e2.Zhedescendercyrillic = 1174, e2.Zhedieresiscyrillic = 1244, e2.Zlinebelow = 7828, e2.Zmonospace = 65338, e2.Zsmall = 63354, e2.Zstroke = 437, e2.a = 97, e2.aabengali = 2438, e2.aacute = 225, e2.aadeva = 2310, e2.aagujarati = 2694, e2.aagurmukhi = 2566, e2.aamatragurmukhi = 2622, e2.aarusquare = 13059, e2.aavowelsignbengali = 2494, e2.aavowelsigndeva = 2366, e2.aavowelsigngujarati = 2750, e2.abbreviationmarkarmenian = 1375, e2.abbreviationsigndeva = 2416, e2.abengali = 2437, e2.abopomofo = 12570, e2.abreve = 259, e2.abreveacute = 7855, e2.abrevecyrillic = 1233, e2.abrevedotbelow = 7863, e2.abrevegrave = 7857, e2.abrevehookabove = 7859, e2.abrevetilde = 7861, e2.acaron = 462, e2.acircle = 9424, e2.acircumflex = 226, e2.acircumflexacute = 7845, e2.acircumflexdotbelow = 7853, e2.acircumflexgrave = 7847, e2.acircumflexhookabove = 7849, e2.acircumflextilde = 7851, e2.acute = 180, e2.acutebelowcmb = 791, e2.acutecmb = 769, e2.acutecomb = 769, e2.acutedeva = 2388, e2.acutelowmod = 719, e2.acutetonecmb = 833, e2.acyrillic = 1072, e2.adblgrave = 513, e2.addakgurmukhi = 2673, e2.adeva = 2309, e2.adieresis = 228, e2.adieresiscyrillic = 1235, e2.adieresismacron = 479, e2.adotbelow = 7841, e2.adotmacron = 481, e2.ae = 230, e2.aeacute = 509, e2.aekorean = 12624, e2.aemacron = 483, e2.afii00208 = 8213, e2.afii08941 = 8356, e2.afii10017 = 1040, e2.afii10018 = 1041, e2.afii10019 = 1042, e2.afii10020 = 1043, e2.afii10021 = 1044, e2.afii10022 = 1045, e2.afii10023 = 1025, e2.afii10024 = 1046, e2.afii10025 = 1047, e2.afii10026 = 1048, e2.afii10027 = 1049, e2.afii10028 = 1050, e2.afii10029 = 1051, e2.afii10030 = 1052;
  e2.afii10031 = 1053, e2.afii10032 = 1054, e2.afii10033 = 1055, e2.afii10034 = 1056, e2.afii10035 = 1057, e2.afii10036 = 1058, e2.afii10037 = 1059, e2.afii10038 = 1060, e2.afii10039 = 1061, e2.afii10040 = 1062, e2.afii10041 = 1063, e2.afii10042 = 1064, e2.afii10043 = 1065, e2.afii10044 = 1066, e2.afii10045 = 1067, e2.afii10046 = 1068, e2.afii10047 = 1069, e2.afii10048 = 1070, e2.afii10049 = 1071, e2.afii10050 = 1168, e2.afii10051 = 1026, e2.afii10052 = 1027, e2.afii10053 = 1028, e2.afii10054 = 1029, e2.afii10055 = 1030, e2.afii10056 = 1031, e2.afii10057 = 1032, e2.afii10058 = 1033, e2.afii10059 = 1034, e2.afii10060 = 1035, e2.afii10061 = 1036, e2.afii10062 = 1038, e2.afii10063 = 63172, e2.afii10064 = 63173, e2.afii10065 = 1072, e2.afii10066 = 1073, e2.afii10067 = 1074, e2.afii10068 = 1075, e2.afii10069 = 1076, e2.afii10070 = 1077, e2.afii10071 = 1105, e2.afii10072 = 1078, e2.afii10073 = 1079, e2.afii10074 = 1080, e2.afii10075 = 1081, e2.afii10076 = 1082, e2.afii10077 = 1083, e2.afii10078 = 1084, e2.afii10079 = 1085, e2.afii10080 = 1086, e2.afii10081 = 1087, e2.afii10082 = 1088, e2.afii10083 = 1089, e2.afii10084 = 1090, e2.afii10085 = 1091, e2.afii10086 = 1092, e2.afii10087 = 1093, e2.afii10088 = 1094, e2.afii10089 = 1095, e2.afii10090 = 1096, e2.afii10091 = 1097, e2.afii10092 = 1098, e2.afii10093 = 1099, e2.afii10094 = 1100, e2.afii10095 = 1101, e2.afii10096 = 1102, e2.afii10097 = 1103, e2.afii10098 = 1169, e2.afii10099 = 1106, e2.afii10100 = 1107, e2.afii10101 = 1108, e2.afii10102 = 1109, e2.afii10103 = 1110, e2.afii10104 = 1111, e2.afii10105 = 1112, e2.afii10106 = 1113, e2.afii10107 = 1114, e2.afii10108 = 1115, e2.afii10109 = 1116, e2.afii10110 = 1118, e2.afii10145 = 1039, e2.afii10146 = 1122, e2.afii10147 = 1138, e2.afii10148 = 1140, e2.afii10192 = 63174, e2.afii10193 = 1119, e2.afii10194 = 1123, e2.afii10195 = 1139, e2.afii10196 = 1141, e2.afii10831 = 63175, e2.afii10832 = 63176, e2.afii10846 = 1241, e2.afii299 = 8206, e2.afii300 = 8207, e2.afii301 = 8205, e2.afii57381 = 1642, e2.afii57388 = 1548, e2.afii57392 = 1632, e2.afii57393 = 1633, e2.afii57394 = 1634, e2.afii57395 = 1635, e2.afii57396 = 1636, e2.afii57397 = 1637, e2.afii57398 = 1638, e2.afii57399 = 1639, e2.afii57400 = 1640, e2.afii57401 = 1641, e2.afii57403 = 1563, e2.afii57407 = 1567, e2.afii57409 = 1569, e2.afii57410 = 1570, e2.afii57411 = 1571, e2.afii57412 = 1572, e2.afii57413 = 1573, e2.afii57414 = 1574, e2.afii57415 = 1575, e2.afii57416 = 1576, e2.afii57417 = 1577, e2.afii57418 = 1578, e2.afii57419 = 1579, e2.afii57420 = 1580, e2.afii57421 = 1581, e2.afii57422 = 1582, e2.afii57423 = 1583, e2.afii57424 = 1584, e2.afii57425 = 1585, e2.afii57426 = 1586, e2.afii57427 = 1587, e2.afii57428 = 1588, e2.afii57429 = 1589, e2.afii57430 = 1590, e2.afii57431 = 1591, e2.afii57432 = 1592, e2.afii57433 = 1593, e2.afii57434 = 1594, e2.afii57440 = 1600, e2.afii57441 = 1601, e2.afii57442 = 1602, e2.afii57443 = 1603, e2.afii57444 = 1604, e2.afii57445 = 1605, e2.afii57446 = 1606, e2.afii57448 = 1608, e2.afii57449 = 1609, e2.afii57450 = 1610, e2.afii57451 = 1611, e2.afii57452 = 1612, e2.afii57453 = 1613, e2.afii57454 = 1614, e2.afii57455 = 1615, e2.afii57456 = 1616, e2.afii57457 = 1617, e2.afii57458 = 1618, e2.afii57470 = 1607, e2.afii57505 = 1700, e2.afii57506 = 1662, e2.afii57507 = 1670, e2.afii57508 = 1688, e2.afii57509 = 1711, e2.afii57511 = 1657, e2.afii57512 = 1672, e2.afii57513 = 1681, e2.afii57514 = 1722, e2.afii57519 = 1746, e2.afii57534 = 1749, e2.afii57636 = 8362, e2.afii57645 = 1470, e2.afii57658 = 1475, e2.afii57664 = 1488, e2.afii57665 = 1489, e2.afii57666 = 1490, e2.afii57667 = 1491, e2.afii57668 = 1492, e2.afii57669 = 1493, e2.afii57670 = 1494, e2.afii57671 = 1495, e2.afii57672 = 1496, e2.afii57673 = 1497, e2.afii57674 = 1498, e2.afii57675 = 1499, e2.afii57676 = 1500, e2.afii57677 = 1501, e2.afii57678 = 1502, e2.afii57679 = 1503, e2.afii57680 = 1504, e2.afii57681 = 1505, e2.afii57682 = 1506, e2.afii57683 = 1507, e2.afii57684 = 1508, e2.afii57685 = 1509, e2.afii57686 = 1510, e2.afii57687 = 1511, e2.afii57688 = 1512, e2.afii57689 = 1513, e2.afii57690 = 1514, e2.afii57694 = 64298, e2.afii57695 = 64299, e2.afii57700 = 64331, e2.afii57705 = 64287, e2.afii57716 = 1520, e2.afii57717 = 1521, e2.afii57718 = 1522, e2.afii57723 = 64309, e2.afii57793 = 1460, e2.afii57794 = 1461, e2.afii57795 = 1462, e2.afii57796 = 1467, e2.afii57797 = 1464, e2.afii57798 = 1463, e2.afii57799 = 1456, e2.afii57800 = 1458, e2.afii57801 = 1457, e2.afii57802 = 1459, e2.afii57803 = 1474, e2.afii57804 = 1473, e2.afii57806 = 1465, e2.afii57807 = 1468, e2.afii57839 = 1469, e2.afii57841 = 1471, e2.afii57842 = 1472, e2.afii57929 = 700, e2.afii61248 = 8453, e2.afii61289 = 8467, e2.afii61352 = 8470, e2.afii61573 = 8236, e2.afii61574 = 8237, e2.afii61575 = 8238, e2.afii61664 = 8204, e2.afii63167 = 1645, e2.afii64937 = 701, e2.agrave = 224, e2.agujarati = 2693, e2.agurmukhi = 2565, e2.ahiragana = 12354, e2.ahookabove = 7843, e2.aibengali = 2448, e2.aibopomofo = 12574, e2.aideva = 2320, e2.aiecyrillic = 1237, e2.aigujarati = 2704, e2.aigurmukhi = 2576, e2.aimatragurmukhi = 2632, e2.ainarabic = 1593, e2.ainfinalarabic = 65226, e2.aininitialarabic = 65227, e2.ainmedialarabic = 65228, e2.ainvertedbreve = 515, e2.aivowelsignbengali = 2504, e2.aivowelsigndeva = 2376, e2.aivowelsigngujarati = 2760, e2.akatakana = 12450, e2.akatakanahalfwidth = 65393, e2.akorean = 12623, e2.alef = 1488, e2.alefarabic = 1575, e2.alefdageshhebrew = 64304, e2.aleffinalarabic = 65166, e2.alefhamzaabovearabic = 1571, e2.alefhamzaabovefinalarabic = 65156, e2.alefhamzabelowarabic = 1573, e2.alefhamzabelowfinalarabic = 65160, e2.alefhebrew = 1488, e2.aleflamedhebrew = 64335, e2.alefmaddaabovearabic = 1570, e2.alefmaddaabovefinalarabic = 65154, e2.alefmaksuraarabic = 1609, e2.alefmaksurafinalarabic = 65264, e2.alefmaksurainitialarabic = 65267, e2.alefmaksuramedialarabic = 65268, e2.alefpatahhebrew = 64302, e2.alefqamatshebrew = 64303, e2.aleph = 8501, e2.allequal = 8780, e2.alpha = 945, e2.alphatonos = 940, e2.amacron = 257, e2.amonospace = 65345, e2.ampersand = 38, e2.ampersandmonospace = 65286, e2.ampersandsmall = 63270, e2.amsquare = 13250, e2.anbopomofo = 12578, e2.angbopomofo = 12580, e2.angbracketleft = 12296, e2.angbracketright = 12297, e2.angkhankhuthai = 3674, e2.angle = 8736, e2.anglebracketleft = 12296, e2.anglebracketleftvertical = 65087, e2.anglebracketright = 12297, e2.anglebracketrightvertical = 65088, e2.angleleft = 9001, e2.angleright = 9002, e2.angstrom = 8491, e2.anoteleia = 903, e2.anudattadeva = 2386, e2.anusvarabengali = 2434, e2.anusvaradeva = 2306, e2.anusvaragujarati = 2690, e2.aogonek = 261, e2.apaatosquare = 13056, e2.aparen = 9372, e2.apostrophearmenian = 1370, e2.apostrophemod = 700, e2.apple = 63743, e2.approaches = 8784, e2.approxequal = 8776, e2.approxequalorimage = 8786, e2.approximatelyequal = 8773, e2.araeaekorean = 12686, e2.araeakorean = 12685, e2.arc = 8978, e2.arighthalfring = 7834, e2.aring = 229, e2.aringacute = 507, e2.aringbelow = 7681, e2.arrowboth = 8596, e2.arrowdashdown = 8675, e2.arrowdashleft = 8672, e2.arrowdashright = 8674, e2.arrowdashup = 8673, e2.arrowdblboth = 8660, e2.arrowdbldown = 8659, e2.arrowdblleft = 8656, e2.arrowdblright = 8658, e2.arrowdblup = 8657, e2.arrowdown = 8595, e2.arrowdownleft = 8601, e2.arrowdownright = 8600, e2.arrowdownwhite = 8681, e2.arrowheaddownmod = 709, e2.arrowheadleftmod = 706, e2.arrowheadrightmod = 707, e2.arrowheadupmod = 708, e2.arrowhorizex = 63719, e2.arrowleft = 8592, e2.arrowleftdbl = 8656, e2.arrowleftdblstroke = 8653, e2.arrowleftoverright = 8646, e2.arrowleftwhite = 8678, e2.arrowright = 8594, e2.arrowrightdblstroke = 8655, e2.arrowrightheavy = 10142, e2.arrowrightoverleft = 8644, e2.arrowrightwhite = 8680, e2.arrowtableft = 8676, e2.arrowtabright = 8677, e2.arrowup = 8593, e2.arrowupdn = 8597, e2.arrowupdnbse = 8616, e2.arrowupdownbase = 8616, e2.arrowupleft = 8598, e2.arrowupleftofdown = 8645, e2.arrowupright = 8599, e2.arrowupwhite = 8679, e2.arrowvertex = 63718, e2.asciicircum = 94, e2.asciicircummonospace = 65342, e2.asciitilde = 126, e2.asciitildemonospace = 65374, e2.ascript = 593, e2.ascriptturned = 594, e2.asmallhiragana = 12353, e2.asmallkatakana = 12449, e2.asmallkatakanahalfwidth = 65383, e2.asterisk = 42, e2.asteriskaltonearabic = 1645, e2.asteriskarabic = 1645, e2.asteriskmath = 8727, e2.asteriskmonospace = 65290, e2.asterisksmall = 65121, e2.asterism = 8258, e2.asuperior = 63209, e2.asymptoticallyequal = 8771, e2.at = 64, e2.atilde = 227, e2.atmonospace = 65312, e2.atsmall = 65131, e2.aturned = 592, e2.aubengali = 2452, e2.aubopomofo = 12576, e2.audeva = 2324, e2.augujarati = 2708, e2.augurmukhi = 2580, e2.aulengthmarkbengali = 2519, e2.aumatragurmukhi = 2636, e2.auvowelsignbengali = 2508, e2.auvowelsigndeva = 2380, e2.auvowelsigngujarati = 2764, e2.avagrahadeva = 2365, e2.aybarmenian = 1377, e2.ayin = 1506, e2.ayinaltonehebrew = 64288, e2.ayinhebrew = 1506, e2.b = 98, e2.babengali = 2476, e2.backslash = 92, e2.backslashmonospace = 65340, e2.badeva = 2348, e2.bagujarati = 2732, e2.bagurmukhi = 2604, e2.bahiragana = 12400, e2.bahtthai = 3647, e2.bakatakana = 12496, e2.bar = 124, e2.barmonospace = 65372, e2.bbopomofo = 12549, e2.bcircle = 9425, e2.bdotaccent = 7683, e2.bdotbelow = 7685, e2.beamedsixteenthnotes = 9836, e2.because = 8757, e2.becyrillic = 1073, e2.beharabic = 1576, e2.behfinalarabic = 65168, e2.behinitialarabic = 65169, e2.behiragana = 12409, e2.behmedialarabic = 65170, e2.behmeeminitialarabic = 64671, e2.behmeemisolatedarabic = 64520, e2.behnoonfinalarabic = 64621, e2.bekatakana = 12505, e2.benarmenian = 1378, e2.bet = 1489, e2.beta = 946, e2.betasymbolgreek = 976, e2.betdagesh = 64305, e2.betdageshhebrew = 64305, e2.bethebrew = 1489, e2.betrafehebrew = 64332, e2.bhabengali = 2477, e2.bhadeva = 2349, e2.bhagujarati = 2733, e2.bhagurmukhi = 2605, e2.bhook = 595, e2.bihiragana = 12403, e2.bikatakana = 12499, e2.bilabialclick = 664, e2.bindigurmukhi = 2562, e2.birusquare = 13105, e2.blackcircle = 9679, e2.blackdiamond = 9670, e2.blackdownpointingtriangle = 9660, e2.blackleftpointingpointer = 9668, e2.blackleftpointingtriangle = 9664, e2.blacklenticularbracketleft = 12304, e2.blacklenticularbracketleftvertical = 65083, e2.blacklenticularbracketright = 12305, e2.blacklenticularbracketrightvertical = 65084, e2.blacklowerlefttriangle = 9699, e2.blacklowerrighttriangle = 9698, e2.blackrectangle = 9644, e2.blackrightpointingpointer = 9658, e2.blackrightpointingtriangle = 9654, e2.blacksmallsquare = 9642, e2.blacksmilingface = 9787, e2.blacksquare = 9632, e2.blackstar = 9733, e2.blackupperlefttriangle = 9700, e2.blackupperrighttriangle = 9701, e2.blackuppointingsmalltriangle = 9652, e2.blackuppointingtriangle = 9650, e2.blank = 9251, e2.blinebelow = 7687, e2.block = 9608, e2.bmonospace = 65346, e2.bobaimaithai = 3610, e2.bohiragana = 12412, e2.bokatakana = 12508, e2.bparen = 9373, e2.bqsquare = 13251, e2.braceex = 63732, e2.braceleft = 123, e2.braceleftbt = 63731, e2.braceleftmid = 63730, e2.braceleftmonospace = 65371, e2.braceleftsmall = 65115, e2.bracelefttp = 63729, e2.braceleftvertical = 65079, e2.braceright = 125, e2.bracerightbt = 63742, e2.bracerightmid = 63741, e2.bracerightmonospace = 65373, e2.bracerightsmall = 65116, e2.bracerighttp = 63740, e2.bracerightvertical = 65080, e2.bracketleft = 91, e2.bracketleftbt = 63728, e2.bracketleftex = 63727, e2.bracketleftmonospace = 65339, e2.bracketlefttp = 63726, e2.bracketright = 93, e2.bracketrightbt = 63739, e2.bracketrightex = 63738, e2.bracketrightmonospace = 65341, e2.bracketrighttp = 63737, e2.breve = 728, e2.brevebelowcmb = 814, e2.brevecmb = 774, e2.breveinvertedbelowcmb = 815, e2.breveinvertedcmb = 785, e2.breveinverteddoublecmb = 865, e2.bridgebelowcmb = 810, e2.bridgeinvertedbelowcmb = 826, e2.brokenbar = 166, e2.bstroke = 384, e2.bsuperior = 63210, e2.btopbar = 387, e2.buhiragana = 12406, e2.bukatakana = 12502, e2.bullet = 8226, e2.bulletinverse = 9688, e2.bulletoperator = 8729, e2.bullseye = 9678, e2.c = 99, e2.caarmenian = 1390, e2.cabengali = 2458, e2.cacute = 263, e2.cadeva = 2330, e2.cagujarati = 2714, e2.cagurmukhi = 2586, e2.calsquare = 13192, e2.candrabindubengali = 2433, e2.candrabinducmb = 784, e2.candrabindudeva = 2305, e2.candrabindugujarati = 2689, e2.capslock = 8682, e2.careof = 8453, e2.caron = 711, e2.caronbelowcmb = 812, e2.caroncmb = 780, e2.carriagereturn = 8629, e2.cbopomofo = 12568, e2.ccaron = 269, e2.ccedilla = 231, e2.ccedillaacute = 7689, e2.ccircle = 9426, e2.ccircumflex = 265, e2.ccurl = 597, e2.cdot = 267, e2.cdotaccent = 267, e2.cdsquare = 13253, e2.cedilla = 184, e2.cedillacmb = 807, e2.cent = 162, e2.centigrade = 8451, e2.centinferior = 63199, e2.centmonospace = 65504, e2.centoldstyle = 63394, e2.centsuperior = 63200, e2.chaarmenian = 1401, e2.chabengali = 2459, e2.chadeva = 2331, e2.chagujarati = 2715, e2.chagurmukhi = 2587, e2.chbopomofo = 12564, e2.cheabkhasiancyrillic = 1213, e2.checkmark = 10003, e2.checyrillic = 1095, e2.chedescenderabkhasiancyrillic = 1215, e2.chedescendercyrillic = 1207, e2.chedieresiscyrillic = 1269, e2.cheharmenian = 1395, e2.chekhakassiancyrillic = 1228, e2.cheverticalstrokecyrillic = 1209, e2.chi = 967, e2.chieuchacirclekorean = 12919, e2.chieuchaparenkorean = 12823, e2.chieuchcirclekorean = 12905, e2.chieuchkorean = 12618, e2.chieuchparenkorean = 12809, e2.chochangthai = 3594, e2.chochanthai = 3592, e2.chochingthai = 3593, e2.chochoethai = 3596, e2.chook = 392, e2.cieucacirclekorean = 12918, e2.cieucaparenkorean = 12822, e2.cieuccirclekorean = 12904, e2.cieuckorean = 12616, e2.cieucparenkorean = 12808, e2.cieucuparenkorean = 12828, e2.circle = 9675, e2.circlecopyrt = 169, e2.circlemultiply = 8855, e2.circleot = 8857, e2.circleplus = 8853, e2.circlepostalmark = 12342, e2.circlewithlefthalfblack = 9680, e2.circlewithrighthalfblack = 9681, e2.circumflex = 710, e2.circumflexbelowcmb = 813, e2.circumflexcmb = 770, e2.clear = 8999, e2.clickalveolar = 450, e2.clickdental = 448, e2.clicklateral = 449, e2.clickretroflex = 451, e2.club = 9827, e2.clubsuitblack = 9827, e2.clubsuitwhite = 9831, e2.cmcubedsquare = 13220, e2.cmonospace = 65347, e2.cmsquaredsquare = 13216, e2.coarmenian = 1409, e2.colon = 58, e2.colonmonetary = 8353, e2.colonmonospace = 65306, e2.colonsign = 8353, e2.colonsmall = 65109, e2.colontriangularhalfmod = 721, e2.colontriangularmod = 720, e2.comma = 44, e2.commaabovecmb = 787, e2.commaaboverightcmb = 789, e2.commaaccent = 63171, e2.commaarabic = 1548, e2.commaarmenian = 1373, e2.commainferior = 63201, e2.commamonospace = 65292, e2.commareversedabovecmb = 788, e2.commareversedmod = 701, e2.commasmall = 65104, e2.commasuperior = 63202, e2.commaturnedabovecmb = 786, e2.commaturnedmod = 699, e2.compass = 9788, e2.congruent = 8773, e2.contourintegral = 8750, e2.control = 8963, e2.controlACK = 6, e2.controlBEL = 7, e2.controlBS = 8, e2.controlCAN = 24, e2.controlCR = 13, e2.controlDC1 = 17, e2.controlDC2 = 18, e2.controlDC3 = 19, e2.controlDC4 = 20, e2.controlDEL = 127, e2.controlDLE = 16, e2.controlEM = 25, e2.controlENQ = 5, e2.controlEOT = 4, e2.controlESC = 27, e2.controlETB = 23, e2.controlETX = 3, e2.controlFF = 12, e2.controlFS = 28, e2.controlGS = 29, e2.controlHT = 9, e2.controlLF = 10, e2.controlNAK = 21, e2.controlNULL = 0, e2.controlRS = 30, e2.controlSI = 15, e2.controlSO = 14, e2.controlSOT = 2, e2.controlSTX = 1, e2.controlSUB = 26, e2.controlSYN = 22, e2.controlUS = 31, e2.controlVT = 11, e2.copyright = 169, e2.copyrightsans = 63721, e2.copyrightserif = 63193, e2.cornerbracketleft = 12300, e2.cornerbracketlefthalfwidth = 65378, e2.cornerbracketleftvertical = 65089, e2.cornerbracketright = 12301, e2.cornerbracketrighthalfwidth = 65379, e2.cornerbracketrightvertical = 65090, e2.corporationsquare = 13183, e2.cosquare = 13255, e2.coverkgsquare = 13254, e2.cparen = 9374, e2.cruzeiro = 8354, e2.cstretched = 663, e2.curlyand = 8911, e2.curlyor = 8910, e2.currency = 164, e2.cyrBreve = 63185, e2.cyrFlex = 63186, e2.cyrbreve = 63188, e2.cyrflex = 63189, e2.d = 100, e2.daarmenian = 1380, e2.dabengali = 2470, e2.dadarabic = 1590, e2.dadeva = 2342, e2.dadfinalarabic = 65214, e2.dadinitialarabic = 65215, e2.dadmedialarabic = 65216, e2.dagesh = 1468, e2.dageshhebrew = 1468, e2.dagger = 8224, e2.daggerdbl = 8225, e2.dagujarati = 2726, e2.dagurmukhi = 2598, e2.dahiragana = 12384, e2.dakatakana = 12480, e2.dalarabic = 1583, e2.dalet = 1491, e2.daletdagesh = 64307, e2.daletdageshhebrew = 64307, e2.dalethebrew = 1491, e2.dalfinalarabic = 65194, e2.dammaarabic = 1615, e2.dammalowarabic = 1615, e2.dammatanaltonearabic = 1612, e2.dammatanarabic = 1612, e2.danda = 2404, e2.dargahebrew = 1447, e2.dargalefthebrew = 1447, e2.dasiapneumatacyrilliccmb = 1157, e2.dblGrave = 63187, e2.dblanglebracketleft = 12298, e2.dblanglebracketleftvertical = 65085, e2.dblanglebracketright = 12299, e2.dblanglebracketrightvertical = 65086, e2.dblarchinvertedbelowcmb = 811, e2.dblarrowleft = 8660, e2.dblarrowright = 8658, e2.dbldanda = 2405, e2.dblgrave = 63190, e2.dblgravecmb = 783, e2.dblintegral = 8748, e2.dbllowline = 8215, e2.dbllowlinecmb = 819, e2.dbloverlinecmb = 831, e2.dblprimemod = 698, e2.dblverticalbar = 8214, e2.dblverticallineabovecmb = 782, e2.dbopomofo = 12553, e2.dbsquare = 13256, e2.dcaron = 271, e2.dcedilla = 7697, e2.dcircle = 9427, e2.dcircumflexbelow = 7699, e2.dcroat = 273, e2.ddabengali = 2465, e2.ddadeva = 2337, e2.ddagujarati = 2721, e2.ddagurmukhi = 2593, e2.ddalarabic = 1672, e2.ddalfinalarabic = 64393, e2.dddhadeva = 2396, e2.ddhabengali = 2466, e2.ddhadeva = 2338, e2.ddhagujarati = 2722, e2.ddhagurmukhi = 2594, e2.ddotaccent = 7691, e2.ddotbelow = 7693, e2.decimalseparatorarabic = 1643, e2.decimalseparatorpersian = 1643, e2.decyrillic = 1076, e2.degree = 176, e2.dehihebrew = 1453, e2.dehiragana = 12391, e2.deicoptic = 1007, e2.dekatakana = 12487, e2.deleteleft = 9003, e2.deleteright = 8998, e2.delta = 948, e2.deltaturned = 397, e2.denominatorminusonenumeratorbengali = 2552, e2.dezh = 676, e2.dhabengali = 2471, e2.dhadeva = 2343, e2.dhagujarati = 2727, e2.dhagurmukhi = 2599, e2.dhook = 599, e2.dialytikatonos = 901, e2.dialytikatonoscmb = 836, e2.diamond = 9830, e2.diamondsuitwhite = 9826, e2.dieresis = 168, e2.dieresisacute = 63191, e2.dieresisbelowcmb = 804, e2.dieresiscmb = 776, e2.dieresisgrave = 63192, e2.dieresistonos = 901, e2.dihiragana = 12386, e2.dikatakana = 12482, e2.dittomark = 12291, e2.divide = 247, e2.divides = 8739, e2.divisionslash = 8725, e2.djecyrillic = 1106, e2.dkshade = 9619, e2.dlinebelow = 7695, e2.dlsquare = 13207, e2.dmacron = 273, e2.dmonospace = 65348, e2.dnblock = 9604, e2.dochadathai = 3598, e2.dodekthai = 3604, e2.dohiragana = 12393, e2.dokatakana = 12489, e2.dollar = 36;
  e2.dollarinferior = 63203, e2.dollarmonospace = 65284, e2.dollaroldstyle = 63268, e2.dollarsmall = 65129, e2.dollarsuperior = 63204, e2.dong = 8363, e2.dorusquare = 13094, e2.dotaccent = 729, e2.dotaccentcmb = 775, e2.dotbelowcmb = 803, e2.dotbelowcomb = 803, e2.dotkatakana = 12539, e2.dotlessi = 305, e2.dotlessj = 63166, e2.dotlessjstrokehook = 644, e2.dotmath = 8901, e2.dottedcircle = 9676, e2.doubleyodpatah = 64287, e2.doubleyodpatahhebrew = 64287, e2.downtackbelowcmb = 798, e2.downtackmod = 725, e2.dparen = 9375, e2.dsuperior = 63211, e2.dtail = 598, e2.dtopbar = 396, e2.duhiragana = 12389, e2.dukatakana = 12485, e2.dz = 499, e2.dzaltone = 675, e2.dzcaron = 454, e2.dzcurl = 677, e2.dzeabkhasiancyrillic = 1249, e2.dzecyrillic = 1109, e2.dzhecyrillic = 1119, e2.e = 101, e2.eacute = 233, e2.earth = 9793, e2.ebengali = 2447, e2.ebopomofo = 12572, e2.ebreve = 277, e2.ecandradeva = 2317, e2.ecandragujarati = 2701, e2.ecandravowelsigndeva = 2373, e2.ecandravowelsigngujarati = 2757, e2.ecaron = 283, e2.ecedillabreve = 7709, e2.echarmenian = 1381, e2.echyiwnarmenian = 1415, e2.ecircle = 9428, e2.ecircumflex = 234, e2.ecircumflexacute = 7871, e2.ecircumflexbelow = 7705, e2.ecircumflexdotbelow = 7879, e2.ecircumflexgrave = 7873, e2.ecircumflexhookabove = 7875, e2.ecircumflextilde = 7877, e2.ecyrillic = 1108, e2.edblgrave = 517, e2.edeva = 2319, e2.edieresis = 235, e2.edot = 279, e2.edotaccent = 279, e2.edotbelow = 7865, e2.eegurmukhi = 2575, e2.eematragurmukhi = 2631, e2.efcyrillic = 1092, e2.egrave = 232, e2.egujarati = 2703, e2.eharmenian = 1383, e2.ehbopomofo = 12573, e2.ehiragana = 12360, e2.ehookabove = 7867, e2.eibopomofo = 12575, e2.eight = 56, e2.eightarabic = 1640, e2.eightbengali = 2542, e2.eightcircle = 9319, e2.eightcircleinversesansserif = 10129, e2.eightdeva = 2414, e2.eighteencircle = 9329, e2.eighteenparen = 9349, e2.eighteenperiod = 9369, e2.eightgujarati = 2798, e2.eightgurmukhi = 2670, e2.eighthackarabic = 1640, e2.eighthangzhou = 12328, e2.eighthnotebeamed = 9835, e2.eightideographicparen = 12839, e2.eightinferior = 8328, e2.eightmonospace = 65304, e2.eightoldstyle = 63288, e2.eightparen = 9339, e2.eightperiod = 9359, e2.eightpersian = 1784, e2.eightroman = 8567, e2.eightsuperior = 8312, e2.eightthai = 3672, e2.einvertedbreve = 519, e2.eiotifiedcyrillic = 1125, e2.ekatakana = 12456, e2.ekatakanahalfwidth = 65396, e2.ekonkargurmukhi = 2676, e2.ekorean = 12628, e2.elcyrillic = 1083, e2.element = 8712, e2.elevencircle = 9322, e2.elevenparen = 9342, e2.elevenperiod = 9362, e2.elevenroman = 8570, e2.ellipsis = 8230, e2.ellipsisvertical = 8942, e2.emacron = 275, e2.emacronacute = 7703, e2.emacrongrave = 7701, e2.emcyrillic = 1084, e2.emdash = 8212, e2.emdashvertical = 65073, e2.emonospace = 65349, e2.emphasismarkarmenian = 1371, e2.emptyset = 8709, e2.enbopomofo = 12579, e2.encyrillic = 1085, e2.endash = 8211, e2.endashvertical = 65074, e2.endescendercyrillic = 1187, e2.eng = 331, e2.engbopomofo = 12581, e2.enghecyrillic = 1189, e2.enhookcyrillic = 1224, e2.enspace = 8194, e2.eogonek = 281, e2.eokorean = 12627, e2.eopen = 603, e2.eopenclosed = 666, e2.eopenreversed = 604, e2.eopenreversedclosed = 606, e2.eopenreversedhook = 605, e2.eparen = 9376, e2.epsilon = 949, e2.epsilontonos = 941, e2.equal = 61, e2.equalmonospace = 65309, e2.equalsmall = 65126, e2.equalsuperior = 8316, e2.equivalence = 8801, e2.erbopomofo = 12582, e2.ercyrillic = 1088, e2.ereversed = 600, e2.ereversedcyrillic = 1101, e2.escyrillic = 1089, e2.esdescendercyrillic = 1195, e2.esh = 643, e2.eshcurl = 646, e2.eshortdeva = 2318, e2.eshortvowelsigndeva = 2374, e2.eshreversedloop = 426, e2.eshsquatreversed = 645, e2.esmallhiragana = 12359, e2.esmallkatakana = 12455, e2.esmallkatakanahalfwidth = 65386, e2.estimated = 8494, e2.esuperior = 63212, e2.eta = 951, e2.etarmenian = 1384, e2.etatonos = 942, e2.eth = 240, e2.etilde = 7869, e2.etildebelow = 7707, e2.etnahtafoukhhebrew = 1425, e2.etnahtafoukhlefthebrew = 1425, e2.etnahtahebrew = 1425, e2.etnahtalefthebrew = 1425, e2.eturned = 477, e2.eukorean = 12641, e2.euro = 8364, e2.evowelsignbengali = 2503, e2.evowelsigndeva = 2375, e2.evowelsigngujarati = 2759, e2.exclam = 33, e2.exclamarmenian = 1372, e2.exclamdbl = 8252, e2.exclamdown = 161, e2.exclamdownsmall = 63393, e2.exclammonospace = 65281, e2.exclamsmall = 63265, e2.existential = 8707, e2.ezh = 658, e2.ezhcaron = 495, e2.ezhcurl = 659, e2.ezhreversed = 441, e2.ezhtail = 442, e2.f = 102, e2.fadeva = 2398, e2.fagurmukhi = 2654, e2.fahrenheit = 8457, e2.fathaarabic = 1614, e2.fathalowarabic = 1614, e2.fathatanarabic = 1611, e2.fbopomofo = 12552, e2.fcircle = 9429, e2.fdotaccent = 7711, e2.feharabic = 1601, e2.feharmenian = 1414, e2.fehfinalarabic = 65234, e2.fehinitialarabic = 65235, e2.fehmedialarabic = 65236, e2.feicoptic = 997, e2.female = 9792, e2.ff = 64256, e2.f_f = 64256, e2.ffi = 64259, e2.f_f_i = 64259, e2.ffl = 64260, e2.f_f_l = 64260, e2.fi = 64257, e2.f_i = 64257, e2.fifteencircle = 9326, e2.fifteenparen = 9346, e2.fifteenperiod = 9366, e2.figuredash = 8210, e2.filledbox = 9632, e2.filledrect = 9644, e2.finalkaf = 1498, e2.finalkafdagesh = 64314, e2.finalkafdageshhebrew = 64314, e2.finalkafhebrew = 1498, e2.finalmem = 1501, e2.finalmemhebrew = 1501, e2.finalnun = 1503, e2.finalnunhebrew = 1503, e2.finalpe = 1507, e2.finalpehebrew = 1507, e2.finaltsadi = 1509, e2.finaltsadihebrew = 1509, e2.firsttonechinese = 713, e2.fisheye = 9673, e2.fitacyrillic = 1139, e2.five = 53, e2.fivearabic = 1637, e2.fivebengali = 2539, e2.fivecircle = 9316, e2.fivecircleinversesansserif = 10126, e2.fivedeva = 2411, e2.fiveeighths = 8541, e2.fivegujarati = 2795, e2.fivegurmukhi = 2667, e2.fivehackarabic = 1637, e2.fivehangzhou = 12325, e2.fiveideographicparen = 12836, e2.fiveinferior = 8325, e2.fivemonospace = 65301, e2.fiveoldstyle = 63285, e2.fiveparen = 9336, e2.fiveperiod = 9356, e2.fivepersian = 1781, e2.fiveroman = 8564, e2.fivesuperior = 8309, e2.fivethai = 3669, e2.fl = 64258, e2.f_l = 64258, e2.florin = 402, e2.fmonospace = 65350, e2.fmsquare = 13209, e2.fofanthai = 3615, e2.fofathai = 3613, e2.fongmanthai = 3663, e2.forall = 8704, e2.four = 52, e2.fourarabic = 1636, e2.fourbengali = 2538, e2.fourcircle = 9315, e2.fourcircleinversesansserif = 10125, e2.fourdeva = 2410, e2.fourgujarati = 2794, e2.fourgurmukhi = 2666, e2.fourhackarabic = 1636, e2.fourhangzhou = 12324, e2.fourideographicparen = 12835, e2.fourinferior = 8324, e2.fourmonospace = 65300, e2.fournumeratorbengali = 2551, e2.fouroldstyle = 63284, e2.fourparen = 9335, e2.fourperiod = 9355, e2.fourpersian = 1780, e2.fourroman = 8563, e2.foursuperior = 8308, e2.fourteencircle = 9325, e2.fourteenparen = 9345, e2.fourteenperiod = 9365, e2.fourthai = 3668, e2.fourthtonechinese = 715, e2.fparen = 9377, e2.fraction = 8260, e2.franc = 8355, e2.g = 103, e2.gabengali = 2455, e2.gacute = 501, e2.gadeva = 2327, e2.gafarabic = 1711, e2.gaffinalarabic = 64403, e2.gafinitialarabic = 64404, e2.gafmedialarabic = 64405, e2.gagujarati = 2711, e2.gagurmukhi = 2583, e2.gahiragana = 12364, e2.gakatakana = 12460, e2.gamma = 947, e2.gammalatinsmall = 611, e2.gammasuperior = 736, e2.gangiacoptic = 1003, e2.gbopomofo = 12557, e2.gbreve = 287, e2.gcaron = 487, e2.gcedilla = 291, e2.gcircle = 9430, e2.gcircumflex = 285, e2.gcommaaccent = 291, e2.gdot = 289, e2.gdotaccent = 289, e2.gecyrillic = 1075, e2.gehiragana = 12370, e2.gekatakana = 12466, e2.geometricallyequal = 8785, e2.gereshaccenthebrew = 1436, e2.gereshhebrew = 1523, e2.gereshmuqdamhebrew = 1437, e2.germandbls = 223, e2.gershayimaccenthebrew = 1438, e2.gershayimhebrew = 1524, e2.getamark = 12307, e2.ghabengali = 2456, e2.ghadarmenian = 1394, e2.ghadeva = 2328, e2.ghagujarati = 2712, e2.ghagurmukhi = 2584, e2.ghainarabic = 1594, e2.ghainfinalarabic = 65230, e2.ghaininitialarabic = 65231, e2.ghainmedialarabic = 65232, e2.ghemiddlehookcyrillic = 1173, e2.ghestrokecyrillic = 1171, e2.gheupturncyrillic = 1169, e2.ghhadeva = 2394, e2.ghhagurmukhi = 2650, e2.ghook = 608, e2.ghzsquare = 13203, e2.gihiragana = 12366, e2.gikatakana = 12462, e2.gimarmenian = 1379, e2.gimel = 1490, e2.gimeldagesh = 64306, e2.gimeldageshhebrew = 64306, e2.gimelhebrew = 1490, e2.gjecyrillic = 1107, e2.glottalinvertedstroke = 446, e2.glottalstop = 660, e2.glottalstopinverted = 662, e2.glottalstopmod = 704, e2.glottalstopreversed = 661, e2.glottalstopreversedmod = 705, e2.glottalstopreversedsuperior = 740, e2.glottalstopstroke = 673, e2.glottalstopstrokereversed = 674, e2.gmacron = 7713, e2.gmonospace = 65351, e2.gohiragana = 12372, e2.gokatakana = 12468, e2.gparen = 9378, e2.gpasquare = 13228, e2.gradient = 8711, e2.grave = 96, e2.gravebelowcmb = 790, e2.gravecmb = 768, e2.gravecomb = 768, e2.gravedeva = 2387, e2.gravelowmod = 718, e2.gravemonospace = 65344, e2.gravetonecmb = 832, e2.greater = 62, e2.greaterequal = 8805, e2.greaterequalorless = 8923, e2.greatermonospace = 65310, e2.greaterorequivalent = 8819, e2.greaterorless = 8823, e2.greateroverequal = 8807, e2.greatersmall = 65125, e2.gscript = 609, e2.gstroke = 485, e2.guhiragana = 12368, e2.guillemotleft = 171, e2.guillemotright = 187, e2.guilsinglleft = 8249, e2.guilsinglright = 8250, e2.gukatakana = 12464, e2.guramusquare = 13080, e2.gysquare = 13257, e2.h = 104, e2.haabkhasiancyrillic = 1193, e2.haaltonearabic = 1729, e2.habengali = 2489, e2.hadescendercyrillic = 1203, e2.hadeva = 2361, e2.hagujarati = 2745, e2.hagurmukhi = 2617, e2.haharabic = 1581, e2.hahfinalarabic = 65186, e2.hahinitialarabic = 65187, e2.hahiragana = 12399, e2.hahmedialarabic = 65188, e2.haitusquare = 13098, e2.hakatakana = 12495, e2.hakatakanahalfwidth = 65418, e2.halantgurmukhi = 2637, e2.hamzaarabic = 1569, e2.hamzalowarabic = 1569, e2.hangulfiller = 12644, e2.hardsigncyrillic = 1098, e2.harpoonleftbarbup = 8636, e2.harpoonrightbarbup = 8640, e2.hasquare = 13258, e2.hatafpatah = 1458, e2.hatafpatah16 = 1458, e2.hatafpatah23 = 1458, e2.hatafpatah2f = 1458, e2.hatafpatahhebrew = 1458, e2.hatafpatahnarrowhebrew = 1458, e2.hatafpatahquarterhebrew = 1458, e2.hatafpatahwidehebrew = 1458, e2.hatafqamats = 1459, e2.hatafqamats1b = 1459, e2.hatafqamats28 = 1459, e2.hatafqamats34 = 1459, e2.hatafqamatshebrew = 1459, e2.hatafqamatsnarrowhebrew = 1459, e2.hatafqamatsquarterhebrew = 1459, e2.hatafqamatswidehebrew = 1459, e2.hatafsegol = 1457, e2.hatafsegol17 = 1457, e2.hatafsegol24 = 1457, e2.hatafsegol30 = 1457, e2.hatafsegolhebrew = 1457, e2.hatafsegolnarrowhebrew = 1457, e2.hatafsegolquarterhebrew = 1457, e2.hatafsegolwidehebrew = 1457, e2.hbar = 295, e2.hbopomofo = 12559, e2.hbrevebelow = 7723, e2.hcedilla = 7721, e2.hcircle = 9431, e2.hcircumflex = 293, e2.hdieresis = 7719, e2.hdotaccent = 7715, e2.hdotbelow = 7717, e2.he = 1492, e2.heart = 9829, e2.heartsuitblack = 9829, e2.heartsuitwhite = 9825, e2.hedagesh = 64308, e2.hedageshhebrew = 64308, e2.hehaltonearabic = 1729, e2.heharabic = 1607, e2.hehebrew = 1492, e2.hehfinalaltonearabic = 64423, e2.hehfinalalttwoarabic = 65258, e2.hehfinalarabic = 65258, e2.hehhamzaabovefinalarabic = 64421, e2.hehhamzaaboveisolatedarabic = 64420, e2.hehinitialaltonearabic = 64424, e2.hehinitialarabic = 65259, e2.hehiragana = 12408, e2.hehmedialaltonearabic = 64425, e2.hehmedialarabic = 65260, e2.heiseierasquare = 13179, e2.hekatakana = 12504, e2.hekatakanahalfwidth = 65421, e2.hekutaarusquare = 13110, e2.henghook = 615, e2.herutusquare = 13113, e2.het = 1495, e2.hethebrew = 1495, e2.hhook = 614, e2.hhooksuperior = 689, e2.hieuhacirclekorean = 12923, e2.hieuhaparenkorean = 12827, e2.hieuhcirclekorean = 12909, e2.hieuhkorean = 12622, e2.hieuhparenkorean = 12813, e2.hihiragana = 12402, e2.hikatakana = 12498, e2.hikatakanahalfwidth = 65419, e2.hiriq = 1460, e2.hiriq14 = 1460, e2.hiriq21 = 1460, e2.hiriq2d = 1460, e2.hiriqhebrew = 1460, e2.hiriqnarrowhebrew = 1460, e2.hiriqquarterhebrew = 1460, e2.hiriqwidehebrew = 1460, e2.hlinebelow = 7830, e2.hmonospace = 65352, e2.hoarmenian = 1392, e2.hohipthai = 3627, e2.hohiragana = 12411, e2.hokatakana = 12507, e2.hokatakanahalfwidth = 65422, e2.holam = 1465, e2.holam19 = 1465, e2.holam26 = 1465, e2.holam32 = 1465, e2.holamhebrew = 1465, e2.holamnarrowhebrew = 1465, e2.holamquarterhebrew = 1465, e2.holamwidehebrew = 1465, e2.honokhukthai = 3630, e2.hookabovecomb = 777, e2.hookcmb = 777, e2.hookpalatalizedbelowcmb = 801, e2.hookretroflexbelowcmb = 802, e2.hoonsquare = 13122, e2.horicoptic = 1001, e2.horizontalbar = 8213, e2.horncmb = 795, e2.hotsprings = 9832, e2.house = 8962, e2.hparen = 9379, e2.hsuperior = 688, e2.hturned = 613, e2.huhiragana = 12405, e2.huiitosquare = 13107, e2.hukatakana = 12501, e2.hukatakanahalfwidth = 65420, e2.hungarumlaut = 733, e2.hungarumlautcmb = 779, e2.hv = 405, e2.hyphen = 45, e2.hypheninferior = 63205, e2.hyphenmonospace = 65293, e2.hyphensmall = 65123, e2.hyphensuperior = 63206, e2.hyphentwo = 8208, e2.i = 105, e2.iacute = 237, e2.iacyrillic = 1103, e2.ibengali = 2439, e2.ibopomofo = 12583, e2.ibreve = 301, e2.icaron = 464, e2.icircle = 9432, e2.icircumflex = 238, e2.icyrillic = 1110, e2.idblgrave = 521, e2.ideographearthcircle = 12943, e2.ideographfirecircle = 12939, e2.ideographicallianceparen = 12863, e2.ideographiccallparen = 12858, e2.ideographiccentrecircle = 12965, e2.ideographicclose = 12294, e2.ideographiccomma = 12289, e2.ideographiccommaleft = 65380, e2.ideographiccongratulationparen = 12855, e2.ideographiccorrectcircle = 12963, e2.ideographicearthparen = 12847, e2.ideographicenterpriseparen = 12861, e2.ideographicexcellentcircle = 12957, e2.ideographicfestivalparen = 12864, e2.ideographicfinancialcircle = 12950, e2.ideographicfinancialparen = 12854, e2.ideographicfireparen = 12843, e2.ideographichaveparen = 12850, e2.ideographichighcircle = 12964, e2.ideographiciterationmark = 12293, e2.ideographiclaborcircle = 12952, e2.ideographiclaborparen = 12856, e2.ideographicleftcircle = 12967, e2.ideographiclowcircle = 12966, e2.ideographicmedicinecircle = 12969, e2.ideographicmetalparen = 12846, e2.ideographicmoonparen = 12842, e2.ideographicnameparen = 12852, e2.ideographicperiod = 12290, e2.ideographicprintcircle = 12958, e2.ideographicreachparen = 12867, e2.ideographicrepresentparen = 12857, e2.ideographicresourceparen = 12862, e2.ideographicrightcircle = 12968, e2.ideographicsecretcircle = 12953, e2.ideographicselfparen = 12866, e2.ideographicsocietyparen = 12851, e2.ideographicspace = 12288, e2.ideographicspecialparen = 12853, e2.ideographicstockparen = 12849, e2.ideographicstudyparen = 12859, e2.ideographicsunparen = 12848, e2.ideographicsuperviseparen = 12860, e2.ideographicwaterparen = 12844, e2.ideographicwoodparen = 12845, e2.ideographiczero = 12295, e2.ideographmetalcircle = 12942, e2.ideographmooncircle = 12938, e2.ideographnamecircle = 12948, e2.ideographsuncircle = 12944, e2.ideographwatercircle = 12940, e2.ideographwoodcircle = 12941, e2.ideva = 2311, e2.idieresis = 239, e2.idieresisacute = 7727, e2.idieresiscyrillic = 1253, e2.idotbelow = 7883, e2.iebrevecyrillic = 1239, e2.iecyrillic = 1077, e2.ieungacirclekorean = 12917, e2.ieungaparenkorean = 12821, e2.ieungcirclekorean = 12903, e2.ieungkorean = 12615, e2.ieungparenkorean = 12807, e2.igrave = 236, e2.igujarati = 2695, e2.igurmukhi = 2567, e2.ihiragana = 12356, e2.ihookabove = 7881, e2.iibengali = 2440, e2.iicyrillic = 1080, e2.iideva = 2312, e2.iigujarati = 2696, e2.iigurmukhi = 2568, e2.iimatragurmukhi = 2624, e2.iinvertedbreve = 523, e2.iishortcyrillic = 1081, e2.iivowelsignbengali = 2496, e2.iivowelsigndeva = 2368, e2.iivowelsigngujarati = 2752, e2.ij = 307, e2.ikatakana = 12452, e2.ikatakanahalfwidth = 65394, e2.ikorean = 12643, e2.ilde = 732, e2.iluyhebrew = 1452, e2.imacron = 299, e2.imacroncyrillic = 1251, e2.imageorapproximatelyequal = 8787, e2.imatragurmukhi = 2623, e2.imonospace = 65353, e2.increment = 8710, e2.infinity = 8734, e2.iniarmenian = 1387, e2.integral = 8747, e2.integralbottom = 8993, e2.integralbt = 8993, e2.integralex = 63733, e2.integraltop = 8992, e2.integraltp = 8992, e2.intersection = 8745, e2.intisquare = 13061, e2.invbullet = 9688, e2.invcircle = 9689, e2.invsmileface = 9787, e2.iocyrillic = 1105, e2.iogonek = 303, e2.iota = 953, e2.iotadieresis = 970, e2.iotadieresistonos = 912, e2.iotalatin = 617, e2.iotatonos = 943, e2.iparen = 9380, e2.irigurmukhi = 2674, e2.ismallhiragana = 12355, e2.ismallkatakana = 12451, e2.ismallkatakanahalfwidth = 65384, e2.issharbengali = 2554, e2.istroke = 616, e2.isuperior = 63213, e2.iterationhiragana = 12445, e2.iterationkatakana = 12541, e2.itilde = 297, e2.itildebelow = 7725, e2.iubopomofo = 12585, e2.iucyrillic = 1102, e2.ivowelsignbengali = 2495, e2.ivowelsigndeva = 2367, e2.ivowelsigngujarati = 2751, e2.izhitsacyrillic = 1141, e2.izhitsadblgravecyrillic = 1143, e2.j = 106, e2.jaarmenian = 1393, e2.jabengali = 2460, e2.jadeva = 2332, e2.jagujarati = 2716, e2.jagurmukhi = 2588, e2.jbopomofo = 12560, e2.jcaron = 496, e2.jcircle = 9433, e2.jcircumflex = 309, e2.jcrossedtail = 669, e2.jdotlessstroke = 607, e2.jecyrillic = 1112, e2.jeemarabic = 1580, e2.jeemfinalarabic = 65182, e2.jeeminitialarabic = 65183, e2.jeemmedialarabic = 65184, e2.jeharabic = 1688, e2.jehfinalarabic = 64395, e2.jhabengali = 2461, e2.jhadeva = 2333, e2.jhagujarati = 2717, e2.jhagurmukhi = 2589, e2.jheharmenian = 1403, e2.jis = 12292, e2.jmonospace = 65354, e2.jparen = 9381, e2.jsuperior = 690, e2.k = 107, e2.kabashkircyrillic = 1185, e2.kabengali = 2453, e2.kacute = 7729, e2.kacyrillic = 1082, e2.kadescendercyrillic = 1179, e2.kadeva = 2325, e2.kaf = 1499, e2.kafarabic = 1603, e2.kafdagesh = 64315, e2.kafdageshhebrew = 64315, e2.kaffinalarabic = 65242, e2.kafhebrew = 1499, e2.kafinitialarabic = 65243, e2.kafmedialarabic = 65244, e2.kafrafehebrew = 64333, e2.kagujarati = 2709, e2.kagurmukhi = 2581, e2.kahiragana = 12363, e2.kahookcyrillic = 1220, e2.kakatakana = 12459, e2.kakatakanahalfwidth = 65398, e2.kappa = 954, e2.kappasymbolgreek = 1008, e2.kapyeounmieumkorean = 12657, e2.kapyeounphieuphkorean = 12676, e2.kapyeounpieupkorean = 12664, e2.kapyeounssangpieupkorean = 12665, e2.karoriisquare = 13069, e2.kashidaautoarabic = 1600, e2.kashidaautonosidebearingarabic = 1600, e2.kasmallkatakana = 12533, e2.kasquare = 13188, e2.kasraarabic = 1616, e2.kasratanarabic = 1613, e2.kastrokecyrillic = 1183, e2.katahiraprolongmarkhalfwidth = 65392, e2.kaverticalstrokecyrillic = 1181, e2.kbopomofo = 12558, e2.kcalsquare = 13193, e2.kcaron = 489, e2.kcedilla = 311, e2.kcircle = 9434, e2.kcommaaccent = 311, e2.kdotbelow = 7731, e2.keharmenian = 1412, e2.kehiragana = 12369, e2.kekatakana = 12465, e2.kekatakanahalfwidth = 65401, e2.kenarmenian = 1391, e2.kesmallkatakana = 12534, e2.kgreenlandic = 312, e2.khabengali = 2454, e2.khacyrillic = 1093, e2.khadeva = 2326, e2.khagujarati = 2710, e2.khagurmukhi = 2582, e2.khaharabic = 1582, e2.khahfinalarabic = 65190, e2.khahinitialarabic = 65191, e2.khahmedialarabic = 65192, e2.kheicoptic = 999, e2.khhadeva = 2393, e2.khhagurmukhi = 2649, e2.khieukhacirclekorean = 12920, e2.khieukhaparenkorean = 12824, e2.khieukhcirclekorean = 12906, e2.khieukhkorean = 12619, e2.khieukhparenkorean = 12810, e2.khokhaithai = 3586, e2.khokhonthai = 3589, e2.khokhuatthai = 3587, e2.khokhwaithai = 3588, e2.khomutthai = 3675, e2.khook = 409, e2.khorakhangthai = 3590, e2.khzsquare = 13201, e2.kihiragana = 12365, e2.kikatakana = 12461, e2.kikatakanahalfwidth = 65399, e2.kiroguramusquare = 13077, e2.kiromeetorusquare = 13078, e2.kirosquare = 13076, e2.kiyeokacirclekorean = 12910, e2.kiyeokaparenkorean = 12814, e2.kiyeokcirclekorean = 12896, e2.kiyeokkorean = 12593, e2.kiyeokparenkorean = 12800, e2.kiyeoksioskorean = 12595;
  e2.kjecyrillic = 1116, e2.klinebelow = 7733, e2.klsquare = 13208, e2.kmcubedsquare = 13222, e2.kmonospace = 65355, e2.kmsquaredsquare = 13218, e2.kohiragana = 12371, e2.kohmsquare = 13248, e2.kokaithai = 3585, e2.kokatakana = 12467, e2.kokatakanahalfwidth = 65402, e2.kooposquare = 13086, e2.koppacyrillic = 1153, e2.koreanstandardsymbol = 12927, e2.koroniscmb = 835, e2.kparen = 9382, e2.kpasquare = 13226, e2.ksicyrillic = 1135, e2.ktsquare = 13263, e2.kturned = 670, e2.kuhiragana = 12367, e2.kukatakana = 12463, e2.kukatakanahalfwidth = 65400, e2.kvsquare = 13240, e2.kwsquare = 13246, e2.l = 108, e2.labengali = 2482, e2.lacute = 314, e2.ladeva = 2354, e2.lagujarati = 2738, e2.lagurmukhi = 2610, e2.lakkhangyaothai = 3653, e2.lamaleffinalarabic = 65276, e2.lamalefhamzaabovefinalarabic = 65272, e2.lamalefhamzaaboveisolatedarabic = 65271, e2.lamalefhamzabelowfinalarabic = 65274, e2.lamalefhamzabelowisolatedarabic = 65273, e2.lamalefisolatedarabic = 65275, e2.lamalefmaddaabovefinalarabic = 65270, e2.lamalefmaddaaboveisolatedarabic = 65269, e2.lamarabic = 1604, e2.lambda = 955, e2.lambdastroke = 411, e2.lamed = 1500, e2.lameddagesh = 64316, e2.lameddageshhebrew = 64316, e2.lamedhebrew = 1500, e2.lamfinalarabic = 65246, e2.lamhahinitialarabic = 64714, e2.laminitialarabic = 65247, e2.lamjeeminitialarabic = 64713, e2.lamkhahinitialarabic = 64715, e2.lamlamhehisolatedarabic = 65010, e2.lammedialarabic = 65248, e2.lammeemhahinitialarabic = 64904, e2.lammeeminitialarabic = 64716, e2.largecircle = 9711, e2.lbar = 410, e2.lbelt = 620, e2.lbopomofo = 12556, e2.lcaron = 318, e2.lcedilla = 316, e2.lcircle = 9435, e2.lcircumflexbelow = 7741, e2.lcommaaccent = 316, e2.ldot = 320, e2.ldotaccent = 320, e2.ldotbelow = 7735, e2.ldotbelowmacron = 7737, e2.leftangleabovecmb = 794, e2.lefttackbelowcmb = 792, e2.less = 60, e2.lessequal = 8804, e2.lessequalorgreater = 8922, e2.lessmonospace = 65308, e2.lessorequivalent = 8818, e2.lessorgreater = 8822, e2.lessoverequal = 8806, e2.lesssmall = 65124, e2.lezh = 622, e2.lfblock = 9612, e2.lhookretroflex = 621, e2.lira = 8356, e2.liwnarmenian = 1388, e2.lj = 457, e2.ljecyrillic = 1113, e2.ll = 63168, e2.lladeva = 2355, e2.llagujarati = 2739, e2.llinebelow = 7739, e2.llladeva = 2356, e2.llvocalicbengali = 2529, e2.llvocalicdeva = 2401, e2.llvocalicvowelsignbengali = 2531, e2.llvocalicvowelsigndeva = 2403, e2.lmiddletilde = 619, e2.lmonospace = 65356, e2.lmsquare = 13264, e2.lochulathai = 3628, e2.logicaland = 8743, e2.logicalnot = 172, e2.logicalnotreversed = 8976, e2.logicalor = 8744, e2.lolingthai = 3621, e2.longs = 383, e2.lowlinecenterline = 65102, e2.lowlinecmb = 818, e2.lowlinedashed = 65101, e2.lozenge = 9674, e2.lparen = 9383, e2.lslash = 322, e2.lsquare = 8467, e2.lsuperior = 63214, e2.ltshade = 9617, e2.luthai = 3622, e2.lvocalicbengali = 2444, e2.lvocalicdeva = 2316, e2.lvocalicvowelsignbengali = 2530, e2.lvocalicvowelsigndeva = 2402, e2.lxsquare = 13267, e2.m = 109, e2.mabengali = 2478, e2.macron = 175, e2.macronbelowcmb = 817, e2.macroncmb = 772, e2.macronlowmod = 717, e2.macronmonospace = 65507, e2.macute = 7743, e2.madeva = 2350, e2.magujarati = 2734, e2.magurmukhi = 2606, e2.mahapakhhebrew = 1444, e2.mahapakhlefthebrew = 1444, e2.mahiragana = 12414, e2.maichattawalowleftthai = 63637, e2.maichattawalowrightthai = 63636, e2.maichattawathai = 3659, e2.maichattawaupperleftthai = 63635, e2.maieklowleftthai = 63628, e2.maieklowrightthai = 63627, e2.maiekthai = 3656, e2.maiekupperleftthai = 63626, e2.maihanakatleftthai = 63620, e2.maihanakatthai = 3633, e2.maitaikhuleftthai = 63625, e2.maitaikhuthai = 3655, e2.maitholowleftthai = 63631, e2.maitholowrightthai = 63630, e2.maithothai = 3657, e2.maithoupperleftthai = 63629, e2.maitrilowleftthai = 63634, e2.maitrilowrightthai = 63633, e2.maitrithai = 3658, e2.maitriupperleftthai = 63632, e2.maiyamokthai = 3654, e2.makatakana = 12510, e2.makatakanahalfwidth = 65423, e2.male = 9794, e2.mansyonsquare = 13127, e2.maqafhebrew = 1470, e2.mars = 9794, e2.masoracirclehebrew = 1455, e2.masquare = 13187, e2.mbopomofo = 12551, e2.mbsquare = 13268, e2.mcircle = 9436, e2.mcubedsquare = 13221, e2.mdotaccent = 7745, e2.mdotbelow = 7747, e2.meemarabic = 1605, e2.meemfinalarabic = 65250, e2.meeminitialarabic = 65251, e2.meemmedialarabic = 65252, e2.meemmeeminitialarabic = 64721, e2.meemmeemisolatedarabic = 64584, e2.meetorusquare = 13133, e2.mehiragana = 12417, e2.meizierasquare = 13182, e2.mekatakana = 12513, e2.mekatakanahalfwidth = 65426, e2.mem = 1502, e2.memdagesh = 64318, e2.memdageshhebrew = 64318, e2.memhebrew = 1502, e2.menarmenian = 1396, e2.merkhahebrew = 1445, e2.merkhakefulahebrew = 1446, e2.merkhakefulalefthebrew = 1446, e2.merkhalefthebrew = 1445, e2.mhook = 625, e2.mhzsquare = 13202, e2.middledotkatakanahalfwidth = 65381, e2.middot = 183, e2.mieumacirclekorean = 12914, e2.mieumaparenkorean = 12818, e2.mieumcirclekorean = 12900, e2.mieumkorean = 12609, e2.mieumpansioskorean = 12656, e2.mieumparenkorean = 12804, e2.mieumpieupkorean = 12654, e2.mieumsioskorean = 12655, e2.mihiragana = 12415, e2.mikatakana = 12511, e2.mikatakanahalfwidth = 65424, e2.minus = 8722, e2.minusbelowcmb = 800, e2.minuscircle = 8854, e2.minusmod = 727, e2.minusplus = 8723, e2.minute = 8242, e2.miribaarusquare = 13130, e2.mirisquare = 13129, e2.mlonglegturned = 624, e2.mlsquare = 13206, e2.mmcubedsquare = 13219, e2.mmonospace = 65357, e2.mmsquaredsquare = 13215, e2.mohiragana = 12418, e2.mohmsquare = 13249, e2.mokatakana = 12514, e2.mokatakanahalfwidth = 65427, e2.molsquare = 13270, e2.momathai = 3617, e2.moverssquare = 13223, e2.moverssquaredsquare = 13224, e2.mparen = 9384, e2.mpasquare = 13227, e2.mssquare = 13235, e2.msuperior = 63215, e2.mturned = 623, e2.mu = 181, e2.mu1 = 181, e2.muasquare = 13186, e2.muchgreater = 8811, e2.muchless = 8810, e2.mufsquare = 13196, e2.mugreek = 956, e2.mugsquare = 13197, e2.muhiragana = 12416, e2.mukatakana = 12512, e2.mukatakanahalfwidth = 65425, e2.mulsquare = 13205, e2.multiply = 215, e2.mumsquare = 13211, e2.munahhebrew = 1443, e2.munahlefthebrew = 1443, e2.musicalnote = 9834, e2.musicalnotedbl = 9835, e2.musicflatsign = 9837, e2.musicsharpsign = 9839, e2.mussquare = 13234, e2.muvsquare = 13238, e2.muwsquare = 13244, e2.mvmegasquare = 13241, e2.mvsquare = 13239, e2.mwmegasquare = 13247, e2.mwsquare = 13245, e2.n = 110, e2.nabengali = 2472, e2.nabla = 8711, e2.nacute = 324, e2.nadeva = 2344, e2.nagujarati = 2728, e2.nagurmukhi = 2600, e2.nahiragana = 12394, e2.nakatakana = 12490, e2.nakatakanahalfwidth = 65413, e2.napostrophe = 329, e2.nasquare = 13185, e2.nbopomofo = 12555, e2.nbspace = 160, e2.ncaron = 328, e2.ncedilla = 326, e2.ncircle = 9437, e2.ncircumflexbelow = 7755, e2.ncommaaccent = 326, e2.ndotaccent = 7749, e2.ndotbelow = 7751, e2.nehiragana = 12397, e2.nekatakana = 12493, e2.nekatakanahalfwidth = 65416, e2.newsheqelsign = 8362, e2.nfsquare = 13195, e2.ngabengali = 2457, e2.ngadeva = 2329, e2.ngagujarati = 2713, e2.ngagurmukhi = 2585, e2.ngonguthai = 3591, e2.nhiragana = 12435, e2.nhookleft = 626, e2.nhookretroflex = 627, e2.nieunacirclekorean = 12911, e2.nieunaparenkorean = 12815, e2.nieuncieuckorean = 12597, e2.nieuncirclekorean = 12897, e2.nieunhieuhkorean = 12598, e2.nieunkorean = 12596, e2.nieunpansioskorean = 12648, e2.nieunparenkorean = 12801, e2.nieunsioskorean = 12647, e2.nieuntikeutkorean = 12646, e2.nihiragana = 12395, e2.nikatakana = 12491, e2.nikatakanahalfwidth = 65414, e2.nikhahitleftthai = 63641, e2.nikhahitthai = 3661, e2.nine = 57, e2.ninearabic = 1641, e2.ninebengali = 2543, e2.ninecircle = 9320, e2.ninecircleinversesansserif = 10130, e2.ninedeva = 2415, e2.ninegujarati = 2799, e2.ninegurmukhi = 2671, e2.ninehackarabic = 1641, e2.ninehangzhou = 12329, e2.nineideographicparen = 12840, e2.nineinferior = 8329, e2.ninemonospace = 65305, e2.nineoldstyle = 63289, e2.nineparen = 9340, e2.nineperiod = 9360, e2.ninepersian = 1785, e2.nineroman = 8568, e2.ninesuperior = 8313, e2.nineteencircle = 9330, e2.nineteenparen = 9350, e2.nineteenperiod = 9370, e2.ninethai = 3673, e2.nj = 460, e2.njecyrillic = 1114, e2.nkatakana = 12531, e2.nkatakanahalfwidth = 65437, e2.nlegrightlong = 414, e2.nlinebelow = 7753, e2.nmonospace = 65358, e2.nmsquare = 13210, e2.nnabengali = 2467, e2.nnadeva = 2339, e2.nnagujarati = 2723, e2.nnagurmukhi = 2595, e2.nnnadeva = 2345, e2.nohiragana = 12398, e2.nokatakana = 12494, e2.nokatakanahalfwidth = 65417, e2.nonbreakingspace = 160, e2.nonenthai = 3603, e2.nonuthai = 3609, e2.noonarabic = 1606, e2.noonfinalarabic = 65254, e2.noonghunnaarabic = 1722, e2.noonghunnafinalarabic = 64415, e2.nooninitialarabic = 65255, e2.noonjeeminitialarabic = 64722, e2.noonjeemisolatedarabic = 64587, e2.noonmedialarabic = 65256, e2.noonmeeminitialarabic = 64725, e2.noonmeemisolatedarabic = 64590, e2.noonnoonfinalarabic = 64653, e2.notcontains = 8716, e2.notelement = 8713, e2.notelementof = 8713, e2.notequal = 8800, e2.notgreater = 8815, e2.notgreaternorequal = 8817, e2.notgreaternorless = 8825, e2.notidentical = 8802, e2.notless = 8814, e2.notlessnorequal = 8816, e2.notparallel = 8742, e2.notprecedes = 8832, e2.notsubset = 8836, e2.notsucceeds = 8833, e2.notsuperset = 8837, e2.nowarmenian = 1398, e2.nparen = 9385, e2.nssquare = 13233, e2.nsuperior = 8319, e2.ntilde = 241, e2.nu = 957, e2.nuhiragana = 12396, e2.nukatakana = 12492, e2.nukatakanahalfwidth = 65415, e2.nuktabengali = 2492, e2.nuktadeva = 2364, e2.nuktagujarati = 2748, e2.nuktagurmukhi = 2620, e2.numbersign = 35, e2.numbersignmonospace = 65283, e2.numbersignsmall = 65119, e2.numeralsigngreek = 884, e2.numeralsignlowergreek = 885, e2.numero = 8470, e2.nun = 1504, e2.nundagesh = 64320, e2.nundageshhebrew = 64320, e2.nunhebrew = 1504, e2.nvsquare = 13237, e2.nwsquare = 13243, e2.nyabengali = 2462, e2.nyadeva = 2334, e2.nyagujarati = 2718, e2.nyagurmukhi = 2590, e2.o = 111, e2.oacute = 243, e2.oangthai = 3629, e2.obarred = 629, e2.obarredcyrillic = 1257, e2.obarreddieresiscyrillic = 1259, e2.obengali = 2451, e2.obopomofo = 12571, e2.obreve = 335, e2.ocandradeva = 2321, e2.ocandragujarati = 2705, e2.ocandravowelsigndeva = 2377, e2.ocandravowelsigngujarati = 2761, e2.ocaron = 466, e2.ocircle = 9438, e2.ocircumflex = 244, e2.ocircumflexacute = 7889, e2.ocircumflexdotbelow = 7897, e2.ocircumflexgrave = 7891, e2.ocircumflexhookabove = 7893, e2.ocircumflextilde = 7895, e2.ocyrillic = 1086, e2.odblacute = 337, e2.odblgrave = 525, e2.odeva = 2323, e2.odieresis = 246, e2.odieresiscyrillic = 1255, e2.odotbelow = 7885, e2.oe = 339, e2.oekorean = 12634, e2.ogonek = 731, e2.ogonekcmb = 808, e2.ograve = 242, e2.ogujarati = 2707, e2.oharmenian = 1413, e2.ohiragana = 12362, e2.ohookabove = 7887, e2.ohorn = 417, e2.ohornacute = 7899, e2.ohorndotbelow = 7907, e2.ohorngrave = 7901, e2.ohornhookabove = 7903, e2.ohorntilde = 7905, e2.ohungarumlaut = 337, e2.oi = 419, e2.oinvertedbreve = 527, e2.okatakana = 12458, e2.okatakanahalfwidth = 65397, e2.okorean = 12631, e2.olehebrew = 1451, e2.omacron = 333, e2.omacronacute = 7763, e2.omacrongrave = 7761, e2.omdeva = 2384, e2.omega = 969, e2.omega1 = 982, e2.omegacyrillic = 1121, e2.omegalatinclosed = 631, e2.omegaroundcyrillic = 1147, e2.omegatitlocyrillic = 1149, e2.omegatonos = 974, e2.omgujarati = 2768, e2.omicron = 959, e2.omicrontonos = 972, e2.omonospace = 65359, e2.one = 49, e2.onearabic = 1633, e2.onebengali = 2535, e2.onecircle = 9312, e2.onecircleinversesansserif = 10122, e2.onedeva = 2407, e2.onedotenleader = 8228, e2.oneeighth = 8539, e2.onefitted = 63196, e2.onegujarati = 2791, e2.onegurmukhi = 2663, e2.onehackarabic = 1633, e2.onehalf = 189, e2.onehangzhou = 12321, e2.oneideographicparen = 12832, e2.oneinferior = 8321, e2.onemonospace = 65297, e2.onenumeratorbengali = 2548, e2.oneoldstyle = 63281, e2.oneparen = 9332, e2.oneperiod = 9352, e2.onepersian = 1777, e2.onequarter = 188, e2.oneroman = 8560, e2.onesuperior = 185, e2.onethai = 3665, e2.onethird = 8531, e2.oogonek = 491, e2.oogonekmacron = 493, e2.oogurmukhi = 2579, e2.oomatragurmukhi = 2635, e2.oopen = 596, e2.oparen = 9386, e2.openbullet = 9702, e2.option = 8997, e2.ordfeminine = 170, e2.ordmasculine = 186, e2.orthogonal = 8735, e2.oshortdeva = 2322, e2.oshortvowelsigndeva = 2378, e2.oslash = 248, e2.oslashacute = 511, e2.osmallhiragana = 12361, e2.osmallkatakana = 12457, e2.osmallkatakanahalfwidth = 65387, e2.ostrokeacute = 511, e2.osuperior = 63216, e2.otcyrillic = 1151, e2.otilde = 245, e2.otildeacute = 7757, e2.otildedieresis = 7759, e2.oubopomofo = 12577, e2.overline = 8254, e2.overlinecenterline = 65098, e2.overlinecmb = 773, e2.overlinedashed = 65097, e2.overlinedblwavy = 65100, e2.overlinewavy = 65099, e2.overscore = 175, e2.ovowelsignbengali = 2507, e2.ovowelsigndeva = 2379, e2.ovowelsigngujarati = 2763, e2.p = 112, e2.paampssquare = 13184, e2.paasentosquare = 13099, e2.pabengali = 2474, e2.pacute = 7765, e2.padeva = 2346, e2.pagedown = 8671, e2.pageup = 8670, e2.pagujarati = 2730, e2.pagurmukhi = 2602, e2.pahiragana = 12401, e2.paiyannoithai = 3631, e2.pakatakana = 12497, e2.palatalizationcyrilliccmb = 1156, e2.palochkacyrillic = 1216, e2.pansioskorean = 12671, e2.paragraph = 182, e2.parallel = 8741, e2.parenleft = 40, e2.parenleftaltonearabic = 64830, e2.parenleftbt = 63725, e2.parenleftex = 63724, e2.parenleftinferior = 8333, e2.parenleftmonospace = 65288, e2.parenleftsmall = 65113, e2.parenleftsuperior = 8317, e2.parenlefttp = 63723, e2.parenleftvertical = 65077, e2.parenright = 41, e2.parenrightaltonearabic = 64831, e2.parenrightbt = 63736, e2.parenrightex = 63735, e2.parenrightinferior = 8334, e2.parenrightmonospace = 65289, e2.parenrightsmall = 65114, e2.parenrightsuperior = 8318, e2.parenrighttp = 63734, e2.parenrightvertical = 65078, e2.partialdiff = 8706, e2.paseqhebrew = 1472, e2.pashtahebrew = 1433, e2.pasquare = 13225, e2.patah = 1463, e2.patah11 = 1463, e2.patah1d = 1463, e2.patah2a = 1463, e2.patahhebrew = 1463, e2.patahnarrowhebrew = 1463, e2.patahquarterhebrew = 1463, e2.patahwidehebrew = 1463, e2.pazerhebrew = 1441, e2.pbopomofo = 12550, e2.pcircle = 9439, e2.pdotaccent = 7767, e2.pe = 1508, e2.pecyrillic = 1087, e2.pedagesh = 64324, e2.pedageshhebrew = 64324, e2.peezisquare = 13115, e2.pefinaldageshhebrew = 64323, e2.peharabic = 1662, e2.peharmenian = 1402, e2.pehebrew = 1508, e2.pehfinalarabic = 64343, e2.pehinitialarabic = 64344, e2.pehiragana = 12410, e2.pehmedialarabic = 64345, e2.pekatakana = 12506, e2.pemiddlehookcyrillic = 1191, e2.perafehebrew = 64334, e2.percent = 37, e2.percentarabic = 1642, e2.percentmonospace = 65285, e2.percentsmall = 65130, e2.period = 46, e2.periodarmenian = 1417, e2.periodcentered = 183, e2.periodhalfwidth = 65377, e2.periodinferior = 63207, e2.periodmonospace = 65294, e2.periodsmall = 65106, e2.periodsuperior = 63208, e2.perispomenigreekcmb = 834, e2.perpendicular = 8869, e2.perthousand = 8240, e2.peseta = 8359, e2.pfsquare = 13194, e2.phabengali = 2475, e2.phadeva = 2347, e2.phagujarati = 2731, e2.phagurmukhi = 2603, e2.phi = 966, e2.phi1 = 981, e2.phieuphacirclekorean = 12922, e2.phieuphaparenkorean = 12826, e2.phieuphcirclekorean = 12908, e2.phieuphkorean = 12621, e2.phieuphparenkorean = 12812, e2.philatin = 632, e2.phinthuthai = 3642, e2.phisymbolgreek = 981, e2.phook = 421, e2.phophanthai = 3614, e2.phophungthai = 3612, e2.phosamphaothai = 3616, e2.pi = 960, e2.pieupacirclekorean = 12915, e2.pieupaparenkorean = 12819, e2.pieupcieuckorean = 12662, e2.pieupcirclekorean = 12901, e2.pieupkiyeokkorean = 12658, e2.pieupkorean = 12610, e2.pieupparenkorean = 12805, e2.pieupsioskiyeokkorean = 12660, e2.pieupsioskorean = 12612, e2.pieupsiostikeutkorean = 12661, e2.pieupthieuthkorean = 12663, e2.pieuptikeutkorean = 12659, e2.pihiragana = 12404, e2.pikatakana = 12500, e2.pisymbolgreek = 982, e2.piwrarmenian = 1411, e2.planckover2pi = 8463, e2.planckover2pi1 = 8463, e2.plus = 43, e2.plusbelowcmb = 799, e2.pluscircle = 8853, e2.plusminus = 177, e2.plusmod = 726, e2.plusmonospace = 65291, e2.plussmall = 65122, e2.plussuperior = 8314, e2.pmonospace = 65360, e2.pmsquare = 13272, e2.pohiragana = 12413, e2.pointingindexdownwhite = 9759, e2.pointingindexleftwhite = 9756, e2.pointingindexrightwhite = 9758, e2.pointingindexupwhite = 9757, e2.pokatakana = 12509, e2.poplathai = 3611, e2.postalmark = 12306, e2.postalmarkface = 12320, e2.pparen = 9387, e2.precedes = 8826, e2.prescription = 8478, e2.primemod = 697, e2.primereversed = 8245, e2.product = 8719, e2.projective = 8965, e2.prolongedkana = 12540, e2.propellor = 8984, e2.propersubset = 8834, e2.propersuperset = 8835, e2.proportion = 8759, e2.proportional = 8733, e2.psi = 968, e2.psicyrillic = 1137, e2.psilipneumatacyrilliccmb = 1158, e2.pssquare = 13232, e2.puhiragana = 12407, e2.pukatakana = 12503, e2.pvsquare = 13236, e2.pwsquare = 13242, e2.q = 113, e2.qadeva = 2392, e2.qadmahebrew = 1448, e2.qafarabic = 1602, e2.qaffinalarabic = 65238, e2.qafinitialarabic = 65239, e2.qafmedialarabic = 65240, e2.qamats = 1464, e2.qamats10 = 1464, e2.qamats1a = 1464, e2.qamats1c = 1464, e2.qamats27 = 1464, e2.qamats29 = 1464, e2.qamats33 = 1464, e2.qamatsde = 1464, e2.qamatshebrew = 1464, e2.qamatsnarrowhebrew = 1464, e2.qamatsqatanhebrew = 1464, e2.qamatsqatannarrowhebrew = 1464, e2.qamatsqatanquarterhebrew = 1464, e2.qamatsqatanwidehebrew = 1464, e2.qamatsquarterhebrew = 1464, e2.qamatswidehebrew = 1464, e2.qarneyparahebrew = 1439, e2.qbopomofo = 12561, e2.qcircle = 9440, e2.qhook = 672, e2.qmonospace = 65361, e2.qof = 1511, e2.qofdagesh = 64327, e2.qofdageshhebrew = 64327, e2.qofhebrew = 1511, e2.qparen = 9388, e2.quarternote = 9833, e2.qubuts = 1467, e2.qubuts18 = 1467, e2.qubuts25 = 1467, e2.qubuts31 = 1467, e2.qubutshebrew = 1467, e2.qubutsnarrowhebrew = 1467, e2.qubutsquarterhebrew = 1467, e2.qubutswidehebrew = 1467, e2.question = 63, e2.questionarabic = 1567, e2.questionarmenian = 1374, e2.questiondown = 191, e2.questiondownsmall = 63423, e2.questiongreek = 894, e2.questionmonospace = 65311, e2.questionsmall = 63295, e2.quotedbl = 34, e2.quotedblbase = 8222, e2.quotedblleft = 8220, e2.quotedblmonospace = 65282, e2.quotedblprime = 12318, e2.quotedblprimereversed = 12317, e2.quotedblright = 8221, e2.quoteleft = 8216, e2.quoteleftreversed = 8219, e2.quotereversed = 8219, e2.quoteright = 8217, e2.quoterightn = 329, e2.quotesinglbase = 8218, e2.quotesingle = 39, e2.quotesinglemonospace = 65287, e2.r = 114, e2.raarmenian = 1404, e2.rabengali = 2480, e2.racute = 341, e2.radeva = 2352, e2.radical = 8730, e2.radicalex = 63717, e2.radoverssquare = 13230, e2.radoverssquaredsquare = 13231, e2.radsquare = 13229, e2.rafe = 1471, e2.rafehebrew = 1471, e2.ragujarati = 2736, e2.ragurmukhi = 2608, e2.rahiragana = 12425, e2.rakatakana = 12521, e2.rakatakanahalfwidth = 65431, e2.ralowerdiagonalbengali = 2545, e2.ramiddlediagonalbengali = 2544, e2.ramshorn = 612, e2.ratio = 8758, e2.rbopomofo = 12566, e2.rcaron = 345, e2.rcedilla = 343, e2.rcircle = 9441, e2.rcommaaccent = 343, e2.rdblgrave = 529, e2.rdotaccent = 7769, e2.rdotbelow = 7771, e2.rdotbelowmacron = 7773, e2.referencemark = 8251, e2.reflexsubset = 8838, e2.reflexsuperset = 8839, e2.registered = 174, e2.registersans = 63720, e2.registerserif = 63194, e2.reharabic = 1585, e2.reharmenian = 1408, e2.rehfinalarabic = 65198, e2.rehiragana = 12428, e2.rekatakana = 12524;
  e2.rekatakanahalfwidth = 65434, e2.resh = 1512, e2.reshdageshhebrew = 64328, e2.reshhebrew = 1512, e2.reversedtilde = 8765, e2.reviahebrew = 1431, e2.reviamugrashhebrew = 1431, e2.revlogicalnot = 8976, e2.rfishhook = 638, e2.rfishhookreversed = 639, e2.rhabengali = 2525, e2.rhadeva = 2397, e2.rho = 961, e2.rhook = 637, e2.rhookturned = 635, e2.rhookturnedsuperior = 693, e2.rhosymbolgreek = 1009, e2.rhotichookmod = 734, e2.rieulacirclekorean = 12913, e2.rieulaparenkorean = 12817, e2.rieulcirclekorean = 12899, e2.rieulhieuhkorean = 12608, e2.rieulkiyeokkorean = 12602, e2.rieulkiyeoksioskorean = 12649, e2.rieulkorean = 12601, e2.rieulmieumkorean = 12603, e2.rieulpansioskorean = 12652, e2.rieulparenkorean = 12803, e2.rieulphieuphkorean = 12607, e2.rieulpieupkorean = 12604, e2.rieulpieupsioskorean = 12651, e2.rieulsioskorean = 12605, e2.rieulthieuthkorean = 12606, e2.rieultikeutkorean = 12650, e2.rieulyeorinhieuhkorean = 12653, e2.rightangle = 8735, e2.righttackbelowcmb = 793, e2.righttriangle = 8895, e2.rihiragana = 12426, e2.rikatakana = 12522, e2.rikatakanahalfwidth = 65432, e2.ring = 730, e2.ringbelowcmb = 805, e2.ringcmb = 778, e2.ringhalfleft = 703, e2.ringhalfleftarmenian = 1369, e2.ringhalfleftbelowcmb = 796, e2.ringhalfleftcentered = 723, e2.ringhalfright = 702, e2.ringhalfrightbelowcmb = 825, e2.ringhalfrightcentered = 722, e2.rinvertedbreve = 531, e2.rittorusquare = 13137, e2.rlinebelow = 7775, e2.rlongleg = 636, e2.rlonglegturned = 634, e2.rmonospace = 65362, e2.rohiragana = 12429, e2.rokatakana = 12525, e2.rokatakanahalfwidth = 65435, e2.roruathai = 3619, e2.rparen = 9389, e2.rrabengali = 2524, e2.rradeva = 2353, e2.rragurmukhi = 2652, e2.rreharabic = 1681, e2.rrehfinalarabic = 64397, e2.rrvocalicbengali = 2528, e2.rrvocalicdeva = 2400, e2.rrvocalicgujarati = 2784, e2.rrvocalicvowelsignbengali = 2500, e2.rrvocalicvowelsigndeva = 2372, e2.rrvocalicvowelsigngujarati = 2756, e2.rsuperior = 63217, e2.rtblock = 9616, e2.rturned = 633, e2.rturnedsuperior = 692, e2.ruhiragana = 12427, e2.rukatakana = 12523, e2.rukatakanahalfwidth = 65433, e2.rupeemarkbengali = 2546, e2.rupeesignbengali = 2547, e2.rupiah = 63197, e2.ruthai = 3620, e2.rvocalicbengali = 2443, e2.rvocalicdeva = 2315, e2.rvocalicgujarati = 2699, e2.rvocalicvowelsignbengali = 2499, e2.rvocalicvowelsigndeva = 2371, e2.rvocalicvowelsigngujarati = 2755, e2.s = 115, e2.sabengali = 2488, e2.sacute = 347, e2.sacutedotaccent = 7781, e2.sadarabic = 1589, e2.sadeva = 2360, e2.sadfinalarabic = 65210, e2.sadinitialarabic = 65211, e2.sadmedialarabic = 65212, e2.sagujarati = 2744, e2.sagurmukhi = 2616, e2.sahiragana = 12373, e2.sakatakana = 12469, e2.sakatakanahalfwidth = 65403, e2.sallallahoualayhewasallamarabic = 65018, e2.samekh = 1505, e2.samekhdagesh = 64321, e2.samekhdageshhebrew = 64321, e2.samekhhebrew = 1505, e2.saraaathai = 3634, e2.saraaethai = 3649, e2.saraaimaimalaithai = 3652, e2.saraaimaimuanthai = 3651, e2.saraamthai = 3635, e2.saraathai = 3632, e2.saraethai = 3648, e2.saraiileftthai = 63622, e2.saraiithai = 3637, e2.saraileftthai = 63621, e2.saraithai = 3636, e2.saraothai = 3650, e2.saraueeleftthai = 63624, e2.saraueethai = 3639, e2.saraueleftthai = 63623, e2.sarauethai = 3638, e2.sarauthai = 3640, e2.sarauuthai = 3641, e2.sbopomofo = 12569, e2.scaron = 353, e2.scarondotaccent = 7783, e2.scedilla = 351, e2.schwa = 601, e2.schwacyrillic = 1241, e2.schwadieresiscyrillic = 1243, e2.schwahook = 602, e2.scircle = 9442, e2.scircumflex = 349, e2.scommaaccent = 537, e2.sdotaccent = 7777, e2.sdotbelow = 7779, e2.sdotbelowdotaccent = 7785, e2.seagullbelowcmb = 828, e2.second = 8243, e2.secondtonechinese = 714, e2.section = 167, e2.seenarabic = 1587, e2.seenfinalarabic = 65202, e2.seeninitialarabic = 65203, e2.seenmedialarabic = 65204, e2.segol = 1462, e2.segol13 = 1462, e2.segol1f = 1462, e2.segol2c = 1462, e2.segolhebrew = 1462, e2.segolnarrowhebrew = 1462, e2.segolquarterhebrew = 1462, e2.segoltahebrew = 1426, e2.segolwidehebrew = 1462, e2.seharmenian = 1405, e2.sehiragana = 12379, e2.sekatakana = 12475, e2.sekatakanahalfwidth = 65406, e2.semicolon = 59, e2.semicolonarabic = 1563, e2.semicolonmonospace = 65307, e2.semicolonsmall = 65108, e2.semivoicedmarkkana = 12444, e2.semivoicedmarkkanahalfwidth = 65439, e2.sentisquare = 13090, e2.sentosquare = 13091, e2.seven = 55, e2.sevenarabic = 1639, e2.sevenbengali = 2541, e2.sevencircle = 9318, e2.sevencircleinversesansserif = 10128, e2.sevendeva = 2413, e2.seveneighths = 8542, e2.sevengujarati = 2797, e2.sevengurmukhi = 2669, e2.sevenhackarabic = 1639, e2.sevenhangzhou = 12327, e2.sevenideographicparen = 12838, e2.seveninferior = 8327, e2.sevenmonospace = 65303, e2.sevenoldstyle = 63287, e2.sevenparen = 9338, e2.sevenperiod = 9358, e2.sevenpersian = 1783, e2.sevenroman = 8566, e2.sevensuperior = 8311, e2.seventeencircle = 9328, e2.seventeenparen = 9348, e2.seventeenperiod = 9368, e2.seventhai = 3671, e2.sfthyphen = 173, e2.shaarmenian = 1399, e2.shabengali = 2486, e2.shacyrillic = 1096, e2.shaddaarabic = 1617, e2.shaddadammaarabic = 64609, e2.shaddadammatanarabic = 64606, e2.shaddafathaarabic = 64608, e2.shaddakasraarabic = 64610, e2.shaddakasratanarabic = 64607, e2.shade = 9618, e2.shadedark = 9619, e2.shadelight = 9617, e2.shademedium = 9618, e2.shadeva = 2358, e2.shagujarati = 2742, e2.shagurmukhi = 2614, e2.shalshelethebrew = 1427, e2.shbopomofo = 12565, e2.shchacyrillic = 1097, e2.sheenarabic = 1588, e2.sheenfinalarabic = 65206, e2.sheeninitialarabic = 65207, e2.sheenmedialarabic = 65208, e2.sheicoptic = 995, e2.sheqel = 8362, e2.sheqelhebrew = 8362, e2.sheva = 1456, e2.sheva115 = 1456, e2.sheva15 = 1456, e2.sheva22 = 1456, e2.sheva2e = 1456, e2.shevahebrew = 1456, e2.shevanarrowhebrew = 1456, e2.shevaquarterhebrew = 1456, e2.shevawidehebrew = 1456, e2.shhacyrillic = 1211, e2.shimacoptic = 1005, e2.shin = 1513, e2.shindagesh = 64329, e2.shindageshhebrew = 64329, e2.shindageshshindot = 64300, e2.shindageshshindothebrew = 64300, e2.shindageshsindot = 64301, e2.shindageshsindothebrew = 64301, e2.shindothebrew = 1473, e2.shinhebrew = 1513, e2.shinshindot = 64298, e2.shinshindothebrew = 64298, e2.shinsindot = 64299, e2.shinsindothebrew = 64299, e2.shook = 642, e2.sigma = 963, e2.sigma1 = 962, e2.sigmafinal = 962, e2.sigmalunatesymbolgreek = 1010, e2.sihiragana = 12375, e2.sikatakana = 12471, e2.sikatakanahalfwidth = 65404, e2.siluqhebrew = 1469, e2.siluqlefthebrew = 1469, e2.similar = 8764, e2.sindothebrew = 1474, e2.siosacirclekorean = 12916, e2.siosaparenkorean = 12820, e2.sioscieuckorean = 12670, e2.sioscirclekorean = 12902, e2.sioskiyeokkorean = 12666, e2.sioskorean = 12613, e2.siosnieunkorean = 12667, e2.siosparenkorean = 12806, e2.siospieupkorean = 12669, e2.siostikeutkorean = 12668, e2.six = 54, e2.sixarabic = 1638, e2.sixbengali = 2540, e2.sixcircle = 9317, e2.sixcircleinversesansserif = 10127, e2.sixdeva = 2412, e2.sixgujarati = 2796, e2.sixgurmukhi = 2668, e2.sixhackarabic = 1638, e2.sixhangzhou = 12326, e2.sixideographicparen = 12837, e2.sixinferior = 8326, e2.sixmonospace = 65302, e2.sixoldstyle = 63286, e2.sixparen = 9337, e2.sixperiod = 9357, e2.sixpersian = 1782, e2.sixroman = 8565, e2.sixsuperior = 8310, e2.sixteencircle = 9327, e2.sixteencurrencydenominatorbengali = 2553, e2.sixteenparen = 9347, e2.sixteenperiod = 9367, e2.sixthai = 3670, e2.slash = 47, e2.slashmonospace = 65295, e2.slong = 383, e2.slongdotaccent = 7835, e2.smileface = 9786, e2.smonospace = 65363, e2.sofpasuqhebrew = 1475, e2.softhyphen = 173, e2.softsigncyrillic = 1100, e2.sohiragana = 12381, e2.sokatakana = 12477, e2.sokatakanahalfwidth = 65407, e2.soliduslongoverlaycmb = 824, e2.solidusshortoverlaycmb = 823, e2.sorusithai = 3625, e2.sosalathai = 3624, e2.sosothai = 3595, e2.sosuathai = 3626, e2.space = 32, e2.spacehackarabic = 32, e2.spade = 9824, e2.spadesuitblack = 9824, e2.spadesuitwhite = 9828, e2.sparen = 9390, e2.squarebelowcmb = 827, e2.squarecc = 13252, e2.squarecm = 13213, e2.squarediagonalcrosshatchfill = 9641, e2.squarehorizontalfill = 9636, e2.squarekg = 13199, e2.squarekm = 13214, e2.squarekmcapital = 13262, e2.squareln = 13265, e2.squarelog = 13266, e2.squaremg = 13198, e2.squaremil = 13269, e2.squaremm = 13212, e2.squaremsquared = 13217, e2.squareorthogonalcrosshatchfill = 9638, e2.squareupperlefttolowerrightfill = 9639, e2.squareupperrighttolowerleftfill = 9640, e2.squareverticalfill = 9637, e2.squarewhitewithsmallblack = 9635, e2.srsquare = 13275, e2.ssabengali = 2487, e2.ssadeva = 2359, e2.ssagujarati = 2743, e2.ssangcieuckorean = 12617, e2.ssanghieuhkorean = 12677, e2.ssangieungkorean = 12672, e2.ssangkiyeokkorean = 12594, e2.ssangnieunkorean = 12645, e2.ssangpieupkorean = 12611, e2.ssangsioskorean = 12614, e2.ssangtikeutkorean = 12600, e2.ssuperior = 63218, e2.sterling = 163, e2.sterlingmonospace = 65505, e2.strokelongoverlaycmb = 822, e2.strokeshortoverlaycmb = 821, e2.subset = 8834, e2.subsetnotequal = 8842, e2.subsetorequal = 8838, e2.succeeds = 8827, e2.suchthat = 8715, e2.suhiragana = 12377, e2.sukatakana = 12473, e2.sukatakanahalfwidth = 65405, e2.sukunarabic = 1618, e2.summation = 8721, e2.sun = 9788, e2.superset = 8835, e2.supersetnotequal = 8843, e2.supersetorequal = 8839, e2.svsquare = 13276, e2.syouwaerasquare = 13180, e2.t = 116, e2.tabengali = 2468, e2.tackdown = 8868, e2.tackleft = 8867, e2.tadeva = 2340, e2.tagujarati = 2724, e2.tagurmukhi = 2596, e2.taharabic = 1591, e2.tahfinalarabic = 65218, e2.tahinitialarabic = 65219, e2.tahiragana = 12383, e2.tahmedialarabic = 65220, e2.taisyouerasquare = 13181, e2.takatakana = 12479, e2.takatakanahalfwidth = 65408, e2.tatweelarabic = 1600, e2.tau = 964, e2.tav = 1514, e2.tavdages = 64330, e2.tavdagesh = 64330, e2.tavdageshhebrew = 64330, e2.tavhebrew = 1514, e2.tbar = 359, e2.tbopomofo = 12554, e2.tcaron = 357, e2.tccurl = 680, e2.tcedilla = 355, e2.tcheharabic = 1670, e2.tchehfinalarabic = 64379, e2.tchehinitialarabic = 64380, e2.tchehmedialarabic = 64381, e2.tcircle = 9443, e2.tcircumflexbelow = 7793, e2.tcommaaccent = 355, e2.tdieresis = 7831, e2.tdotaccent = 7787, e2.tdotbelow = 7789, e2.tecyrillic = 1090, e2.tedescendercyrillic = 1197, e2.teharabic = 1578, e2.tehfinalarabic = 65174, e2.tehhahinitialarabic = 64674, e2.tehhahisolatedarabic = 64524, e2.tehinitialarabic = 65175, e2.tehiragana = 12390, e2.tehjeeminitialarabic = 64673, e2.tehjeemisolatedarabic = 64523, e2.tehmarbutaarabic = 1577, e2.tehmarbutafinalarabic = 65172, e2.tehmedialarabic = 65176, e2.tehmeeminitialarabic = 64676, e2.tehmeemisolatedarabic = 64526, e2.tehnoonfinalarabic = 64627, e2.tekatakana = 12486, e2.tekatakanahalfwidth = 65411, e2.telephone = 8481, e2.telephoneblack = 9742, e2.telishagedolahebrew = 1440, e2.telishaqetanahebrew = 1449, e2.tencircle = 9321, e2.tenideographicparen = 12841, e2.tenparen = 9341, e2.tenperiod = 9361, e2.tenroman = 8569, e2.tesh = 679, e2.tet = 1496, e2.tetdagesh = 64312, e2.tetdageshhebrew = 64312, e2.tethebrew = 1496, e2.tetsecyrillic = 1205, e2.tevirhebrew = 1435, e2.tevirlefthebrew = 1435, e2.thabengali = 2469, e2.thadeva = 2341, e2.thagujarati = 2725, e2.thagurmukhi = 2597, e2.thalarabic = 1584, e2.thalfinalarabic = 65196, e2.thanthakhatlowleftthai = 63640, e2.thanthakhatlowrightthai = 63639, e2.thanthakhatthai = 3660, e2.thanthakhatupperleftthai = 63638, e2.theharabic = 1579, e2.thehfinalarabic = 65178, e2.thehinitialarabic = 65179, e2.thehmedialarabic = 65180, e2.thereexists = 8707, e2.therefore = 8756, e2.theta = 952, e2.theta1 = 977, e2.thetasymbolgreek = 977, e2.thieuthacirclekorean = 12921, e2.thieuthaparenkorean = 12825, e2.thieuthcirclekorean = 12907, e2.thieuthkorean = 12620, e2.thieuthparenkorean = 12811, e2.thirteencircle = 9324, e2.thirteenparen = 9344, e2.thirteenperiod = 9364, e2.thonangmonthothai = 3601, e2.thook = 429, e2.thophuthaothai = 3602, e2.thorn = 254, e2.thothahanthai = 3607, e2.thothanthai = 3600, e2.thothongthai = 3608, e2.thothungthai = 3606, e2.thousandcyrillic = 1154, e2.thousandsseparatorarabic = 1644, e2.thousandsseparatorpersian = 1644, e2.three = 51, e2.threearabic = 1635, e2.threebengali = 2537, e2.threecircle = 9314, e2.threecircleinversesansserif = 10124, e2.threedeva = 2409, e2.threeeighths = 8540, e2.threegujarati = 2793, e2.threegurmukhi = 2665, e2.threehackarabic = 1635, e2.threehangzhou = 12323, e2.threeideographicparen = 12834, e2.threeinferior = 8323, e2.threemonospace = 65299, e2.threenumeratorbengali = 2550, e2.threeoldstyle = 63283, e2.threeparen = 9334, e2.threeperiod = 9354, e2.threepersian = 1779, e2.threequarters = 190, e2.threequartersemdash = 63198, e2.threeroman = 8562, e2.threesuperior = 179, e2.threethai = 3667, e2.thzsquare = 13204, e2.tihiragana = 12385, e2.tikatakana = 12481, e2.tikatakanahalfwidth = 65409, e2.tikeutacirclekorean = 12912, e2.tikeutaparenkorean = 12816, e2.tikeutcirclekorean = 12898, e2.tikeutkorean = 12599, e2.tikeutparenkorean = 12802, e2.tilde = 732, e2.tildebelowcmb = 816, e2.tildecmb = 771, e2.tildecomb = 771, e2.tildedoublecmb = 864, e2.tildeoperator = 8764, e2.tildeoverlaycmb = 820, e2.tildeverticalcmb = 830, e2.timescircle = 8855, e2.tipehahebrew = 1430, e2.tipehalefthebrew = 1430, e2.tippigurmukhi = 2672, e2.titlocyrilliccmb = 1155, e2.tiwnarmenian = 1407, e2.tlinebelow = 7791, e2.tmonospace = 65364, e2.toarmenian = 1385, e2.tohiragana = 12392, e2.tokatakana = 12488, e2.tokatakanahalfwidth = 65412, e2.tonebarextrahighmod = 741, e2.tonebarextralowmod = 745, e2.tonebarhighmod = 742, e2.tonebarlowmod = 744, e2.tonebarmidmod = 743, e2.tonefive = 445, e2.tonesix = 389, e2.tonetwo = 424, e2.tonos = 900, e2.tonsquare = 13095, e2.topatakthai = 3599, e2.tortoiseshellbracketleft = 12308, e2.tortoiseshellbracketleftsmall = 65117, e2.tortoiseshellbracketleftvertical = 65081, e2.tortoiseshellbracketright = 12309, e2.tortoiseshellbracketrightsmall = 65118, e2.tortoiseshellbracketrightvertical = 65082, e2.totaothai = 3605, e2.tpalatalhook = 427, e2.tparen = 9391, e2.trademark = 8482, e2.trademarksans = 63722, e2.trademarkserif = 63195, e2.tretroflexhook = 648, e2.triagdn = 9660, e2.triaglf = 9668, e2.triagrt = 9658, e2.triagup = 9650, e2.ts = 678, e2.tsadi = 1510, e2.tsadidagesh = 64326, e2.tsadidageshhebrew = 64326, e2.tsadihebrew = 1510, e2.tsecyrillic = 1094, e2.tsere = 1461, e2.tsere12 = 1461, e2.tsere1e = 1461, e2.tsere2b = 1461, e2.tserehebrew = 1461, e2.tserenarrowhebrew = 1461, e2.tserequarterhebrew = 1461, e2.tserewidehebrew = 1461, e2.tshecyrillic = 1115, e2.tsuperior = 63219, e2.ttabengali = 2463, e2.ttadeva = 2335, e2.ttagujarati = 2719, e2.ttagurmukhi = 2591, e2.tteharabic = 1657, e2.ttehfinalarabic = 64359, e2.ttehinitialarabic = 64360, e2.ttehmedialarabic = 64361, e2.tthabengali = 2464, e2.tthadeva = 2336, e2.tthagujarati = 2720, e2.tthagurmukhi = 2592, e2.tturned = 647, e2.tuhiragana = 12388, e2.tukatakana = 12484, e2.tukatakanahalfwidth = 65410, e2.tusmallhiragana = 12387, e2.tusmallkatakana = 12483, e2.tusmallkatakanahalfwidth = 65391, e2.twelvecircle = 9323, e2.twelveparen = 9343, e2.twelveperiod = 9363, e2.twelveroman = 8571, e2.twentycircle = 9331, e2.twentyhangzhou = 21316, e2.twentyparen = 9351, e2.twentyperiod = 9371, e2.two = 50, e2.twoarabic = 1634, e2.twobengali = 2536, e2.twocircle = 9313, e2.twocircleinversesansserif = 10123, e2.twodeva = 2408, e2.twodotenleader = 8229, e2.twodotleader = 8229, e2.twodotleadervertical = 65072, e2.twogujarati = 2792, e2.twogurmukhi = 2664, e2.twohackarabic = 1634, e2.twohangzhou = 12322, e2.twoideographicparen = 12833, e2.twoinferior = 8322, e2.twomonospace = 65298, e2.twonumeratorbengali = 2549, e2.twooldstyle = 63282, e2.twoparen = 9333, e2.twoperiod = 9353, e2.twopersian = 1778, e2.tworoman = 8561, e2.twostroke = 443, e2.twosuperior = 178, e2.twothai = 3666, e2.twothirds = 8532, e2.u = 117, e2.uacute = 250, e2.ubar = 649, e2.ubengali = 2441, e2.ubopomofo = 12584, e2.ubreve = 365, e2.ucaron = 468, e2.ucircle = 9444, e2.ucircumflex = 251, e2.ucircumflexbelow = 7799, e2.ucyrillic = 1091, e2.udattadeva = 2385, e2.udblacute = 369, e2.udblgrave = 533, e2.udeva = 2313, e2.udieresis = 252, e2.udieresisacute = 472, e2.udieresisbelow = 7795, e2.udieresiscaron = 474, e2.udieresiscyrillic = 1265, e2.udieresisgrave = 476, e2.udieresismacron = 470, e2.udotbelow = 7909, e2.ugrave = 249, e2.ugujarati = 2697, e2.ugurmukhi = 2569, e2.uhiragana = 12358, e2.uhookabove = 7911, e2.uhorn = 432, e2.uhornacute = 7913, e2.uhorndotbelow = 7921, e2.uhorngrave = 7915, e2.uhornhookabove = 7917, e2.uhorntilde = 7919, e2.uhungarumlaut = 369, e2.uhungarumlautcyrillic = 1267, e2.uinvertedbreve = 535, e2.ukatakana = 12454, e2.ukatakanahalfwidth = 65395, e2.ukcyrillic = 1145, e2.ukorean = 12636, e2.umacron = 363, e2.umacroncyrillic = 1263, e2.umacrondieresis = 7803, e2.umatragurmukhi = 2625, e2.umonospace = 65365, e2.underscore = 95, e2.underscoredbl = 8215, e2.underscoremonospace = 65343, e2.underscorevertical = 65075, e2.underscorewavy = 65103, e2.union = 8746, e2.universal = 8704, e2.uogonek = 371, e2.uparen = 9392, e2.upblock = 9600, e2.upperdothebrew = 1476, e2.upsilon = 965, e2.upsilondieresis = 971, e2.upsilondieresistonos = 944, e2.upsilonlatin = 650, e2.upsilontonos = 973, e2.uptackbelowcmb = 797, e2.uptackmod = 724, e2.uragurmukhi = 2675, e2.uring = 367, e2.ushortcyrillic = 1118, e2.usmallhiragana = 12357, e2.usmallkatakana = 12453, e2.usmallkatakanahalfwidth = 65385, e2.ustraightcyrillic = 1199, e2.ustraightstrokecyrillic = 1201, e2.utilde = 361, e2.utildeacute = 7801, e2.utildebelow = 7797, e2.uubengali = 2442, e2.uudeva = 2314, e2.uugujarati = 2698, e2.uugurmukhi = 2570, e2.uumatragurmukhi = 2626, e2.uuvowelsignbengali = 2498, e2.uuvowelsigndeva = 2370, e2.uuvowelsigngujarati = 2754, e2.uvowelsignbengali = 2497, e2.uvowelsigndeva = 2369, e2.uvowelsigngujarati = 2753, e2.v = 118, e2.vadeva = 2357, e2.vagujarati = 2741, e2.vagurmukhi = 2613, e2.vakatakana = 12535, e2.vav = 1493, e2.vavdagesh = 64309, e2.vavdagesh65 = 64309, e2.vavdageshhebrew = 64309, e2.vavhebrew = 1493, e2.vavholam = 64331, e2.vavholamhebrew = 64331, e2.vavvavhebrew = 1520, e2.vavyodhebrew = 1521, e2.vcircle = 9445, e2.vdotbelow = 7807, e2.vecyrillic = 1074, e2.veharabic = 1700, e2.vehfinalarabic = 64363, e2.vehinitialarabic = 64364, e2.vehmedialarabic = 64365, e2.vekatakana = 12537, e2.venus = 9792, e2.verticalbar = 124, e2.verticallineabovecmb = 781, e2.verticallinebelowcmb = 809, e2.verticallinelowmod = 716, e2.verticallinemod = 712, e2.vewarmenian = 1406, e2.vhook = 651, e2.vikatakana = 12536, e2.viramabengali = 2509, e2.viramadeva = 2381, e2.viramagujarati = 2765, e2.visargabengali = 2435, e2.visargadeva = 2307, e2.visargagujarati = 2691, e2.vmonospace = 65366, e2.voarmenian = 1400, e2.voicediterationhiragana = 12446, e2.voicediterationkatakana = 12542, e2.voicedmarkkana = 12443, e2.voicedmarkkanahalfwidth = 65438, e2.vokatakana = 12538, e2.vparen = 9393, e2.vtilde = 7805, e2.vturned = 652, e2.vuhiragana = 12436, e2.vukatakana = 12532, e2.w = 119, e2.wacute = 7811, e2.waekorean = 12633, e2.wahiragana = 12431, e2.wakatakana = 12527, e2.wakatakanahalfwidth = 65436, e2.wakorean = 12632, e2.wasmallhiragana = 12430, e2.wasmallkatakana = 12526, e2.wattosquare = 13143, e2.wavedash = 12316, e2.wavyunderscorevertical = 65076, e2.wawarabic = 1608, e2.wawfinalarabic = 65262, e2.wawhamzaabovearabic = 1572, e2.wawhamzaabovefinalarabic = 65158, e2.wbsquare = 13277, e2.wcircle = 9446, e2.wcircumflex = 373, e2.wdieresis = 7813, e2.wdotaccent = 7815, e2.wdotbelow = 7817, e2.wehiragana = 12433, e2.weierstrass = 8472, e2.wekatakana = 12529, e2.wekorean = 12638, e2.weokorean = 12637, e2.wgrave = 7809, e2.whitebullet = 9702, e2.whitecircle = 9675, e2.whitecircleinverse = 9689, e2.whitecornerbracketleft = 12302, e2.whitecornerbracketleftvertical = 65091, e2.whitecornerbracketright = 12303, e2.whitecornerbracketrightvertical = 65092, e2.whitediamond = 9671, e2.whitediamondcontainingblacksmalldiamond = 9672, e2.whitedownpointingsmalltriangle = 9663;
  e2.whitedownpointingtriangle = 9661, e2.whiteleftpointingsmalltriangle = 9667, e2.whiteleftpointingtriangle = 9665, e2.whitelenticularbracketleft = 12310, e2.whitelenticularbracketright = 12311, e2.whiterightpointingsmalltriangle = 9657, e2.whiterightpointingtriangle = 9655, e2.whitesmallsquare = 9643, e2.whitesmilingface = 9786, e2.whitesquare = 9633, e2.whitestar = 9734, e2.whitetelephone = 9743, e2.whitetortoiseshellbracketleft = 12312, e2.whitetortoiseshellbracketright = 12313, e2.whiteuppointingsmalltriangle = 9653, e2.whiteuppointingtriangle = 9651, e2.wihiragana = 12432, e2.wikatakana = 12528, e2.wikorean = 12639, e2.wmonospace = 65367, e2.wohiragana = 12434, e2.wokatakana = 12530, e2.wokatakanahalfwidth = 65382, e2.won = 8361, e2.wonmonospace = 65510, e2.wowaenthai = 3623, e2.wparen = 9394, e2.wring = 7832, e2.wsuperior = 695, e2.wturned = 653, e2.wynn = 447, e2.x = 120, e2.xabovecmb = 829, e2.xbopomofo = 12562, e2.xcircle = 9447, e2.xdieresis = 7821, e2.xdotaccent = 7819, e2.xeharmenian = 1389, e2.xi = 958, e2.xmonospace = 65368, e2.xparen = 9395, e2.xsuperior = 739, e2.y = 121, e2.yaadosquare = 13134, e2.yabengali = 2479, e2.yacute = 253, e2.yadeva = 2351, e2.yaekorean = 12626, e2.yagujarati = 2735, e2.yagurmukhi = 2607, e2.yahiragana = 12420, e2.yakatakana = 12516, e2.yakatakanahalfwidth = 65428, e2.yakorean = 12625, e2.yamakkanthai = 3662, e2.yasmallhiragana = 12419, e2.yasmallkatakana = 12515, e2.yasmallkatakanahalfwidth = 65388, e2.yatcyrillic = 1123, e2.ycircle = 9448, e2.ycircumflex = 375, e2.ydieresis = 255, e2.ydotaccent = 7823, e2.ydotbelow = 7925, e2.yeharabic = 1610, e2.yehbarreearabic = 1746, e2.yehbarreefinalarabic = 64431, e2.yehfinalarabic = 65266, e2.yehhamzaabovearabic = 1574, e2.yehhamzaabovefinalarabic = 65162, e2.yehhamzaaboveinitialarabic = 65163, e2.yehhamzaabovemedialarabic = 65164, e2.yehinitialarabic = 65267, e2.yehmedialarabic = 65268, e2.yehmeeminitialarabic = 64733, e2.yehmeemisolatedarabic = 64600, e2.yehnoonfinalarabic = 64660, e2.yehthreedotsbelowarabic = 1745, e2.yekorean = 12630, e2.yen = 165, e2.yenmonospace = 65509, e2.yeokorean = 12629, e2.yeorinhieuhkorean = 12678, e2.yerahbenyomohebrew = 1450, e2.yerahbenyomolefthebrew = 1450, e2.yericyrillic = 1099, e2.yerudieresiscyrillic = 1273, e2.yesieungkorean = 12673, e2.yesieungpansioskorean = 12675, e2.yesieungsioskorean = 12674, e2.yetivhebrew = 1434, e2.ygrave = 7923, e2.yhook = 436, e2.yhookabove = 7927, e2.yiarmenian = 1397, e2.yicyrillic = 1111, e2.yikorean = 12642, e2.yinyang = 9775, e2.yiwnarmenian = 1410, e2.ymonospace = 65369, e2.yod = 1497, e2.yoddagesh = 64313, e2.yoddageshhebrew = 64313, e2.yodhebrew = 1497, e2.yodyodhebrew = 1522, e2.yodyodpatahhebrew = 64287, e2.yohiragana = 12424, e2.yoikorean = 12681, e2.yokatakana = 12520, e2.yokatakanahalfwidth = 65430, e2.yokorean = 12635, e2.yosmallhiragana = 12423, e2.yosmallkatakana = 12519, e2.yosmallkatakanahalfwidth = 65390, e2.yotgreek = 1011, e2.yoyaekorean = 12680, e2.yoyakorean = 12679, e2.yoyakthai = 3618, e2.yoyingthai = 3597, e2.yparen = 9396, e2.ypogegrammeni = 890, e2.ypogegrammenigreekcmb = 837, e2.yr = 422, e2.yring = 7833, e2.ysuperior = 696, e2.ytilde = 7929, e2.yturned = 654, e2.yuhiragana = 12422, e2.yuikorean = 12684, e2.yukatakana = 12518, e2.yukatakanahalfwidth = 65429, e2.yukorean = 12640, e2.yusbigcyrillic = 1131, e2.yusbigiotifiedcyrillic = 1133, e2.yuslittlecyrillic = 1127, e2.yuslittleiotifiedcyrillic = 1129, e2.yusmallhiragana = 12421, e2.yusmallkatakana = 12517, e2.yusmallkatakanahalfwidth = 65389, e2.yuyekorean = 12683, e2.yuyeokorean = 12682, e2.yyabengali = 2527, e2.yyadeva = 2399, e2.z = 122, e2.zaarmenian = 1382, e2.zacute = 378, e2.zadeva = 2395, e2.zagurmukhi = 2651, e2.zaharabic = 1592, e2.zahfinalarabic = 65222, e2.zahinitialarabic = 65223, e2.zahiragana = 12374, e2.zahmedialarabic = 65224, e2.zainarabic = 1586, e2.zainfinalarabic = 65200, e2.zakatakana = 12470, e2.zaqefgadolhebrew = 1429, e2.zaqefqatanhebrew = 1428, e2.zarqahebrew = 1432, e2.zayin = 1494, e2.zayindagesh = 64310, e2.zayindageshhebrew = 64310, e2.zayinhebrew = 1494, e2.zbopomofo = 12567, e2.zcaron = 382, e2.zcircle = 9449, e2.zcircumflex = 7825, e2.zcurl = 657, e2.zdot = 380, e2.zdotaccent = 380, e2.zdotbelow = 7827, e2.zecyrillic = 1079, e2.zedescendercyrillic = 1177, e2.zedieresiscyrillic = 1247, e2.zehiragana = 12380, e2.zekatakana = 12476, e2.zero = 48, e2.zeroarabic = 1632, e2.zerobengali = 2534, e2.zerodeva = 2406, e2.zerogujarati = 2790, e2.zerogurmukhi = 2662, e2.zerohackarabic = 1632, e2.zeroinferior = 8320, e2.zeromonospace = 65296, e2.zerooldstyle = 63280, e2.zeropersian = 1776, e2.zerosuperior = 8304, e2.zerothai = 3664, e2.zerowidthjoiner = 65279, e2.zerowidthnonjoiner = 8204, e2.zerowidthspace = 8203, e2.zeta = 950, e2.zhbopomofo = 12563, e2.zhearmenian = 1386, e2.zhebrevecyrillic = 1218, e2.zhecyrillic = 1078, e2.zhedescendercyrillic = 1175, e2.zhedieresiscyrillic = 1245, e2.zihiragana = 12376, e2.zikatakana = 12472, e2.zinorhebrew = 1454, e2.zlinebelow = 7829, e2.zmonospace = 65370, e2.zohiragana = 12382, e2.zokatakana = 12478, e2.zparen = 9397, e2.zretroflexhook = 656, e2.zstroke = 438, e2.zuhiragana = 12378, e2.zukatakana = 12474, e2[".notdef"] = 0, e2.angbracketleftbig = 9001, e2.angbracketleftBig = 9001, e2.angbracketleftbigg = 9001, e2.angbracketleftBigg = 9001, e2.angbracketrightBig = 9002, e2.angbracketrightbig = 9002, e2.angbracketrightBigg = 9002, e2.angbracketrightbigg = 9002, e2.arrowhookleft = 8618, e2.arrowhookright = 8617, e2.arrowlefttophalf = 8636, e2.arrowleftbothalf = 8637, e2.arrownortheast = 8599, e2.arrownorthwest = 8598, e2.arrowrighttophalf = 8640, e2.arrowrightbothalf = 8641, e2.arrowsoutheast = 8600, e2.arrowsouthwest = 8601, e2.backslashbig = 8726, e2.backslashBig = 8726, e2.backslashBigg = 8726, e2.backslashbigg = 8726, e2.bardbl = 8214, e2.bracehtipdownleft = 65079, e2.bracehtipdownright = 65079, e2.bracehtipupleft = 65080, e2.bracehtipupright = 65080, e2.braceleftBig = 123, e2.braceleftbig = 123, e2.braceleftbigg = 123, e2.braceleftBigg = 123, e2.bracerightBig = 125, e2.bracerightbig = 125, e2.bracerightbigg = 125, e2.bracerightBigg = 125, e2.bracketleftbig = 91, e2.bracketleftBig = 91, e2.bracketleftbigg = 91, e2.bracketleftBigg = 91, e2.bracketrightBig = 93, e2.bracketrightbig = 93, e2.bracketrightbigg = 93, e2.bracketrightBigg = 93, e2.ceilingleftbig = 8968, e2.ceilingleftBig = 8968, e2.ceilingleftBigg = 8968, e2.ceilingleftbigg = 8968, e2.ceilingrightbig = 8969, e2.ceilingrightBig = 8969, e2.ceilingrightbigg = 8969, e2.ceilingrightBigg = 8969, e2.circledotdisplay = 8857, e2.circledottext = 8857, e2.circlemultiplydisplay = 8855, e2.circlemultiplytext = 8855, e2.circleplusdisplay = 8853, e2.circleplustext = 8853, e2.contintegraldisplay = 8750, e2.contintegraltext = 8750, e2.coproductdisplay = 8720, e2.coproducttext = 8720, e2.floorleftBig = 8970, e2.floorleftbig = 8970, e2.floorleftbigg = 8970, e2.floorleftBigg = 8970, e2.floorrightbig = 8971, e2.floorrightBig = 8971, e2.floorrightBigg = 8971, e2.floorrightbigg = 8971, e2.hatwide = 770, e2.hatwider = 770, e2.hatwidest = 770, e2.intercal = 7488, e2.integraldisplay = 8747, e2.integraltext = 8747, e2.intersectiondisplay = 8898, e2.intersectiontext = 8898, e2.logicalanddisplay = 8743, e2.logicalandtext = 8743, e2.logicalordisplay = 8744, e2.logicalortext = 8744, e2.parenleftBig = 40, e2.parenleftbig = 40, e2.parenleftBigg = 40, e2.parenleftbigg = 40, e2.parenrightBig = 41, e2.parenrightbig = 41, e2.parenrightBigg = 41, e2.parenrightbigg = 41, e2.prime = 8242, e2.productdisplay = 8719, e2.producttext = 8719, e2.radicalbig = 8730, e2.radicalBig = 8730, e2.radicalBigg = 8730, e2.radicalbigg = 8730, e2.radicalbt = 8730, e2.radicaltp = 8730, e2.radicalvertex = 8730, e2.slashbig = 47, e2.slashBig = 47, e2.slashBigg = 47, e2.slashbigg = 47, e2.summationdisplay = 8721, e2.summationtext = 8721, e2.tildewide = 732, e2.tildewider = 732, e2.tildewidest = 732, e2.uniondisplay = 8899, e2.unionmultidisplay = 8846, e2.unionmultitext = 8846, e2.unionsqdisplay = 8852, e2.unionsqtext = 8852, e2.uniontext = 8899, e2.vextenddouble = 8741, e2.vextendsingle = 8739;
}), bn = getLookupTableFactory(function(e2) {
  e2.space = 32, e2.a1 = 9985, e2.a2 = 9986, e2.a202 = 9987, e2.a3 = 9988, e2.a4 = 9742, e2.a5 = 9990, e2.a119 = 9991, e2.a118 = 9992, e2.a117 = 9993, e2.a11 = 9755, e2.a12 = 9758, e2.a13 = 9996, e2.a14 = 9997, e2.a15 = 9998, e2.a16 = 9999, e2.a105 = 1e4, e2.a17 = 10001, e2.a18 = 10002, e2.a19 = 10003, e2.a20 = 10004, e2.a21 = 10005, e2.a22 = 10006, e2.a23 = 10007, e2.a24 = 10008, e2.a25 = 10009, e2.a26 = 10010, e2.a27 = 10011, e2.a28 = 10012, e2.a6 = 10013, e2.a7 = 10014, e2.a8 = 10015, e2.a9 = 10016, e2.a10 = 10017, e2.a29 = 10018, e2.a30 = 10019, e2.a31 = 10020, e2.a32 = 10021, e2.a33 = 10022, e2.a34 = 10023, e2.a35 = 9733, e2.a36 = 10025, e2.a37 = 10026, e2.a38 = 10027, e2.a39 = 10028, e2.a40 = 10029, e2.a41 = 10030, e2.a42 = 10031, e2.a43 = 10032, e2.a44 = 10033, e2.a45 = 10034, e2.a46 = 10035, e2.a47 = 10036, e2.a48 = 10037, e2.a49 = 10038, e2.a50 = 10039, e2.a51 = 10040, e2.a52 = 10041, e2.a53 = 10042, e2.a54 = 10043, e2.a55 = 10044, e2.a56 = 10045, e2.a57 = 10046, e2.a58 = 10047, e2.a59 = 10048, e2.a60 = 10049, e2.a61 = 10050, e2.a62 = 10051, e2.a63 = 10052, e2.a64 = 10053, e2.a65 = 10054, e2.a66 = 10055, e2.a67 = 10056, e2.a68 = 10057, e2.a69 = 10058, e2.a70 = 10059, e2.a71 = 9679, e2.a72 = 10061, e2.a73 = 9632, e2.a74 = 10063, e2.a203 = 10064, e2.a75 = 10065, e2.a204 = 10066, e2.a76 = 9650, e2.a77 = 9660, e2.a78 = 9670, e2.a79 = 10070, e2.a81 = 9687, e2.a82 = 10072, e2.a83 = 10073, e2.a84 = 10074, e2.a97 = 10075, e2.a98 = 10076, e2.a99 = 10077, e2.a100 = 10078, e2.a101 = 10081, e2.a102 = 10082, e2.a103 = 10083, e2.a104 = 10084, e2.a106 = 10085, e2.a107 = 10086, e2.a108 = 10087, e2.a112 = 9827, e2.a111 = 9830, e2.a110 = 9829, e2.a109 = 9824, e2.a120 = 9312, e2.a121 = 9313, e2.a122 = 9314, e2.a123 = 9315, e2.a124 = 9316, e2.a125 = 9317, e2.a126 = 9318, e2.a127 = 9319, e2.a128 = 9320, e2.a129 = 9321, e2.a130 = 10102, e2.a131 = 10103, e2.a132 = 10104, e2.a133 = 10105, e2.a134 = 10106, e2.a135 = 10107, e2.a136 = 10108, e2.a137 = 10109, e2.a138 = 10110, e2.a139 = 10111, e2.a140 = 10112, e2.a141 = 10113, e2.a142 = 10114, e2.a143 = 10115, e2.a144 = 10116, e2.a145 = 10117, e2.a146 = 10118, e2.a147 = 10119, e2.a148 = 10120, e2.a149 = 10121, e2.a150 = 10122, e2.a151 = 10123, e2.a152 = 10124, e2.a153 = 10125, e2.a154 = 10126, e2.a155 = 10127, e2.a156 = 10128, e2.a157 = 10129, e2.a158 = 10130, e2.a159 = 10131, e2.a160 = 10132, e2.a161 = 8594, e2.a163 = 8596, e2.a164 = 8597, e2.a196 = 10136, e2.a165 = 10137, e2.a192 = 10138, e2.a166 = 10139, e2.a167 = 10140, e2.a168 = 10141, e2.a169 = 10142, e2.a170 = 10143, e2.a171 = 10144, e2.a172 = 10145, e2.a173 = 10146, e2.a162 = 10147, e2.a174 = 10148, e2.a175 = 10149, e2.a176 = 10150, e2.a177 = 10151, e2.a178 = 10152, e2.a179 = 10153, e2.a193 = 10154, e2.a180 = 10155, e2.a199 = 10156, e2.a181 = 10157, e2.a200 = 10158, e2.a182 = 10159, e2.a201 = 10161, e2.a183 = 10162, e2.a184 = 10163, e2.a197 = 10164, e2.a185 = 10165, e2.a194 = 10166, e2.a198 = 10167, e2.a186 = 10168, e2.a195 = 10169, e2.a187 = 10170, e2.a188 = 10171, e2.a189 = 10172, e2.a190 = 10173, e2.a191 = 10174, e2.a89 = 10088, e2.a90 = 10089, e2.a93 = 10090, e2.a94 = 10091, e2.a91 = 10092, e2.a92 = 10093, e2.a205 = 10094, e2.a85 = 10095, e2.a206 = 10096, e2.a86 = 10097, e2.a87 = 10098, e2.a88 = 10099, e2.a95 = 10100, e2.a96 = 10101, e2[".notdef"] = 0;
}), yn = getLookupTableFactory(function(e2) {
  e2[63721] = 169, e2[63193] = 169, e2[63720] = 174, e2[63194] = 174, e2[63722] = 8482, e2[63195] = 8482, e2[63729] = 9127, e2[63730] = 9128, e2[63731] = 9129, e2[63740] = 9131, e2[63741] = 9132, e2[63742] = 9133, e2[63726] = 9121, e2[63727] = 9122, e2[63728] = 9123, e2[63737] = 9124, e2[63738] = 9125, e2[63739] = 9126, e2[63723] = 9115, e2[63724] = 9116, e2[63725] = 9117, e2[63734] = 9118, e2[63735] = 9119, e2[63736] = 9120;
});
function getUnicodeForGlyph(e2, t2) {
  let i2 = t2[e2];
  if (void 0 !== i2) return i2;
  if (!e2) return -1;
  if ("u" === e2[0]) {
    const t3 = e2.length;
    let n2;
    if (7 === t3 && "n" === e2[1] && "i" === e2[2]) n2 = e2.substring(3);
    else {
      if (!(t3 >= 5 && t3 <= 7)) return -1;
      n2 = e2.substring(1);
    }
    if (n2 === n2.toUpperCase() && (i2 = parseInt(n2, 16), i2 >= 0)) return i2;
  }
  return -1;
}
const wn = [[0, 127], [128, 255], [256, 383], [384, 591], [592, 687, 7424, 7551, 7552, 7615], [688, 767, 42752, 42783], [768, 879, 7616, 7679], [880, 1023], [11392, 11519], [1024, 1279, 1280, 1327, 11744, 11775, 42560, 42655], [1328, 1423], [1424, 1535], [42240, 42559], [1536, 1791, 1872, 1919], [1984, 2047], [2304, 2431], [2432, 2559], [2560, 2687], [2688, 2815], [2816, 2943], [2944, 3071], [3072, 3199], [3200, 3327], [3328, 3455], [3584, 3711], [3712, 3839], [4256, 4351, 11520, 11567], [6912, 7039], [4352, 4607], [7680, 7935, 11360, 11391, 42784, 43007], [7936, 8191], [8192, 8303, 11776, 11903], [8304, 8351], [8352, 8399], [8400, 8447], [8448, 8527], [8528, 8591], [8592, 8703, 10224, 10239, 10496, 10623, 11008, 11263], [8704, 8959, 10752, 11007, 10176, 10223, 10624, 10751], [8960, 9215], [9216, 9279], [9280, 9311], [9312, 9471], [9472, 9599], [9600, 9631], [9632, 9727], [9728, 9983], [9984, 10175], [12288, 12351], [12352, 12447], [12448, 12543, 12784, 12799], [12544, 12591, 12704, 12735], [12592, 12687], [43072, 43135], [12800, 13055], [13056, 13311], [44032, 55215], [55296, 57343], [67840, 67871], [19968, 40959, 11904, 12031, 12032, 12255, 12272, 12287, 13312, 19903, 131072, 173791, 12688, 12703], [57344, 63743], [12736, 12783, 63744, 64255, 194560, 195103], [64256, 64335], [64336, 65023], [65056, 65071], [65040, 65055], [65104, 65135], [65136, 65279], [65280, 65519], [65520, 65535], [3840, 4095], [1792, 1871], [1920, 1983], [3456, 3583], [4096, 4255], [4608, 4991, 4992, 5023, 11648, 11743], [5024, 5119], [5120, 5759], [5760, 5791], [5792, 5887], [6016, 6143], [6144, 6319], [10240, 10495], [40960, 42127], [5888, 5919, 5920, 5951, 5952, 5983, 5984, 6015], [66304, 66351], [66352, 66383], [66560, 66639], [118784, 119039, 119040, 119295, 119296, 119375], [119808, 120831], [1044480, 1048573], [65024, 65039, 917760, 917999], [917504, 917631], [6400, 6479], [6480, 6527], [6528, 6623], [6656, 6687], [11264, 11359], [11568, 11647], [19904, 19967], [43008, 43055], [65536, 65663, 65664, 65791, 65792, 65855], [65856, 65935], [66432, 66463], [66464, 66527], [66640, 66687], [66688, 66735], [67584, 67647], [68096, 68191], [119552, 119647], [73728, 74751, 74752, 74879], [119648, 119679], [7040, 7103], [7168, 7247], [7248, 7295], [43136, 43231], [43264, 43311], [43312, 43359], [43520, 43615], [65936, 65999], [66e3, 66047], [66208, 66271, 66176, 66207, 67872, 67903], [127024, 127135, 126976, 127023]];
function getUnicodeRangeFor(e2, t2 = -1) {
  if (-1 !== t2) {
    const i2 = wn[t2];
    for (let n2 = 0, a2 = i2.length; n2 < a2; n2 += 2) if (e2 >= i2[n2] && e2 <= i2[n2 + 1]) return t2;
  }
  for (let t3 = 0, i2 = wn.length; t3 < i2; t3++) {
    const i3 = wn[t3];
    for (let n2 = 0, a2 = i3.length; n2 < a2; n2 += 2) if (e2 >= i3[n2] && e2 <= i3[n2 + 1]) return t3;
  }
  return -1;
}
const An = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u"), xn = /* @__PURE__ */ new Map();
const Sn = true, vn = 1, Cn = 2, kn = 4, Tn = 32, Fn = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
function recoverGlyphName(e2, t2) {
  if (void 0 !== t2[e2]) return e2;
  const i2 = getUnicodeForGlyph(e2, t2);
  if (-1 !== i2) {
    for (const e3 in t2) if (t2[e3] === i2) return e3;
  }
  return info$1("Unable to recover a standard glyph name for: " + e2), e2;
}
function type1FontGlyphMapping(e2, t2, i2) {
  const n2 = /* @__PURE__ */ Object.create(null);
  let a2, s2, r2;
  const o2 = !!(e2.flags & kn);
  if (e2.isInternalFont) for (r2 = t2, s2 = 0; s2 < r2.length; s2++) a2 = i2.indexOf(r2[s2]), n2[s2] = a2 >= 0 ? a2 : 0;
  else if (e2.baseEncodingName) for (r2 = getEncoding(e2.baseEncodingName), s2 = 0; s2 < r2.length; s2++) a2 = i2.indexOf(r2[s2]), n2[s2] = a2 >= 0 ? a2 : 0;
  else if (o2) for (s2 in t2) n2[s2] = t2[s2];
  else for (r2 = un, s2 = 0; s2 < r2.length; s2++) a2 = i2.indexOf(r2[s2]), n2[s2] = a2 >= 0 ? a2 : 0;
  const l2 = e2.differences;
  let c2;
  if (l2) for (s2 in l2) {
    const e3 = l2[s2];
    if (a2 = i2.indexOf(e3), -1 === a2) {
      c2 || (c2 = mn());
      const t3 = recoverGlyphName(e3, c2);
      t3 !== e3 && (a2 = i2.indexOf(t3));
    }
    n2[s2] = a2 >= 0 ? a2 : 0;
  }
  return n2;
}
function normalizeFontName(e2) {
  return e2.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
}
const In = getLookupTableFactory((e2) => {
  e2[8211] = 65074, e2[8212] = 65073, e2[8229] = 65072, e2[8230] = 65049, e2[12289] = 65041, e2[12290] = 65042, e2[12296] = 65087, e2[12297] = 65088, e2[12298] = 65085, e2[12299] = 65086, e2[12300] = 65089, e2[12301] = 65090, e2[12302] = 65091, e2[12303] = 65092, e2[12304] = 65083, e2[12305] = 65084, e2[12308] = 65081, e2[12309] = 65082, e2[12310] = 65047, e2[12311] = 65048, e2[65103] = 65076, e2[65281] = 65045, e2[65288] = 65077, e2[65289] = 65078, e2[65292] = 65040, e2[65306] = 65043, e2[65307] = 65044, e2[65311] = 65046, e2[65339] = 65095, e2[65341] = 65096, e2[65343] = 65075, e2[65371] = 65079, e2[65373] = 65080;
});
const En = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"], Mn = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"], Dn = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"], On = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"], _n = 391, Pn = [null, { id: "hstem", min: 2, stackClearing: true, stem: true }, null, { id: "vstem", min: 2, stackClearing: true, stem: true }, { id: "vmoveto", min: 1, stackClearing: true }, { id: "rlineto", min: 2, resetStack: true }, { id: "hlineto", min: 1, resetStack: true }, { id: "vlineto", min: 1, resetStack: true }, { id: "rrcurveto", min: 6, resetStack: true }, null, { id: "callsubr", min: 1, undefStack: true }, { id: "return", min: 0, undefStack: true }, null, null, { id: "endchar", min: 0, stackClearing: true }, null, null, null, { id: "hstemhm", min: 2, stackClearing: true, stem: true }, { id: "hintmask", min: 0, stackClearing: true }, { id: "cntrmask", min: 0, stackClearing: true }, { id: "rmoveto", min: 2, stackClearing: true }, { id: "hmoveto", min: 1, stackClearing: true }, { id: "vstemhm", min: 2, stackClearing: true, stem: true }, { id: "rcurveline", min: 8, resetStack: true }, { id: "rlinecurve", min: 8, resetStack: true }, { id: "vvcurveto", min: 4, resetStack: true }, { id: "hhcurveto", min: 4, resetStack: true }, null, { id: "callgsubr", min: 1, undefStack: true }, { id: "vhcurveto", min: 4, resetStack: true }, { id: "hvcurveto", min: 4, resetStack: true }], Rn = [null, null, null, { id: "and", min: 2, stackDelta: -1 }, { id: "or", min: 2, stackDelta: -1 }, { id: "not", min: 1, stackDelta: 0 }, null, null, null, { id: "abs", min: 1, stackDelta: 0 }, { id: "add", min: 2, stackDelta: -1, stackFn(e2, t2) {
  e2[t2 - 2] = e2[t2 - 2] + e2[t2 - 1];
} }, { id: "sub", min: 2, stackDelta: -1, stackFn(e2, t2) {
  e2[t2 - 2] = e2[t2 - 2] - e2[t2 - 1];
} }, { id: "div", min: 2, stackDelta: -1, stackFn(e2, t2) {
  e2[t2 - 2] = e2[t2 - 2] / e2[t2 - 1];
} }, null, { id: "neg", min: 1, stackDelta: 0, stackFn(e2, t2) {
  e2[t2 - 1] = -e2[t2 - 1];
} }, { id: "eq", min: 2, stackDelta: -1 }, null, null, { id: "drop", min: 1, stackDelta: -1 }, null, { id: "put", min: 2, stackDelta: -2 }, { id: "get", min: 1, stackDelta: 0 }, { id: "ifelse", min: 4, stackDelta: -3 }, { id: "random", min: 0, stackDelta: 1 }, { id: "mul", min: 2, stackDelta: -1, stackFn(e2, t2) {
  e2[t2 - 2] = e2[t2 - 2] * e2[t2 - 1];
} }, null, { id: "sqrt", min: 1, stackDelta: 0 }, { id: "dup", min: 1, stackDelta: 1 }, { id: "exch", min: 2, stackDelta: 0 }, { id: "index", min: 2, stackDelta: 0 }, { id: "roll", min: 3, stackDelta: -2 }, null, null, null, { id: "hflex", min: 7, resetStack: true }, { id: "flex", min: 13, resetStack: true }, { id: "hflex1", min: 9, resetStack: true }, { id: "flex1", min: 11, resetStack: true }];
class CFFParser {
  constructor(e2, t2, i2) {
    this.bytes = e2.getBytes(), this.properties = t2, this.seacAnalysisEnabled = !!i2;
  }
  parse() {
    const e2 = this.properties, t2 = new CFF();
    this.cff = t2;
    const i2 = this.parseHeader(), n2 = this.parseIndex(i2.endPos), a2 = this.parseIndex(n2.endPos), s2 = this.parseIndex(a2.endPos), r2 = this.parseIndex(s2.endPos), o2 = this.parseDict(a2.obj.get(0)), l2 = this.createDict(CFFTopDict, o2, t2.strings);
    t2.header = i2.obj, t2.names = this.parseNameIndex(n2.obj), t2.strings = this.parseStringIndex(s2.obj), t2.topDict = l2, t2.globalSubrIndex = r2.obj, this.parsePrivateDict(t2.topDict), t2.isCIDFont = l2.hasName("ROS");
    const c2 = l2.getByName("CharStrings"), h2 = this.parseIndex(c2).obj, d2 = l2.getByName("FontMatrix");
    d2 && (e2.fontMatrix = d2);
    const u2 = l2.getByName("FontBBox");
    let g2, f2;
    if (u2 && (e2.ascent = Math.max(u2[3], u2[1]), e2.descent = Math.min(u2[1], u2[3]), e2.ascentScaled = true), t2.isCIDFont) {
      const e3 = this.parseIndex(l2.getByName("FDArray")).obj;
      for (let i3 = 0, n3 = e3.count; i3 < n3; ++i3) {
        const n4 = e3.get(i3), a3 = this.createDict(CFFTopDict, this.parseDict(n4), t2.strings);
        this.parsePrivateDict(a3), t2.fdArray.push(a3);
      }
      f2 = null, g2 = this.parseCharsets(l2.getByName("charset"), h2.count, t2.strings, true), t2.fdSelect = this.parseFDSelect(l2.getByName("FDSelect"), h2.count);
    } else g2 = this.parseCharsets(l2.getByName("charset"), h2.count, t2.strings, false), f2 = this.parseEncoding(l2.getByName("Encoding"), e2, t2.strings, g2.charset);
    t2.charset = g2, t2.encoding = f2;
    const p2 = this.parseCharStrings({ charStrings: h2, localSubrIndex: l2.privateDict.subrsIndex, globalSubrIndex: r2.obj, fdSelect: t2.fdSelect, fdArray: t2.fdArray, privateDict: l2.privateDict });
    return t2.charStrings = p2.charStrings, t2.seacs = p2.seacs, t2.widths = p2.widths, t2;
  }
  parseHeader() {
    let e2 = this.bytes;
    const t2 = e2.length;
    let i2 = 0;
    for (; i2 < t2 && 1 !== e2[i2]; ) ++i2;
    if (i2 >= t2) throw new ti("Invalid CFF header");
    0 !== i2 && (info$1("cff data is shifted"), e2 = e2.subarray(i2), this.bytes = e2);
    const n2 = e2[0], a2 = e2[1], s2 = e2[2], r2 = e2[3];
    return { obj: new CFFHeader(n2, a2, s2, r2), endPos: s2 };
  }
  parseDict(e2) {
    let t2 = 0;
    function parseOperand() {
      let i3 = e2[t2++];
      return 30 === i3 ? (function() {
        let i4 = "";
        const n3 = 15, a3 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], s2 = e2.length;
        for (; t2 < s2; ) {
          const s3 = e2[t2++], r2 = s3 >> 4, o2 = 15 & s3;
          if (r2 === n3) break;
          if (i4 += a3[r2], o2 === n3) break;
          i4 += a3[o2];
        }
        return parseFloat(i4);
      })() : 28 === i3 ? (i3 = readInt16(e2, t2), t2 += 2, i3) : 29 === i3 ? (i3 = e2[t2++], i3 = i3 << 8 | e2[t2++], i3 = i3 << 8 | e2[t2++], i3 = i3 << 8 | e2[t2++], i3) : i3 >= 32 && i3 <= 246 ? i3 - 139 : i3 >= 247 && i3 <= 250 ? 256 * (i3 - 247) + e2[t2++] + 108 : i3 >= 251 && i3 <= 254 ? -256 * (i3 - 251) - e2[t2++] - 108 : (warn$1('CFFParser_parseDict: "' + i3 + '" is a reserved command.'), NaN);
    }
    let i2 = [];
    const n2 = [];
    t2 = 0;
    const a2 = e2.length;
    for (; t2 < a2; ) {
      let a3 = e2[t2];
      a3 <= 21 ? (12 === a3 && (a3 = a3 << 8 | e2[++t2]), n2.push([a3, i2]), i2 = [], ++t2) : i2.push(parseOperand());
    }
    return n2;
  }
  parseIndex(e2) {
    const t2 = new CFFIndex(), i2 = this.bytes, n2 = i2[e2++] << 8 | i2[e2++], a2 = [];
    let s2, r2, o2 = e2;
    if (0 !== n2) {
      const t3 = i2[e2++], l2 = e2 + (n2 + 1) * t3 - 1;
      for (s2 = 0, r2 = n2 + 1; s2 < r2; ++s2) {
        let n3 = 0;
        for (let a3 = 0; a3 < t3; ++a3) n3 <<= 8, n3 += i2[e2++];
        a2.push(l2 + n3);
      }
      o2 = a2[n2];
    }
    for (s2 = 0, r2 = a2.length - 1; s2 < r2; ++s2) {
      const e3 = a2[s2], n3 = a2[s2 + 1];
      t2.add(i2.subarray(e3, n3));
    }
    return { obj: t2, endPos: o2 };
  }
  parseNameIndex(e2) {
    const t2 = [];
    for (let i2 = 0, n2 = e2.count; i2 < n2; ++i2) {
      const n3 = e2.get(i2);
      t2.push(bytesToString$1(n3));
    }
    return t2;
  }
  parseStringIndex(e2) {
    const t2 = new CFFStrings();
    for (let i2 = 0, n2 = e2.count; i2 < n2; ++i2) {
      const n3 = e2.get(i2);
      t2.add(bytesToString$1(n3));
    }
    return t2;
  }
  createDict(e2, t2, i2) {
    const n2 = new e2(i2);
    for (const [e3, i3] of t2) n2.setByKey(e3, i3);
    return n2;
  }
  parseCharString(e2, t2, i2, n2) {
    if (!t2 || e2.callDepth > 10) return false;
    let a2 = e2.stackSize;
    const s2 = e2.stack;
    let r2 = t2.length;
    for (let o2 = 0; o2 < r2; ) {
      const l2 = t2[o2++];
      let c2 = null;
      if (12 === l2) {
        const e3 = t2[o2++];
        0 === e3 ? (t2[o2 - 2] = 139, t2[o2 - 1] = 22, a2 = 0) : c2 = Rn[e3];
      } else if (28 === l2) s2[a2] = readInt16(t2, o2), o2 += 2, a2++;
      else if (14 === l2) {
        if (a2 >= 4 && (a2 -= 4, this.seacAnalysisEnabled)) return e2.seac = s2.slice(a2, a2 + 4), false;
        c2 = Pn[l2];
      } else if (l2 >= 32 && l2 <= 246) s2[a2] = l2 - 139, a2++;
      else if (l2 >= 247 && l2 <= 254) s2[a2] = l2 < 251 ? (l2 - 247 << 8) + t2[o2] + 108 : -(l2 - 251 << 8) - t2[o2] - 108, o2++, a2++;
      else if (255 === l2) s2[a2] = (t2[o2] << 24 | t2[o2 + 1] << 16 | t2[o2 + 2] << 8 | t2[o2 + 3]) / 65536, o2 += 4, a2++;
      else if (19 === l2 || 20 === l2) {
        if (e2.hints += a2 >> 1, 0 === e2.hints) {
          t2.copyWithin(o2 - 1, o2, -1), o2 -= 1, r2 -= 1;
          continue;
        }
        o2 += e2.hints + 7 >> 3, a2 %= 2, c2 = Pn[l2];
      } else {
        if (10 === l2 || 29 === l2) {
          const t3 = 10 === l2 ? i2 : n2;
          if (!t3) return c2 = Pn[l2], warn$1("Missing subrsIndex for " + c2.id), false;
          let r3 = 32768;
          t3.count < 1240 ? r3 = 107 : t3.count < 33900 && (r3 = 1131);
          const o3 = s2[--a2] + r3;
          if (o3 < 0 || o3 >= t3.count || isNaN(o3)) return c2 = Pn[l2], warn$1("Out of bounds subrIndex for " + c2.id), false;
          e2.stackSize = a2, e2.callDepth++;
          if (!this.parseCharString(e2, t3.get(o3), i2, n2)) return false;
          e2.callDepth--, a2 = e2.stackSize;
          continue;
        }
        if (11 === l2) return e2.stackSize = a2, true;
        if (0 === l2 && o2 === t2.length) t2[o2 - 1] = 14, c2 = Pn[14];
        else {
          if (9 === l2) {
            t2.copyWithin(o2 - 1, o2, -1), o2 -= 1, r2 -= 1;
            continue;
          }
          c2 = Pn[l2];
        }
      }
      if (c2) {
        if (c2.stem && (e2.hints += a2 >> 1, 3 === l2 || 23 === l2 ? e2.hasVStems = true : !e2.hasVStems || 1 !== l2 && 18 !== l2 || (warn$1("CFF stem hints are in wrong order"), t2[o2 - 1] = 1 === l2 ? 3 : 23)), "min" in c2 && !e2.undefStack && a2 < c2.min) return warn$1("Not enough parameters for " + c2.id + "; actual: " + a2 + ", expected: " + c2.min), 0 === a2 && (t2[o2 - 1] = 14, true);
        e2.firstStackClearing && c2.stackClearing && (e2.firstStackClearing = false, a2 -= c2.min, a2 >= 2 && c2.stem ? a2 %= 2 : a2 > 1 && warn$1("Found too many parameters for stack-clearing command"), a2 > 0 && (e2.width = s2[a2 - 1])), "stackDelta" in c2 ? ("stackFn" in c2 && c2.stackFn(s2, a2), a2 += c2.stackDelta) : c2.stackClearing ? a2 = 0 : c2.resetStack ? (a2 = 0, e2.undefStack = false) : c2.undefStack && (a2 = 0, e2.undefStack = true, e2.firstStackClearing = false);
      }
    }
    return r2 < t2.length && t2.fill(14, r2), e2.stackSize = a2, true;
  }
  parseCharStrings({ charStrings: e2, localSubrIndex: t2, globalSubrIndex: i2, fdSelect: n2, fdArray: a2, privateDict: s2 }) {
    const r2 = [], o2 = [], l2 = e2.count;
    for (let c2 = 0; c2 < l2; c2++) {
      const l3 = e2.get(c2), h2 = { callDepth: 0, stackSize: 0, stack: [], undefStack: true, hints: 0, firstStackClearing: true, seac: null, width: null, hasVStems: false };
      let d2 = true, u2 = null, g2 = s2;
      if (n2 && a2.length) {
        const e3 = n2.getFDIndex(c2);
        -1 === e3 && (warn$1("Glyph index is not in fd select."), d2 = false), e3 >= a2.length && (warn$1("Invalid fd index for glyph index."), d2 = false), d2 && (g2 = a2[e3].privateDict, u2 = g2.subrsIndex);
      } else t2 && (u2 = t2);
      if (d2 && (d2 = this.parseCharString(h2, l3, u2, i2)), null !== h2.width) {
        const e3 = g2.getByName("nominalWidthX");
        o2[c2] = e3 + h2.width;
      } else {
        const e3 = g2.getByName("defaultWidthX");
        o2[c2] = e3;
      }
      null !== h2.seac && (r2[c2] = h2.seac), d2 || e2.set(c2, new Uint8Array([14]));
    }
    return { charStrings: e2, seacs: r2, widths: o2 };
  }
  emptyPrivateDictionary(e2) {
    const t2 = this.createDict(CFFPrivateDict, [], e2.strings);
    e2.setByKey(18, [0, 0]), e2.privateDict = t2;
  }
  parsePrivateDict(e2) {
    if (!e2.hasName("Private")) return void this.emptyPrivateDictionary(e2);
    const t2 = e2.getByName("Private");
    if (!Array.isArray(t2) || 2 !== t2.length) return void e2.removeByName("Private");
    const i2 = t2[0], n2 = t2[1];
    if (0 === i2 || n2 >= this.bytes.length) return void this.emptyPrivateDictionary(e2);
    const a2 = n2 + i2, s2 = this.bytes.subarray(n2, a2), r2 = this.parseDict(s2), o2 = this.createDict(CFFPrivateDict, r2, e2.strings);
    if (e2.privateDict = o2, 0 === o2.getByName("ExpansionFactor") && o2.setByName("ExpansionFactor", 0.06), !o2.getByName("Subrs")) return;
    const l2 = o2.getByName("Subrs"), c2 = n2 + l2;
    if (0 === l2 || c2 >= this.bytes.length) return void this.emptyPrivateDictionary(e2);
    const h2 = this.parseIndex(c2);
    o2.subrsIndex = h2.obj;
  }
  parseCharsets(e2, t2, i2, n2) {
    if (0 === e2) return new CFFCharset(true, Ln.ISO_ADOBE, En);
    if (1 === e2) return new CFFCharset(true, Ln.EXPERT, Mn);
    if (2 === e2) return new CFFCharset(true, Ln.EXPERT_SUBSET, Dn);
    const a2 = this.bytes, s2 = e2, r2 = a2[e2++], o2 = [n2 ? 0 : ".notdef"];
    let l2, c2, h2;
    switch (t2 -= 1, r2) {
      case 0:
        for (h2 = 0; h2 < t2; h2++) l2 = a2[e2++] << 8 | a2[e2++], o2.push(n2 ? l2 : i2.get(l2));
        break;
      case 1:
        for (; o2.length <= t2; ) for (l2 = a2[e2++] << 8 | a2[e2++], c2 = a2[e2++], h2 = 0; h2 <= c2; h2++) o2.push(n2 ? l2++ : i2.get(l2++));
        break;
      case 2:
        for (; o2.length <= t2; ) for (l2 = a2[e2++] << 8 | a2[e2++], c2 = a2[e2++] << 8 | a2[e2++], h2 = 0; h2 <= c2; h2++) o2.push(n2 ? l2++ : i2.get(l2++));
        break;
      default:
        throw new ti("Unknown charset format");
    }
    const d2 = e2, u2 = a2.subarray(s2, d2);
    return new CFFCharset(false, r2, o2, u2);
  }
  parseEncoding(e2, t2, i2, n2) {
    const a2 = /* @__PURE__ */ Object.create(null), s2 = this.bytes;
    let r2, o2, l2, c2 = false, h2 = null;
    if (0 === e2 || 1 === e2) {
      c2 = true, r2 = e2;
      const t3 = e2 ? cn : un;
      for (o2 = 0, l2 = n2.length; o2 < l2; o2++) {
        const e3 = t3.indexOf(n2[o2]);
        -1 !== e3 && (a2[e3] = o2);
      }
    } else {
      const t3 = e2;
      switch (r2 = s2[e2++], 127 & r2) {
        case 0:
          const t4 = s2[e2++];
          for (o2 = 1; o2 <= t4; o2++) a2[s2[e2++]] = o2;
          break;
        case 1:
          const i3 = s2[e2++];
          let n3 = 1;
          for (o2 = 0; o2 < i3; o2++) {
            const t5 = s2[e2++], i4 = s2[e2++];
            for (let e3 = t5; e3 <= t5 + i4; e3++) a2[e3] = n3++;
          }
          break;
        default:
          throw new ti(`Unknown encoding format: ${r2} in CFF`);
      }
      const l3 = e2;
      128 & r2 && (s2[t3] &= 127, (function() {
        const t4 = s2[e2++];
        for (o2 = 0; o2 < t4; o2++) {
          const t5 = s2[e2++], r3 = (s2[e2++] << 8) + (255 & s2[e2++]);
          a2[t5] = n2.indexOf(i2.get(r3));
        }
      })()), h2 = s2.subarray(t3, l3);
    }
    return r2 &= 127, new CFFEncoding(c2, r2, a2, h2);
  }
  parseFDSelect(e2, t2) {
    const i2 = this.bytes, n2 = i2[e2++], a2 = [];
    let s2;
    switch (n2) {
      case 0:
        for (s2 = 0; s2 < t2; ++s2) {
          const t3 = i2[e2++];
          a2.push(t3);
        }
        break;
      case 3:
        const r2 = i2[e2++] << 8 | i2[e2++];
        for (s2 = 0; s2 < r2; ++s2) {
          let t3 = i2[e2++] << 8 | i2[e2++];
          0 === s2 && 0 !== t3 && (warn$1("parseFDSelect: The first range must have a first GID of 0 -- trying to recover."), t3 = 0);
          const n3 = i2[e2++], r3 = i2[e2] << 8 | i2[e2 + 1];
          for (let e3 = t3; e3 < r3; ++e3) a2.push(n3);
        }
        e2 += 2;
        break;
      default:
        throw new ti(`parseFDSelect: Unknown format "${n2}".`);
    }
    if (a2.length !== t2) throw new ti("parseFDSelect: Invalid font data.");
    return new CFFFDSelect(n2, a2);
  }
}
class CFF {
  constructor() {
    this.header = null, this.names = [], this.topDict = null, this.strings = new CFFStrings(), this.globalSubrIndex = null, this.encoding = null, this.charset = null, this.charStrings = null, this.fdArray = [], this.fdSelect = null, this.isCIDFont = false;
  }
  duplicateFirstGlyph() {
    if (this.charStrings.count >= 65535) return void warn$1("Not enough space in charstrings to duplicate first glyph.");
    const e2 = this.charStrings.get(0);
    this.charStrings.add(e2), this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
  }
  hasGlyphId(e2) {
    if (e2 < 0 || e2 >= this.charStrings.count) return false;
    return this.charStrings.get(e2).length > 0;
  }
}
class CFFHeader {
  constructor(e2, t2, i2, n2) {
    this.major = e2, this.minor = t2, this.hdrSize = i2, this.offSize = n2;
  }
}
class CFFStrings {
  constructor() {
    this.strings = [];
  }
  get(e2) {
    return e2 >= 0 && e2 <= 390 ? On[e2] : e2 - _n <= this.strings.length ? this.strings[e2 - _n] : On[0];
  }
  getSID(e2) {
    let t2 = On.indexOf(e2);
    return -1 !== t2 ? t2 : (t2 = this.strings.indexOf(e2), -1 !== t2 ? t2 + _n : -1);
  }
  add(e2) {
    this.strings.push(e2);
  }
  get count() {
    return this.strings.length;
  }
}
class CFFIndex {
  constructor() {
    this.objects = [], this.length = 0;
  }
  add(e2) {
    this.length += e2.length, this.objects.push(e2);
  }
  set(e2, t2) {
    this.length += t2.length - this.objects[e2].length, this.objects[e2] = t2;
  }
  get(e2) {
    return this.objects[e2];
  }
  get count() {
    return this.objects.length;
  }
}
class CFFDict {
  constructor(e2, t2) {
    this.keyToNameMap = e2.keyToNameMap, this.nameToKeyMap = e2.nameToKeyMap, this.defaults = e2.defaults, this.types = e2.types, this.opcodes = e2.opcodes, this.order = e2.order, this.strings = t2, this.values = /* @__PURE__ */ Object.create(null);
  }
  setByKey(e2, t2) {
    if (!(e2 in this.keyToNameMap)) return false;
    if (0 === t2.length) return true;
    for (const i3 of t2) if (isNaN(i3)) return warn$1(`Invalid CFFDict value: "${t2}" for key "${e2}".`), true;
    const i2 = this.types[e2];
    return "num" !== i2 && "sid" !== i2 && "offset" !== i2 || (t2 = t2[0]), this.values[e2] = t2, true;
  }
  setByName(e2, t2) {
    if (!(e2 in this.nameToKeyMap)) throw new ti(`Invalid dictionary name "${e2}"`);
    this.values[this.nameToKeyMap[e2]] = t2;
  }
  hasName(e2) {
    return this.nameToKeyMap[e2] in this.values;
  }
  getByName(e2) {
    if (!(e2 in this.nameToKeyMap)) throw new ti(`Invalid dictionary name ${e2}"`);
    const t2 = this.nameToKeyMap[e2];
    return t2 in this.values ? this.values[t2] : this.defaults[t2];
  }
  removeByName(e2) {
    delete this.values[this.nameToKeyMap[e2]];
  }
  static createTables(e2) {
    const t2 = { keyToNameMap: {}, nameToKeyMap: {}, defaults: {}, types: {}, opcodes: {}, order: [] };
    for (const i2 of e2) {
      const e3 = Array.isArray(i2[0]) ? (i2[0][0] << 8) + i2[0][1] : i2[0];
      t2.keyToNameMap[e3] = i2[1], t2.nameToKeyMap[i2[1]] = e3, t2.types[e3] = i2[2], t2.defaults[e3] = i2[3], t2.opcodes[e3] = Array.isArray(i2[0]) ? i2[0] : [i2[0]], t2.order.push(e3);
    }
    return t2;
  }
}
const Bn = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
class CFFTopDict extends CFFDict {
  static get tables() {
    return shadow$1(this, "tables", this.createTables(Bn));
  }
  constructor(e2) {
    super(CFFTopDict.tables, e2), this.privateDict = null;
  }
}
const Nn = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
class CFFPrivateDict extends CFFDict {
  static get tables() {
    return shadow$1(this, "tables", this.createTables(Nn));
  }
  constructor(e2) {
    super(CFFPrivateDict.tables, e2), this.subrsIndex = null;
  }
}
const Ln = { ISO_ADOBE: 0, EXPERT: 1, EXPERT_SUBSET: 2 };
class CFFCharset {
  constructor(e2, t2, i2, n2) {
    this.predefined = e2, this.format = t2, this.charset = i2, this.raw = n2;
  }
}
class CFFEncoding {
  constructor(e2, t2, i2, n2) {
    this.predefined = e2, this.format = t2, this.encoding = i2, this.raw = n2;
  }
}
class CFFFDSelect {
  constructor(e2, t2) {
    this.format = e2, this.fdSelect = t2;
  }
  getFDIndex(e2) {
    return e2 < 0 || e2 >= this.fdSelect.length ? -1 : this.fdSelect[e2];
  }
}
class CFFOffsetTracker {
  constructor() {
    this.offsets = /* @__PURE__ */ Object.create(null);
  }
  isTracking(e2) {
    return e2 in this.offsets;
  }
  track(e2, t2) {
    if (e2 in this.offsets) throw new ti(`Already tracking location of ${e2}`);
    this.offsets[e2] = t2;
  }
  offset(e2) {
    for (const t2 in this.offsets) this.offsets[t2] += e2;
  }
  setEntryLocation(e2, t2, i2) {
    if (!(e2 in this.offsets)) throw new ti(`Not tracking location of ${e2}`);
    const n2 = i2.data, a2 = this.offsets[e2];
    for (let e3 = 0, i3 = t2.length; e3 < i3; ++e3) {
      const i4 = 5 * e3 + a2, s2 = i4 + 1, r2 = i4 + 2, o2 = i4 + 3, l2 = i4 + 4;
      if (29 !== n2[i4] || 0 !== n2[s2] || 0 !== n2[r2] || 0 !== n2[o2] || 0 !== n2[l2]) throw new ti("writing to an offset that is not empty");
      const c2 = t2[e3];
      n2[i4] = 29, n2[s2] = c2 >> 24 & 255, n2[r2] = c2 >> 16 & 255, n2[o2] = c2 >> 8 & 255, n2[l2] = 255 & c2;
    }
  }
}
class CFFCompiler {
  constructor(e2) {
    this.cff = e2;
  }
  compile() {
    const e2 = this.cff, t2 = { data: [], length: 0, add(e3) {
      try {
        this.data.push(...e3);
      } catch {
        this.data = this.data.concat(e3);
      }
      this.length = this.data.length;
    } }, i2 = this.compileHeader(e2.header);
    t2.add(i2);
    const n2 = this.compileNameIndex(e2.names);
    if (t2.add(n2), e2.isCIDFont && e2.topDict.hasName("FontMatrix")) {
      const t3 = e2.topDict.getByName("FontMatrix");
      e2.topDict.removeByName("FontMatrix");
      for (const i3 of e2.fdArray) {
        let e3 = t3.slice(0);
        i3.hasName("FontMatrix") && (e3 = ai.transform(e3, i3.getByName("FontMatrix"))), i3.setByName("FontMatrix", e3);
      }
    }
    const a2 = e2.topDict.getByName("XUID");
    a2?.length > 16 && e2.topDict.removeByName("XUID"), e2.topDict.setByName("charset", 0);
    let s2 = this.compileTopDicts([e2.topDict], t2.length, e2.isCIDFont);
    t2.add(s2.output);
    const r2 = s2.trackers[0], o2 = this.compileStringIndex(e2.strings.strings);
    t2.add(o2);
    const l2 = this.compileIndex(e2.globalSubrIndex);
    if (t2.add(l2), e2.encoding && e2.topDict.hasName("Encoding")) if (e2.encoding.predefined) r2.setEntryLocation("Encoding", [e2.encoding.format], t2);
    else {
      const i3 = this.compileEncoding(e2.encoding);
      r2.setEntryLocation("Encoding", [t2.length], t2), t2.add(i3);
    }
    const c2 = this.compileCharset(e2.charset, e2.charStrings.count, e2.strings, e2.isCIDFont);
    r2.setEntryLocation("charset", [t2.length], t2), t2.add(c2);
    const h2 = this.compileCharStrings(e2.charStrings);
    if (r2.setEntryLocation("CharStrings", [t2.length], t2), t2.add(h2), e2.isCIDFont) {
      r2.setEntryLocation("FDSelect", [t2.length], t2);
      const i3 = this.compileFDSelect(e2.fdSelect);
      t2.add(i3), s2 = this.compileTopDicts(e2.fdArray, t2.length, true), r2.setEntryLocation("FDArray", [t2.length], t2), t2.add(s2.output);
      const n3 = s2.trackers;
      this.compilePrivateDicts(e2.fdArray, n3, t2);
    }
    return this.compilePrivateDicts([e2.topDict], [r2], t2), t2.add([0]), t2.data;
  }
  encodeNumber(e2) {
    return Number.isInteger(e2) ? this.encodeInteger(e2) : this.encodeFloat(e2);
  }
  static get EncodeFloatRegExp() {
    return shadow$1(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
  }
  encodeFloat(e2) {
    let t2 = e2.toString();
    const i2 = CFFCompiler.EncodeFloatRegExp.exec(t2);
    if (i2) {
      const n3 = parseFloat("1e" + ((i2[2] ? +i2[2] : 0) + i2[1].length));
      t2 = (Math.round(e2 * n3) / n3).toString();
    }
    let n2, a2, s2 = "";
    for (n2 = 0, a2 = t2.length; n2 < a2; ++n2) {
      const e3 = t2[n2];
      s2 += "e" === e3 ? "-" === t2[++n2] ? "c" : "b" : "." === e3 ? "a" : "-" === e3 ? "e" : e3;
    }
    s2 += 1 & s2.length ? "f" : "ff";
    const r2 = [30];
    for (n2 = 0, a2 = s2.length; n2 < a2; n2 += 2) r2.push(parseInt(s2.substring(n2, n2 + 2), 16));
    return r2;
  }
  encodeInteger(e2) {
    let t2;
    return t2 = e2 >= -107 && e2 <= 107 ? [e2 + 139] : e2 >= 108 && e2 <= 1131 ? [247 + ((e2 -= 108) >> 8), 255 & e2] : e2 >= -1131 && e2 <= -108 ? [251 + ((e2 = -e2 - 108) >> 8), 255 & e2] : e2 >= -32768 && e2 <= 32767 ? [28, e2 >> 8 & 255, 255 & e2] : [29, e2 >> 24 & 255, e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2], t2;
  }
  compileHeader(e2) {
    return [e2.major, e2.minor, 4, e2.offSize];
  }
  compileNameIndex(e2) {
    const t2 = new CFFIndex();
    for (const i2 of e2) {
      const e3 = Math.min(i2.length, 127);
      let n2 = new Array(e3);
      for (let t3 = 0; t3 < e3; t3++) {
        let e4 = i2[t3];
        (e4 < "!" || e4 > "~" || "[" === e4 || "]" === e4 || "(" === e4 || ")" === e4 || "{" === e4 || "}" === e4 || "<" === e4 || ">" === e4 || "/" === e4 || "%" === e4) && (e4 = "_"), n2[t3] = e4;
      }
      n2 = n2.join(""), "" === n2 && (n2 = "Bad_Font_Name"), t2.add(stringToBytes$1(n2));
    }
    return this.compileIndex(t2);
  }
  compileTopDicts(e2, t2, i2) {
    const n2 = [];
    let a2 = new CFFIndex();
    for (const s2 of e2) {
      i2 && (s2.removeByName("CIDFontVersion"), s2.removeByName("CIDFontRevision"), s2.removeByName("CIDFontType"), s2.removeByName("CIDCount"), s2.removeByName("UIDBase"));
      const e3 = new CFFOffsetTracker(), r2 = this.compileDict(s2, e3);
      n2.push(e3), a2.add(r2), e3.offset(t2);
    }
    return a2 = this.compileIndex(a2, n2), { trackers: n2, output: a2 };
  }
  compilePrivateDicts(e2, t2, i2) {
    for (let n2 = 0, a2 = e2.length; n2 < a2; ++n2) {
      const a3 = e2[n2], s2 = a3.privateDict;
      if (!s2 || !a3.hasName("Private")) throw new ti("There must be a private dictionary.");
      const r2 = new CFFOffsetTracker(), o2 = this.compileDict(s2, r2);
      let l2 = i2.length;
      if (r2.offset(l2), o2.length || (l2 = 0), t2[n2].setEntryLocation("Private", [o2.length, l2], i2), i2.add(o2), s2.subrsIndex && s2.hasName("Subrs")) {
        const e3 = this.compileIndex(s2.subrsIndex);
        r2.setEntryLocation("Subrs", [o2.length], i2), i2.add(e3);
      }
    }
  }
  compileDict(e2, t2) {
    const i2 = [];
    for (const n2 of e2.order) {
      if (!(n2 in e2.values)) continue;
      let a2 = e2.values[n2], s2 = e2.types[n2];
      if (Array.isArray(s2) || (s2 = [s2]), Array.isArray(a2) || (a2 = [a2]), 0 !== a2.length) {
        for (let r2 = 0, o2 = s2.length; r2 < o2; ++r2) {
          const o3 = s2[r2], l2 = a2[r2];
          switch (o3) {
            case "num":
            case "sid":
              i2.push(...this.encodeNumber(l2));
              break;
            case "offset":
              const s3 = e2.keyToNameMap[n2];
              t2.isTracking(s3) || t2.track(s3, i2.length), i2.push(29, 0, 0, 0, 0);
              break;
            case "array":
            case "delta":
              i2.push(...this.encodeNumber(l2));
              for (let e3 = 1, t3 = a2.length; e3 < t3; ++e3) i2.push(...this.encodeNumber(a2[e3]));
              break;
            default:
              throw new ti(`Unknown data type of ${o3}`);
          }
        }
        i2.push(...e2.opcodes[n2]);
      }
    }
    return i2;
  }
  compileStringIndex(e2) {
    const t2 = new CFFIndex();
    for (const i2 of e2) t2.add(stringToBytes$1(i2));
    return this.compileIndex(t2);
  }
  compileCharStrings(e2) {
    const t2 = new CFFIndex();
    for (let i2 = 0; i2 < e2.count; i2++) {
      const n2 = e2.get(i2);
      0 !== n2.length ? t2.add(n2) : t2.add(new Uint8Array([139, 14]));
    }
    return this.compileIndex(t2);
  }
  compileCharset(e2, t2, i2, n2) {
    let a2;
    const s2 = t2 - 1;
    if (n2) {
      const e3 = s2 - 1;
      a2 = new Uint8Array([2, 0, 1, e3 >> 8 & 255, 255 & e3]);
    } else {
      a2 = new Uint8Array(1 + 2 * s2), a2[0] = 0;
      let t3 = 0;
      const n3 = e2.charset.length;
      let r2 = false;
      for (let s3 = 1; s3 < a2.length; s3 += 2) {
        let o2 = 0;
        if (t3 < n3) {
          const n4 = e2.charset[t3++];
          o2 = i2.getSID(n4), -1 === o2 && (o2 = 0, r2 || (r2 = true, warn$1(`Couldn't find ${n4} in CFF strings`)));
        }
        a2[s3] = o2 >> 8 & 255, a2[s3 + 1] = 255 & o2;
      }
    }
    return this.compileTypedArray(a2);
  }
  compileEncoding(e2) {
    return this.compileTypedArray(e2.raw);
  }
  compileFDSelect(e2) {
    const t2 = e2.format;
    let i2, n2;
    switch (t2) {
      case 0:
        for (i2 = new Uint8Array(1 + e2.fdSelect.length), i2[0] = t2, n2 = 0; n2 < e2.fdSelect.length; n2++) i2[n2 + 1] = e2.fdSelect[n2];
        break;
      case 3:
        const a2 = 0;
        let s2 = e2.fdSelect[0];
        const r2 = [t2, 0, 0, a2 >> 8 & 255, 255 & a2, s2];
        for (n2 = 1; n2 < e2.fdSelect.length; n2++) {
          const t3 = e2.fdSelect[n2];
          t3 !== s2 && (r2.push(n2 >> 8 & 255, 255 & n2, t3), s2 = t3);
        }
        const o2 = (r2.length - 3) / 3;
        r2[1] = o2 >> 8 & 255, r2[2] = 255 & o2, r2.push(n2 >> 8 & 255, 255 & n2), i2 = new Uint8Array(r2);
    }
    return this.compileTypedArray(i2);
  }
  compileTypedArray(e2) {
    return Array.from(e2);
  }
  compileIndex(e2, t2 = []) {
    const i2 = e2.objects, n2 = i2.length;
    if (0 === n2) return [0, 0];
    const a2 = [n2 >> 8 & 255, 255 & n2];
    let s2, r2, o2 = 1;
    for (s2 = 0; s2 < n2; ++s2) o2 += i2[s2].length;
    r2 = o2 < 256 ? 1 : o2 < 65536 ? 2 : o2 < 16777216 ? 3 : 4, a2.push(r2);
    let l2 = 1;
    for (s2 = 0; s2 < n2 + 1; s2++) 1 === r2 ? a2.push(255 & l2) : 2 === r2 ? a2.push(l2 >> 8 & 255, 255 & l2) : 3 === r2 ? a2.push(l2 >> 16 & 255, l2 >> 8 & 255, 255 & l2) : a2.push(l2 >>> 24 & 255, l2 >> 16 & 255, l2 >> 8 & 255, 255 & l2), i2[s2] && (l2 += i2[s2].length);
    for (s2 = 0; s2 < n2; s2++) t2[s2] && t2[s2].offset(a2.length), a2.push(...i2[s2]);
    return a2;
  }
}
const Un = getLookupTableFactory(function(e2) {
  e2["Times-Roman"] = "Times-Roman", e2.Helvetica = "Helvetica", e2.Courier = "Courier", e2.Symbol = "Symbol", e2["Times-Bold"] = "Times-Bold", e2["Helvetica-Bold"] = "Helvetica-Bold", e2["Courier-Bold"] = "Courier-Bold", e2.ZapfDingbats = "ZapfDingbats", e2["Times-Italic"] = "Times-Italic", e2["Helvetica-Oblique"] = "Helvetica-Oblique", e2["Courier-Oblique"] = "Courier-Oblique", e2["Times-BoldItalic"] = "Times-BoldItalic", e2["Helvetica-BoldOblique"] = "Helvetica-BoldOblique", e2["Courier-BoldOblique"] = "Courier-BoldOblique", e2.ArialNarrow = "Helvetica", e2["ArialNarrow-Bold"] = "Helvetica-Bold", e2["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique", e2["ArialNarrow-Italic"] = "Helvetica-Oblique", e2.ArialBlack = "Helvetica", e2["ArialBlack-Bold"] = "Helvetica-Bold", e2["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique", e2["ArialBlack-Italic"] = "Helvetica-Oblique", e2["Arial-Black"] = "Helvetica", e2["Arial-Black-Bold"] = "Helvetica-Bold", e2["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique", e2["Arial-Black-Italic"] = "Helvetica-Oblique", e2.Arial = "Helvetica", e2["Arial-Bold"] = "Helvetica-Bold", e2["Arial-BoldItalic"] = "Helvetica-BoldOblique", e2["Arial-Italic"] = "Helvetica-Oblique", e2.ArialMT = "Helvetica", e2["Arial-BoldItalicMT"] = "Helvetica-BoldOblique", e2["Arial-BoldMT"] = "Helvetica-Bold", e2["Arial-ItalicMT"] = "Helvetica-Oblique", e2["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique", e2["Arial-BoldMT-Bold"] = "Helvetica-Bold", e2["Arial-ItalicMT-Italic"] = "Helvetica-Oblique", e2.ArialUnicodeMS = "Helvetica", e2["ArialUnicodeMS-Bold"] = "Helvetica-Bold", e2["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique", e2["ArialUnicodeMS-Italic"] = "Helvetica-Oblique", e2["Courier-BoldItalic"] = "Courier-BoldOblique", e2["Courier-Italic"] = "Courier-Oblique", e2.CourierNew = "Courier", e2["CourierNew-Bold"] = "Courier-Bold", e2["CourierNew-BoldItalic"] = "Courier-BoldOblique", e2["CourierNew-Italic"] = "Courier-Oblique", e2["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique", e2["CourierNewPS-BoldMT"] = "Courier-Bold", e2["CourierNewPS-ItalicMT"] = "Courier-Oblique", e2.CourierNewPSMT = "Courier", e2["Helvetica-BoldItalic"] = "Helvetica-BoldOblique", e2["Helvetica-Italic"] = "Helvetica-Oblique", e2["HelveticaLTStd-Bold"] = "Helvetica-Bold", e2["Symbol-Bold"] = "Symbol", e2["Symbol-BoldItalic"] = "Symbol", e2["Symbol-Italic"] = "Symbol", e2.TimesNewRoman = "Times-Roman", e2["TimesNewRoman-Bold"] = "Times-Bold", e2["TimesNewRoman-BoldItalic"] = "Times-BoldItalic", e2["TimesNewRoman-Italic"] = "Times-Italic", e2.TimesNewRomanPS = "Times-Roman", e2["TimesNewRomanPS-Bold"] = "Times-Bold", e2["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic", e2["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic", e2["TimesNewRomanPS-BoldMT"] = "Times-Bold", e2["TimesNewRomanPS-Italic"] = "Times-Italic", e2["TimesNewRomanPS-ItalicMT"] = "Times-Italic", e2.TimesNewRomanPSMT = "Times-Roman", e2["TimesNewRomanPSMT-Bold"] = "Times-Bold", e2["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic", e2["TimesNewRomanPSMT-Italic"] = "Times-Italic";
}), jn = getLookupTableFactory(function(e2) {
  e2.Courier = "FoxitFixed.pfb", e2["Courier-Bold"] = "FoxitFixedBold.pfb", e2["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb", e2["Courier-Oblique"] = "FoxitFixedItalic.pfb", e2.Helvetica = "LiberationSans-Regular.ttf", e2["Helvetica-Bold"] = "LiberationSans-Bold.ttf", e2["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf", e2["Helvetica-Oblique"] = "LiberationSans-Italic.ttf", e2["Times-Roman"] = "FoxitSerif.pfb", e2["Times-Bold"] = "FoxitSerifBold.pfb", e2["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb", e2["Times-Italic"] = "FoxitSerifItalic.pfb", e2.Symbol = "FoxitSymbol.pfb", e2.ZapfDingbats = "FoxitDingbats.pfb", e2["LiberationSans-Regular"] = "LiberationSans-Regular.ttf", e2["LiberationSans-Bold"] = "LiberationSans-Bold.ttf", e2["LiberationSans-Italic"] = "LiberationSans-Italic.ttf", e2["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
}), $n = getLookupTableFactory(function(e2) {
  e2.Calibri = "Helvetica", e2["Calibri-Bold"] = "Helvetica-Bold", e2["Calibri-BoldItalic"] = "Helvetica-BoldOblique", e2["Calibri-Italic"] = "Helvetica-Oblique", e2.CenturyGothic = "Helvetica", e2["CenturyGothic-Bold"] = "Helvetica-Bold", e2["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique", e2["CenturyGothic-Italic"] = "Helvetica-Oblique", e2.ComicSansMS = "Comic Sans MS", e2["ComicSansMS-Bold"] = "Comic Sans MS-Bold", e2["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic", e2["ComicSansMS-Italic"] = "Comic Sans MS-Italic", e2.GillSansMT = "Helvetica", e2["GillSansMT-Bold"] = "Helvetica-Bold", e2["GillSansMT-BoldItalic"] = "Helvetica-BoldOblique", e2["GillSansMT-Italic"] = "Helvetica-Oblique", e2.Impact = "Helvetica", e2["ItcSymbol-Bold"] = "Helvetica-Bold", e2["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique", e2["ItcSymbol-Book"] = "Helvetica", e2["ItcSymbol-BookItalic"] = "Helvetica-Oblique", e2["ItcSymbol-Medium"] = "Helvetica", e2["ItcSymbol-MediumItalic"] = "Helvetica-Oblique", e2.LucidaConsole = "Courier", e2["LucidaConsole-Bold"] = "Courier-Bold", e2["LucidaConsole-BoldItalic"] = "Courier-BoldOblique", e2["LucidaConsole-Italic"] = "Courier-Oblique", e2["LucidaSans-Demi"] = "Helvetica-Bold", e2["MS-Gothic"] = "MS Gothic", e2["MS-Gothic-Bold"] = "MS Gothic-Bold", e2["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic", e2["MS-Gothic-Italic"] = "MS Gothic-Italic", e2["MS-Mincho"] = "MS Mincho", e2["MS-Mincho-Bold"] = "MS Mincho-Bold", e2["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic", e2["MS-Mincho-Italic"] = "MS Mincho-Italic", e2["MS-PGothic"] = "MS PGothic", e2["MS-PGothic-Bold"] = "MS PGothic-Bold", e2["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic", e2["MS-PGothic-Italic"] = "MS PGothic-Italic", e2["MS-PMincho"] = "MS PMincho", e2["MS-PMincho-Bold"] = "MS PMincho-Bold", e2["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic", e2["MS-PMincho-Italic"] = "MS PMincho-Italic", e2.NuptialScript = "Times-Italic", e2.SegoeUISymbol = "Helvetica";
}), Hn = getLookupTableFactory(function(e2) {
  e2["Adobe Jenson"] = true, e2["Adobe Text"] = true, e2.Albertus = true, e2.Aldus = true, e2.Alexandria = true, e2.Algerian = true, e2["American Typewriter"] = true, e2.Antiqua = true, e2.Apex = true, e2.Arno = true, e2.Aster = true, e2.Aurora = true, e2.Baskerville = true, e2.Bell = true, e2.Bembo = true, e2["Bembo Schoolbook"] = true, e2.Benguiat = true, e2["Berkeley Old Style"] = true, e2["Bernhard Modern"] = true, e2["Berthold City"] = true, e2.Bodoni = true, e2["Bauer Bodoni"] = true, e2["Book Antiqua"] = true, e2.Bookman = true, e2["Bordeaux Roman"] = true, e2["Californian FB"] = true, e2.Calisto = true, e2.Calvert = true, e2.Capitals = true, e2.Cambria = true, e2.Cartier = true, e2.Caslon = true, e2.Catull = true, e2.Centaur = true, e2["Century Old Style"] = true, e2["Century Schoolbook"] = true, e2.Chaparral = true, e2["Charis SIL"] = true, e2.Cheltenham = true, e2["Cholla Slab"] = true, e2.Clarendon = true, e2.Clearface = true, e2.Cochin = true, e2.Colonna = true, e2["Computer Modern"] = true, e2["Concrete Roman"] = true, e2.Constantia = true, e2["Cooper Black"] = true, e2.Corona = true, e2.Ecotype = true, e2.Egyptienne = true, e2.Elephant = true, e2.Excelsior = true, e2.Fairfield = true, e2["FF Scala"] = true, e2.Folkard = true, e2.Footlight = true, e2.FreeSerif = true, e2["Friz Quadrata"] = true, e2.Garamond = true, e2.Gentium = true, e2.Georgia = true, e2.Gloucester = true, e2["Goudy Old Style"] = true, e2["Goudy Schoolbook"] = true, e2["Goudy Pro Font"] = true, e2.Granjon = true, e2["Guardian Egyptian"] = true, e2.Heather = true, e2.Hercules = true, e2["High Tower Text"] = true, e2.Hiroshige = true, e2["Hoefler Text"] = true, e2["Humana Serif"] = true, e2.Imprint = true, e2["Ionic No. 5"] = true, e2.Janson = true, e2.Joanna = true, e2.Korinna = true, e2.Lexicon = true, e2.LiberationSerif = true, e2["Liberation Serif"] = true, e2["Linux Libertine"] = true, e2.Literaturnaya = true, e2.Lucida = true, e2["Lucida Bright"] = true, e2.Melior = true, e2.Memphis = true, e2.Miller = true, e2.Minion = true, e2.Modern = true, e2["Mona Lisa"] = true, e2["Mrs Eaves"] = true, e2["MS Serif"] = true, e2["Museo Slab"] = true, e2["New York"] = true, e2["Nimbus Roman"] = true, e2["NPS Rawlinson Roadway"] = true, e2.NuptialScript = true, e2.Palatino = true, e2.Perpetua = true, e2.Plantin = true, e2["Plantin Schoolbook"] = true, e2.Playbill = true, e2["Poor Richard"] = true, e2["Rawlinson Roadway"] = true, e2.Renault = true, e2.Requiem = true, e2.Rockwell = true, e2.Roman = true, e2["Rotis Serif"] = true, e2.Sabon = true, e2.Scala = true, e2.Seagull = true, e2.Sistina = true, e2.Souvenir = true, e2.STIX = true, e2["Stone Informal"] = true, e2["Stone Serif"] = true, e2.Sylfaen = true, e2.Times = true, e2.Trajan = true, e2["Trinité"] = true, e2["Trump Mediaeval"] = true, e2.Utopia = true, e2["Vale Type"] = true, e2["Bitstream Vera"] = true, e2["Vera Serif"] = true, e2.Versailles = true, e2.Wanted = true, e2.Weiss = true, e2["Wide Latin"] = true, e2.Windsor = true, e2.XITS = true;
}), Xn = getLookupTableFactory(function(e2) {
  e2.Dingbats = true, e2.Symbol = true, e2.ZapfDingbats = true, e2.Wingdings = true, e2["Wingdings-Bold"] = true, e2["Wingdings-Regular"] = true;
}), qn = getLookupTableFactory(function(e2) {
  e2[2] = 10, e2[3] = 32, e2[4] = 33, e2[5] = 34, e2[6] = 35, e2[7] = 36, e2[8] = 37, e2[9] = 38, e2[10] = 39, e2[11] = 40, e2[12] = 41, e2[13] = 42, e2[14] = 43, e2[15] = 44, e2[16] = 45, e2[17] = 46, e2[18] = 47, e2[19] = 48, e2[20] = 49, e2[21] = 50, e2[22] = 51, e2[23] = 52, e2[24] = 53, e2[25] = 54, e2[26] = 55, e2[27] = 56, e2[28] = 57, e2[29] = 58, e2[30] = 894, e2[31] = 60, e2[32] = 61, e2[33] = 62, e2[34] = 63, e2[35] = 64, e2[36] = 65, e2[37] = 66, e2[38] = 67, e2[39] = 68, e2[40] = 69, e2[41] = 70, e2[42] = 71, e2[43] = 72, e2[44] = 73, e2[45] = 74, e2[46] = 75, e2[47] = 76, e2[48] = 77, e2[49] = 78, e2[50] = 79, e2[51] = 80, e2[52] = 81, e2[53] = 82, e2[54] = 83, e2[55] = 84, e2[56] = 85, e2[57] = 86, e2[58] = 87, e2[59] = 88, e2[60] = 89, e2[61] = 90, e2[62] = 91, e2[63] = 92, e2[64] = 93, e2[65] = 94, e2[66] = 95, e2[67] = 96, e2[68] = 97, e2[69] = 98, e2[70] = 99, e2[71] = 100, e2[72] = 101, e2[73] = 102, e2[74] = 103, e2[75] = 104, e2[76] = 105, e2[77] = 106, e2[78] = 107, e2[79] = 108, e2[80] = 109, e2[81] = 110, e2[82] = 111, e2[83] = 112, e2[84] = 113, e2[85] = 114, e2[86] = 115, e2[87] = 116, e2[88] = 117, e2[89] = 118, e2[90] = 119, e2[91] = 120, e2[92] = 121, e2[93] = 122, e2[94] = 123, e2[95] = 124, e2[96] = 125, e2[97] = 126, e2[98] = 196, e2[99] = 197, e2[100] = 199, e2[101] = 201, e2[102] = 209, e2[103] = 214, e2[104] = 220, e2[105] = 225, e2[106] = 224, e2[107] = 226, e2[108] = 228, e2[109] = 227, e2[110] = 229, e2[111] = 231, e2[112] = 233, e2[113] = 232, e2[114] = 234, e2[115] = 235, e2[116] = 237, e2[117] = 236, e2[118] = 238, e2[119] = 239, e2[120] = 241, e2[121] = 243, e2[122] = 242, e2[123] = 244, e2[124] = 246, e2[125] = 245, e2[126] = 250, e2[127] = 249, e2[128] = 251, e2[129] = 252, e2[130] = 8224, e2[131] = 176, e2[132] = 162, e2[133] = 163, e2[134] = 167, e2[135] = 8226, e2[136] = 182, e2[137] = 223, e2[138] = 174, e2[139] = 169, e2[140] = 8482, e2[141] = 180, e2[142] = 168, e2[143] = 8800, e2[144] = 198, e2[145] = 216, e2[146] = 8734, e2[147] = 177, e2[148] = 8804, e2[149] = 8805, e2[150] = 165, e2[151] = 181, e2[152] = 8706, e2[153] = 8721, e2[154] = 8719, e2[156] = 8747, e2[157] = 170, e2[158] = 186, e2[159] = 8486, e2[160] = 230, e2[161] = 248, e2[162] = 191, e2[163] = 161, e2[164] = 172, e2[165] = 8730, e2[166] = 402, e2[167] = 8776, e2[168] = 8710, e2[169] = 171, e2[170] = 187, e2[171] = 8230, e2[179] = 8220, e2[180] = 8221, e2[181] = 8216, e2[182] = 8217, e2[200] = 193, e2[203] = 205, e2[207] = 211, e2[210] = 218, e2[223] = 711, e2[224] = 321, e2[225] = 322, e2[226] = 352, e2[227] = 353, e2[228] = 381, e2[229] = 382, e2[233] = 221, e2[234] = 253, e2[252] = 263, e2[253] = 268, e2[254] = 269, e2[258] = 258, e2[260] = 260, e2[261] = 261, e2[265] = 280, e2[266] = 281, e2[267] = 282, e2[268] = 283, e2[269] = 313, e2[275] = 323, e2[276] = 324, e2[278] = 328, e2[283] = 344, e2[284] = 345, e2[285] = 346, e2[286] = 347, e2[292] = 367, e2[295] = 377, e2[296] = 378, e2[298] = 380, e2[305] = 963, e2[306] = 964, e2[307] = 966, e2[308] = 8215, e2[309] = 8252, e2[310] = 8319, e2[311] = 8359, e2[312] = 8592, e2[313] = 8593, e2[337] = 9552, e2[493] = 1039, e2[494] = 1040, e2[570] = 1040, e2[571] = 1041, e2[572] = 1042, e2[573] = 1043, e2[574] = 1044, e2[575] = 1045, e2[576] = 1046, e2[577] = 1047, e2[578] = 1048, e2[579] = 1049, e2[580] = 1050, e2[581] = 1051, e2[582] = 1052, e2[583] = 1053, e2[584] = 1054, e2[585] = 1055, e2[586] = 1056, e2[587] = 1057, e2[588] = 1058, e2[589] = 1059, e2[590] = 1060, e2[591] = 1061, e2[592] = 1062, e2[593] = 1063, e2[594] = 1064, e2[595] = 1065, e2[596] = 1066, e2[597] = 1067, e2[598] = 1068, e2[599] = 1069, e2[600] = 1070, e2[672] = 1488, e2[673] = 1489, e2[674] = 1490, e2[675] = 1491, e2[676] = 1492, e2[677] = 1493, e2[678] = 1494, e2[679] = 1495, e2[680] = 1496, e2[681] = 1497, e2[682] = 1498, e2[683] = 1499, e2[684] = 1500, e2[685] = 1501, e2[686] = 1502, e2[687] = 1503, e2[688] = 1504, e2[689] = 1505, e2[690] = 1506, e2[691] = 1507, e2[692] = 1508, e2[693] = 1509, e2[694] = 1510, e2[695] = 1511, e2[696] = 1512, e2[697] = 1513, e2[698] = 1514, e2[705] = 1524, e2[706] = 8362, e2[710] = 64288, e2[711] = 64298, e2[759] = 1617, e2[761] = 1776, e2[763] = 1778, e2[775] = 1652, e2[777] = 1764, e2[778] = 1780, e2[779] = 1781, e2[780] = 1782, e2[782] = 771, e2[783] = 64726, e2[786] = 8363, e2[788] = 8532, e2[790] = 768, e2[791] = 769, e2[792] = 768, e2[795] = 803, e2[797] = 64336, e2[798] = 64337, e2[799] = 64342, e2[800] = 64343, e2[801] = 64344, e2[802] = 64345, e2[803] = 64362, e2[804] = 64363, e2[805] = 64364, e2[2424] = 7821, e2[2425] = 7822, e2[2426] = 7823, e2[2427] = 7824, e2[2428] = 7825, e2[2429] = 7826, e2[2430] = 7827, e2[2433] = 7682, e2[2678] = 8045, e2[2679] = 8046, e2[2830] = 1552, e2[2838] = 686, e2[2840] = 751, e2[2842] = 753, e2[2843] = 754, e2[2844] = 755, e2[2846] = 757, e2[2856] = 767, e2[2857] = 848, e2[2858] = 849, e2[2862] = 853, e2[2863] = 854, e2[2864] = 855, e2[2865] = 861, e2[2866] = 862, e2[2906] = 7460, e2[2908] = 7462, e2[2909] = 7463, e2[2910] = 7464, e2[2912] = 7466, e2[2913] = 7467, e2[2914] = 7468, e2[2916] = 7470, e2[2917] = 7471, e2[2918] = 7472, e2[2920] = 7474, e2[2921] = 7475, e2[2922] = 7476, e2[2924] = 7478, e2[2925] = 7479, e2[2926] = 7480, e2[2928] = 7482, e2[2929] = 7483, e2[2930] = 7484, e2[2932] = 7486, e2[2933] = 7487, e2[2934] = 7488, e2[2936] = 7490, e2[2937] = 7491, e2[2938] = 7492, e2[2940] = 7494, e2[2941] = 7495, e2[2942] = 7496, e2[2944] = 7498, e2[2946] = 7500, e2[2948] = 7502, e2[2950] = 7504, e2[2951] = 7505, e2[2952] = 7506, e2[2954] = 7508, e2[2955] = 7509, e2[2956] = 7510, e2[2958] = 7512, e2[2959] = 7513, e2[2960] = 7514, e2[2962] = 7516, e2[2963] = 7517, e2[2964] = 7518, e2[2966] = 7520, e2[2967] = 7521, e2[2968] = 7522, e2[2970] = 7524, e2[2971] = 7525, e2[2972] = 7526, e2[2974] = 7528, e2[2975] = 7529, e2[2976] = 7530, e2[2978] = 1537, e2[2979] = 1538, e2[2980] = 1539, e2[2982] = 1549, e2[2983] = 1551, e2[2984] = 1552, e2[2986] = 1554, e2[2987] = 1555, e2[2988] = 1556, e2[2990] = 1623, e2[2991] = 1624, e2[2995] = 1775, e2[2999] = 1791, e2[3002] = 64290, e2[3003] = 64291, e2[3004] = 64292, e2[3006] = 64294, e2[3007] = 64295, e2[3008] = 64296, e2[3011] = 1900, e2[3014] = 8223, e2[3015] = 8244, e2[3017] = 7532, e2[3018] = 7533, e2[3019] = 7534, e2[3075] = 7590, e2[3076] = 7591, e2[3079] = 7594, e2[3080] = 7595, e2[3083] = 7598, e2[3084] = 7599, e2[3087] = 7602, e2[3088] = 7603, e2[3091] = 7606, e2[3092] = 7607, e2[3095] = 7610, e2[3096] = 7611, e2[3099] = 7614, e2[3100] = 7615, e2[3103] = 7618, e2[3104] = 7619, e2[3107] = 8337, e2[3108] = 8338, e2[3116] = 1884, e2[3119] = 1885, e2[3120] = 1885, e2[3123] = 1886, e2[3124] = 1886, e2[3127] = 1887, e2[3128] = 1887, e2[3131] = 1888, e2[3132] = 1888, e2[3135] = 1889, e2[3136] = 1889, e2[3139] = 1890, e2[3140] = 1890, e2[3143] = 1891, e2[3144] = 1891, e2[3147] = 1892, e2[3148] = 1892, e2[3153] = 580, e2[3154] = 581, e2[3157] = 584, e2[3158] = 585, e2[3161] = 588, e2[3162] = 589, e2[3165] = 891, e2[3166] = 892, e2[3169] = 1274, e2[3170] = 1275, e2[3173] = 1278, e2[3174] = 1279, e2[3181] = 7622, e2[3182] = 7623, e2[3282] = 11799, e2[3316] = 578, e2[3379] = 42785, e2[3393] = 1159, e2[3416] = 8377;
}), zn = getLookupTableFactory(function(e2) {
  e2[227] = 322, e2[264] = 261, e2[291] = 346;
}), Wn = getLookupTableFactory(function(e2) {
  e2[1] = 32, e2[4] = 65, e2[5] = 192, e2[6] = 193, e2[9] = 196, e2[17] = 66, e2[18] = 67, e2[21] = 268, e2[24] = 68, e2[28] = 69, e2[29] = 200, e2[30] = 201, e2[32] = 282, e2[38] = 70, e2[39] = 71, e2[44] = 72, e2[47] = 73, e2[48] = 204, e2[49] = 205, e2[58] = 74, e2[60] = 75, e2[62] = 76, e2[68] = 77, e2[69] = 78, e2[75] = 79, e2[76] = 210, e2[80] = 214, e2[87] = 80, e2[89] = 81, e2[90] = 82, e2[92] = 344, e2[94] = 83, e2[97] = 352, e2[100] = 84, e2[104] = 85, e2[109] = 220, e2[115] = 86, e2[116] = 87, e2[121] = 88, e2[122] = 89, e2[124] = 221, e2[127] = 90, e2[129] = 381, e2[258] = 97, e2[259] = 224, e2[260] = 225, e2[263] = 228, e2[268] = 261, e2[271] = 98, e2[272] = 99, e2[273] = 263, e2[275] = 269, e2[282] = 100, e2[286] = 101, e2[287] = 232, e2[288] = 233, e2[290] = 283, e2[295] = 281, e2[296] = 102, e2[336] = 103, e2[346] = 104, e2[349] = 105, e2[350] = 236, e2[351] = 237, e2[361] = 106, e2[364] = 107, e2[367] = 108, e2[371] = 322, e2[373] = 109, e2[374] = 110, e2[381] = 111, e2[382] = 242, e2[383] = 243, e2[386] = 246, e2[393] = 112, e2[395] = 113, e2[396] = 114, e2[398] = 345, e2[400] = 115, e2[401] = 347, e2[403] = 353, e2[410] = 116, e2[437] = 117, e2[442] = 252, e2[448] = 118, e2[449] = 119, e2[454] = 120, e2[455] = 121, e2[457] = 253, e2[460] = 122, e2[462] = 382, e2[463] = 380, e2[853] = 44, e2[855] = 58, e2[856] = 46, e2[876] = 47, e2[878] = 45, e2[882] = 45, e2[894] = 40, e2[895] = 41, e2[896] = 91, e2[897] = 93, e2[923] = 64, e2[940] = 163, e2[1004] = 48, e2[1005] = 49, e2[1006] = 50, e2[1007] = 51, e2[1008] = 52, e2[1009] = 53, e2[1010] = 54, e2[1011] = 55, e2[1012] = 56, e2[1013] = 57, e2[1081] = 37, e2[1085] = 43, e2[1086] = 45;
});
function getStandardFontName(e2) {
  const t2 = normalizeFontName(e2);
  return Un()[t2];
}
function isKnownFontName(e2) {
  const t2 = normalizeFontName(e2);
  return !!(Un()[t2] || $n()[t2] || Hn()[t2] || Xn()[t2]);
}
class ToUnicodeMap {
  constructor(e2 = []) {
    this._map = e2;
  }
  get length() {
    return this._map.length;
  }
  forEach(e2) {
    for (const t2 in this._map) e2(t2, this._map[t2].codePointAt(0));
  }
  has(e2) {
    return void 0 !== this._map[e2];
  }
  get(e2) {
    return this._map[e2];
  }
  charCodeOf(e2) {
    const t2 = this._map;
    if (t2.length <= 65536) return t2.indexOf(e2);
    for (const i2 in t2) if (t2[i2] === e2) return 0 | i2;
    return -1;
  }
  amend(e2) {
    for (const t2 in e2) this._map[t2] = e2[t2];
  }
}
class IdentityToUnicodeMap {
  constructor(e2, t2) {
    this.firstChar = e2, this.lastChar = t2;
  }
  get length() {
    return this.lastChar + 1 - this.firstChar;
  }
  forEach(e2) {
    for (let t2 = this.firstChar, i2 = this.lastChar; t2 <= i2; t2++) e2(t2, t2);
  }
  has(e2) {
    return this.firstChar <= e2 && e2 <= this.lastChar;
  }
  get(e2) {
    if (this.firstChar <= e2 && e2 <= this.lastChar) return String.fromCharCode(e2);
  }
  charCodeOf(e2) {
    return Number.isInteger(e2) && e2 >= this.firstChar && e2 <= this.lastChar ? e2 : -1;
  }
  amend(e2) {
    unreachable$1("Should not call amend()");
  }
}
class CFFFont {
  constructor(e2, t2) {
    this.properties = t2;
    const i2 = new CFFParser(e2, t2, Sn);
    this.cff = i2.parse(), this.cff.duplicateFirstGlyph();
    const n2 = new CFFCompiler(this.cff);
    this.seacs = this.cff.seacs;
    try {
      this.data = n2.compile();
    } catch {
      warn$1("Failed to compile font " + t2.loadedName), this.data = e2;
    }
    this._createBuiltInEncoding();
  }
  get numGlyphs() {
    return this.cff.charStrings.count;
  }
  getCharset() {
    return this.cff.charset.charset;
  }
  getGlyphMapping() {
    const e2 = this.cff, t2 = this.properties, { cidToGidMap: i2, cMap: n2 } = t2, a2 = e2.charset.charset;
    let s2, r2;
    if (t2.composite) {
      let t3, o3;
      if (i2?.length > 0) {
        t3 = /* @__PURE__ */ Object.create(null);
        for (let e3 = 0, n3 = i2.length; e3 < n3; e3++) {
          const n4 = i2[e3];
          void 0 !== n4 && (t3[n4] = e3);
        }
      }
      if (s2 = /* @__PURE__ */ Object.create(null), e2.isCIDFont) for (r2 = 0; r2 < a2.length; r2++) {
        const e3 = a2[r2];
        o3 = n2.charCodeOf(e3), void 0 !== t3?.[o3] && (o3 = t3[o3]), s2[o3] = r2;
      }
      else for (r2 = 0; r2 < e2.charStrings.count; r2++) o3 = n2.charCodeOf(r2), s2[o3] = r2;
      return s2;
    }
    let o2 = e2.encoding ? e2.encoding.encoding : null;
    return t2.isInternalFont && (o2 = t2.defaultEncoding), s2 = type1FontGlyphMapping(t2, o2, a2), s2;
  }
  hasGlyphId(e2) {
    return this.cff.hasGlyphId(e2);
  }
  _createBuiltInEncoding() {
    const { charset: e2, encoding: t2 } = this.cff;
    if (!e2 || !t2) return;
    const i2 = e2.charset, n2 = t2.encoding, a2 = [];
    for (const e3 in n2) {
      const t3 = n2[e3];
      if (t3 >= 0) {
        const n3 = i2[t3];
        n3 && (a2[e3] = n3);
      }
    }
    a2.length > 0 && (this.properties.builtInEncoding = a2);
  }
}
function getFloat214(e2, t2) {
  return readInt16(e2, t2) / 16384;
}
function getSubroutineBias(e2) {
  const t2 = e2.length;
  let i2 = 32768;
  return t2 < 1240 ? i2 = 107 : t2 < 33900 && (i2 = 1131), i2;
}
function parseCmap(e2, t2, i2) {
  const n2 = 1 === readUint16(e2, t2 + 2) ? readUint32(e2, t2 + 8) : readUint32(e2, t2 + 16), a2 = readUint16(e2, t2 + n2);
  let s2, r2, o2;
  if (4 === a2) {
    readUint16(e2, t2 + n2 + 2);
    const i3 = readUint16(e2, t2 + n2 + 6) >> 1;
    for (r2 = t2 + n2 + 14, s2 = [], o2 = 0; o2 < i3; o2++, r2 += 2) s2[o2] = { end: readUint16(e2, r2) };
    for (r2 += 2, o2 = 0; o2 < i3; o2++, r2 += 2) s2[o2].start = readUint16(e2, r2);
    for (o2 = 0; o2 < i3; o2++, r2 += 2) s2[o2].idDelta = readUint16(e2, r2);
    for (o2 = 0; o2 < i3; o2++, r2 += 2) {
      let t3 = readUint16(e2, r2);
      if (0 !== t3) {
        s2[o2].ids = [];
        for (let i4 = 0, n3 = s2[o2].end - s2[o2].start + 1; i4 < n3; i4++) s2[o2].ids[i4] = readUint16(e2, r2 + t3), t3 += 2;
      }
    }
    return s2;
  }
  if (12 === a2) {
    const i3 = readUint32(e2, t2 + n2 + 12);
    for (r2 = t2 + n2 + 16, s2 = [], o2 = 0; o2 < i3; o2++) t2 = readUint32(e2, r2), s2.push({ start: t2, end: readUint32(e2, r2 + 4), idDelta: readUint32(e2, r2 + 8) - t2 }), r2 += 12;
    return s2;
  }
  throw new ti(`unsupported cmap: ${a2}`);
}
function parseCff(e2, t2, i2, n2) {
  const a2 = new CFFParser(new Stream(e2, t2, i2 - t2), {}, n2).parse();
  return { glyphs: a2.charStrings.objects, subrs: a2.topDict.privateDict?.subrsIndex?.objects, gsubrs: a2.globalSubrIndex?.objects, isCFFCIDFont: a2.isCIDFont, fdSelect: a2.fdSelect, fdArray: a2.fdArray };
}
function lookupCmap(e2, t2) {
  const i2 = t2.codePointAt(0);
  let n2 = 0, a2 = 0, s2 = e2.length - 1;
  for (; a2 < s2; ) {
    const t3 = a2 + s2 + 1 >> 1;
    i2 < e2[t3].start ? s2 = t3 - 1 : a2 = t3;
  }
  return e2[a2].start <= i2 && i2 <= e2[a2].end && (n2 = e2[a2].idDelta + (e2[a2].ids ? e2[a2].ids[i2 - e2[a2].start] : i2) & 65535), { charCode: i2, glyphId: n2 };
}
function compileGlyf(e2, t2, i2) {
  function moveTo(e3, i3) {
    r2 && t2.add("L", r2), r2 = [e3, i3], t2.add("M", [e3, i3]);
  }
  function lineTo(e3, i3) {
    t2.add("L", [e3, i3]);
  }
  function quadraticCurveTo(e3, i3, n3, a3) {
    t2.add("Q", [e3, i3, n3, a3]);
  }
  let n2 = 0;
  const a2 = readInt16(e2, n2);
  let s2, r2 = null, o2 = 0, l2 = 0;
  if (n2 += 10, a2 < 0) do {
    s2 = readUint16(e2, n2);
    const a3 = readUint16(e2, n2 + 2);
    let r3, c2;
    n2 += 4, 1 & s2 ? (2 & s2 ? (r3 = readInt16(e2, n2), c2 = readInt16(e2, n2 + 2)) : (r3 = readUint16(e2, n2), c2 = readUint16(e2, n2 + 2)), n2 += 4) : 2 & s2 ? (r3 = readInt8(e2, n2++), c2 = readInt8(e2, n2++)) : (r3 = e2[n2++], c2 = e2[n2++]), 2 & s2 ? (o2 = r3, l2 = c2) : (o2 = 0, l2 = 0);
    let h2 = 1, d2 = 1, u2 = 0, g2 = 0;
    8 & s2 ? (h2 = d2 = getFloat214(e2, n2), n2 += 2) : 64 & s2 ? (h2 = getFloat214(e2, n2), d2 = getFloat214(e2, n2 + 2), n2 += 4) : 128 & s2 && (h2 = getFloat214(e2, n2), u2 = getFloat214(e2, n2 + 2), g2 = getFloat214(e2, n2 + 4), d2 = getFloat214(e2, n2 + 6), n2 += 8);
    const f2 = i2.glyphs[a3];
    f2 && (t2.save(), t2.transform([h2, u2, g2, d2, o2, l2]), compileGlyf(f2, t2, i2), t2.restore());
  } while (32 & s2);
  else {
    const t3 = [];
    let i3, r3;
    for (i3 = 0; i3 < a2; i3++) t3.push(readUint16(e2, n2)), n2 += 2;
    n2 += 2 + readUint16(e2, n2);
    const c2 = t3.at(-1) + 1, h2 = [];
    for (; h2.length < c2; ) {
      s2 = e2[n2++];
      let t4 = 1;
      for (8 & s2 && (t4 += e2[n2++]); t4-- > 0; ) h2.push({ flags: s2 });
    }
    for (i3 = 0; i3 < c2; i3++) {
      switch (18 & h2[i3].flags) {
        case 0:
          o2 += readInt16(e2, n2), n2 += 2;
          break;
        case 2:
          o2 -= e2[n2++];
          break;
        case 18:
          o2 += e2[n2++];
      }
      h2[i3].x = o2;
    }
    for (i3 = 0; i3 < c2; i3++) {
      switch (36 & h2[i3].flags) {
        case 0:
          l2 += readInt16(e2, n2), n2 += 2;
          break;
        case 4:
          l2 -= e2[n2++];
          break;
        case 36:
          l2 += e2[n2++];
      }
      h2[i3].y = l2;
    }
    let d2 = 0;
    for (n2 = 0; n2 < a2; n2++) {
      const e3 = t3[n2], a3 = h2.slice(d2, e3 + 1);
      if (1 & a3[0].flags) a3.push(a3[0]);
      else if (1 & a3.at(-1).flags) a3.unshift(a3.at(-1));
      else {
        const e4 = { flags: 1, x: (a3[0].x + a3.at(-1).x) / 2, y: (a3[0].y + a3.at(-1).y) / 2 };
        a3.unshift(e4), a3.push(e4);
      }
      for (moveTo(a3[0].x, a3[0].y), i3 = 1, r3 = a3.length; i3 < r3; i3++) 1 & a3[i3].flags ? lineTo(a3[i3].x, a3[i3].y) : 1 & a3[i3 + 1].flags ? (quadraticCurveTo(a3[i3].x, a3[i3].y, a3[i3 + 1].x, a3[i3 + 1].y), i3++) : quadraticCurveTo(a3[i3].x, a3[i3].y, (a3[i3].x + a3[i3 + 1].x) / 2, (a3[i3].y + a3[i3 + 1].y) / 2);
      d2 = e3 + 1;
    }
  }
}
function compileCharString(e2, t2, i2, n2) {
  function moveTo(e3, i3) {
    l2 && t2.add("L", l2), l2 = [e3, i3], t2.add("M", [e3, i3]);
  }
  function lineTo(e3, i3) {
    t2.add("L", [e3, i3]);
  }
  function bezierCurveTo(e3, i3, n3, a3, s3, r3) {
    t2.add("C", [e3, i3, n3, a3, s3, r3]);
  }
  const a2 = [];
  let s2 = 0, r2 = 0, o2 = 0, l2 = null;
  !(function parse(e3) {
    let l3 = 0;
    for (; l3 < e3.length; ) {
      let c2, h2, d2, u2, g2, f2, p2, m2, b2, y2 = false, w2 = e3[l3++];
      switch (w2) {
        case 1:
        case 3:
        case 18:
        case 23:
          o2 += a2.length >> 1, y2 = true;
          break;
        case 4:
          r2 += a2.pop(), moveTo(s2, r2), y2 = true;
          break;
        case 5:
          for (; a2.length > 0; ) s2 += a2.shift(), r2 += a2.shift(), lineTo(s2, r2);
          break;
        case 6:
          for (; a2.length > 0 && (s2 += a2.shift(), lineTo(s2, r2), 0 !== a2.length); ) r2 += a2.shift(), lineTo(s2, r2);
          break;
        case 7:
          for (; a2.length > 0 && (r2 += a2.shift(), lineTo(s2, r2), 0 !== a2.length); ) s2 += a2.shift(), lineTo(s2, r2);
          break;
        case 8:
          for (; a2.length > 0; ) c2 = s2 + a2.shift(), d2 = r2 + a2.shift(), h2 = c2 + a2.shift(), u2 = d2 + a2.shift(), s2 = h2 + a2.shift(), r2 = u2 + a2.shift(), bezierCurveTo(c2, d2, h2, u2, s2, r2);
          break;
        case 10:
          if (m2 = a2.pop(), b2 = null, i2.isCFFCIDFont) {
            const e4 = i2.fdSelect.getFDIndex(n2);
            if (e4 >= 0 && e4 < i2.fdArray.length) {
              const t3 = i2.fdArray[e4];
              let n3;
              t3.privateDict?.subrsIndex && (n3 = t3.privateDict.subrsIndex.objects), n3 && (m2 += getSubroutineBias(n3), b2 = n3[m2]);
            } else warn$1("Invalid fd index for glyph index.");
          } else b2 = i2.subrs[m2 + i2.subrsBias];
          b2 && parse(b2);
          break;
        case 11:
          return;
        case 12:
          switch (w2 = e3[l3++], w2) {
            case 34:
              c2 = s2 + a2.shift(), h2 = c2 + a2.shift(), g2 = r2 + a2.shift(), s2 = h2 + a2.shift(), bezierCurveTo(c2, r2, h2, g2, s2, g2), c2 = s2 + a2.shift(), h2 = c2 + a2.shift(), s2 = h2 + a2.shift(), bezierCurveTo(c2, g2, h2, r2, s2, r2);
              break;
            case 35:
              c2 = s2 + a2.shift(), d2 = r2 + a2.shift(), h2 = c2 + a2.shift(), u2 = d2 + a2.shift(), s2 = h2 + a2.shift(), r2 = u2 + a2.shift(), bezierCurveTo(c2, d2, h2, u2, s2, r2), c2 = s2 + a2.shift(), d2 = r2 + a2.shift(), h2 = c2 + a2.shift(), u2 = d2 + a2.shift(), s2 = h2 + a2.shift(), r2 = u2 + a2.shift(), bezierCurveTo(c2, d2, h2, u2, s2, r2), a2.pop();
              break;
            case 36:
              c2 = s2 + a2.shift(), g2 = r2 + a2.shift(), h2 = c2 + a2.shift(), f2 = g2 + a2.shift(), s2 = h2 + a2.shift(), bezierCurveTo(c2, g2, h2, f2, s2, f2), c2 = s2 + a2.shift(), h2 = c2 + a2.shift(), p2 = f2 + a2.shift(), s2 = h2 + a2.shift(), bezierCurveTo(c2, f2, h2, p2, s2, r2);
              break;
            case 37:
              const e4 = s2, t3 = r2;
              c2 = s2 + a2.shift(), d2 = r2 + a2.shift(), h2 = c2 + a2.shift(), u2 = d2 + a2.shift(), s2 = h2 + a2.shift(), r2 = u2 + a2.shift(), bezierCurveTo(c2, d2, h2, u2, s2, r2), c2 = s2 + a2.shift(), d2 = r2 + a2.shift(), h2 = c2 + a2.shift(), u2 = d2 + a2.shift(), s2 = h2, r2 = u2, Math.abs(s2 - e4) > Math.abs(r2 - t3) ? s2 += a2.shift() : r2 += a2.shift(), bezierCurveTo(c2, d2, h2, u2, s2, r2);
              break;
            default:
              throw new ti(`unknown operator: 12 ${w2}`);
          }
          break;
        case 14:
          if (a2.length >= 4) {
            const e4 = a2.pop(), n3 = a2.pop();
            r2 = a2.pop(), s2 = a2.pop(), t2.save(), t2.translate(s2, r2);
            let o3 = lookupCmap(i2.cmap, String.fromCharCode(i2.glyphNameMap[un[e4]]));
            compileCharString(i2.glyphs[o3.glyphId], t2, i2, o3.glyphId), t2.restore(), o3 = lookupCmap(i2.cmap, String.fromCharCode(i2.glyphNameMap[un[n3]])), compileCharString(i2.glyphs[o3.glyphId], t2, i2, o3.glyphId);
          }
          return;
        case 19:
        case 20:
          o2 += a2.length >> 1, l3 += o2 + 7 >> 3, y2 = true;
          break;
        case 21:
          r2 += a2.pop(), s2 += a2.pop(), moveTo(s2, r2), y2 = true;
          break;
        case 22:
          s2 += a2.pop(), moveTo(s2, r2), y2 = true;
          break;
        case 24:
          for (; a2.length > 2; ) c2 = s2 + a2.shift(), d2 = r2 + a2.shift(), h2 = c2 + a2.shift(), u2 = d2 + a2.shift(), s2 = h2 + a2.shift(), r2 = u2 + a2.shift(), bezierCurveTo(c2, d2, h2, u2, s2, r2);
          s2 += a2.shift(), r2 += a2.shift(), lineTo(s2, r2);
          break;
        case 25:
          for (; a2.length > 6; ) s2 += a2.shift(), r2 += a2.shift(), lineTo(s2, r2);
          c2 = s2 + a2.shift(), d2 = r2 + a2.shift(), h2 = c2 + a2.shift(), u2 = d2 + a2.shift(), s2 = h2 + a2.shift(), r2 = u2 + a2.shift(), bezierCurveTo(c2, d2, h2, u2, s2, r2);
          break;
        case 26:
          for (a2.length % 2 && (s2 += a2.shift()); a2.length > 0; ) c2 = s2, d2 = r2 + a2.shift(), h2 = c2 + a2.shift(), u2 = d2 + a2.shift(), s2 = h2, r2 = u2 + a2.shift(), bezierCurveTo(c2, d2, h2, u2, s2, r2);
          break;
        case 27:
          for (a2.length % 2 && (r2 += a2.shift()); a2.length > 0; ) c2 = s2 + a2.shift(), d2 = r2, h2 = c2 + a2.shift(), u2 = d2 + a2.shift(), s2 = h2 + a2.shift(), r2 = u2, bezierCurveTo(c2, d2, h2, u2, s2, r2);
          break;
        case 28:
          a2.push(readInt16(e3, l3)), l3 += 2;
          break;
        case 29:
          m2 = a2.pop() + i2.gsubrsBias, b2 = i2.gsubrs[m2], b2 && parse(b2);
          break;
        case 30:
          for (; a2.length > 0 && (c2 = s2, d2 = r2 + a2.shift(), h2 = c2 + a2.shift(), u2 = d2 + a2.shift(), s2 = h2 + a2.shift(), r2 = u2 + (1 === a2.length ? a2.shift() : 0), bezierCurveTo(c2, d2, h2, u2, s2, r2), 0 !== a2.length); ) c2 = s2 + a2.shift(), d2 = r2, h2 = c2 + a2.shift(), u2 = d2 + a2.shift(), r2 = u2 + a2.shift(), s2 = h2 + (1 === a2.length ? a2.shift() : 0), bezierCurveTo(c2, d2, h2, u2, s2, r2);
          break;
        case 31:
          for (; a2.length > 0 && (c2 = s2 + a2.shift(), d2 = r2, h2 = c2 + a2.shift(), u2 = d2 + a2.shift(), r2 = u2 + a2.shift(), s2 = h2 + (1 === a2.length ? a2.shift() : 0), bezierCurveTo(c2, d2, h2, u2, s2, r2), 0 !== a2.length); ) c2 = s2, d2 = r2 + a2.shift(), h2 = c2 + a2.shift(), u2 = d2 + a2.shift(), s2 = h2 + a2.shift(), r2 = u2 + (1 === a2.length ? a2.shift() : 0), bezierCurveTo(c2, d2, h2, u2, s2, r2);
          break;
        default:
          if (w2 < 32) throw new ti(`unknown operator: ${w2}`);
          w2 < 247 ? a2.push(w2 - 139) : w2 < 251 ? a2.push(256 * (w2 - 247) + e3[l3++] + 108) : w2 < 255 ? a2.push(256 * -(w2 - 251) - e3[l3++] - 108) : (a2.push((e3[l3] << 24 | e3[l3 + 1] << 16 | e3[l3 + 2] << 8 | e3[l3 + 3]) / 65536), l3 += 4);
      }
      y2 && (a2.length = 0);
    }
  })(e2);
}
class Commands {
  cmds = [];
  transformStack = [];
  currentTransform = [1, 0, 0, 1, 0, 0];
  add(e2, t2) {
    if (t2) {
      const { currentTransform: i2 } = this;
      for (let e3 = 0, n2 = t2.length; e3 < n2; e3 += 2) ai.applyTransform(t2, i2, e3);
      this.cmds.push(`${e2}${t2.join(" ")}`);
    } else this.cmds.push(e2);
  }
  transform(e2) {
    this.currentTransform = ai.transform(this.currentTransform, e2);
  }
  translate(e2, t2) {
    this.transform([1, 0, 0, 1, e2, t2]);
  }
  save() {
    this.transformStack.push(this.currentTransform.slice());
  }
  restore() {
    this.currentTransform = this.transformStack.pop() || [1, 0, 0, 1, 0, 0];
  }
  getSVG() {
    return this.cmds.join("");
  }
}
class CompiledFont {
  constructor(e2) {
    this.fontMatrix = e2, this.compiledGlyphs = /* @__PURE__ */ Object.create(null), this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
  }
  getPathJs(e2) {
    const { charCode: t2, glyphId: i2 } = lookupCmap(this.cmap, e2);
    let n2, a2 = this.compiledGlyphs[i2];
    if (void 0 === a2) {
      try {
        a2 = this.compileGlyph(this.glyphs[i2], i2);
      } catch (e3) {
        a2 = "", n2 = e3;
      }
      this.compiledGlyphs[i2] = a2;
    }
    if (this.compiledCharCodeToGlyphId[t2] ??= i2, n2) throw n2;
    return a2;
  }
  compileGlyph(e2, i2) {
    if (!e2?.length || 14 === e2[0]) return "";
    let n2 = this.fontMatrix;
    if (this.isCFFCIDFont) {
      const e3 = this.fdSelect.getFDIndex(i2);
      if (e3 >= 0 && e3 < this.fdArray.length) {
        n2 = this.fdArray[e3].getByName("FontMatrix") || t;
      } else warn$1("Invalid fd index for glyph index.");
    }
    assert$1(isNumberArray(n2, 6), "Expected a valid fontMatrix.");
    const a2 = new Commands();
    return a2.transform(n2.slice()), this.compileGlyphImpl(e2, a2, i2), a2.add("Z"), a2.getSVG();
  }
  compileGlyphImpl() {
    unreachable$1("Children classes should implement this.");
  }
  hasBuiltPath(e2) {
    const { charCode: t2, glyphId: i2 } = lookupCmap(this.cmap, e2);
    return void 0 !== this.compiledGlyphs[i2] && void 0 !== this.compiledCharCodeToGlyphId[t2];
  }
}
class TrueTypeCompiled extends CompiledFont {
  constructor(e2, t2, i2) {
    super(i2 || [488e-6, 0, 0, 488e-6, 0, 0]), this.glyphs = e2, this.cmap = t2;
  }
  compileGlyphImpl(e2, t2) {
    compileGlyf(e2, t2, this);
  }
}
class Type2Compiled extends CompiledFont {
  constructor(e2, t2, i2) {
    super(i2 || [1e-3, 0, 0, 1e-3, 0, 0]), this.glyphs = e2.glyphs, this.gsubrs = e2.gsubrs || [], this.subrs = e2.subrs || [], this.cmap = t2, this.glyphNameMap = mn(), this.gsubrsBias = getSubroutineBias(this.gsubrs), this.subrsBias = getSubroutineBias(this.subrs), this.isCFFCIDFont = e2.isCFFCIDFont, this.fdSelect = e2.fdSelect, this.fdArray = e2.fdArray;
  }
  compileGlyphImpl(e2, t2, i2) {
    compileCharString(e2, t2, this, i2);
  }
}
class FontRendererFactory {
  static create(e2, t2) {
    const i2 = new Uint8Array(e2.data);
    let n2, a2, s2, r2, o2, l2;
    const c2 = readUint16(i2, 4);
    for (let e3 = 0, h2 = 12; e3 < c2; e3++, h2 += 16) {
      const e4 = bytesToString$1(i2.subarray(h2, h2 + 4)), c3 = readUint32(i2, h2 + 8), d2 = readUint32(i2, h2 + 12);
      switch (e4) {
        case "cmap":
          n2 = parseCmap(i2, c3);
          break;
        case "glyf":
          a2 = i2.subarray(c3, c3 + d2);
          break;
        case "loca":
          s2 = i2.subarray(c3, c3 + d2);
          break;
        case "head":
          l2 = readUint16(i2, c3 + 18), o2 = readUint16(i2, c3 + 50);
          break;
        case "CFF ":
          r2 = parseCff(i2, c3, c3 + d2, t2);
      }
    }
    if (a2) {
      const t3 = l2 ? [1 / l2, 0, 0, 1 / l2, 0, 0] : e2.fontMatrix;
      return new TrueTypeCompiled((function(e3, t4, i3) {
        let n3, a3;
        i3 ? (n3 = 4, a3 = readUint32) : (n3 = 2, a3 = (e4, t5) => 2 * readUint16(e4, t5));
        const s3 = [];
        let r3 = a3(t4, 0);
        for (let i4 = n3; i4 < t4.length; i4 += n3) {
          const n4 = a3(t4, i4);
          s3.push(e3.subarray(r3, n4)), r3 = n4;
        }
        return s3;
      })(a2, s2, o2), n2, t3);
    }
    return new Type2Compiled(r2, n2, e2.fontMatrix);
  }
}
const Gn = getLookupTableFactory(function(e2) {
  e2.Courier = 600, e2["Courier-Bold"] = 600, e2["Courier-BoldOblique"] = 600, e2["Courier-Oblique"] = 600, e2.Helvetica = getLookupTableFactory(function(e3) {
    e3.space = 278, e3.exclam = 278, e3.quotedbl = 355, e3.numbersign = 556, e3.dollar = 556, e3.percent = 889, e3.ampersand = 667, e3.quoteright = 222, e3.parenleft = 333, e3.parenright = 333, e3.asterisk = 389, e3.plus = 584, e3.comma = 278, e3.hyphen = 333, e3.period = 278, e3.slash = 278, e3.zero = 556, e3.one = 556, e3.two = 556, e3.three = 556, e3.four = 556, e3.five = 556, e3.six = 556, e3.seven = 556, e3.eight = 556, e3.nine = 556, e3.colon = 278, e3.semicolon = 278, e3.less = 584, e3.equal = 584, e3.greater = 584, e3.question = 556, e3.at = 1015, e3.A = 667, e3.B = 667, e3.C = 722, e3.D = 722, e3.E = 667, e3.F = 611, e3.G = 778, e3.H = 722, e3.I = 278, e3.J = 500, e3.K = 667, e3.L = 556, e3.M = 833, e3.N = 722, e3.O = 778, e3.P = 667, e3.Q = 778, e3.R = 722, e3.S = 667, e3.T = 611, e3.U = 722, e3.V = 667, e3.W = 944, e3.X = 667, e3.Y = 667, e3.Z = 611, e3.bracketleft = 278, e3.backslash = 278, e3.bracketright = 278, e3.asciicircum = 469, e3.underscore = 556, e3.quoteleft = 222, e3.a = 556, e3.b = 556, e3.c = 500, e3.d = 556, e3.e = 556, e3.f = 278, e3.g = 556, e3.h = 556, e3.i = 222, e3.j = 222, e3.k = 500, e3.l = 222, e3.m = 833, e3.n = 556, e3.o = 556, e3.p = 556, e3.q = 556, e3.r = 333, e3.s = 500, e3.t = 278, e3.u = 556, e3.v = 500, e3.w = 722, e3.x = 500, e3.y = 500, e3.z = 500, e3.braceleft = 334, e3.bar = 260, e3.braceright = 334, e3.asciitilde = 584, e3.exclamdown = 333, e3.cent = 556, e3.sterling = 556, e3.fraction = 167, e3.yen = 556, e3.florin = 556, e3.section = 556, e3.currency = 556, e3.quotesingle = 191, e3.quotedblleft = 333, e3.guillemotleft = 556, e3.guilsinglleft = 333, e3.guilsinglright = 333, e3.fi = 500, e3.fl = 500, e3.endash = 556, e3.dagger = 556, e3.daggerdbl = 556, e3.periodcentered = 278, e3.paragraph = 537, e3.bullet = 350, e3.quotesinglbase = 222, e3.quotedblbase = 333, e3.quotedblright = 333, e3.guillemotright = 556, e3.ellipsis = 1e3, e3.perthousand = 1e3, e3.questiondown = 611, e3.grave = 333, e3.acute = 333, e3.circumflex = 333, e3.tilde = 333, e3.macron = 333, e3.breve = 333, e3.dotaccent = 333, e3.dieresis = 333, e3.ring = 333, e3.cedilla = 333, e3.hungarumlaut = 333, e3.ogonek = 333, e3.caron = 333, e3.emdash = 1e3, e3.AE = 1e3, e3.ordfeminine = 370, e3.Lslash = 556, e3.Oslash = 778, e3.OE = 1e3, e3.ordmasculine = 365, e3.ae = 889, e3.dotlessi = 278, e3.lslash = 222, e3.oslash = 611, e3.oe = 944, e3.germandbls = 611, e3.Idieresis = 278, e3.eacute = 556, e3.abreve = 556, e3.uhungarumlaut = 556, e3.ecaron = 556, e3.Ydieresis = 667, e3.divide = 584, e3.Yacute = 667, e3.Acircumflex = 667, e3.aacute = 556, e3.Ucircumflex = 722, e3.yacute = 500, e3.scommaaccent = 500, e3.ecircumflex = 556, e3.Uring = 722, e3.Udieresis = 722, e3.aogonek = 556, e3.Uacute = 722, e3.uogonek = 556, e3.Edieresis = 667, e3.Dcroat = 722, e3.commaaccent = 250, e3.copyright = 737, e3.Emacron = 667, e3.ccaron = 500, e3.aring = 556, e3.Ncommaaccent = 722, e3.lacute = 222, e3.agrave = 556, e3.Tcommaaccent = 611, e3.Cacute = 722, e3.atilde = 556, e3.Edotaccent = 667, e3.scaron = 500, e3.scedilla = 500, e3.iacute = 278, e3.lozenge = 471, e3.Rcaron = 722, e3.Gcommaaccent = 778, e3.ucircumflex = 556, e3.acircumflex = 556, e3.Amacron = 667, e3.rcaron = 333, e3.ccedilla = 500, e3.Zdotaccent = 611, e3.Thorn = 667, e3.Omacron = 778, e3.Racute = 722, e3.Sacute = 667, e3.dcaron = 643, e3.Umacron = 722, e3.uring = 556, e3.threesuperior = 333, e3.Ograve = 778, e3.Agrave = 667, e3.Abreve = 667, e3.multiply = 584, e3.uacute = 556, e3.Tcaron = 611, e3.partialdiff = 476, e3.ydieresis = 500, e3.Nacute = 722, e3.icircumflex = 278, e3.Ecircumflex = 667, e3.adieresis = 556, e3.edieresis = 556, e3.cacute = 500, e3.nacute = 556, e3.umacron = 556, e3.Ncaron = 722, e3.Iacute = 278, e3.plusminus = 584, e3.brokenbar = 260, e3.registered = 737, e3.Gbreve = 778, e3.Idotaccent = 278, e3.summation = 600, e3.Egrave = 667, e3.racute = 333, e3.omacron = 556, e3.Zacute = 611, e3.Zcaron = 611, e3.greaterequal = 549, e3.Eth = 722, e3.Ccedilla = 722, e3.lcommaaccent = 222, e3.tcaron = 317, e3.eogonek = 556, e3.Uogonek = 722, e3.Aacute = 667, e3.Adieresis = 667, e3.egrave = 556, e3.zacute = 500, e3.iogonek = 222, e3.Oacute = 778, e3.oacute = 556, e3.amacron = 556, e3.sacute = 500, e3.idieresis = 278, e3.Ocircumflex = 778, e3.Ugrave = 722, e3.Delta = 612, e3.thorn = 556, e3.twosuperior = 333, e3.Odieresis = 778, e3.mu = 556, e3.igrave = 278, e3.ohungarumlaut = 556, e3.Eogonek = 667, e3.dcroat = 556, e3.threequarters = 834, e3.Scedilla = 667, e3.lcaron = 299, e3.Kcommaaccent = 667, e3.Lacute = 556, e3.trademark = 1e3, e3.edotaccent = 556, e3.Igrave = 278, e3.Imacron = 278, e3.Lcaron = 556, e3.onehalf = 834, e3.lessequal = 549, e3.ocircumflex = 556, e3.ntilde = 556, e3.Uhungarumlaut = 722, e3.Eacute = 667, e3.emacron = 556, e3.gbreve = 556, e3.onequarter = 834, e3.Scaron = 667, e3.Scommaaccent = 667, e3.Ohungarumlaut = 778, e3.degree = 400, e3.ograve = 556, e3.Ccaron = 722, e3.ugrave = 556, e3.radical = 453, e3.Dcaron = 722, e3.rcommaaccent = 333, e3.Ntilde = 722, e3.otilde = 556, e3.Rcommaaccent = 722, e3.Lcommaaccent = 556, e3.Atilde = 667, e3.Aogonek = 667, e3.Aring = 667, e3.Otilde = 778, e3.zdotaccent = 500, e3.Ecaron = 667, e3.Iogonek = 278, e3.kcommaaccent = 500, e3.minus = 584, e3.Icircumflex = 278, e3.ncaron = 556, e3.tcommaaccent = 278, e3.logicalnot = 584, e3.odieresis = 556, e3.udieresis = 556, e3.notequal = 549, e3.gcommaaccent = 556, e3.eth = 556, e3.zcaron = 500, e3.ncommaaccent = 556, e3.onesuperior = 333, e3.imacron = 278, e3.Euro = 556;
  }), e2["Helvetica-Bold"] = getLookupTableFactory(function(e3) {
    e3.space = 278, e3.exclam = 333, e3.quotedbl = 474, e3.numbersign = 556, e3.dollar = 556, e3.percent = 889, e3.ampersand = 722, e3.quoteright = 278, e3.parenleft = 333, e3.parenright = 333, e3.asterisk = 389, e3.plus = 584, e3.comma = 278, e3.hyphen = 333, e3.period = 278, e3.slash = 278, e3.zero = 556, e3.one = 556, e3.two = 556, e3.three = 556, e3.four = 556, e3.five = 556, e3.six = 556, e3.seven = 556, e3.eight = 556, e3.nine = 556, e3.colon = 333, e3.semicolon = 333, e3.less = 584, e3.equal = 584, e3.greater = 584, e3.question = 611, e3.at = 975, e3.A = 722, e3.B = 722, e3.C = 722, e3.D = 722, e3.E = 667, e3.F = 611, e3.G = 778, e3.H = 722, e3.I = 278, e3.J = 556, e3.K = 722, e3.L = 611, e3.M = 833, e3.N = 722, e3.O = 778, e3.P = 667, e3.Q = 778, e3.R = 722, e3.S = 667, e3.T = 611, e3.U = 722, e3.V = 667, e3.W = 944, e3.X = 667, e3.Y = 667, e3.Z = 611, e3.bracketleft = 333, e3.backslash = 278, e3.bracketright = 333, e3.asciicircum = 584, e3.underscore = 556, e3.quoteleft = 278, e3.a = 556, e3.b = 611, e3.c = 556, e3.d = 611, e3.e = 556, e3.f = 333, e3.g = 611, e3.h = 611, e3.i = 278, e3.j = 278, e3.k = 556, e3.l = 278, e3.m = 889, e3.n = 611, e3.o = 611, e3.p = 611, e3.q = 611, e3.r = 389, e3.s = 556, e3.t = 333, e3.u = 611, e3.v = 556, e3.w = 778, e3.x = 556, e3.y = 556, e3.z = 500, e3.braceleft = 389, e3.bar = 280, e3.braceright = 389, e3.asciitilde = 584, e3.exclamdown = 333, e3.cent = 556, e3.sterling = 556, e3.fraction = 167, e3.yen = 556, e3.florin = 556, e3.section = 556, e3.currency = 556, e3.quotesingle = 238, e3.quotedblleft = 500, e3.guillemotleft = 556, e3.guilsinglleft = 333, e3.guilsinglright = 333, e3.fi = 611, e3.fl = 611, e3.endash = 556, e3.dagger = 556, e3.daggerdbl = 556, e3.periodcentered = 278, e3.paragraph = 556, e3.bullet = 350, e3.quotesinglbase = 278, e3.quotedblbase = 500, e3.quotedblright = 500, e3.guillemotright = 556, e3.ellipsis = 1e3, e3.perthousand = 1e3, e3.questiondown = 611, e3.grave = 333, e3.acute = 333, e3.circumflex = 333, e3.tilde = 333, e3.macron = 333, e3.breve = 333, e3.dotaccent = 333, e3.dieresis = 333, e3.ring = 333, e3.cedilla = 333, e3.hungarumlaut = 333, e3.ogonek = 333, e3.caron = 333, e3.emdash = 1e3, e3.AE = 1e3, e3.ordfeminine = 370, e3.Lslash = 611, e3.Oslash = 778, e3.OE = 1e3, e3.ordmasculine = 365, e3.ae = 889, e3.dotlessi = 278, e3.lslash = 278, e3.oslash = 611, e3.oe = 944, e3.germandbls = 611, e3.Idieresis = 278, e3.eacute = 556, e3.abreve = 556, e3.uhungarumlaut = 611, e3.ecaron = 556, e3.Ydieresis = 667, e3.divide = 584, e3.Yacute = 667, e3.Acircumflex = 722, e3.aacute = 556, e3.Ucircumflex = 722, e3.yacute = 556, e3.scommaaccent = 556, e3.ecircumflex = 556, e3.Uring = 722, e3.Udieresis = 722, e3.aogonek = 556, e3.Uacute = 722, e3.uogonek = 611, e3.Edieresis = 667, e3.Dcroat = 722, e3.commaaccent = 250, e3.copyright = 737, e3.Emacron = 667, e3.ccaron = 556, e3.aring = 556, e3.Ncommaaccent = 722, e3.lacute = 278, e3.agrave = 556, e3.Tcommaaccent = 611, e3.Cacute = 722, e3.atilde = 556, e3.Edotaccent = 667, e3.scaron = 556, e3.scedilla = 556, e3.iacute = 278, e3.lozenge = 494, e3.Rcaron = 722, e3.Gcommaaccent = 778, e3.ucircumflex = 611, e3.acircumflex = 556, e3.Amacron = 722, e3.rcaron = 389, e3.ccedilla = 556, e3.Zdotaccent = 611, e3.Thorn = 667, e3.Omacron = 778, e3.Racute = 722, e3.Sacute = 667, e3.dcaron = 743, e3.Umacron = 722, e3.uring = 611, e3.threesuperior = 333, e3.Ograve = 778, e3.Agrave = 722, e3.Abreve = 722, e3.multiply = 584, e3.uacute = 611, e3.Tcaron = 611, e3.partialdiff = 494, e3.ydieresis = 556, e3.Nacute = 722, e3.icircumflex = 278, e3.Ecircumflex = 667, e3.adieresis = 556, e3.edieresis = 556, e3.cacute = 556, e3.nacute = 611, e3.umacron = 611, e3.Ncaron = 722, e3.Iacute = 278, e3.plusminus = 584, e3.brokenbar = 280, e3.registered = 737, e3.Gbreve = 778, e3.Idotaccent = 278, e3.summation = 600, e3.Egrave = 667, e3.racute = 389, e3.omacron = 611, e3.Zacute = 611, e3.Zcaron = 611, e3.greaterequal = 549, e3.Eth = 722, e3.Ccedilla = 722, e3.lcommaaccent = 278, e3.tcaron = 389, e3.eogonek = 556, e3.Uogonek = 722, e3.Aacute = 722, e3.Adieresis = 722, e3.egrave = 556, e3.zacute = 500, e3.iogonek = 278, e3.Oacute = 778, e3.oacute = 611, e3.amacron = 556, e3.sacute = 556, e3.idieresis = 278, e3.Ocircumflex = 778, e3.Ugrave = 722, e3.Delta = 612, e3.thorn = 611, e3.twosuperior = 333, e3.Odieresis = 778, e3.mu = 611, e3.igrave = 278, e3.ohungarumlaut = 611, e3.Eogonek = 667, e3.dcroat = 611, e3.threequarters = 834, e3.Scedilla = 667, e3.lcaron = 400, e3.Kcommaaccent = 722, e3.Lacute = 611, e3.trademark = 1e3, e3.edotaccent = 556, e3.Igrave = 278, e3.Imacron = 278, e3.Lcaron = 611, e3.onehalf = 834, e3.lessequal = 549, e3.ocircumflex = 611, e3.ntilde = 611, e3.Uhungarumlaut = 722, e3.Eacute = 667, e3.emacron = 556, e3.gbreve = 611, e3.onequarter = 834, e3.Scaron = 667, e3.Scommaaccent = 667, e3.Ohungarumlaut = 778, e3.degree = 400, e3.ograve = 611, e3.Ccaron = 722, e3.ugrave = 611, e3.radical = 549, e3.Dcaron = 722, e3.rcommaaccent = 389, e3.Ntilde = 722, e3.otilde = 611, e3.Rcommaaccent = 722, e3.Lcommaaccent = 611, e3.Atilde = 722, e3.Aogonek = 722, e3.Aring = 722, e3.Otilde = 778, e3.zdotaccent = 500, e3.Ecaron = 667, e3.Iogonek = 278, e3.kcommaaccent = 556, e3.minus = 584, e3.Icircumflex = 278, e3.ncaron = 611, e3.tcommaaccent = 333, e3.logicalnot = 584, e3.odieresis = 611, e3.udieresis = 611, e3.notequal = 549, e3.gcommaaccent = 611, e3.eth = 611, e3.zcaron = 500, e3.ncommaaccent = 611, e3.onesuperior = 333, e3.imacron = 278, e3.Euro = 556;
  }), e2["Helvetica-BoldOblique"] = getLookupTableFactory(function(e3) {
    e3.space = 278, e3.exclam = 333, e3.quotedbl = 474, e3.numbersign = 556, e3.dollar = 556, e3.percent = 889, e3.ampersand = 722, e3.quoteright = 278, e3.parenleft = 333, e3.parenright = 333, e3.asterisk = 389, e3.plus = 584, e3.comma = 278, e3.hyphen = 333, e3.period = 278, e3.slash = 278, e3.zero = 556, e3.one = 556, e3.two = 556, e3.three = 556, e3.four = 556, e3.five = 556, e3.six = 556, e3.seven = 556, e3.eight = 556, e3.nine = 556, e3.colon = 333, e3.semicolon = 333, e3.less = 584, e3.equal = 584, e3.greater = 584, e3.question = 611, e3.at = 975, e3.A = 722, e3.B = 722, e3.C = 722, e3.D = 722, e3.E = 667, e3.F = 611, e3.G = 778, e3.H = 722, e3.I = 278, e3.J = 556, e3.K = 722, e3.L = 611, e3.M = 833, e3.N = 722, e3.O = 778, e3.P = 667, e3.Q = 778, e3.R = 722, e3.S = 667, e3.T = 611, e3.U = 722, e3.V = 667, e3.W = 944, e3.X = 667, e3.Y = 667, e3.Z = 611, e3.bracketleft = 333, e3.backslash = 278, e3.bracketright = 333, e3.asciicircum = 584, e3.underscore = 556, e3.quoteleft = 278, e3.a = 556, e3.b = 611, e3.c = 556, e3.d = 611, e3.e = 556, e3.f = 333, e3.g = 611, e3.h = 611, e3.i = 278, e3.j = 278, e3.k = 556, e3.l = 278, e3.m = 889, e3.n = 611, e3.o = 611, e3.p = 611, e3.q = 611, e3.r = 389, e3.s = 556, e3.t = 333, e3.u = 611, e3.v = 556, e3.w = 778, e3.x = 556, e3.y = 556, e3.z = 500, e3.braceleft = 389, e3.bar = 280, e3.braceright = 389, e3.asciitilde = 584, e3.exclamdown = 333, e3.cent = 556, e3.sterling = 556, e3.fraction = 167, e3.yen = 556, e3.florin = 556, e3.section = 556, e3.currency = 556, e3.quotesingle = 238, e3.quotedblleft = 500, e3.guillemotleft = 556, e3.guilsinglleft = 333, e3.guilsinglright = 333, e3.fi = 611, e3.fl = 611, e3.endash = 556, e3.dagger = 556, e3.daggerdbl = 556, e3.periodcentered = 278, e3.paragraph = 556, e3.bullet = 350, e3.quotesinglbase = 278, e3.quotedblbase = 500, e3.quotedblright = 500, e3.guillemotright = 556, e3.ellipsis = 1e3, e3.perthousand = 1e3, e3.questiondown = 611, e3.grave = 333, e3.acute = 333, e3.circumflex = 333, e3.tilde = 333, e3.macron = 333, e3.breve = 333, e3.dotaccent = 333, e3.dieresis = 333, e3.ring = 333, e3.cedilla = 333, e3.hungarumlaut = 333, e3.ogonek = 333, e3.caron = 333, e3.emdash = 1e3, e3.AE = 1e3, e3.ordfeminine = 370, e3.Lslash = 611, e3.Oslash = 778, e3.OE = 1e3, e3.ordmasculine = 365, e3.ae = 889, e3.dotlessi = 278, e3.lslash = 278, e3.oslash = 611, e3.oe = 944, e3.germandbls = 611, e3.Idieresis = 278, e3.eacute = 556, e3.abreve = 556, e3.uhungarumlaut = 611, e3.ecaron = 556, e3.Ydieresis = 667, e3.divide = 584, e3.Yacute = 667, e3.Acircumflex = 722, e3.aacute = 556, e3.Ucircumflex = 722, e3.yacute = 556, e3.scommaaccent = 556, e3.ecircumflex = 556, e3.Uring = 722, e3.Udieresis = 722, e3.aogonek = 556, e3.Uacute = 722, e3.uogonek = 611, e3.Edieresis = 667, e3.Dcroat = 722, e3.commaaccent = 250, e3.copyright = 737, e3.Emacron = 667, e3.ccaron = 556, e3.aring = 556, e3.Ncommaaccent = 722, e3.lacute = 278, e3.agrave = 556, e3.Tcommaaccent = 611, e3.Cacute = 722, e3.atilde = 556, e3.Edotaccent = 667, e3.scaron = 556, e3.scedilla = 556, e3.iacute = 278, e3.lozenge = 494, e3.Rcaron = 722, e3.Gcommaaccent = 778, e3.ucircumflex = 611, e3.acircumflex = 556, e3.Amacron = 722, e3.rcaron = 389, e3.ccedilla = 556, e3.Zdotaccent = 611, e3.Thorn = 667, e3.Omacron = 778, e3.Racute = 722, e3.Sacute = 667, e3.dcaron = 743, e3.Umacron = 722, e3.uring = 611, e3.threesuperior = 333, e3.Ograve = 778, e3.Agrave = 722, e3.Abreve = 722, e3.multiply = 584, e3.uacute = 611, e3.Tcaron = 611, e3.partialdiff = 494, e3.ydieresis = 556, e3.Nacute = 722, e3.icircumflex = 278, e3.Ecircumflex = 667, e3.adieresis = 556, e3.edieresis = 556, e3.cacute = 556, e3.nacute = 611, e3.umacron = 611, e3.Ncaron = 722, e3.Iacute = 278, e3.plusminus = 584, e3.brokenbar = 280, e3.registered = 737, e3.Gbreve = 778, e3.Idotaccent = 278, e3.summation = 600, e3.Egrave = 667, e3.racute = 389, e3.omacron = 611, e3.Zacute = 611, e3.Zcaron = 611, e3.greaterequal = 549, e3.Eth = 722, e3.Ccedilla = 722, e3.lcommaaccent = 278, e3.tcaron = 389, e3.eogonek = 556, e3.Uogonek = 722, e3.Aacute = 722, e3.Adieresis = 722, e3.egrave = 556, e3.zacute = 500, e3.iogonek = 278, e3.Oacute = 778, e3.oacute = 611, e3.amacron = 556, e3.sacute = 556, e3.idieresis = 278, e3.Ocircumflex = 778, e3.Ugrave = 722, e3.Delta = 612, e3.thorn = 611, e3.twosuperior = 333, e3.Odieresis = 778, e3.mu = 611, e3.igrave = 278, e3.ohungarumlaut = 611, e3.Eogonek = 667, e3.dcroat = 611, e3.threequarters = 834, e3.Scedilla = 667, e3.lcaron = 400, e3.Kcommaaccent = 722, e3.Lacute = 611, e3.trademark = 1e3, e3.edotaccent = 556, e3.Igrave = 278, e3.Imacron = 278, e3.Lcaron = 611, e3.onehalf = 834, e3.lessequal = 549, e3.ocircumflex = 611, e3.ntilde = 611, e3.Uhungarumlaut = 722, e3.Eacute = 667, e3.emacron = 556, e3.gbreve = 611, e3.onequarter = 834, e3.Scaron = 667, e3.Scommaaccent = 667, e3.Ohungarumlaut = 778, e3.degree = 400, e3.ograve = 611, e3.Ccaron = 722, e3.ugrave = 611, e3.radical = 549, e3.Dcaron = 722, e3.rcommaaccent = 389, e3.Ntilde = 722, e3.otilde = 611, e3.Rcommaaccent = 722, e3.Lcommaaccent = 611, e3.Atilde = 722, e3.Aogonek = 722, e3.Aring = 722, e3.Otilde = 778, e3.zdotaccent = 500, e3.Ecaron = 667, e3.Iogonek = 278, e3.kcommaaccent = 556, e3.minus = 584, e3.Icircumflex = 278, e3.ncaron = 611, e3.tcommaaccent = 333, e3.logicalnot = 584, e3.odieresis = 611, e3.udieresis = 611, e3.notequal = 549, e3.gcommaaccent = 611, e3.eth = 611, e3.zcaron = 500, e3.ncommaaccent = 611, e3.onesuperior = 333, e3.imacron = 278, e3.Euro = 556;
  }), e2["Helvetica-Oblique"] = getLookupTableFactory(function(e3) {
    e3.space = 278, e3.exclam = 278, e3.quotedbl = 355, e3.numbersign = 556, e3.dollar = 556, e3.percent = 889, e3.ampersand = 667, e3.quoteright = 222, e3.parenleft = 333, e3.parenright = 333, e3.asterisk = 389, e3.plus = 584, e3.comma = 278, e3.hyphen = 333, e3.period = 278, e3.slash = 278, e3.zero = 556, e3.one = 556, e3.two = 556, e3.three = 556, e3.four = 556, e3.five = 556, e3.six = 556, e3.seven = 556, e3.eight = 556, e3.nine = 556, e3.colon = 278, e3.semicolon = 278, e3.less = 584, e3.equal = 584, e3.greater = 584, e3.question = 556, e3.at = 1015, e3.A = 667, e3.B = 667, e3.C = 722, e3.D = 722, e3.E = 667, e3.F = 611, e3.G = 778, e3.H = 722, e3.I = 278, e3.J = 500, e3.K = 667, e3.L = 556, e3.M = 833, e3.N = 722, e3.O = 778, e3.P = 667, e3.Q = 778, e3.R = 722, e3.S = 667, e3.T = 611, e3.U = 722, e3.V = 667, e3.W = 944, e3.X = 667, e3.Y = 667, e3.Z = 611, e3.bracketleft = 278, e3.backslash = 278, e3.bracketright = 278, e3.asciicircum = 469, e3.underscore = 556, e3.quoteleft = 222, e3.a = 556, e3.b = 556, e3.c = 500, e3.d = 556, e3.e = 556, e3.f = 278, e3.g = 556, e3.h = 556, e3.i = 222, e3.j = 222, e3.k = 500, e3.l = 222, e3.m = 833, e3.n = 556, e3.o = 556, e3.p = 556, e3.q = 556, e3.r = 333, e3.s = 500, e3.t = 278, e3.u = 556, e3.v = 500, e3.w = 722, e3.x = 500, e3.y = 500, e3.z = 500, e3.braceleft = 334, e3.bar = 260, e3.braceright = 334, e3.asciitilde = 584, e3.exclamdown = 333, e3.cent = 556, e3.sterling = 556, e3.fraction = 167, e3.yen = 556, e3.florin = 556, e3.section = 556, e3.currency = 556, e3.quotesingle = 191, e3.quotedblleft = 333, e3.guillemotleft = 556, e3.guilsinglleft = 333, e3.guilsinglright = 333, e3.fi = 500, e3.fl = 500, e3.endash = 556, e3.dagger = 556, e3.daggerdbl = 556, e3.periodcentered = 278, e3.paragraph = 537, e3.bullet = 350, e3.quotesinglbase = 222, e3.quotedblbase = 333, e3.quotedblright = 333, e3.guillemotright = 556, e3.ellipsis = 1e3, e3.perthousand = 1e3, e3.questiondown = 611, e3.grave = 333, e3.acute = 333, e3.circumflex = 333, e3.tilde = 333, e3.macron = 333, e3.breve = 333, e3.dotaccent = 333, e3.dieresis = 333, e3.ring = 333, e3.cedilla = 333, e3.hungarumlaut = 333, e3.ogonek = 333, e3.caron = 333, e3.emdash = 1e3, e3.AE = 1e3, e3.ordfeminine = 370, e3.Lslash = 556, e3.Oslash = 778, e3.OE = 1e3, e3.ordmasculine = 365, e3.ae = 889, e3.dotlessi = 278, e3.lslash = 222, e3.oslash = 611, e3.oe = 944, e3.germandbls = 611, e3.Idieresis = 278, e3.eacute = 556, e3.abreve = 556, e3.uhungarumlaut = 556, e3.ecaron = 556, e3.Ydieresis = 667, e3.divide = 584, e3.Yacute = 667, e3.Acircumflex = 667, e3.aacute = 556, e3.Ucircumflex = 722, e3.yacute = 500, e3.scommaaccent = 500, e3.ecircumflex = 556, e3.Uring = 722, e3.Udieresis = 722, e3.aogonek = 556, e3.Uacute = 722, e3.uogonek = 556, e3.Edieresis = 667, e3.Dcroat = 722, e3.commaaccent = 250, e3.copyright = 737, e3.Emacron = 667, e3.ccaron = 500, e3.aring = 556, e3.Ncommaaccent = 722, e3.lacute = 222, e3.agrave = 556, e3.Tcommaaccent = 611, e3.Cacute = 722, e3.atilde = 556, e3.Edotaccent = 667, e3.scaron = 500, e3.scedilla = 500, e3.iacute = 278, e3.lozenge = 471, e3.Rcaron = 722, e3.Gcommaaccent = 778, e3.ucircumflex = 556, e3.acircumflex = 556, e3.Amacron = 667, e3.rcaron = 333, e3.ccedilla = 500, e3.Zdotaccent = 611, e3.Thorn = 667, e3.Omacron = 778, e3.Racute = 722, e3.Sacute = 667, e3.dcaron = 643, e3.Umacron = 722, e3.uring = 556, e3.threesuperior = 333, e3.Ograve = 778, e3.Agrave = 667, e3.Abreve = 667, e3.multiply = 584, e3.uacute = 556, e3.Tcaron = 611, e3.partialdiff = 476, e3.ydieresis = 500, e3.Nacute = 722, e3.icircumflex = 278, e3.Ecircumflex = 667, e3.adieresis = 556, e3.edieresis = 556, e3.cacute = 500, e3.nacute = 556, e3.umacron = 556, e3.Ncaron = 722, e3.Iacute = 278, e3.plusminus = 584, e3.brokenbar = 260, e3.registered = 737, e3.Gbreve = 778, e3.Idotaccent = 278, e3.summation = 600, e3.Egrave = 667, e3.racute = 333, e3.omacron = 556, e3.Zacute = 611, e3.Zcaron = 611, e3.greaterequal = 549, e3.Eth = 722, e3.Ccedilla = 722, e3.lcommaaccent = 222, e3.tcaron = 317, e3.eogonek = 556, e3.Uogonek = 722, e3.Aacute = 667, e3.Adieresis = 667, e3.egrave = 556, e3.zacute = 500, e3.iogonek = 222, e3.Oacute = 778, e3.oacute = 556, e3.amacron = 556, e3.sacute = 500, e3.idieresis = 278, e3.Ocircumflex = 778, e3.Ugrave = 722, e3.Delta = 612, e3.thorn = 556, e3.twosuperior = 333, e3.Odieresis = 778, e3.mu = 556, e3.igrave = 278, e3.ohungarumlaut = 556, e3.Eogonek = 667, e3.dcroat = 556, e3.threequarters = 834, e3.Scedilla = 667, e3.lcaron = 299, e3.Kcommaaccent = 667, e3.Lacute = 556, e3.trademark = 1e3, e3.edotaccent = 556, e3.Igrave = 278, e3.Imacron = 278, e3.Lcaron = 556, e3.onehalf = 834, e3.lessequal = 549, e3.ocircumflex = 556, e3.ntilde = 556, e3.Uhungarumlaut = 722, e3.Eacute = 667, e3.emacron = 556, e3.gbreve = 556, e3.onequarter = 834, e3.Scaron = 667, e3.Scommaaccent = 667, e3.Ohungarumlaut = 778, e3.degree = 400, e3.ograve = 556, e3.Ccaron = 722, e3.ugrave = 556, e3.radical = 453, e3.Dcaron = 722, e3.rcommaaccent = 333, e3.Ntilde = 722, e3.otilde = 556, e3.Rcommaaccent = 722, e3.Lcommaaccent = 556, e3.Atilde = 667, e3.Aogonek = 667, e3.Aring = 667, e3.Otilde = 778, e3.zdotaccent = 500, e3.Ecaron = 667, e3.Iogonek = 278, e3.kcommaaccent = 500, e3.minus = 584, e3.Icircumflex = 278, e3.ncaron = 556, e3.tcommaaccent = 278, e3.logicalnot = 584, e3.odieresis = 556, e3.udieresis = 556, e3.notequal = 549, e3.gcommaaccent = 556, e3.eth = 556, e3.zcaron = 500, e3.ncommaaccent = 556, e3.onesuperior = 333, e3.imacron = 278, e3.Euro = 556;
  }), e2.Symbol = getLookupTableFactory(function(e3) {
    e3.space = 250, e3.exclam = 333, e3.universal = 713, e3.numbersign = 500, e3.existential = 549, e3.percent = 833, e3.ampersand = 778, e3.suchthat = 439, e3.parenleft = 333, e3.parenright = 333, e3.asteriskmath = 500, e3.plus = 549, e3.comma = 250, e3.minus = 549, e3.period = 250, e3.slash = 278, e3.zero = 500, e3.one = 500, e3.two = 500, e3.three = 500, e3.four = 500, e3.five = 500, e3.six = 500, e3.seven = 500, e3.eight = 500, e3.nine = 500, e3.colon = 278, e3.semicolon = 278, e3.less = 549, e3.equal = 549, e3.greater = 549, e3.question = 444, e3.congruent = 549, e3.Alpha = 722, e3.Beta = 667, e3.Chi = 722, e3.Delta = 612, e3.Epsilon = 611, e3.Phi = 763, e3.Gamma = 603, e3.Eta = 722, e3.Iota = 333, e3.theta1 = 631, e3.Kappa = 722, e3.Lambda = 686, e3.Mu = 889, e3.Nu = 722, e3.Omicron = 722, e3.Pi = 768, e3.Theta = 741, e3.Rho = 556, e3.Sigma = 592, e3.Tau = 611, e3.Upsilon = 690, e3.sigma1 = 439, e3.Omega = 768, e3.Xi = 645, e3.Psi = 795, e3.Zeta = 611, e3.bracketleft = 333, e3.therefore = 863, e3.bracketright = 333, e3.perpendicular = 658, e3.underscore = 500, e3.radicalex = 500, e3.alpha = 631, e3.beta = 549, e3.chi = 549, e3.delta = 494, e3.epsilon = 439, e3.phi = 521, e3.gamma = 411, e3.eta = 603, e3.iota = 329, e3.phi1 = 603, e3.kappa = 549, e3.lambda = 549, e3.mu = 576, e3.nu = 521, e3.omicron = 549, e3.pi = 549, e3.theta = 521, e3.rho = 549, e3.sigma = 603, e3.tau = 439, e3.upsilon = 576, e3.omega1 = 713, e3.omega = 686, e3.xi = 493, e3.psi = 686, e3.zeta = 494, e3.braceleft = 480, e3.bar = 200, e3.braceright = 480, e3.similar = 549, e3.Euro = 750, e3.Upsilon1 = 620, e3.minute = 247, e3.lessequal = 549, e3.fraction = 167, e3.infinity = 713, e3.florin = 500, e3.club = 753, e3.diamond = 753, e3.heart = 753, e3.spade = 753, e3.arrowboth = 1042, e3.arrowleft = 987, e3.arrowup = 603, e3.arrowright = 987, e3.arrowdown = 603, e3.degree = 400, e3.plusminus = 549, e3.second = 411, e3.greaterequal = 549, e3.multiply = 549, e3.proportional = 713, e3.partialdiff = 494, e3.bullet = 460, e3.divide = 549, e3.notequal = 549, e3.equivalence = 549, e3.approxequal = 549, e3.ellipsis = 1e3, e3.arrowvertex = 603, e3.arrowhorizex = 1e3, e3.carriagereturn = 658, e3.aleph = 823, e3.Ifraktur = 686, e3.Rfraktur = 795, e3.weierstrass = 987, e3.circlemultiply = 768, e3.circleplus = 768, e3.emptyset = 823, e3.intersection = 768, e3.union = 768, e3.propersuperset = 713, e3.reflexsuperset = 713, e3.notsubset = 713, e3.propersubset = 713, e3.reflexsubset = 713, e3.element = 713, e3.notelement = 713, e3.angle = 768, e3.gradient = 713, e3.registerserif = 790, e3.copyrightserif = 790, e3.trademarkserif = 890, e3.product = 823, e3.radical = 549, e3.dotmath = 250, e3.logicalnot = 713, e3.logicaland = 603, e3.logicalor = 603, e3.arrowdblboth = 1042, e3.arrowdblleft = 987, e3.arrowdblup = 603, e3.arrowdblright = 987, e3.arrowdbldown = 603, e3.lozenge = 494, e3.angleleft = 329, e3.registersans = 790, e3.copyrightsans = 790, e3.trademarksans = 786, e3.summation = 713, e3.parenlefttp = 384, e3.parenleftex = 384, e3.parenleftbt = 384, e3.bracketlefttp = 384, e3.bracketleftex = 384, e3.bracketleftbt = 384, e3.bracelefttp = 494, e3.braceleftmid = 494, e3.braceleftbt = 494, e3.braceex = 494, e3.angleright = 329, e3.integral = 274, e3.integraltp = 686, e3.integralex = 686, e3.integralbt = 686, e3.parenrighttp = 384, e3.parenrightex = 384, e3.parenrightbt = 384, e3.bracketrighttp = 384, e3.bracketrightex = 384, e3.bracketrightbt = 384, e3.bracerighttp = 494, e3.bracerightmid = 494, e3.bracerightbt = 494, e3.apple = 790;
  }), e2["Times-Roman"] = getLookupTableFactory(function(e3) {
    e3.space = 250, e3.exclam = 333, e3.quotedbl = 408, e3.numbersign = 500, e3.dollar = 500, e3.percent = 833, e3.ampersand = 778, e3.quoteright = 333, e3.parenleft = 333, e3.parenright = 333, e3.asterisk = 500, e3.plus = 564, e3.comma = 250, e3.hyphen = 333, e3.period = 250, e3.slash = 278, e3.zero = 500, e3.one = 500, e3.two = 500, e3.three = 500, e3.four = 500, e3.five = 500, e3.six = 500, e3.seven = 500, e3.eight = 500, e3.nine = 500, e3.colon = 278, e3.semicolon = 278, e3.less = 564, e3.equal = 564, e3.greater = 564, e3.question = 444, e3.at = 921, e3.A = 722, e3.B = 667, e3.C = 667, e3.D = 722, e3.E = 611, e3.F = 556, e3.G = 722, e3.H = 722, e3.I = 333, e3.J = 389, e3.K = 722, e3.L = 611, e3.M = 889, e3.N = 722, e3.O = 722, e3.P = 556, e3.Q = 722, e3.R = 667, e3.S = 556, e3.T = 611, e3.U = 722, e3.V = 722, e3.W = 944, e3.X = 722, e3.Y = 722, e3.Z = 611, e3.bracketleft = 333, e3.backslash = 278, e3.bracketright = 333, e3.asciicircum = 469, e3.underscore = 500, e3.quoteleft = 333, e3.a = 444, e3.b = 500, e3.c = 444, e3.d = 500, e3.e = 444, e3.f = 333, e3.g = 500, e3.h = 500, e3.i = 278, e3.j = 278, e3.k = 500, e3.l = 278, e3.m = 778, e3.n = 500, e3.o = 500, e3.p = 500, e3.q = 500, e3.r = 333, e3.s = 389, e3.t = 278, e3.u = 500, e3.v = 500, e3.w = 722, e3.x = 500, e3.y = 500, e3.z = 444, e3.braceleft = 480, e3.bar = 200, e3.braceright = 480, e3.asciitilde = 541, e3.exclamdown = 333, e3.cent = 500, e3.sterling = 500, e3.fraction = 167, e3.yen = 500, e3.florin = 500, e3.section = 500, e3.currency = 500, e3.quotesingle = 180, e3.quotedblleft = 444, e3.guillemotleft = 500, e3.guilsinglleft = 333, e3.guilsinglright = 333, e3.fi = 556, e3.fl = 556, e3.endash = 500, e3.dagger = 500, e3.daggerdbl = 500, e3.periodcentered = 250, e3.paragraph = 453, e3.bullet = 350, e3.quotesinglbase = 333, e3.quotedblbase = 444, e3.quotedblright = 444, e3.guillemotright = 500, e3.ellipsis = 1e3, e3.perthousand = 1e3, e3.questiondown = 444, e3.grave = 333, e3.acute = 333, e3.circumflex = 333, e3.tilde = 333, e3.macron = 333, e3.breve = 333, e3.dotaccent = 333, e3.dieresis = 333, e3.ring = 333, e3.cedilla = 333, e3.hungarumlaut = 333, e3.ogonek = 333, e3.caron = 333, e3.emdash = 1e3, e3.AE = 889, e3.ordfeminine = 276, e3.Lslash = 611, e3.Oslash = 722, e3.OE = 889, e3.ordmasculine = 310, e3.ae = 667, e3.dotlessi = 278, e3.lslash = 278, e3.oslash = 500, e3.oe = 722, e3.germandbls = 500, e3.Idieresis = 333, e3.eacute = 444, e3.abreve = 444, e3.uhungarumlaut = 500, e3.ecaron = 444, e3.Ydieresis = 722, e3.divide = 564, e3.Yacute = 722, e3.Acircumflex = 722, e3.aacute = 444, e3.Ucircumflex = 722, e3.yacute = 500, e3.scommaaccent = 389, e3.ecircumflex = 444, e3.Uring = 722, e3.Udieresis = 722, e3.aogonek = 444, e3.Uacute = 722, e3.uogonek = 500, e3.Edieresis = 611, e3.Dcroat = 722, e3.commaaccent = 250, e3.copyright = 760, e3.Emacron = 611, e3.ccaron = 444, e3.aring = 444, e3.Ncommaaccent = 722, e3.lacute = 278, e3.agrave = 444, e3.Tcommaaccent = 611, e3.Cacute = 667, e3.atilde = 444, e3.Edotaccent = 611, e3.scaron = 389, e3.scedilla = 389, e3.iacute = 278, e3.lozenge = 471, e3.Rcaron = 667, e3.Gcommaaccent = 722, e3.ucircumflex = 500, e3.acircumflex = 444, e3.Amacron = 722, e3.rcaron = 333, e3.ccedilla = 444, e3.Zdotaccent = 611, e3.Thorn = 556, e3.Omacron = 722, e3.Racute = 667, e3.Sacute = 556, e3.dcaron = 588, e3.Umacron = 722, e3.uring = 500, e3.threesuperior = 300, e3.Ograve = 722, e3.Agrave = 722, e3.Abreve = 722, e3.multiply = 564, e3.uacute = 500, e3.Tcaron = 611, e3.partialdiff = 476, e3.ydieresis = 500, e3.Nacute = 722, e3.icircumflex = 278, e3.Ecircumflex = 611, e3.adieresis = 444, e3.edieresis = 444, e3.cacute = 444, e3.nacute = 500, e3.umacron = 500, e3.Ncaron = 722, e3.Iacute = 333, e3.plusminus = 564, e3.brokenbar = 200, e3.registered = 760, e3.Gbreve = 722, e3.Idotaccent = 333, e3.summation = 600, e3.Egrave = 611, e3.racute = 333, e3.omacron = 500, e3.Zacute = 611, e3.Zcaron = 611, e3.greaterequal = 549, e3.Eth = 722, e3.Ccedilla = 667, e3.lcommaaccent = 278, e3.tcaron = 326, e3.eogonek = 444, e3.Uogonek = 722, e3.Aacute = 722, e3.Adieresis = 722, e3.egrave = 444, e3.zacute = 444, e3.iogonek = 278, e3.Oacute = 722, e3.oacute = 500, e3.amacron = 444, e3.sacute = 389, e3.idieresis = 278, e3.Ocircumflex = 722, e3.Ugrave = 722, e3.Delta = 612, e3.thorn = 500, e3.twosuperior = 300, e3.Odieresis = 722, e3.mu = 500, e3.igrave = 278, e3.ohungarumlaut = 500, e3.Eogonek = 611, e3.dcroat = 500, e3.threequarters = 750, e3.Scedilla = 556, e3.lcaron = 344, e3.Kcommaaccent = 722, e3.Lacute = 611, e3.trademark = 980, e3.edotaccent = 444, e3.Igrave = 333, e3.Imacron = 333, e3.Lcaron = 611, e3.onehalf = 750, e3.lessequal = 549, e3.ocircumflex = 500, e3.ntilde = 500, e3.Uhungarumlaut = 722, e3.Eacute = 611, e3.emacron = 444, e3.gbreve = 500, e3.onequarter = 750, e3.Scaron = 556, e3.Scommaaccent = 556, e3.Ohungarumlaut = 722, e3.degree = 400, e3.ograve = 500, e3.Ccaron = 667, e3.ugrave = 500, e3.radical = 453, e3.Dcaron = 722, e3.rcommaaccent = 333, e3.Ntilde = 722, e3.otilde = 500, e3.Rcommaaccent = 667, e3.Lcommaaccent = 611, e3.Atilde = 722, e3.Aogonek = 722, e3.Aring = 722, e3.Otilde = 722, e3.zdotaccent = 444, e3.Ecaron = 611, e3.Iogonek = 333, e3.kcommaaccent = 500, e3.minus = 564, e3.Icircumflex = 333, e3.ncaron = 500, e3.tcommaaccent = 278, e3.logicalnot = 564, e3.odieresis = 500, e3.udieresis = 500, e3.notequal = 549, e3.gcommaaccent = 500, e3.eth = 500, e3.zcaron = 444, e3.ncommaaccent = 500, e3.onesuperior = 300, e3.imacron = 278, e3.Euro = 500;
  }), e2["Times-Bold"] = getLookupTableFactory(function(e3) {
    e3.space = 250, e3.exclam = 333, e3.quotedbl = 555, e3.numbersign = 500, e3.dollar = 500, e3.percent = 1e3, e3.ampersand = 833, e3.quoteright = 333, e3.parenleft = 333, e3.parenright = 333, e3.asterisk = 500, e3.plus = 570, e3.comma = 250, e3.hyphen = 333, e3.period = 250, e3.slash = 278, e3.zero = 500, e3.one = 500, e3.two = 500, e3.three = 500, e3.four = 500, e3.five = 500, e3.six = 500, e3.seven = 500, e3.eight = 500, e3.nine = 500, e3.colon = 333, e3.semicolon = 333, e3.less = 570, e3.equal = 570, e3.greater = 570, e3.question = 500, e3.at = 930, e3.A = 722, e3.B = 667, e3.C = 722, e3.D = 722, e3.E = 667, e3.F = 611, e3.G = 778, e3.H = 778, e3.I = 389, e3.J = 500, e3.K = 778, e3.L = 667, e3.M = 944, e3.N = 722, e3.O = 778, e3.P = 611, e3.Q = 778, e3.R = 722, e3.S = 556, e3.T = 667, e3.U = 722, e3.V = 722, e3.W = 1e3, e3.X = 722, e3.Y = 722, e3.Z = 667, e3.bracketleft = 333, e3.backslash = 278, e3.bracketright = 333, e3.asciicircum = 581, e3.underscore = 500, e3.quoteleft = 333, e3.a = 500, e3.b = 556, e3.c = 444, e3.d = 556, e3.e = 444, e3.f = 333, e3.g = 500, e3.h = 556, e3.i = 278, e3.j = 333, e3.k = 556, e3.l = 278, e3.m = 833, e3.n = 556, e3.o = 500, e3.p = 556, e3.q = 556, e3.r = 444, e3.s = 389, e3.t = 333, e3.u = 556, e3.v = 500, e3.w = 722, e3.x = 500, e3.y = 500, e3.z = 444, e3.braceleft = 394, e3.bar = 220, e3.braceright = 394, e3.asciitilde = 520, e3.exclamdown = 333, e3.cent = 500, e3.sterling = 500, e3.fraction = 167, e3.yen = 500, e3.florin = 500, e3.section = 500, e3.currency = 500, e3.quotesingle = 278, e3.quotedblleft = 500, e3.guillemotleft = 500, e3.guilsinglleft = 333, e3.guilsinglright = 333, e3.fi = 556, e3.fl = 556, e3.endash = 500, e3.dagger = 500, e3.daggerdbl = 500, e3.periodcentered = 250, e3.paragraph = 540, e3.bullet = 350, e3.quotesinglbase = 333, e3.quotedblbase = 500, e3.quotedblright = 500, e3.guillemotright = 500, e3.ellipsis = 1e3, e3.perthousand = 1e3, e3.questiondown = 500, e3.grave = 333, e3.acute = 333, e3.circumflex = 333, e3.tilde = 333, e3.macron = 333, e3.breve = 333, e3.dotaccent = 333, e3.dieresis = 333, e3.ring = 333, e3.cedilla = 333, e3.hungarumlaut = 333, e3.ogonek = 333, e3.caron = 333, e3.emdash = 1e3, e3.AE = 1e3, e3.ordfeminine = 300, e3.Lslash = 667, e3.Oslash = 778, e3.OE = 1e3, e3.ordmasculine = 330, e3.ae = 722, e3.dotlessi = 278, e3.lslash = 278, e3.oslash = 500, e3.oe = 722, e3.germandbls = 556, e3.Idieresis = 389, e3.eacute = 444, e3.abreve = 500, e3.uhungarumlaut = 556, e3.ecaron = 444, e3.Ydieresis = 722, e3.divide = 570, e3.Yacute = 722, e3.Acircumflex = 722, e3.aacute = 500, e3.Ucircumflex = 722, e3.yacute = 500, e3.scommaaccent = 389, e3.ecircumflex = 444, e3.Uring = 722, e3.Udieresis = 722, e3.aogonek = 500, e3.Uacute = 722, e3.uogonek = 556, e3.Edieresis = 667, e3.Dcroat = 722, e3.commaaccent = 250, e3.copyright = 747, e3.Emacron = 667, e3.ccaron = 444, e3.aring = 500, e3.Ncommaaccent = 722, e3.lacute = 278, e3.agrave = 500, e3.Tcommaaccent = 667, e3.Cacute = 722, e3.atilde = 500, e3.Edotaccent = 667, e3.scaron = 389, e3.scedilla = 389, e3.iacute = 278, e3.lozenge = 494, e3.Rcaron = 722, e3.Gcommaaccent = 778, e3.ucircumflex = 556, e3.acircumflex = 500, e3.Amacron = 722, e3.rcaron = 444, e3.ccedilla = 444, e3.Zdotaccent = 667, e3.Thorn = 611, e3.Omacron = 778, e3.Racute = 722, e3.Sacute = 556, e3.dcaron = 672, e3.Umacron = 722, e3.uring = 556, e3.threesuperior = 300, e3.Ograve = 778, e3.Agrave = 722, e3.Abreve = 722, e3.multiply = 570, e3.uacute = 556, e3.Tcaron = 667, e3.partialdiff = 494, e3.ydieresis = 500, e3.Nacute = 722, e3.icircumflex = 278, e3.Ecircumflex = 667, e3.adieresis = 500, e3.edieresis = 444, e3.cacute = 444, e3.nacute = 556, e3.umacron = 556, e3.Ncaron = 722, e3.Iacute = 389, e3.plusminus = 570, e3.brokenbar = 220, e3.registered = 747, e3.Gbreve = 778, e3.Idotaccent = 389, e3.summation = 600, e3.Egrave = 667, e3.racute = 444, e3.omacron = 500, e3.Zacute = 667, e3.Zcaron = 667, e3.greaterequal = 549, e3.Eth = 722, e3.Ccedilla = 722, e3.lcommaaccent = 278, e3.tcaron = 416, e3.eogonek = 444, e3.Uogonek = 722, e3.Aacute = 722, e3.Adieresis = 722, e3.egrave = 444, e3.zacute = 444, e3.iogonek = 278, e3.Oacute = 778, e3.oacute = 500, e3.amacron = 500, e3.sacute = 389, e3.idieresis = 278, e3.Ocircumflex = 778, e3.Ugrave = 722, e3.Delta = 612, e3.thorn = 556, e3.twosuperior = 300, e3.Odieresis = 778, e3.mu = 556, e3.igrave = 278, e3.ohungarumlaut = 500, e3.Eogonek = 667, e3.dcroat = 556, e3.threequarters = 750, e3.Scedilla = 556, e3.lcaron = 394, e3.Kcommaaccent = 778, e3.Lacute = 667, e3.trademark = 1e3, e3.edotaccent = 444, e3.Igrave = 389, e3.Imacron = 389, e3.Lcaron = 667, e3.onehalf = 750, e3.lessequal = 549, e3.ocircumflex = 500, e3.ntilde = 556, e3.Uhungarumlaut = 722, e3.Eacute = 667, e3.emacron = 444, e3.gbreve = 500, e3.onequarter = 750, e3.Scaron = 556, e3.Scommaaccent = 556, e3.Ohungarumlaut = 778, e3.degree = 400, e3.ograve = 500, e3.Ccaron = 722, e3.ugrave = 556, e3.radical = 549, e3.Dcaron = 722, e3.rcommaaccent = 444, e3.Ntilde = 722, e3.otilde = 500, e3.Rcommaaccent = 722, e3.Lcommaaccent = 667, e3.Atilde = 722, e3.Aogonek = 722, e3.Aring = 722, e3.Otilde = 778, e3.zdotaccent = 444, e3.Ecaron = 667, e3.Iogonek = 389, e3.kcommaaccent = 556, e3.minus = 570, e3.Icircumflex = 389, e3.ncaron = 556, e3.tcommaaccent = 333, e3.logicalnot = 570, e3.odieresis = 500, e3.udieresis = 556, e3.notequal = 549, e3.gcommaaccent = 500, e3.eth = 500, e3.zcaron = 444, e3.ncommaaccent = 556, e3.onesuperior = 300, e3.imacron = 278, e3.Euro = 500;
  }), e2["Times-BoldItalic"] = getLookupTableFactory(function(e3) {
    e3.space = 250, e3.exclam = 389, e3.quotedbl = 555, e3.numbersign = 500, e3.dollar = 500, e3.percent = 833, e3.ampersand = 778, e3.quoteright = 333, e3.parenleft = 333, e3.parenright = 333, e3.asterisk = 500, e3.plus = 570, e3.comma = 250, e3.hyphen = 333, e3.period = 250, e3.slash = 278, e3.zero = 500, e3.one = 500, e3.two = 500, e3.three = 500, e3.four = 500, e3.five = 500, e3.six = 500, e3.seven = 500, e3.eight = 500, e3.nine = 500, e3.colon = 333, e3.semicolon = 333, e3.less = 570, e3.equal = 570, e3.greater = 570, e3.question = 500, e3.at = 832, e3.A = 667, e3.B = 667, e3.C = 667, e3.D = 722, e3.E = 667, e3.F = 667, e3.G = 722, e3.H = 778, e3.I = 389, e3.J = 500, e3.K = 667, e3.L = 611, e3.M = 889, e3.N = 722, e3.O = 722, e3.P = 611, e3.Q = 722, e3.R = 667, e3.S = 556, e3.T = 611, e3.U = 722, e3.V = 667, e3.W = 889, e3.X = 667, e3.Y = 611, e3.Z = 611, e3.bracketleft = 333, e3.backslash = 278, e3.bracketright = 333, e3.asciicircum = 570, e3.underscore = 500, e3.quoteleft = 333, e3.a = 500, e3.b = 500, e3.c = 444, e3.d = 500, e3.e = 444, e3.f = 333, e3.g = 500, e3.h = 556, e3.i = 278, e3.j = 278, e3.k = 500, e3.l = 278, e3.m = 778, e3.n = 556, e3.o = 500, e3.p = 500, e3.q = 500, e3.r = 389, e3.s = 389, e3.t = 278, e3.u = 556, e3.v = 444, e3.w = 667, e3.x = 500, e3.y = 444, e3.z = 389, e3.braceleft = 348, e3.bar = 220, e3.braceright = 348, e3.asciitilde = 570, e3.exclamdown = 389, e3.cent = 500, e3.sterling = 500, e3.fraction = 167, e3.yen = 500, e3.florin = 500, e3.section = 500, e3.currency = 500, e3.quotesingle = 278, e3.quotedblleft = 500, e3.guillemotleft = 500, e3.guilsinglleft = 333, e3.guilsinglright = 333, e3.fi = 556, e3.fl = 556, e3.endash = 500, e3.dagger = 500, e3.daggerdbl = 500, e3.periodcentered = 250, e3.paragraph = 500, e3.bullet = 350, e3.quotesinglbase = 333, e3.quotedblbase = 500, e3.quotedblright = 500, e3.guillemotright = 500, e3.ellipsis = 1e3, e3.perthousand = 1e3, e3.questiondown = 500, e3.grave = 333, e3.acute = 333, e3.circumflex = 333, e3.tilde = 333, e3.macron = 333, e3.breve = 333, e3.dotaccent = 333, e3.dieresis = 333, e3.ring = 333, e3.cedilla = 333, e3.hungarumlaut = 333, e3.ogonek = 333, e3.caron = 333, e3.emdash = 1e3, e3.AE = 944, e3.ordfeminine = 266, e3.Lslash = 611, e3.Oslash = 722, e3.OE = 944, e3.ordmasculine = 300, e3.ae = 722, e3.dotlessi = 278, e3.lslash = 278, e3.oslash = 500, e3.oe = 722, e3.germandbls = 500, e3.Idieresis = 389, e3.eacute = 444, e3.abreve = 500, e3.uhungarumlaut = 556, e3.ecaron = 444, e3.Ydieresis = 611, e3.divide = 570, e3.Yacute = 611, e3.Acircumflex = 667, e3.aacute = 500, e3.Ucircumflex = 722, e3.yacute = 444, e3.scommaaccent = 389, e3.ecircumflex = 444, e3.Uring = 722, e3.Udieresis = 722, e3.aogonek = 500, e3.Uacute = 722, e3.uogonek = 556, e3.Edieresis = 667, e3.Dcroat = 722, e3.commaaccent = 250, e3.copyright = 747, e3.Emacron = 667, e3.ccaron = 444, e3.aring = 500, e3.Ncommaaccent = 722, e3.lacute = 278, e3.agrave = 500, e3.Tcommaaccent = 611, e3.Cacute = 667, e3.atilde = 500, e3.Edotaccent = 667, e3.scaron = 389, e3.scedilla = 389, e3.iacute = 278, e3.lozenge = 494, e3.Rcaron = 667, e3.Gcommaaccent = 722, e3.ucircumflex = 556, e3.acircumflex = 500, e3.Amacron = 667, e3.rcaron = 389, e3.ccedilla = 444, e3.Zdotaccent = 611, e3.Thorn = 611, e3.Omacron = 722, e3.Racute = 667, e3.Sacute = 556, e3.dcaron = 608, e3.Umacron = 722, e3.uring = 556, e3.threesuperior = 300, e3.Ograve = 722, e3.Agrave = 667, e3.Abreve = 667, e3.multiply = 570, e3.uacute = 556, e3.Tcaron = 611, e3.partialdiff = 494, e3.ydieresis = 444, e3.Nacute = 722, e3.icircumflex = 278, e3.Ecircumflex = 667, e3.adieresis = 500, e3.edieresis = 444, e3.cacute = 444, e3.nacute = 556, e3.umacron = 556, e3.Ncaron = 722, e3.Iacute = 389, e3.plusminus = 570, e3.brokenbar = 220, e3.registered = 747, e3.Gbreve = 722, e3.Idotaccent = 389, e3.summation = 600, e3.Egrave = 667, e3.racute = 389, e3.omacron = 500, e3.Zacute = 611, e3.Zcaron = 611, e3.greaterequal = 549, e3.Eth = 722, e3.Ccedilla = 667, e3.lcommaaccent = 278, e3.tcaron = 366, e3.eogonek = 444, e3.Uogonek = 722, e3.Aacute = 667, e3.Adieresis = 667, e3.egrave = 444, e3.zacute = 389, e3.iogonek = 278, e3.Oacute = 722, e3.oacute = 500, e3.amacron = 500, e3.sacute = 389, e3.idieresis = 278, e3.Ocircumflex = 722, e3.Ugrave = 722, e3.Delta = 612, e3.thorn = 500, e3.twosuperior = 300, e3.Odieresis = 722, e3.mu = 576, e3.igrave = 278, e3.ohungarumlaut = 500, e3.Eogonek = 667, e3.dcroat = 500, e3.threequarters = 750, e3.Scedilla = 556, e3.lcaron = 382, e3.Kcommaaccent = 667, e3.Lacute = 611, e3.trademark = 1e3, e3.edotaccent = 444, e3.Igrave = 389, e3.Imacron = 389, e3.Lcaron = 611, e3.onehalf = 750, e3.lessequal = 549, e3.ocircumflex = 500, e3.ntilde = 556, e3.Uhungarumlaut = 722, e3.Eacute = 667, e3.emacron = 444, e3.gbreve = 500, e3.onequarter = 750, e3.Scaron = 556, e3.Scommaaccent = 556, e3.Ohungarumlaut = 722, e3.degree = 400, e3.ograve = 500, e3.Ccaron = 667, e3.ugrave = 556, e3.radical = 549, e3.Dcaron = 722, e3.rcommaaccent = 389, e3.Ntilde = 722, e3.otilde = 500, e3.Rcommaaccent = 667, e3.Lcommaaccent = 611, e3.Atilde = 667, e3.Aogonek = 667, e3.Aring = 667, e3.Otilde = 722, e3.zdotaccent = 389, e3.Ecaron = 667, e3.Iogonek = 389, e3.kcommaaccent = 500, e3.minus = 606, e3.Icircumflex = 389, e3.ncaron = 556, e3.tcommaaccent = 278, e3.logicalnot = 606, e3.odieresis = 500, e3.udieresis = 556, e3.notequal = 549, e3.gcommaaccent = 500, e3.eth = 500, e3.zcaron = 389, e3.ncommaaccent = 556, e3.onesuperior = 300, e3.imacron = 278, e3.Euro = 500;
  }), e2["Times-Italic"] = getLookupTableFactory(function(e3) {
    e3.space = 250, e3.exclam = 333, e3.quotedbl = 420, e3.numbersign = 500, e3.dollar = 500, e3.percent = 833, e3.ampersand = 778, e3.quoteright = 333, e3.parenleft = 333, e3.parenright = 333, e3.asterisk = 500, e3.plus = 675, e3.comma = 250, e3.hyphen = 333, e3.period = 250, e3.slash = 278, e3.zero = 500, e3.one = 500, e3.two = 500, e3.three = 500, e3.four = 500, e3.five = 500, e3.six = 500, e3.seven = 500, e3.eight = 500, e3.nine = 500, e3.colon = 333, e3.semicolon = 333, e3.less = 675, e3.equal = 675, e3.greater = 675, e3.question = 500, e3.at = 920, e3.A = 611, e3.B = 611, e3.C = 667, e3.D = 722, e3.E = 611, e3.F = 611, e3.G = 722, e3.H = 722, e3.I = 333, e3.J = 444, e3.K = 667, e3.L = 556, e3.M = 833, e3.N = 667, e3.O = 722, e3.P = 611, e3.Q = 722, e3.R = 611, e3.S = 500, e3.T = 556, e3.U = 722, e3.V = 611, e3.W = 833, e3.X = 611, e3.Y = 556, e3.Z = 556, e3.bracketleft = 389, e3.backslash = 278, e3.bracketright = 389, e3.asciicircum = 422, e3.underscore = 500, e3.quoteleft = 333, e3.a = 500, e3.b = 500, e3.c = 444, e3.d = 500, e3.e = 444, e3.f = 278, e3.g = 500, e3.h = 500, e3.i = 278, e3.j = 278, e3.k = 444, e3.l = 278, e3.m = 722, e3.n = 500, e3.o = 500, e3.p = 500, e3.q = 500, e3.r = 389, e3.s = 389, e3.t = 278, e3.u = 500, e3.v = 444, e3.w = 667, e3.x = 444, e3.y = 444, e3.z = 389, e3.braceleft = 400, e3.bar = 275, e3.braceright = 400, e3.asciitilde = 541, e3.exclamdown = 389, e3.cent = 500, e3.sterling = 500, e3.fraction = 167, e3.yen = 500, e3.florin = 500, e3.section = 500, e3.currency = 500, e3.quotesingle = 214, e3.quotedblleft = 556, e3.guillemotleft = 500, e3.guilsinglleft = 333, e3.guilsinglright = 333, e3.fi = 500, e3.fl = 500, e3.endash = 500, e3.dagger = 500, e3.daggerdbl = 500, e3.periodcentered = 250, e3.paragraph = 523, e3.bullet = 350, e3.quotesinglbase = 333, e3.quotedblbase = 556, e3.quotedblright = 556, e3.guillemotright = 500, e3.ellipsis = 889, e3.perthousand = 1e3, e3.questiondown = 500, e3.grave = 333, e3.acute = 333, e3.circumflex = 333, e3.tilde = 333, e3.macron = 333, e3.breve = 333, e3.dotaccent = 333, e3.dieresis = 333, e3.ring = 333, e3.cedilla = 333, e3.hungarumlaut = 333, e3.ogonek = 333, e3.caron = 333, e3.emdash = 889, e3.AE = 889, e3.ordfeminine = 276, e3.Lslash = 556, e3.Oslash = 722, e3.OE = 944, e3.ordmasculine = 310, e3.ae = 667, e3.dotlessi = 278, e3.lslash = 278, e3.oslash = 500, e3.oe = 667, e3.germandbls = 500, e3.Idieresis = 333, e3.eacute = 444, e3.abreve = 500, e3.uhungarumlaut = 500, e3.ecaron = 444, e3.Ydieresis = 556, e3.divide = 675, e3.Yacute = 556, e3.Acircumflex = 611, e3.aacute = 500, e3.Ucircumflex = 722, e3.yacute = 444, e3.scommaaccent = 389, e3.ecircumflex = 444, e3.Uring = 722, e3.Udieresis = 722, e3.aogonek = 500, e3.Uacute = 722, e3.uogonek = 500, e3.Edieresis = 611, e3.Dcroat = 722, e3.commaaccent = 250, e3.copyright = 760, e3.Emacron = 611, e3.ccaron = 444, e3.aring = 500, e3.Ncommaaccent = 667, e3.lacute = 278, e3.agrave = 500, e3.Tcommaaccent = 556, e3.Cacute = 667, e3.atilde = 500, e3.Edotaccent = 611, e3.scaron = 389, e3.scedilla = 389, e3.iacute = 278, e3.lozenge = 471, e3.Rcaron = 611, e3.Gcommaaccent = 722, e3.ucircumflex = 500, e3.acircumflex = 500, e3.Amacron = 611, e3.rcaron = 389, e3.ccedilla = 444, e3.Zdotaccent = 556, e3.Thorn = 611, e3.Omacron = 722, e3.Racute = 611, e3.Sacute = 500, e3.dcaron = 544, e3.Umacron = 722, e3.uring = 500, e3.threesuperior = 300, e3.Ograve = 722, e3.Agrave = 611, e3.Abreve = 611, e3.multiply = 675, e3.uacute = 500, e3.Tcaron = 556, e3.partialdiff = 476, e3.ydieresis = 444, e3.Nacute = 667, e3.icircumflex = 278, e3.Ecircumflex = 611, e3.adieresis = 500, e3.edieresis = 444, e3.cacute = 444, e3.nacute = 500, e3.umacron = 500, e3.Ncaron = 667, e3.Iacute = 333, e3.plusminus = 675, e3.brokenbar = 275, e3.registered = 760, e3.Gbreve = 722, e3.Idotaccent = 333, e3.summation = 600, e3.Egrave = 611, e3.racute = 389, e3.omacron = 500, e3.Zacute = 556, e3.Zcaron = 556, e3.greaterequal = 549, e3.Eth = 722, e3.Ccedilla = 667, e3.lcommaaccent = 278, e3.tcaron = 300, e3.eogonek = 444, e3.Uogonek = 722, e3.Aacute = 611, e3.Adieresis = 611, e3.egrave = 444, e3.zacute = 389, e3.iogonek = 278, e3.Oacute = 722, e3.oacute = 500, e3.amacron = 500, e3.sacute = 389, e3.idieresis = 278, e3.Ocircumflex = 722, e3.Ugrave = 722, e3.Delta = 612, e3.thorn = 500, e3.twosuperior = 300, e3.Odieresis = 722, e3.mu = 500, e3.igrave = 278, e3.ohungarumlaut = 500, e3.Eogonek = 611, e3.dcroat = 500, e3.threequarters = 750, e3.Scedilla = 500, e3.lcaron = 300, e3.Kcommaaccent = 667, e3.Lacute = 556, e3.trademark = 980, e3.edotaccent = 444, e3.Igrave = 333, e3.Imacron = 333, e3.Lcaron = 611, e3.onehalf = 750, e3.lessequal = 549, e3.ocircumflex = 500, e3.ntilde = 500, e3.Uhungarumlaut = 722, e3.Eacute = 611, e3.emacron = 444, e3.gbreve = 500, e3.onequarter = 750, e3.Scaron = 500, e3.Scommaaccent = 500, e3.Ohungarumlaut = 722, e3.degree = 400, e3.ograve = 500, e3.Ccaron = 667, e3.ugrave = 500, e3.radical = 453, e3.Dcaron = 722, e3.rcommaaccent = 389, e3.Ntilde = 667, e3.otilde = 500, e3.Rcommaaccent = 611, e3.Lcommaaccent = 556, e3.Atilde = 611, e3.Aogonek = 611, e3.Aring = 611, e3.Otilde = 722, e3.zdotaccent = 389, e3.Ecaron = 611, e3.Iogonek = 333, e3.kcommaaccent = 444, e3.minus = 675, e3.Icircumflex = 333, e3.ncaron = 500, e3.tcommaaccent = 278, e3.logicalnot = 675, e3.odieresis = 500, e3.udieresis = 500, e3.notequal = 549, e3.gcommaaccent = 500, e3.eth = 500, e3.zcaron = 389, e3.ncommaaccent = 500, e3.onesuperior = 300, e3.imacron = 278, e3.Euro = 500;
  }), e2.ZapfDingbats = getLookupTableFactory(function(e3) {
    e3.space = 278, e3.a1 = 974, e3.a2 = 961, e3.a202 = 974, e3.a3 = 980, e3.a4 = 719, e3.a5 = 789, e3.a119 = 790, e3.a118 = 791, e3.a117 = 690, e3.a11 = 960, e3.a12 = 939, e3.a13 = 549, e3.a14 = 855, e3.a15 = 911, e3.a16 = 933, e3.a105 = 911, e3.a17 = 945, e3.a18 = 974, e3.a19 = 755, e3.a20 = 846, e3.a21 = 762, e3.a22 = 761, e3.a23 = 571, e3.a24 = 677, e3.a25 = 763, e3.a26 = 760, e3.a27 = 759, e3.a28 = 754, e3.a6 = 494, e3.a7 = 552, e3.a8 = 537, e3.a9 = 577, e3.a10 = 692, e3.a29 = 786, e3.a30 = 788, e3.a31 = 788, e3.a32 = 790, e3.a33 = 793, e3.a34 = 794, e3.a35 = 816, e3.a36 = 823, e3.a37 = 789, e3.a38 = 841, e3.a39 = 823, e3.a40 = 833, e3.a41 = 816, e3.a42 = 831, e3.a43 = 923, e3.a44 = 744, e3.a45 = 723, e3.a46 = 749, e3.a47 = 790, e3.a48 = 792, e3.a49 = 695, e3.a50 = 776, e3.a51 = 768, e3.a52 = 792, e3.a53 = 759, e3.a54 = 707, e3.a55 = 708, e3.a56 = 682, e3.a57 = 701, e3.a58 = 826, e3.a59 = 815, e3.a60 = 789, e3.a61 = 789, e3.a62 = 707, e3.a63 = 687, e3.a64 = 696, e3.a65 = 689, e3.a66 = 786, e3.a67 = 787, e3.a68 = 713, e3.a69 = 791, e3.a70 = 785, e3.a71 = 791, e3.a72 = 873, e3.a73 = 761, e3.a74 = 762, e3.a203 = 762, e3.a75 = 759, e3.a204 = 759, e3.a76 = 892, e3.a77 = 892, e3.a78 = 788, e3.a79 = 784, e3.a81 = 438, e3.a82 = 138, e3.a83 = 277, e3.a84 = 415, e3.a97 = 392, e3.a98 = 392, e3.a99 = 668, e3.a100 = 668, e3.a89 = 390, e3.a90 = 390, e3.a93 = 317, e3.a94 = 317, e3.a91 = 276, e3.a92 = 276, e3.a205 = 509, e3.a85 = 509, e3.a206 = 410, e3.a86 = 410, e3.a87 = 234, e3.a88 = 234, e3.a95 = 334, e3.a96 = 334, e3.a101 = 732, e3.a102 = 544, e3.a103 = 544, e3.a104 = 910, e3.a106 = 667, e3.a107 = 760, e3.a108 = 760, e3.a112 = 776, e3.a111 = 595, e3.a110 = 694, e3.a109 = 626, e3.a120 = 788, e3.a121 = 788, e3.a122 = 788, e3.a123 = 788, e3.a124 = 788, e3.a125 = 788, e3.a126 = 788, e3.a127 = 788, e3.a128 = 788, e3.a129 = 788, e3.a130 = 788, e3.a131 = 788, e3.a132 = 788, e3.a133 = 788, e3.a134 = 788, e3.a135 = 788, e3.a136 = 788, e3.a137 = 788, e3.a138 = 788, e3.a139 = 788, e3.a140 = 788, e3.a141 = 788, e3.a142 = 788, e3.a143 = 788, e3.a144 = 788, e3.a145 = 788, e3.a146 = 788, e3.a147 = 788, e3.a148 = 788, e3.a149 = 788, e3.a150 = 788, e3.a151 = 788, e3.a152 = 788, e3.a153 = 788, e3.a154 = 788, e3.a155 = 788, e3.a156 = 788, e3.a157 = 788, e3.a158 = 788, e3.a159 = 788, e3.a160 = 894, e3.a161 = 838, e3.a163 = 1016, e3.a164 = 458, e3.a196 = 748, e3.a165 = 924, e3.a192 = 748, e3.a166 = 918, e3.a167 = 927, e3.a168 = 928, e3.a169 = 928, e3.a170 = 834, e3.a171 = 873, e3.a172 = 828, e3.a173 = 924, e3.a162 = 924, e3.a174 = 917, e3.a175 = 930, e3.a176 = 931, e3.a177 = 463, e3.a178 = 883, e3.a179 = 836, e3.a193 = 836, e3.a180 = 867, e3.a199 = 867, e3.a181 = 696, e3.a200 = 696, e3.a182 = 874, e3.a201 = 874, e3.a183 = 760, e3.a184 = 946, e3.a197 = 771, e3.a185 = 865, e3.a194 = 771, e3.a198 = 888, e3.a186 = 967, e3.a195 = 888, e3.a187 = 831, e3.a188 = 873, e3.a189 = 927, e3.a190 = 970, e3.a191 = 918;
  });
}), Vn = getLookupTableFactory(function(e2) {
  e2.Courier = { ascent: 629, descent: -157, capHeight: 562, xHeight: -426 }, e2["Courier-Bold"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 439 }, e2["Courier-Oblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 }, e2["Courier-BoldOblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 }, e2.Helvetica = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 }, e2["Helvetica-Bold"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 }, e2["Helvetica-Oblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 }, e2["Helvetica-BoldOblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 }, e2["Times-Roman"] = { ascent: 683, descent: -217, capHeight: 662, xHeight: 450 }, e2["Times-Bold"] = { ascent: 683, descent: -217, capHeight: 676, xHeight: 461 }, e2["Times-Italic"] = { ascent: 683, descent: -217, capHeight: 653, xHeight: 441 }, e2["Times-BoldItalic"] = { ascent: 683, descent: -217, capHeight: 669, xHeight: 462 }, e2.Symbol = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN }, e2.ZapfDingbats = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN };
});
class GlyfTable {
  constructor({ glyfTable: e2, isGlyphLocationsLong: t2, locaTable: i2, numGlyphs: n2 }) {
    this.glyphs = [];
    const a2 = new DataView(i2.buffer, i2.byteOffset, i2.byteLength), s2 = new DataView(e2.buffer, e2.byteOffset, e2.byteLength), r2 = t2 ? 4 : 2;
    let o2 = t2 ? a2.getUint32(0) : 2 * a2.getUint16(0), l2 = 0;
    for (let e3 = 0; e3 < n2; e3++) {
      l2 += r2;
      const e4 = t2 ? a2.getUint32(l2) : 2 * a2.getUint16(l2);
      if (e4 === o2) {
        this.glyphs.push(new Glyph({}));
        continue;
      }
      const i3 = Glyph.parse(o2, s2);
      this.glyphs.push(i3), o2 = e4;
    }
  }
  getSize() {
    return Math.sumPrecise(this.glyphs.map((e2) => e2.getSize() + 3 & -4));
  }
  write() {
    const e2 = this.getSize(), t2 = new DataView(new ArrayBuffer(e2)), i2 = e2 > 131070, n2 = i2 ? 4 : 2, a2 = new DataView(new ArrayBuffer((this.glyphs.length + 1) * n2));
    i2 ? a2.setUint32(0, 0) : a2.setUint16(0, 0);
    let s2 = 0, r2 = 0;
    for (const e3 of this.glyphs) s2 += e3.write(s2, t2), s2 = s2 + 3 & -4, r2 += n2, i2 ? a2.setUint32(r2, s2) : a2.setUint16(r2, s2 >> 1);
    return { isLocationLong: i2, loca: new Uint8Array(a2.buffer), glyf: new Uint8Array(t2.buffer) };
  }
  scale(e2) {
    for (let t2 = 0, i2 = this.glyphs.length; t2 < i2; t2++) this.glyphs[t2].scale(e2[t2]);
  }
}
class Glyph {
  constructor({ header: e2 = null, simple: t2 = null, composites: i2 = null }) {
    this.header = e2, this.simple = t2, this.composites = i2;
  }
  static parse(e2, t2) {
    const [i2, n2] = GlyphHeader.parse(e2, t2);
    if (e2 += i2, n2.numberOfContours < 0) {
      const i3 = [];
      for (; ; ) {
        const [n3, a3] = CompositeGlyph.parse(e2, t2);
        if (e2 += n3, i3.push(a3), !(32 & a3.flags)) break;
      }
      return new Glyph({ header: n2, composites: i3 });
    }
    const a2 = SimpleGlyph.parse(e2, t2, n2.numberOfContours);
    return new Glyph({ header: n2, simple: a2 });
  }
  getSize() {
    if (!this.header) return 0;
    const e2 = this.simple ? this.simple.getSize() : Math.sumPrecise(this.composites.map((e3) => e3.getSize()));
    return this.header.getSize() + e2;
  }
  write(e2, t2) {
    if (!this.header) return 0;
    const i2 = e2;
    if (e2 += this.header.write(e2, t2), this.simple) e2 += this.simple.write(e2, t2);
    else for (const i3 of this.composites) e2 += i3.write(e2, t2);
    return e2 - i2;
  }
  scale(e2) {
    if (!this.header) return;
    const t2 = (this.header.xMin + this.header.xMax) / 2;
    if (this.header.scale(t2, e2), this.simple) this.simple.scale(t2, e2);
    else for (const i2 of this.composites) i2.scale(t2, e2);
  }
}
class GlyphHeader {
  constructor({ numberOfContours: e2, xMin: t2, yMin: i2, xMax: n2, yMax: a2 }) {
    this.numberOfContours = e2, this.xMin = t2, this.yMin = i2, this.xMax = n2, this.yMax = a2;
  }
  static parse(e2, t2) {
    return [10, new GlyphHeader({ numberOfContours: t2.getInt16(e2), xMin: t2.getInt16(e2 + 2), yMin: t2.getInt16(e2 + 4), xMax: t2.getInt16(e2 + 6), yMax: t2.getInt16(e2 + 8) })];
  }
  getSize() {
    return 10;
  }
  write(e2, t2) {
    return t2.setInt16(e2, this.numberOfContours), t2.setInt16(e2 + 2, this.xMin), t2.setInt16(e2 + 4, this.yMin), t2.setInt16(e2 + 6, this.xMax), t2.setInt16(e2 + 8, this.yMax), 10;
  }
  scale(e2, t2) {
    this.xMin = Math.round(e2 + (this.xMin - e2) * t2), this.xMax = Math.round(e2 + (this.xMax - e2) * t2);
  }
}
class Contour {
  constructor({ flags: e2, xCoordinates: t2, yCoordinates: i2 }) {
    this.xCoordinates = t2, this.yCoordinates = i2, this.flags = e2;
  }
}
class SimpleGlyph {
  constructor({ contours: e2, instructions: t2 }) {
    this.contours = e2, this.instructions = t2;
  }
  static parse(e2, t2, i2) {
    const n2 = [];
    for (let a3 = 0; a3 < i2; a3++) {
      const i3 = t2.getUint16(e2);
      e2 += 2, n2.push(i3);
    }
    const a2 = n2[i2 - 1] + 1, s2 = t2.getUint16(e2);
    e2 += 2;
    const r2 = new Uint8Array(t2).slice(e2, e2 + s2);
    e2 += s2;
    const o2 = [];
    for (let i3 = 0; i3 < a2; e2++, i3++) {
      let n3 = t2.getUint8(e2);
      if (o2.push(n3), 8 & n3) {
        const a3 = t2.getUint8(++e2);
        n3 ^= 8;
        for (let e3 = 0; e3 < a3; e3++) o2.push(n3);
        i3 += a3;
      }
    }
    const l2 = [];
    let c2 = [], h2 = [], d2 = [];
    const u2 = [];
    let g2 = 0, f2 = 0;
    for (let i3 = 0; i3 < a2; i3++) {
      const a3 = o2[i3];
      if (2 & a3) {
        const i4 = t2.getUint8(e2++);
        f2 += 16 & a3 ? i4 : -i4, c2.push(f2);
      } else 16 & a3 || (f2 += t2.getInt16(e2), e2 += 2), c2.push(f2);
      n2[g2] === i3 && (g2++, l2.push(c2), c2 = []);
    }
    f2 = 0, g2 = 0;
    for (let i3 = 0; i3 < a2; i3++) {
      const a3 = o2[i3];
      if (4 & a3) {
        const i4 = t2.getUint8(e2++);
        f2 += 32 & a3 ? i4 : -i4, h2.push(f2);
      } else 32 & a3 || (f2 += t2.getInt16(e2), e2 += 2), h2.push(f2);
      d2.push(1 & a3 | 64 & a3), n2[g2] === i3 && (c2 = l2[g2], g2++, u2.push(new Contour({ flags: d2, xCoordinates: c2, yCoordinates: h2 })), h2 = [], d2 = []);
    }
    return new SimpleGlyph({ contours: u2, instructions: r2 });
  }
  getSize() {
    let e2 = 2 * this.contours.length + 2 + this.instructions.length, t2 = 0, i2 = 0;
    for (const n2 of this.contours) {
      e2 += n2.flags.length;
      for (let a2 = 0, s2 = n2.xCoordinates.length; a2 < s2; a2++) {
        const s3 = n2.xCoordinates[a2], r2 = n2.yCoordinates[a2];
        let o2 = Math.abs(s3 - t2);
        o2 > 255 ? e2 += 2 : o2 > 0 && (e2 += 1), t2 = s3, o2 = Math.abs(r2 - i2), o2 > 255 ? e2 += 2 : o2 > 0 && (e2 += 1), i2 = r2;
      }
    }
    return e2;
  }
  write(e2, t2) {
    const i2 = e2, n2 = [], a2 = [], s2 = [];
    let r2 = 0, o2 = 0;
    for (const i3 of this.contours) {
      for (let e3 = 0, t3 = i3.xCoordinates.length; e3 < t3; e3++) {
        let t4 = i3.flags[e3];
        const l2 = i3.xCoordinates[e3];
        let c2 = l2 - r2;
        if (0 === c2) t4 |= 16, n2.push(0);
        else {
          const e4 = Math.abs(c2);
          e4 <= 255 ? (t4 |= c2 >= 0 ? 18 : 2, n2.push(e4)) : n2.push(c2);
        }
        r2 = l2;
        const h2 = i3.yCoordinates[e3];
        if (c2 = h2 - o2, 0 === c2) t4 |= 32, a2.push(0);
        else {
          const e4 = Math.abs(c2);
          e4 <= 255 ? (t4 |= c2 >= 0 ? 36 : 4, a2.push(e4)) : a2.push(c2);
        }
        o2 = h2, s2.push(t4);
      }
      t2.setUint16(e2, n2.length - 1), e2 += 2;
    }
    t2.setUint16(e2, this.instructions.length), e2 += 2, this.instructions.length && (new Uint8Array(t2.buffer, 0, t2.buffer.byteLength).set(this.instructions, e2), e2 += this.instructions.length);
    for (const i3 of s2) t2.setUint8(e2++, i3);
    for (let i3 = 0, a3 = n2.length; i3 < a3; i3++) {
      const a4 = n2[i3], r3 = s2[i3];
      2 & r3 ? t2.setUint8(e2++, a4) : 16 & r3 || (t2.setInt16(e2, a4), e2 += 2);
    }
    for (let i3 = 0, n3 = a2.length; i3 < n3; i3++) {
      const n4 = a2[i3], r3 = s2[i3];
      4 & r3 ? t2.setUint8(e2++, n4) : 32 & r3 || (t2.setInt16(e2, n4), e2 += 2);
    }
    return e2 - i2;
  }
  scale(e2, t2) {
    for (const i2 of this.contours) if (0 !== i2.xCoordinates.length) for (let n2 = 0, a2 = i2.xCoordinates.length; n2 < a2; n2++) i2.xCoordinates[n2] = Math.round(e2 + (i2.xCoordinates[n2] - e2) * t2);
  }
}
class CompositeGlyph {
  constructor({ flags: e2, glyphIndex: t2, argument1: i2, argument2: n2, transf: a2, instructions: s2 }) {
    this.flags = e2, this.glyphIndex = t2, this.argument1 = i2, this.argument2 = n2, this.transf = a2, this.instructions = s2;
  }
  static parse(e2, t2) {
    const i2 = e2, n2 = [];
    let a2 = t2.getUint16(e2);
    const s2 = t2.getUint16(e2 + 2);
    let r2, o2;
    e2 += 4, 1 & a2 ? (2 & a2 ? (r2 = t2.getInt16(e2), o2 = t2.getInt16(e2 + 2)) : (r2 = t2.getUint16(e2), o2 = t2.getUint16(e2 + 2)), e2 += 4, a2 ^= 1) : (2 & a2 ? (r2 = t2.getInt8(e2), o2 = t2.getInt8(e2 + 1)) : (r2 = t2.getUint8(e2), o2 = t2.getUint8(e2 + 1)), e2 += 2), 8 & a2 ? (n2.push(t2.getUint16(e2)), e2 += 2) : 64 & a2 ? (n2.push(t2.getUint16(e2), t2.getUint16(e2 + 2)), e2 += 4) : 128 & a2 && (n2.push(t2.getUint16(e2), t2.getUint16(e2 + 2), t2.getUint16(e2 + 4), t2.getUint16(e2 + 6)), e2 += 8);
    let l2 = null;
    if (256 & a2) {
      const i3 = t2.getUint16(e2);
      e2 += 2, l2 = new Uint8Array(t2).slice(e2, e2 + i3), e2 += i3;
    }
    return [e2 - i2, new CompositeGlyph({ flags: a2, glyphIndex: s2, argument1: r2, argument2: o2, transf: n2, instructions: l2 })];
  }
  getSize() {
    let e2 = 4 + 2 * this.transf.length;
    return 256 & this.flags && (e2 += 2 + this.instructions.length), e2 += 2, 2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (e2 += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (e2 += 2), e2;
  }
  write(e2, t2) {
    const i2 = e2;
    return 2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= 1) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= 1), t2.setUint16(e2, this.flags), t2.setUint16(e2 + 2, this.glyphIndex), e2 += 4, 1 & this.flags ? (2 & this.flags ? (t2.setInt16(e2, this.argument1), t2.setInt16(e2 + 2, this.argument2)) : (t2.setUint16(e2, this.argument1), t2.setUint16(e2 + 2, this.argument2)), e2 += 4) : (t2.setUint8(e2, this.argument1), t2.setUint8(e2 + 1, this.argument2), e2 += 2), 256 & this.flags && (t2.setUint16(e2, this.instructions.length), e2 += 2, this.instructions.length && (new Uint8Array(t2.buffer, 0, t2.buffer.byteLength).set(this.instructions, e2), e2 += this.instructions.length)), e2 - i2;
  }
  scale(e2, t2) {
  }
}
function writeInt16(e2, t2, i2) {
  e2[t2] = i2 >> 8 & 255, e2[t2 + 1] = 255 & i2;
}
function writeInt32(e2, t2, i2) {
  e2[t2] = i2 >> 24 & 255, e2[t2 + 1] = i2 >> 16 & 255, e2[t2 + 2] = i2 >> 8 & 255, e2[t2 + 3] = 255 & i2;
}
function writeData(e2, t2, i2) {
  if (i2 instanceof Uint8Array) e2.set(i2, t2);
  else if ("string" == typeof i2) for (let n2 = 0, a2 = i2.length; n2 < a2; n2++) e2[t2++] = 255 & i2.charCodeAt(n2);
  else for (const n2 of i2) e2[t2++] = 255 & n2;
}
class OpenTypeFileBuilder {
  constructor(e2) {
    this.sfnt = e2, this.tables = /* @__PURE__ */ Object.create(null);
  }
  static getSearchParams(e2, t2) {
    let i2 = 1, n2 = 0;
    for (; (i2 ^ e2) > i2; ) i2 <<= 1, n2++;
    const a2 = i2 * t2;
    return { range: a2, entry: n2, rangeShift: t2 * e2 - a2 };
  }
  toArray() {
    let e2 = this.sfnt;
    const t2 = this.tables, i2 = Object.keys(t2);
    i2.sort();
    const n2 = i2.length;
    let a2, s2, r2, o2, l2, c2 = 12 + 16 * n2;
    const h2 = [c2];
    for (a2 = 0; a2 < n2; a2++) {
      o2 = t2[i2[a2]];
      c2 += (o2.length + 3 & -4) >>> 0, h2.push(c2);
    }
    const d2 = new Uint8Array(c2);
    for (a2 = 0; a2 < n2; a2++) o2 = t2[i2[a2]], writeData(d2, h2[a2], o2);
    "true" === e2 && (e2 = string32$1(65536)), d2[0] = 255 & e2.charCodeAt(0), d2[1] = 255 & e2.charCodeAt(1), d2[2] = 255 & e2.charCodeAt(2), d2[3] = 255 & e2.charCodeAt(3), writeInt16(d2, 4, n2);
    const u2 = OpenTypeFileBuilder.getSearchParams(n2, 16);
    for (writeInt16(d2, 6, u2.range), writeInt16(d2, 8, u2.entry), writeInt16(d2, 10, u2.rangeShift), c2 = 12, a2 = 0; a2 < n2; a2++) {
      l2 = i2[a2], d2[c2] = 255 & l2.charCodeAt(0), d2[c2 + 1] = 255 & l2.charCodeAt(1), d2[c2 + 2] = 255 & l2.charCodeAt(2), d2[c2 + 3] = 255 & l2.charCodeAt(3);
      let e3 = 0;
      for (s2 = h2[a2], r2 = h2[a2 + 1]; s2 < r2; s2 += 4) {
        e3 = e3 + readUint32(d2, s2) >>> 0;
      }
      writeInt32(d2, c2 + 4, e3), writeInt32(d2, c2 + 8, h2[a2]), writeInt32(d2, c2 + 12, t2[l2].length), c2 += 16;
    }
    return d2;
  }
  addTable(e2, t2) {
    if (e2 in this.tables) throw new Error("Table " + e2 + " already exists");
    this.tables[e2] = t2;
  }
}
const Kn = [4], Yn = [5], Jn = [6], Zn = [7], Qn = [8], ea = [12, 35], ta = [14], ia = [21], na = [22], aa = [30], sa = [31];
class Type1CharString {
  constructor() {
    this.width = 0, this.lsb = 0, this.flexing = false, this.output = [], this.stack = [];
  }
  convert(e2, t2, i2) {
    const n2 = e2.length;
    let a2, s2, r2, o2 = false;
    for (let l2 = 0; l2 < n2; l2++) {
      let n3 = e2[l2];
      if (n3 < 32) {
        switch (12 === n3 && (n3 = (n3 << 8) + e2[++l2]), n3) {
          case 1:
          case 3:
          case 9:
          case 3072:
          case 3073:
          case 3074:
          case 3105:
            this.stack = [];
            break;
          case 4:
            if (this.flexing) {
              if (this.stack.length < 1) {
                o2 = true;
                break;
              }
              const e4 = this.stack.pop();
              this.stack.push(0, e4);
              break;
            }
            o2 = this.executeCommand(1, Kn);
            break;
          case 5:
            o2 = this.executeCommand(2, Yn);
            break;
          case 6:
            o2 = this.executeCommand(1, Jn);
            break;
          case 7:
            o2 = this.executeCommand(1, Zn);
            break;
          case 8:
            o2 = this.executeCommand(6, Qn);
            break;
          case 10:
            if (this.stack.length < 1) {
              o2 = true;
              break;
            }
            if (r2 = this.stack.pop(), !t2[r2]) {
              o2 = true;
              break;
            }
            o2 = this.convert(t2[r2], t2, i2);
            break;
          case 11:
            return o2;
          case 13:
            if (this.stack.length < 2) {
              o2 = true;
              break;
            }
            a2 = this.stack.pop(), s2 = this.stack.pop(), this.lsb = s2, this.width = a2, this.stack.push(a2, s2), o2 = this.executeCommand(2, na);
            break;
          case 14:
            this.output.push(ta[0]);
            break;
          case 21:
            if (this.flexing) break;
            o2 = this.executeCommand(2, ia);
            break;
          case 22:
            if (this.flexing) {
              this.stack.push(0);
              break;
            }
            o2 = this.executeCommand(1, na);
            break;
          case 30:
            o2 = this.executeCommand(4, aa);
            break;
          case 31:
            o2 = this.executeCommand(4, sa);
            break;
          case 3078:
            if (i2) {
              const e4 = this.stack.at(-5);
              this.seac = this.stack.splice(-4, 4), this.seac[0] += this.lsb - e4, o2 = this.executeCommand(0, ta);
            } else o2 = this.executeCommand(4, ta);
            break;
          case 3079:
            if (this.stack.length < 4) {
              o2 = true;
              break;
            }
            this.stack.pop(), a2 = this.stack.pop();
            const e3 = this.stack.pop();
            s2 = this.stack.pop(), this.lsb = s2, this.width = a2, this.stack.push(a2, s2, e3), o2 = this.executeCommand(3, ia);
            break;
          case 3084:
            if (this.stack.length < 2) {
              o2 = true;
              break;
            }
            const l3 = this.stack.pop(), c2 = this.stack.pop();
            this.stack.push(c2 / l3);
            break;
          case 3088:
            if (this.stack.length < 2) {
              o2 = true;
              break;
            }
            r2 = this.stack.pop();
            const h2 = this.stack.pop();
            if (0 === r2 && 3 === h2) {
              const e4 = this.stack.splice(-17, 17);
              this.stack.push(e4[2] + e4[0], e4[3] + e4[1], e4[4], e4[5], e4[6], e4[7], e4[8], e4[9], e4[10], e4[11], e4[12], e4[13], e4[14]), o2 = this.executeCommand(13, ea, true), this.flexing = false, this.stack.push(e4[15], e4[16]);
            } else 1 === r2 && 0 === h2 && (this.flexing = true);
            break;
          case 3089:
            break;
          default:
            warn$1('Unknown type 1 charstring command of "' + n3 + '"');
        }
        if (o2) break;
      } else n3 <= 246 ? n3 -= 139 : n3 = n3 <= 250 ? 256 * (n3 - 247) + e2[++l2] + 108 : n3 <= 254 ? -256 * (n3 - 251) - e2[++l2] - 108 : (255 & e2[++l2]) << 24 | (255 & e2[++l2]) << 16 | (255 & e2[++l2]) << 8 | 255 & e2[++l2], this.stack.push(n3);
    }
    return o2;
  }
  executeCommand(e2, t2, i2) {
    const n2 = this.stack.length;
    if (e2 > n2) return true;
    const a2 = n2 - e2;
    for (let e3 = a2; e3 < n2; e3++) {
      let t3 = this.stack[e3];
      Number.isInteger(t3) ? this.output.push(28, t3 >> 8 & 255, 255 & t3) : (t3 = 65536 * t3 | 0, this.output.push(255, t3 >> 24 & 255, t3 >> 16 & 255, t3 >> 8 & 255, 255 & t3));
    }
    return this.output.push(...t2), i2 ? this.stack.splice(a2, e2) : this.stack.length = 0, false;
  }
}
function isHexDigit(e2) {
  return e2 >= 48 && e2 <= 57 || e2 >= 65 && e2 <= 70 || e2 >= 97 && e2 <= 102;
}
function decrypt(e2, t2, i2) {
  if (i2 >= e2.length) return new Uint8Array(0);
  let n2, a2, s2 = 0 | t2;
  for (n2 = 0; n2 < i2; n2++) s2 = 52845 * (e2[n2] + s2) + 22719 & 65535;
  const r2 = e2.length - i2, o2 = new Uint8Array(r2);
  for (n2 = i2, a2 = 0; a2 < r2; n2++, a2++) {
    const t3 = e2[n2];
    o2[a2] = t3 ^ s2 >> 8, s2 = 52845 * (t3 + s2) + 22719 & 65535;
  }
  return o2;
}
function isSpecial(e2) {
  return 47 === e2 || 91 === e2 || 93 === e2 || 123 === e2 || 125 === e2 || 40 === e2 || 41 === e2;
}
class Type1Parser {
  constructor(e2, t2, i2) {
    if (t2) {
      const t3 = e2.getBytes(), i3 = !((isHexDigit(t3[0]) || isWhiteSpace(t3[0])) && isHexDigit(t3[1]) && isHexDigit(t3[2]) && isHexDigit(t3[3]) && isHexDigit(t3[4]) && isHexDigit(t3[5]) && isHexDigit(t3[6]) && isHexDigit(t3[7]));
      e2 = new Stream(i3 ? decrypt(t3, 55665, 4) : (function(e3, t4, i4) {
        let n2 = 0 | t4;
        const a2 = e3.length, s2 = new Uint8Array(a2 >>> 1);
        let r2, o2;
        for (r2 = 0, o2 = 0; r2 < a2; r2++) {
          const t5 = e3[r2];
          if (!isHexDigit(t5)) continue;
          let i5;
          for (r2++; r2 < a2 && !isHexDigit(i5 = e3[r2]); ) r2++;
          if (r2 < a2) {
            const e4 = parseInt(String.fromCharCode(t5, i5), 16);
            s2[o2++] = e4 ^ n2 >> 8, n2 = 52845 * (e4 + n2) + 22719 & 65535;
          }
        }
        return s2.slice(i4, o2);
      })(t3, 55665, 4));
    }
    this.seacAnalysisEnabled = !!i2, this.stream = e2, this.nextChar();
  }
  readNumberArray() {
    this.getToken();
    const e2 = [];
    for (; ; ) {
      const t2 = this.getToken();
      if (null === t2 || "]" === t2 || "}" === t2) break;
      e2.push(parseFloat(t2 || 0));
    }
    return e2;
  }
  readNumber() {
    const e2 = this.getToken();
    return parseFloat(e2 || 0);
  }
  readInt() {
    const e2 = this.getToken();
    return 0 | parseInt(e2 || 0, 10);
  }
  readBoolean() {
    return "true" === this.getToken() ? 1 : 0;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  prevChar() {
    return this.stream.skip(-2), this.currentChar = this.stream.getByte();
  }
  getToken() {
    let e2 = false, t2 = this.currentChar;
    for (; ; ) {
      if (-1 === t2) return null;
      if (e2) 10 !== t2 && 13 !== t2 || (e2 = false);
      else if (37 === t2) e2 = true;
      else if (!isWhiteSpace(t2)) break;
      t2 = this.nextChar();
    }
    if (isSpecial(t2)) return this.nextChar(), String.fromCharCode(t2);
    let i2 = "";
    do {
      i2 += String.fromCharCode(t2), t2 = this.nextChar();
    } while (t2 >= 0 && !isWhiteSpace(t2) && !isSpecial(t2));
    return i2;
  }
  readCharStrings(e2, t2) {
    return -1 === t2 ? e2 : decrypt(e2, 4330, t2);
  }
  extractFontProgram(e2) {
    const t2 = this.stream, i2 = [], n2 = [], a2 = /* @__PURE__ */ Object.create(null);
    a2.lenIV = 4;
    const s2 = { subrs: [], charstrings: [], properties: { privateData: a2 } };
    let r2, o2, l2, c2;
    for (; null !== (r2 = this.getToken()); ) if ("/" === r2) switch (r2 = this.getToken(), r2) {
      case "CharStrings":
        for (this.getToken(), this.getToken(), this.getToken(), this.getToken(); r2 = this.getToken(), null !== r2 && "end" !== r2; ) {
          if ("/" !== r2) continue;
          const e4 = this.getToken();
          o2 = this.readInt(), this.getToken(), l2 = o2 > 0 ? t2.getBytes(o2) : new Uint8Array(0), c2 = s2.properties.privateData.lenIV;
          const i3 = this.readCharStrings(l2, c2);
          this.nextChar(), r2 = this.getToken(), "noaccess" === r2 ? this.getToken() : "/" === r2 && this.prevChar(), n2.push({ glyph: e4, encoded: i3 });
        }
        break;
      case "Subrs":
        for (this.readInt(), this.getToken(); "dup" === this.getToken(); ) {
          const e4 = this.readInt();
          o2 = this.readInt(), this.getToken(), l2 = o2 > 0 ? t2.getBytes(o2) : new Uint8Array(0), c2 = s2.properties.privateData.lenIV;
          const n3 = this.readCharStrings(l2, c2);
          this.nextChar(), r2 = this.getToken(), "noaccess" === r2 && this.getToken(), i2[e4] = n3;
        }
        break;
      case "BlueValues":
      case "OtherBlues":
      case "FamilyBlues":
      case "FamilyOtherBlues":
        const e3 = this.readNumberArray();
        e3.length > 0 && e3.length;
        break;
      case "StemSnapH":
      case "StemSnapV":
        s2.properties.privateData[r2] = this.readNumberArray();
        break;
      case "StdHW":
      case "StdVW":
        s2.properties.privateData[r2] = this.readNumberArray()[0];
        break;
      case "BlueShift":
      case "lenIV":
      case "BlueFuzz":
      case "BlueScale":
      case "LanguageGroup":
        s2.properties.privateData[r2] = this.readNumber();
        break;
      case "ExpansionFactor":
        s2.properties.privateData[r2] = this.readNumber() || 0.06;
        break;
      case "ForceBold":
        s2.properties.privateData[r2] = this.readBoolean();
    }
    for (const { encoded: t3, glyph: a3 } of n2) {
      const n3 = new Type1CharString(), r3 = n3.convert(t3, i2, this.seacAnalysisEnabled);
      let o3 = n3.output;
      r3 && (o3 = [14]);
      const l3 = { glyphName: a3, charstring: o3, width: n3.width, lsb: n3.lsb, seac: n3.seac };
      if (".notdef" === a3 ? s2.charstrings.unshift(l3) : s2.charstrings.push(l3), e2.builtInEncoding) {
        const t4 = e2.builtInEncoding.indexOf(a3);
        t4 > -1 && void 0 === e2.widths[t4] && t4 >= e2.firstChar && t4 <= e2.lastChar && (e2.widths[t4] = n3.width);
      }
    }
    return s2;
  }
  extractFontHeader(e2) {
    let t2;
    for (; null !== (t2 = this.getToken()); ) if ("/" === t2) switch (t2 = this.getToken(), t2) {
      case "FontMatrix":
        const i2 = this.readNumberArray();
        e2.fontMatrix = i2;
        break;
      case "Encoding":
        const n2 = this.getToken();
        let a2;
        if (/^\d+$/.test(n2)) {
          a2 = [];
          const e3 = 0 | parseInt(n2, 10);
          this.getToken();
          for (let i3 = 0; i3 < e3; i3++) {
            for (t2 = this.getToken(); "dup" !== t2 && "def" !== t2; ) if (t2 = this.getToken(), null === t2) return;
            if ("def" === t2) break;
            const e4 = this.readInt();
            this.getToken();
            const i4 = this.getToken();
            a2[e4] = i4, this.getToken();
          }
        } else a2 = getEncoding(n2);
        e2.builtInEncoding = a2;
        break;
      case "FontBBox":
        const s2 = this.readNumberArray();
        e2.ascent = Math.max(s2[3], s2[1]), e2.descent = Math.min(s2[1], s2[3]), e2.ascentScaled = true;
    }
  }
}
function findBlock(e2, t2, i2) {
  const n2 = e2.length, a2 = t2.length, s2 = n2 - a2;
  let r2 = i2, o2 = false;
  for (; r2 < s2; ) {
    let i3 = 0;
    for (; i3 < a2 && e2[r2 + i3] === t2[i3]; ) i3++;
    if (i3 >= a2) {
      for (r2 += i3; r2 < n2 && isWhiteSpace(e2[r2]); ) r2++;
      o2 = true;
      break;
    }
    r2++;
  }
  return { found: o2, length: r2 };
}
class Type1Font {
  constructor(e2, t2, i2) {
    let n2 = i2.length1;
    i2.length2;
    let a2 = t2.peekBytes(6);
    const s2 = 128 === a2[0] && 1 === a2[1];
    s2 && (t2.skip(6), n2 = a2[5] << 24 | a2[4] << 16 | a2[3] << 8 | a2[2]);
    const r2 = (function(e3, t3) {
      const i3 = [101, 101, 120, 101, 99], n3 = e3.pos;
      let a3, s3, r3, o3;
      try {
        a3 = e3.getBytes(t3), s3 = a3.length;
      } catch {
      }
      if (s3 === t3 && (r3 = findBlock(a3, i3, t3 - 2 * i3.length), r3.found && r3.length === t3)) return { stream: new Stream(a3), length: t3 };
      for (warn$1('Invalid "Length1" property in Type1 font -- trying to recover.'), e3.pos = n3; r3 = findBlock(e3.peekBytes(2048), i3, 0), 0 !== r3.length; ) if (e3.pos += r3.length, r3.found) {
        o3 = e3.pos - n3;
        break;
      }
      return e3.pos = n3, o3 ? { stream: new Stream(e3.getBytes(o3)), length: o3 } : (warn$1('Unable to recover "Length1" property in Type1 font -- using as is.'), { stream: new Stream(e3.getBytes(t3)), length: t3 });
    })(t2, n2);
    new Type1Parser(r2.stream, false, Sn).extractFontHeader(i2), s2 && (a2 = t2.getBytes(6), a2[5], a2[4], a2[3], a2[2]);
    const o2 = (function(e3) {
      const t3 = e3.getBytes();
      if (0 === t3.length) throw new ti("getEexecBlock - no font program found.");
      return { stream: new Stream(t3), length: t3.length };
    })(t2), l2 = new Type1Parser(o2.stream, true, Sn).extractFontProgram(i2);
    for (const e3 in l2.properties) i2[e3] = l2.properties[e3];
    const c2 = l2.charstrings, h2 = this.getType2Charstrings(c2), d2 = this.getType2Subrs(l2.subrs);
    this.charstrings = c2, this.data = this.wrap(e2, h2, this.charstrings, d2, i2), this.seacs = this.getSeacs(l2.charstrings);
  }
  get numGlyphs() {
    return this.charstrings.length + 1;
  }
  getCharset() {
    const e2 = [".notdef"];
    for (const { glyphName: t2 } of this.charstrings) e2.push(t2);
    return e2;
  }
  getGlyphMapping(e2) {
    const t2 = this.charstrings;
    if (e2.composite) {
      const i3 = /* @__PURE__ */ Object.create(null);
      for (let n3 = 0, a3 = t2.length; n3 < a3; n3++) {
        i3[e2.cMap.charCodeOf(n3)] = n3 + 1;
      }
      return i3;
    }
    const i2 = [".notdef"];
    let n2, a2;
    for (a2 = 0; a2 < t2.length; a2++) i2.push(t2[a2].glyphName);
    const s2 = e2.builtInEncoding;
    if (s2) {
      n2 = /* @__PURE__ */ Object.create(null);
      for (const e3 in s2) a2 = i2.indexOf(s2[e3]), a2 >= 0 && (n2[e3] = a2);
    }
    return type1FontGlyphMapping(e2, n2, i2);
  }
  hasGlyphId(e2) {
    if (e2 < 0 || e2 >= this.numGlyphs) return false;
    if (0 === e2) return true;
    return this.charstrings[e2 - 1].charstring.length > 0;
  }
  getSeacs(e2) {
    const t2 = [];
    for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) {
      const n3 = e2[i2];
      n3.seac && (t2[i2 + 1] = n3.seac);
    }
    return t2;
  }
  getType2Charstrings(e2) {
    const t2 = [];
    for (const i2 of e2) t2.push(i2.charstring);
    return t2;
  }
  getType2Subrs(e2) {
    let t2 = 0;
    const i2 = e2.length;
    t2 = i2 < 1133 ? 107 : i2 < 33769 ? 1131 : 32768;
    const n2 = [];
    let a2;
    for (a2 = 0; a2 < t2; a2++) n2.push([11]);
    for (a2 = 0; a2 < i2; a2++) n2.push(e2[a2]);
    return n2;
  }
  wrap(e2, t2, i2, n2, a2) {
    const s2 = new CFF();
    s2.header = new CFFHeader(1, 0, 4, 4), s2.names = [e2];
    const r2 = new CFFTopDict();
    r2.setByName("version", 391), r2.setByName("Notice", 392), r2.setByName("FullName", 393), r2.setByName("FamilyName", 394), r2.setByName("Weight", 395), r2.setByName("Encoding", null), r2.setByName("FontMatrix", a2.fontMatrix), r2.setByName("FontBBox", a2.bbox), r2.setByName("charset", null), r2.setByName("CharStrings", null), r2.setByName("Private", null), s2.topDict = r2;
    const o2 = new CFFStrings();
    o2.add("Version 0.11"), o2.add("See original notice"), o2.add(e2), o2.add(e2), o2.add("Medium"), s2.strings = o2, s2.globalSubrIndex = new CFFIndex();
    const l2 = t2.length, c2 = [".notdef"];
    let h2, d2;
    for (h2 = 0; h2 < l2; h2++) {
      const e3 = i2[h2].glyphName;
      -1 === On.indexOf(e3) && o2.add(e3), c2.push(e3);
    }
    s2.charset = new CFFCharset(false, 0, c2);
    const u2 = new CFFIndex();
    for (u2.add([139, 14]), h2 = 0; h2 < l2; h2++) u2.add(t2[h2]);
    s2.charStrings = u2;
    const g2 = new CFFPrivateDict();
    g2.setByName("Subrs", null);
    const f2 = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
    for (h2 = 0, d2 = f2.length; h2 < d2; h2++) {
      const e3 = f2[h2];
      if (!(e3 in a2.privateData)) continue;
      const t3 = a2.privateData[e3];
      if (Array.isArray(t3)) for (let e4 = t3.length - 1; e4 > 0; e4--) t3[e4] -= t3[e4 - 1];
      g2.setByName(e3, t3);
    }
    s2.topDict.privateDict = g2;
    const p2 = new CFFIndex();
    for (h2 = 0, d2 = n2.length; h2 < d2; h2++) p2.add(n2[h2]);
    g2.subrsIndex = p2;
    return new CFFCompiler(s2).compile();
  }
}
const ra = [[57344, 63743], [1048576, 1114109]], oa = 1e3, la = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "disableFontFace", "fallbackName", "fontExtraProperties", "fontMatrix", "isInvalidPDFjsFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "systemFontInfo", "vertical"], ca = ["cMap", "composite", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "subtype", "toFontChar", "toUnicode", "type", "vmetrics", "widths"];
function adjustWidths(e2) {
  if (!e2.fontMatrix) return;
  if (e2.fontMatrix[0] === t[0]) return;
  const i2 = 1e-3 / e2.fontMatrix[0], n2 = e2.widths;
  for (const e3 in n2) n2[e3] *= i2;
  e2.defaultWidth *= i2;
}
function amendFallbackToUnicode(e2) {
  if (!e2.fallbackToUnicode) return;
  if (e2.toUnicode instanceof IdentityToUnicodeMap) return;
  const t2 = [];
  for (const i2 in e2.fallbackToUnicode) e2.toUnicode.has(i2) || (t2[i2] = e2.fallbackToUnicode[i2]);
  t2.length > 0 && e2.toUnicode.amend(t2);
}
class fonts_Glyph {
  constructor(e2, t2, i2, n2, a2, s2, r2, o2, l2) {
    this.originalCharCode = e2, this.fontChar = t2, this.unicode = i2, this.accent = n2, this.width = a2, this.vmetric = s2, this.operatorListId = r2, this.isSpace = o2, this.isInFont = l2;
  }
  get category() {
    return shadow$1(this, "category", (function(e2) {
      const t2 = xn.get(e2);
      if (t2) return t2;
      const i2 = e2.match(An), n2 = { isWhitespace: !!i2?.[1], isZeroWidthDiacritic: !!i2?.[2], isInvisibleFormatMark: !!i2?.[3] };
      return xn.set(e2, n2), n2;
    })(this.unicode), true);
  }
}
function int16(e2, t2) {
  return (e2 << 8) + t2;
}
function writeSignedInt16(e2, t2, i2) {
  e2[t2 + 1] = i2, e2[t2] = i2 >>> 8;
}
function signedInt16(e2, t2) {
  const i2 = (e2 << 8) + t2;
  return 32768 & i2 ? i2 - 65536 : i2;
}
function string16(e2) {
  return String.fromCharCode(e2 >> 8 & 255, 255 & e2);
}
function safeString16(e2) {
  return e2 > 32767 ? e2 = 32767 : e2 < -32768 && (e2 = -32768), String.fromCharCode(e2 >> 8 & 255, 255 & e2);
}
function isTrueTypeCollectionFile(e2) {
  return "ttcf" === bytesToString$1(e2.peekBytes(4));
}
function getFontFileType(e2, { type: t2, subtype: i2, composite: n2 }) {
  let a2, s2;
  return (function(e3) {
    const t3 = e3.peekBytes(4);
    return 65536 === readUint32(t3, 0) || "true" === bytesToString$1(t3);
  })(e2) || isTrueTypeCollectionFile(e2) ? a2 = n2 ? "CIDFontType2" : "TrueType" : !(function(e3) {
    return "OTTO" === bytesToString$1(e3.peekBytes(4));
  })(e2) ? !(function(e3) {
    const t3 = e3.peekBytes(2);
    return 37 === t3[0] && 33 === t3[1] || 128 === t3[0] && 1 === t3[1];
  })(e2) ? !(function(e3) {
    const t3 = e3.peekBytes(4);
    return t3[0] >= 1 && t3[3] >= 1 && t3[3] <= 4;
  })(e2) ? (warn$1("getFontFileType: Unable to detect correct font file Type/Subtype."), a2 = t2, s2 = i2) : n2 ? (a2 = "CIDFontType0", s2 = "CIDFontType0C") : (a2 = "MMType1" === t2 ? "MMType1" : "Type1", s2 = "Type1C") : a2 = n2 ? "CIDFontType0" : "MMType1" === t2 ? "MMType1" : "Type1" : a2 = n2 ? "CIDFontType2" : "OpenType", [a2, s2];
}
function applyStandardFontGlyphMap(e2, t2) {
  for (const i2 in t2) e2[+i2] = t2[i2];
}
function buildToFontChar(e2, t2, i2) {
  const n2 = [];
  let a2;
  for (let i3 = 0, s2 = e2.length; i3 < s2; i3++) a2 = getUnicodeForGlyph(e2[i3], t2), -1 !== a2 && (n2[i3] = a2);
  for (const e3 in i2) a2 = getUnicodeForGlyph(i2[e3], t2), -1 !== a2 && (n2[+e3] = a2);
  return n2;
}
function isMacNameRecord(e2) {
  return 1 === e2.platform && 0 === e2.encoding && 0 === e2.language;
}
function isWinNameRecord(e2) {
  return 3 === e2.platform && 1 === e2.encoding && 1033 === e2.language;
}
function convertCidString(e2, t2, i2 = false) {
  switch (t2.length) {
    case 1:
      return t2.charCodeAt(0);
    case 2:
      return t2.charCodeAt(0) << 8 | t2.charCodeAt(1);
  }
  const n2 = `Unsupported CID string (charCode ${e2}): "${t2}".`;
  if (i2) throw new ti(n2);
  return warn$1(n2), t2;
}
function adjustMapping(e2, t2, i2, n2) {
  const a2 = /* @__PURE__ */ Object.create(null), s2 = /* @__PURE__ */ new Map(), r2 = [], o2 = /* @__PURE__ */ new Set();
  let l2 = 0;
  let c2 = ra[l2][0], h2 = ra[l2][1];
  const isInPrivateArea = (e3) => ra[0][0] <= e3 && e3 <= ra[0][1] || ra[1][0] <= e3 && e3 <= ra[1][1];
  let d2 = null;
  for (const u2 in e2) {
    let g2 = e2[u2];
    if (!t2(g2)) continue;
    if (c2 > h2) {
      if (l2++, l2 >= ra.length) {
        warn$1("Ran out of space in font private use area.");
        break;
      }
      c2 = ra[l2][0], h2 = ra[l2][1];
    }
    const f2 = c2++;
    0 === g2 && (g2 = i2);
    let p2 = n2.get(u2);
    if ("string" == typeof p2) if (1 === p2.length) p2 = p2.codePointAt(0);
    else {
      if (!d2) {
        d2 = /* @__PURE__ */ new Map();
        for (let e3 = 64256; e3 <= 64335; e3++) {
          const t3 = String.fromCharCode(e3).normalize("NFKD");
          t3.length > 1 && d2.set(t3, e3);
        }
      }
      p2 = d2.get(p2) || p2.codePointAt(0);
    }
    !p2 || isInPrivateArea(p2) || o2.has(g2) || (s2.set(p2, g2), o2.add(g2)), a2[f2] = g2, r2[u2] = f2;
  }
  return { toFontChar: r2, charCodeToGlyphId: a2, toUnicodeExtraMap: s2, nextAvailableFontCharCode: c2 };
}
function createCmapTable(e2, t2, i2) {
  const n2 = (function(e3, t3, i3) {
    const n3 = [];
    for (const t4 in e3) e3[t4] >= i3 || n3.push({ fontCharCode: 0 | t4, glyphId: e3[t4] });
    if (t3) for (const [e4, a4] of t3) a4 >= i3 || n3.push({ fontCharCode: e4, glyphId: a4 });
    0 === n3.length && n3.push({ fontCharCode: 0, glyphId: 0 }), n3.sort((e4, t4) => e4.fontCharCode - t4.fontCharCode);
    const a3 = [], s3 = n3.length;
    for (let e4 = 0; e4 < s3; ) {
      const t4 = n3[e4].fontCharCode, i4 = [n3[e4].glyphId];
      ++e4;
      let r3 = t4;
      for (; e4 < s3 && r3 + 1 === n3[e4].fontCharCode && (i4.push(n3[e4].glyphId), ++r3, ++e4, 65535 !== r3); ) ;
      a3.push([t4, r3, i4]);
    }
    return a3;
  })(e2, t2, i2), a2 = n2.at(-1)[1] > 65535 ? 2 : 1;
  let s2, r2, o2, l2, c2 = "\0\0" + string16(a2) + "\0\0" + string32$1(4 + 8 * a2);
  for (s2 = n2.length - 1; s2 >= 0 && !(n2[s2][0] <= 65535); --s2) ;
  const h2 = s2 + 1;
  n2[s2][0] < 65535 && 65535 === n2[s2][1] && (n2[s2][1] = 65534);
  const d2 = n2[s2][1] < 65535 ? 1 : 0, u2 = h2 + d2, g2 = OpenTypeFileBuilder.getSearchParams(u2, 2);
  let f2, p2, m2, b2, y2 = "", w2 = "", x2 = "", S2 = "", v2 = "", C2 = 0;
  for (s2 = 0, r2 = h2; s2 < r2; s2++) {
    f2 = n2[s2], p2 = f2[0], m2 = f2[1], y2 += string16(p2), w2 += string16(m2), b2 = f2[2];
    let e3 = true;
    for (o2 = 1, l2 = b2.length; o2 < l2; ++o2) if (b2[o2] !== b2[o2 - 1] + 1) {
      e3 = false;
      break;
    }
    if (e3) {
      x2 += string16(b2[0] - p2 & 65535), S2 += string16(0);
    } else {
      const e4 = 2 * (u2 - s2) + 2 * C2;
      for (C2 += m2 - p2 + 1, x2 += string16(0), S2 += string16(e4), o2 = 0, l2 = b2.length; o2 < l2; ++o2) v2 += string16(b2[o2]);
    }
  }
  d2 > 0 && (w2 += "ÿÿ", y2 += "ÿÿ", x2 += "\0", S2 += "\0\0");
  const k2 = "\0\0" + string16(2 * u2) + string16(g2.range) + string16(g2.entry) + string16(g2.rangeShift) + w2 + "\0\0" + y2 + x2 + S2 + v2;
  let T2 = "", F2 = "";
  if (a2 > 1) {
    for (c2 += "\0\0\n" + string32$1(4 + 8 * a2 + 4 + k2.length), T2 = "", s2 = 0, r2 = n2.length; s2 < r2; s2++) {
      f2 = n2[s2], p2 = f2[0], b2 = f2[2];
      let e3 = b2[0];
      for (o2 = 1, l2 = b2.length; o2 < l2; ++o2) b2[o2] !== b2[o2 - 1] + 1 && (m2 = f2[0] + o2 - 1, T2 += string32$1(p2) + string32$1(m2) + string32$1(e3), p2 = m2 + 1, e3 = b2[o2]);
      T2 += string32$1(p2) + string32$1(f2[1]) + string32$1(e3);
    }
    F2 = "\0\f\0\0" + string32$1(T2.length + 16) + "\0\0\0\0" + string32$1(T2.length / 12);
  }
  return c2 + "\0" + string16(k2.length + 4) + k2 + F2 + T2;
}
function createOS2Table(e2, t2, i2) {
  i2 ||= { unitsPerEm: 0, yMax: 0, yMin: 0, ascent: 0, descent: 0 };
  let n2 = 0, a2 = 0, s2 = 0, r2 = 0, o2 = null, l2 = 0, c2 = -1;
  if (t2) {
    for (let e3 in t2) if (e3 |= 0, (o2 > e3 || !o2) && (o2 = e3), l2 < e3 && (l2 = e3), c2 = getUnicodeRangeFor(e3, c2), c2 < 32) n2 |= 1 << c2;
    else if (c2 < 64) a2 |= 1 << c2 - 32;
    else if (c2 < 96) s2 |= 1 << c2 - 64;
    else {
      if (!(c2 < 123)) throw new ti("Unicode ranges Bits > 123 are reserved for internal usage");
      r2 |= 1 << c2 - 96;
    }
    l2 > 65535 && (l2 = 65535);
  } else o2 = 0, l2 = 255;
  const h2 = e2.bbox || [0, 0, 0, 0], d2 = i2.unitsPerEm || (e2.fontMatrix ? 1 / Math.max(...e2.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3), u2 = e2.ascentScaled ? 1 : d2 / oa, g2 = i2.ascent || Math.round(u2 * (e2.ascent || h2[3]));
  let f2 = i2.descent || Math.round(u2 * (e2.descent || h2[1]));
  f2 > 0 && e2.descent > 0 && h2[1] < 0 && (f2 = -f2);
  const p2 = i2.yMax || g2, m2 = -i2.yMin || -f2;
  return "\0$ô\0\0\0»\0\0\0»\0\0ß\x001\0\0\0\0" + String.fromCharCode(e2.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + string32$1(n2) + string32$1(a2) + string32$1(s2) + string32$1(r2) + "*21*" + string16(e2.italicAngle ? 1 : 0) + string16(o2 || e2.firstChar) + string16(l2 || e2.lastChar) + string16(g2) + string16(f2) + "\0d" + string16(p2) + string16(m2) + "\0\0\0\0\0\0\0\0" + string16(e2.xHeight) + string16(e2.capHeight) + string16(0) + string16(o2 || e2.firstChar) + "\0";
}
function createPostTable(e2) {
  return "\0\0\0" + string32$1(Math.floor(65536 * e2.italicAngle)) + "\0\0\0\0" + string32$1(e2.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
}
function createPostscriptName(e2) {
  return e2.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
}
function createNameTable(e2, t2) {
  t2 || (t2 = [[], []]);
  const i2 = [t2[0][0] || "Original licence", t2[0][1] || e2, t2[0][2] || "Unknown", t2[0][3] || "uniqueID", t2[0][4] || e2, t2[0][5] || "Version 0.11", t2[0][6] || createPostscriptName(e2), t2[0][7] || "Unknown", t2[0][8] || "Unknown", t2[0][9] || "Unknown"], n2 = [];
  let a2, s2, r2, o2, l2;
  for (a2 = 0, s2 = i2.length; a2 < s2; a2++) {
    l2 = t2[1][a2] || i2[a2];
    const e3 = [];
    for (r2 = 0, o2 = l2.length; r2 < o2; r2++) e3.push(string16(l2.charCodeAt(r2)));
    n2.push(e3.join(""));
  }
  const c2 = [i2, n2], h2 = ["\0", "\0"], d2 = ["\0\0", "\0"], u2 = ["\0\0", "	"], g2 = i2.length * h2.length;
  let f2 = "\0\0" + string16(g2) + string16(12 * g2 + 6), p2 = 0;
  for (a2 = 0, s2 = h2.length; a2 < s2; a2++) {
    const e3 = c2[a2];
    for (r2 = 0, o2 = e3.length; r2 < o2; r2++) {
      l2 = e3[r2];
      f2 += h2[a2] + d2[a2] + u2[a2] + string16(r2) + string16(l2.length) + string16(p2), p2 += l2.length;
    }
  }
  return f2 += i2.join("") + n2.join(""), f2;
}
class Font {
  constructor(e2, t2, i2, n2) {
    this.name = e2, this.psName = null, this.mimetype = null, this.disableFontFace = n2.disableFontFace, this.fontExtraProperties = n2.fontExtraProperties, this.loadedName = i2.loadedName, this.isType3Font = i2.isType3Font, this.missingFile = false, this.cssFontInfo = i2.cssFontInfo, this._charsCache = /* @__PURE__ */ Object.create(null), this._glyphCache = /* @__PURE__ */ Object.create(null);
    let a2 = !!(i2.flags & Cn);
    if (!a2 && !i2.isSimulatedFlags) {
      const t3 = Un(), i3 = $n(), n3 = Hn();
      for (const s3 of e2.split("+")) {
        let e3 = s3.replaceAll(/[,_]/g, "-");
        if (e3 = t3[e3] || i3[e3] || e3, e3 = e3.split("-", 1)[0], n3[e3]) {
          a2 = true;
          break;
        }
      }
    }
    this.isSerifFont = a2, this.isSymbolicFont = !!(i2.flags & kn), this.isMonospace = !!(i2.flags & vn);
    let { type: s2, subtype: r2 } = i2;
    this.type = s2, this.subtype = r2, this.systemFontInfo = i2.systemFontInfo;
    const o2 = e2.match(/^InvalidPDFjsFont_(.*)_\d+$/);
    if (this.isInvalidPDFjsFont = !!o2, this.isInvalidPDFjsFont ? this.fallbackName = o2[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif", this.systemFontInfo?.guessFallback && (this.systemFontInfo.guessFallback = false, this.systemFontInfo.css += `,${this.fallbackName}`), this.differences = i2.differences, this.widths = i2.widths, this.defaultWidth = i2.defaultWidth, this.composite = i2.composite, this.cMap = i2.cMap, this.capHeight = i2.capHeight / oa, this.ascent = i2.ascent / oa, this.descent = i2.descent / oa, this.lineHeight = this.ascent - this.descent, this.fontMatrix = i2.fontMatrix, this.bbox = i2.bbox, this.defaultEncoding = i2.defaultEncoding, this.toUnicode = i2.toUnicode, this.toFontChar = [], "Type3" === i2.type) {
      for (let e3 = 0; e3 < 256; e3++) this.toFontChar[e3] = this.differences[e3] || i2.defaultEncoding[e3];
      return;
    }
    if (this.cidEncoding = i2.cidEncoding || "", this.vertical = !!i2.vertical, this.vertical && (this.vmetrics = i2.vmetrics, this.defaultVMetrics = i2.defaultVMetrics), !t2 || t2.isEmpty) return t2 && warn$1('Font file is empty in "' + e2 + '" (' + this.loadedName + ")"), void this.fallbackToSystemFont(i2);
    let l2;
    [s2, r2] = getFontFileType(t2, i2), s2 === this.type && r2 === this.subtype || info$1(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${s2}/${r2}.`);
    try {
      switch (s2) {
        case "MMType1":
          info$1("MMType1 font (" + e2 + "), falling back to Type1.");
        case "Type1":
        case "CIDFontType0":
          this.mimetype = "font/opentype";
          const n3 = "Type1C" === r2 || "CIDFontType0C" === r2 ? new CFFFont(t2, i2) : new Type1Font(e2, t2, i2);
          adjustWidths(i2), l2 = this.convert(e2, n3, i2);
          break;
        case "OpenType":
        case "TrueType":
        case "CIDFontType2":
          this.mimetype = "font/opentype", l2 = this.checkAndRepair(e2, t2, i2), adjustWidths(i2), this.isOpenType && (s2 = "OpenType");
          break;
        default:
          throw new ti(`Font ${s2} is not supported`);
      }
    } catch (e3) {
      return warn$1(e3), void this.fallbackToSystemFont(i2);
    }
    amendFallbackToUnicode(i2), this.data = l2, this.type = s2, this.subtype = r2, this.fontMatrix = i2.fontMatrix, this.widths = i2.widths, this.defaultWidth = i2.defaultWidth, this.toUnicode = i2.toUnicode, this.seacMap = i2.seacMap;
  }
  get renderer() {
    return shadow$1(this, "renderer", FontRendererFactory.create(this, Sn));
  }
  exportData() {
    const e2 = /* @__PURE__ */ Object.create(null);
    for (const t3 of la) {
      const i2 = this[t3];
      void 0 !== i2 && (e2[t3] = i2);
    }
    if (!this.fontExtraProperties) return { data: e2 };
    const t2 = /* @__PURE__ */ Object.create(null);
    for (const e3 of ca) {
      const i2 = this[e3];
      void 0 !== i2 && (t2[e3] = i2);
    }
    return { data: e2, extra: t2 };
  }
  fallbackToSystemFont(e2) {
    this.missingFile = true;
    const { name: t2, type: i2 } = this;
    let n2 = normalizeFontName(t2);
    const a2 = Un(), s2 = $n(), r2 = !!a2[n2], o2 = !(!s2[n2] || !a2[s2[n2]]);
    n2 = a2[n2] || s2[n2] || n2;
    const l2 = Vn()[n2];
    l2 && (isNaN(this.ascent) && (this.ascent = l2.ascent / oa), isNaN(this.descent) && (this.descent = l2.descent / oa), isNaN(this.capHeight) && (this.capHeight = l2.capHeight / oa)), this.bold = /bold/gi.test(n2), this.italic = /oblique|italic/gi.test(n2), this.black = /Black/g.test(t2);
    const c2 = /Narrow/g.test(t2);
    if (this.remeasure = (!r2 || c2) && Object.keys(this.widths).length > 0, (r2 || o2) && "CIDFontType2" === i2 && this.cidEncoding.startsWith("Identity-")) {
      const i3 = e2.cidToGidMap, n3 = [];
      if (applyStandardFontGlyphMap(n3, qn()), /Arial-?Black/i.test(t2) ? applyStandardFontGlyphMap(n3, zn()) : /Calibri/i.test(t2) && applyStandardFontGlyphMap(n3, Wn()), i3) {
        for (const e3 in n3) {
          const t3 = n3[e3];
          void 0 !== i3[t3] && (n3[+e3] = i3[t3]);
        }
        i3.length !== this.toUnicode.length && e2.hasIncludedToUnicodeMap && this.toUnicode instanceof IdentityToUnicodeMap && this.toUnicode.forEach(function(e3, t3) {
          const a3 = n3[e3];
          void 0 === i3[a3] && (n3[+e3] = t3);
        });
      }
      this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(e3, t3) {
        n3[+e3] = t3;
      }), this.toFontChar = n3, this.toUnicode = new ToUnicodeMap(n3);
    } else if (/Symbol/i.test(n2)) this.toFontChar = buildToFontChar(fn, mn(), this.differences);
    else if (/Dingbats/i.test(n2)) this.toFontChar = buildToFontChar(pn, bn(), this.differences);
    else if (r2 || o2) {
      const e3 = buildToFontChar(this.defaultEncoding, mn(), this.differences);
      "CIDFontType2" !== i2 || this.cidEncoding.startsWith("Identity-") || this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(t3, i3) {
        e3[+t3] = i3;
      }), this.toFontChar = e3;
    } else {
      const e3 = mn(), i3 = [];
      this.toUnicode.forEach((t3, n3) => {
        if (!this.composite) {
          const i4 = getUnicodeForGlyph(this.differences[t3] || this.defaultEncoding[t3], e3);
          -1 !== i4 && (n3 = i4);
        }
        i3[+t3] = n3;
      }), this.composite && this.toUnicode instanceof IdentityToUnicodeMap && /Tahoma|Verdana/i.test(t2) && applyStandardFontGlyphMap(i3, qn()), this.toFontChar = i3;
    }
    amendFallbackToUnicode(e2), this.loadedName = n2.split("-", 1)[0];
  }
  checkAndRepair(e2, t2, i2) {
    const n2 = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
    function readTables(e3, t3) {
      const i3 = /* @__PURE__ */ Object.create(null);
      i3["OS/2"] = null, i3.cmap = null, i3.head = null, i3.hhea = null, i3.hmtx = null, i3.maxp = null, i3.name = null, i3.post = null;
      for (let a3 = 0; a3 < t3; a3++) {
        const t4 = readTableEntry(e3);
        n2.includes(t4.tag) && (0 !== t4.length && (i3[t4.tag] = t4));
      }
      return i3;
    }
    function readTableEntry(e3) {
      const t3 = e3.getString(4), i3 = e3.getInt32() >>> 0, n3 = e3.getInt32() >>> 0, a3 = e3.getInt32() >>> 0, s3 = e3.pos;
      e3.pos = e3.start || 0, e3.skip(n3);
      const r3 = e3.getBytes(a3);
      return e3.pos = s3, "head" === t3 && (r3[8] = r3[9] = r3[10] = r3[11] = 0, r3[17] |= 32), { tag: t3, checksum: i3, length: a3, offset: n3, data: r3 };
    }
    function readOpenTypeHeader(e3) {
      return { version: e3.getString(4), numTables: e3.getUint16(), searchRange: e3.getUint16(), entrySelector: e3.getUint16(), rangeShift: e3.getUint16() };
    }
    function sanitizeGlyph(e3, t3, i3, n3, a3, s3) {
      const r3 = { length: 0, sizeOfInstructions: 0 };
      if (t3 < 0 || t3 >= e3.length || i3 > e3.length || i3 - t3 <= 12) return r3;
      const o3 = e3.subarray(t3, i3), l3 = signedInt16(o3[2], o3[3]), c3 = signedInt16(o3[4], o3[5]), h3 = signedInt16(o3[6], o3[7]), d3 = signedInt16(o3[8], o3[9]);
      l3 > h3 && (writeSignedInt16(o3, 2, h3), writeSignedInt16(o3, 6, l3)), c3 > d3 && (writeSignedInt16(o3, 4, d3), writeSignedInt16(o3, 8, c3));
      const u3 = signedInt16(o3[0], o3[1]);
      if (u3 < 0) return u3 < -1 || (n3.set(o3, a3), r3.length = o3.length), r3;
      let g3, f3 = 10, p3 = 0;
      for (g3 = 0; g3 < u3; g3++) {
        p3 = (o3[f3] << 8 | o3[f3 + 1]) + 1, f3 += 2;
      }
      const m3 = f3, b3 = o3[f3] << 8 | o3[f3 + 1];
      r3.sizeOfInstructions = b3, f3 += 2 + b3;
      const y3 = f3;
      let w3 = 0;
      for (g3 = 0; g3 < p3; g3++) {
        const e4 = o3[f3++];
        192 & e4 && (o3[f3 - 1] = 63 & e4);
        let t4 = 2;
        2 & e4 ? t4 = 1 : 16 & e4 && (t4 = 0);
        let i4 = 2;
        4 & e4 ? i4 = 1 : 32 & e4 && (i4 = 0);
        const n4 = t4 + i4;
        if (w3 += n4, 8 & e4) {
          const e5 = o3[f3++];
          0 === e5 && (o3[f3 - 1] ^= 8), g3 += e5, w3 += e5 * n4;
        }
      }
      if (0 === w3) return r3;
      let x3 = f3 + w3;
      return x3 > o3.length ? r3 : !s3 && b3 > 0 ? (n3.set(o3.subarray(0, m3), a3), n3.set([0, 0], a3 + m3), n3.set(o3.subarray(y3, x3), a3 + m3 + 2), x3 -= b3, o3.length - x3 > 3 && (x3 = x3 + 3 & -4), r3.length = x3, r3) : o3.length - x3 > 3 ? (x3 = x3 + 3 & -4, n3.set(o3.subarray(0, x3), a3), r3.length = x3, r3) : (n3.set(o3, a3), r3.length = o3.length, r3);
    }
    function readNameTable(e3) {
      const i3 = (t2.start || 0) + e3.offset;
      t2.pos = i3;
      const n3 = [[], []], a3 = [], s3 = e3.length, r3 = i3 + s3;
      if (0 !== t2.getUint16() || s3 < 6) return [n3, a3];
      const o3 = t2.getUint16(), l3 = t2.getUint16();
      let c3, h3;
      for (c3 = 0; c3 < o3 && t2.pos + 12 <= r3; c3++) {
        const e4 = { platform: t2.getUint16(), encoding: t2.getUint16(), language: t2.getUint16(), name: t2.getUint16(), length: t2.getUint16(), offset: t2.getUint16() };
        (isMacNameRecord(e4) || isWinNameRecord(e4)) && a3.push(e4);
      }
      for (c3 = 0, h3 = a3.length; c3 < h3; c3++) {
        const e4 = a3[c3];
        if (e4.length <= 0) continue;
        const s4 = i3 + l3 + e4.offset;
        if (s4 + e4.length > r3) continue;
        t2.pos = s4;
        const o4 = e4.name;
        if (e4.encoding) {
          let i4 = "";
          for (let n4 = 0, a4 = e4.length; n4 < a4; n4 += 2) i4 += String.fromCharCode(t2.getUint16());
          n3[1][o4] = i4;
        } else n3[0][o4] = t2.getString(e4.length);
      }
      return [n3, a3];
    }
    const a2 = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
    function sanitizeTTProgram(e3, t3) {
      let i3, n3, s3, r3, o3, l3 = e3.data, c3 = 0, h3 = 0, d3 = 0;
      const u3 = [], g3 = [], f3 = [];
      let p3 = t3.tooComplexToFollowFunctions, m3 = false, b3 = 0, y3 = 0;
      for (let e4 = l3.length; c3 < e4; ) {
        const e5 = l3[c3++];
        if (64 === e5) if (n3 = l3[c3++], m3 || y3) c3 += n3;
        else for (i3 = 0; i3 < n3; i3++) u3.push(l3[c3++]);
        else if (65 === e5) if (n3 = l3[c3++], m3 || y3) c3 += 2 * n3;
        else for (i3 = 0; i3 < n3; i3++) s3 = l3[c3++], u3.push(s3 << 8 | l3[c3++]);
        else if (176 == (248 & e5)) if (n3 = e5 - 176 + 1, m3 || y3) c3 += n3;
        else for (i3 = 0; i3 < n3; i3++) u3.push(l3[c3++]);
        else if (184 == (248 & e5)) if (n3 = e5 - 184 + 1, m3 || y3) c3 += 2 * n3;
        else for (i3 = 0; i3 < n3; i3++) s3 = l3[c3++], u3.push(signedInt16(s3, l3[c3++]));
        else if (43 !== e5 || p3) if (44 !== e5 || p3) {
          if (45 === e5) if (m3) m3 = false, h3 = c3;
          else {
            if (o3 = g3.pop(), !o3) return warn$1("TT: ENDF bad stack"), void (t3.hintsValid = false);
            r3 = f3.pop(), l3 = o3.data, c3 = o3.i, t3.functionsStackDeltas[r3] = u3.length - o3.stackTop;
          }
          else if (137 === e5) (m3 || y3) && (warn$1("TT: nested IDEFs not allowed"), p3 = true), m3 = true, d3 = c3;
          else if (88 === e5) ++b3;
          else if (27 === e5) y3 = b3;
          else if (89 === e5) y3 === b3 && (y3 = 0), --b3;
          else if (28 === e5 && !m3 && !y3) {
            const e6 = u3.at(-1);
            e6 > 0 && (c3 += e6 - 1);
          }
        } else (m3 || y3) && (warn$1("TT: nested FDEFs not allowed"), p3 = true), m3 = true, d3 = c3, r3 = u3.pop(), t3.functionsDefined[r3] = { data: l3, i: c3 };
        else if (!m3 && !y3) {
          if (r3 = u3.at(-1), isNaN(r3)) info$1("TT: CALL empty stack (or invalid entry).");
          else if (t3.functionsUsed[r3] = true, r3 in t3.functionsStackDeltas) {
            const e6 = u3.length + t3.functionsStackDeltas[r3];
            if (e6 < 0) return warn$1("TT: CALL invalid functions stack delta."), void (t3.hintsValid = false);
            u3.length = e6;
          } else if (r3 in t3.functionsDefined && !f3.includes(r3)) {
            if (g3.push({ data: l3, i: c3, stackTop: u3.length - 1 }), f3.push(r3), o3 = t3.functionsDefined[r3], !o3) return warn$1("TT: CALL non-existent function"), void (t3.hintsValid = false);
            l3 = o3.data, c3 = o3.i;
          }
        }
        if (!m3 && !y3) {
          let t4 = 0;
          for (e5 <= 142 ? t4 = a2[e5] : e5 >= 192 && e5 <= 223 ? t4 = -1 : e5 >= 224 && (t4 = -2), e5 >= 113 && e5 <= 117 && (n3 = u3.pop(), isNaN(n3) || (t4 = 2 * -n3)); t4 < 0 && u3.length > 0; ) u3.pop(), t4++;
          for (; t4 > 0; ) u3.push(NaN), t4--;
        }
      }
      t3.tooComplexToFollowFunctions = p3;
      const w3 = [l3];
      c3 > l3.length && w3.push(new Uint8Array(c3 - l3.length)), d3 > h3 && (warn$1("TT: complementing a missing function tail"), w3.push(new Uint8Array([34, 45]))), (function(e4, t4) {
        if (t4.length > 1) {
          let i4, n4, a3 = 0;
          for (i4 = 0, n4 = t4.length; i4 < n4; i4++) a3 += t4[i4].length;
          a3 = a3 + 3 & -4;
          const s4 = new Uint8Array(a3);
          let r4 = 0;
          for (i4 = 0, n4 = t4.length; i4 < n4; i4++) s4.set(t4[i4], r4), r4 += t4[i4].length;
          e4.data = s4, e4.length = a3;
        }
      })(e3, w3);
    }
    let s2, r2, o2, l2;
    if (isTrueTypeCollectionFile(t2 = new Stream(new Uint8Array(t2.getBytes())))) {
      const e3 = (function(e4, t3) {
        const { numFonts: i3, offsetTable: n3 } = (function(e5) {
          const t4 = e5.getString(4);
          assert$1("ttcf" === t4, "Must be a TrueType Collection font.");
          const i4 = e5.getUint16(), n4 = e5.getUint16(), a4 = e5.getInt32() >>> 0, s4 = [];
          for (let t5 = 0; t5 < a4; t5++) s4.push(e5.getInt32() >>> 0);
          const r3 = { ttcTag: t4, majorVersion: i4, minorVersion: n4, numFonts: a4, offsetTable: s4 };
          switch (i4) {
            case 1:
              return r3;
            case 2:
              return r3.dsigTag = e5.getInt32() >>> 0, r3.dsigLength = e5.getInt32() >>> 0, r3.dsigOffset = e5.getInt32() >>> 0, r3;
          }
          throw new ti(`Invalid TrueType Collection majorVersion: ${i4}.`);
        })(e4), a3 = t3.split("+");
        let s3;
        for (let r3 = 0; r3 < i3; r3++) {
          e4.pos = (e4.start || 0) + n3[r3];
          const i4 = readOpenTypeHeader(e4), o3 = readTables(e4, i4.numTables);
          if (!o3.name) throw new ti('TrueType Collection font must contain a "name" table.');
          const [l3] = readNameTable(o3.name);
          for (let e5 = 0, n4 = l3.length; e5 < n4; e5++) for (let n5 = 0, r4 = l3[e5].length; n5 < r4; n5++) {
            const r5 = l3[e5][n5]?.replaceAll(/\s/g, "");
            if (r5) {
              if (r5 === t3) return { header: i4, tables: o3 };
              if (!(a3.length < 2)) for (const e6 of a3) r5 === e6 && (s3 = { name: e6, header: i4, tables: o3 });
            }
          }
        }
        if (s3) return warn$1(`TrueType Collection does not contain "${t3}" font, falling back to "${s3.name}" font instead.`), { header: s3.header, tables: s3.tables };
        throw new ti(`TrueType Collection does not contain "${t3}" font.`);
      })(t2, this.name);
      s2 = e3.header, r2 = e3.tables;
    } else s2 = readOpenTypeHeader(t2), r2 = readTables(t2, s2.numTables);
    const c2 = !r2["CFF "];
    if (c2) {
      if (!r2.loca) throw new ti('Required "loca" table is not found');
      r2.glyf || (warn$1('Required "glyf" table is not found -- trying to recover.'), r2.glyf = { tag: "glyf", data: new Uint8Array(0) }), this.isOpenType = false;
    } else {
      const t3 = i2.composite && (i2.cidToGidMap?.length > 0 || !(i2.cMap instanceof IdentityCMap));
      if ("OTTO" === s2.version && !t3 || !r2.head || !r2.hhea || !r2.maxp || !r2.post) return l2 = new Stream(r2["CFF "].data), o2 = new CFFFont(l2, i2), this.convert(e2, o2, i2);
      delete r2.glyf, delete r2.loca, delete r2.fpgm, delete r2.prep, delete r2["cvt "], this.isOpenType = true;
    }
    if (!r2.maxp) throw new ti('Required "maxp" table is not found');
    t2.pos = (t2.start || 0) + r2.maxp.offset;
    let h2 = t2.getInt32();
    const d2 = t2.getUint16();
    if (65536 !== h2 && 20480 !== h2) {
      if (6 === r2.maxp.length) h2 = 20480;
      else {
        if (!(r2.maxp.length >= 32)) throw new ti('"maxp" table has a wrong version number');
        h2 = 65536;
      }
      u2 = r2.maxp.data, f2 = h2, u2[(g2 = 0) + 3] = 255 & f2, u2[g2 + 2] = f2 >>> 8, u2[g2 + 1] = f2 >>> 16, u2[g2] = f2 >>> 24;
    }
    var u2, g2, f2;
    if (i2.scaleFactors?.length === d2 && c2) {
      const { scaleFactors: e3 } = i2, t3 = int16(r2.head.data[50], r2.head.data[51]), n3 = new GlyfTable({ glyfTable: r2.glyf.data, isGlyphLocationsLong: t3, locaTable: r2.loca.data, numGlyphs: d2 });
      n3.scale(e3);
      const { glyf: a3, loca: s3, isLocationLong: o3 } = n3.write();
      r2.glyf.data = a3, r2.loca.data = s3, o3 !== !!t3 && (r2.head.data[50] = 0, r2.head.data[51] = o3 ? 1 : 0);
      const l3 = r2.hmtx.data;
      for (let t4 = 0; t4 < d2; t4++) {
        const i3 = 4 * t4, n4 = Math.round(e3[t4] * int16(l3[i3], l3[i3 + 1]));
        l3[i3] = n4 >> 8 & 255, l3[i3 + 1] = 255 & n4;
        writeSignedInt16(l3, i3 + 2, Math.round(e3[t4] * signedInt16(l3[i3 + 2], l3[i3 + 3])));
      }
    }
    let p2 = d2 + 1, m2 = true;
    p2 > 65535 && (m2 = false, p2 = d2, warn$1("Not enough space in glyfs to duplicate first glyph."));
    let b2 = 0, y2 = 0;
    if (h2 >= 65536 && r2.maxp.length >= 32) {
      t2.pos += 8;
      t2.getUint16() > 2 && (r2.maxp.data[14] = 0, r2.maxp.data[15] = 2), t2.pos += 4, b2 = t2.getUint16(), t2.pos += 4, y2 = t2.getUint16();
    }
    r2.maxp.data[4] = p2 >> 8, r2.maxp.data[5] = 255 & p2;
    const w2 = (function(e3, t3, i3, n3) {
      const a3 = { functionsDefined: [], functionsUsed: [], functionsStackDeltas: [], tooComplexToFollowFunctions: false, hintsValid: true };
      if (e3 && sanitizeTTProgram(e3, a3), t3 && sanitizeTTProgram(t3, a3), e3 && (function(e4, t4) {
        if (!e4.tooComplexToFollowFunctions) {
          if (e4.functionsDefined.length > t4) return warn$1("TT: more functions defined than expected"), void (e4.hintsValid = false);
          for (let i4 = 0, n4 = e4.functionsUsed.length; i4 < n4; i4++) {
            if (i4 > t4) return warn$1("TT: invalid function id: " + i4), void (e4.hintsValid = false);
            if (e4.functionsUsed[i4] && !e4.functionsDefined[i4]) return warn$1("TT: undefined function: " + i4), void (e4.hintsValid = false);
          }
        }
      })(a3, n3), i3 && 1 & i3.length) {
        const e4 = new Uint8Array(i3.length + 1);
        e4.set(i3.data), i3.data = e4;
      }
      return a3.hintsValid;
    })(r2.fpgm, r2.prep, r2["cvt "], b2);
    if (w2 || (delete r2.fpgm, delete r2.prep, delete r2["cvt "]), (function(e3, t3, i3, n3, a3, s3) {
      if (!t3) return void (i3 && (i3.data = null));
      e3.pos = (e3.start || 0) + t3.offset, e3.pos += 4, e3.pos += 2, e3.pos += 2, e3.pos += 2, e3.pos += 2, e3.pos += 2, e3.pos += 2, e3.pos += 2, e3.pos += 2, e3.pos += 2;
      const r3 = e3.getUint16();
      e3.pos += 8, e3.pos += 2;
      let o3 = e3.getUint16();
      if (0 !== r3) {
        2 & int16(n3.data[44], n3.data[45]) || (t3.data[22] = 0, t3.data[23] = 0);
      }
      o3 > a3 && (info$1(`The numOfMetrics (${o3}) should not be greater than the numGlyphs (${a3}).`), o3 = a3, t3.data[34] = (65280 & o3) >> 8, t3.data[35] = 255 & o3);
      const l3 = a3 - o3 - (i3.length - 4 * o3 >> 1);
      if (l3 > 0) {
        const e4 = new Uint8Array(i3.length + 2 * l3);
        e4.set(i3.data), s3 && (e4[i3.length] = i3.data[2], e4[i3.length + 1] = i3.data[3]), i3.data = e4;
      }
    })(t2, r2.hhea, r2.hmtx, r2.head, p2, m2), !r2.head) throw new ti('Required "head" table is not found');
    !(function(e3, t3, i3) {
      const n3 = e3.data, a3 = (s3 = n3[0], r3 = n3[1], o3 = n3[2], l3 = n3[3], (s3 << 24) + (r3 << 16) + (o3 << 8) + l3);
      var s3, r3, o3, l3;
      a3 >> 16 != 1 && (info$1("Attempting to fix invalid version in head table: " + a3), n3[0] = 0, n3[1] = 1, n3[2] = 0, n3[3] = 0);
      const c3 = int16(n3[50], n3[51]);
      if (c3 < 0 || c3 > 1) {
        info$1("Attempting to fix invalid indexToLocFormat in head table: " + c3);
        const e4 = t3 + 1;
        if (i3 === e4 << 1) n3[50] = 0, n3[51] = 0;
        else {
          if (i3 !== e4 << 2) throw new ti("Could not fix indexToLocFormat: " + c3);
          n3[50] = 0, n3[51] = 1;
        }
      }
    })(r2.head, d2, c2 ? r2.loca.length : 0);
    let x2 = /* @__PURE__ */ Object.create(null);
    if (c2) {
      const e3 = int16(r2.head.data[50], r2.head.data[51]), t3 = (function(e4, t4, i3, n3, a3, s3, r3) {
        let o3, l3, c3;
        n3 ? (o3 = 4, l3 = function(e5, t5) {
          return e5[t5] << 24 | e5[t5 + 1] << 16 | e5[t5 + 2] << 8 | e5[t5 + 3];
        }, c3 = function(e5, t5, i4) {
          e5[t5] = i4 >>> 24 & 255, e5[t5 + 1] = i4 >> 16 & 255, e5[t5 + 2] = i4 >> 8 & 255, e5[t5 + 3] = 255 & i4;
        }) : (o3 = 2, l3 = function(e5, t5) {
          return e5[t5] << 9 | e5[t5 + 1] << 1;
        }, c3 = function(e5, t5, i4) {
          e5[t5] = i4 >> 9 & 255, e5[t5 + 1] = i4 >> 1 & 255;
        });
        const h3 = s3 ? i3 + 1 : i3, d3 = o3 * (1 + h3), u3 = new Uint8Array(d3);
        u3.set(e4.data.subarray(0, d3)), e4.data = u3;
        const g3 = t4.data, f3 = g3.length, p3 = new Uint8Array(f3);
        let m3, b3;
        const y3 = [];
        for (m3 = 0, b3 = 0; m3 < i3 + 1; m3++, b3 += o3) {
          let e5 = l3(u3, b3);
          e5 > f3 && (e5 = f3), y3.push({ index: m3, offset: e5, endOffset: 0 });
        }
        for (y3.sort((e5, t5) => e5.offset - t5.offset), m3 = 0; m3 < i3; m3++) y3[m3].endOffset = y3[m3 + 1].offset;
        for (y3.sort((e5, t5) => e5.index - t5.index), m3 = 0; m3 < i3; m3++) {
          const { offset: e5, endOffset: t5 } = y3[m3];
          if (0 !== e5 || 0 !== t5) break;
          const i4 = y3[m3 + 1].offset;
          if (0 !== i4) {
            y3[m3].endOffset = i4;
            break;
          }
        }
        const w3 = y3.at(-2);
        0 !== w3.offset && 0 === w3.endOffset && (w3.endOffset = f3);
        const x3 = /* @__PURE__ */ Object.create(null);
        let S3 = 0;
        for (c3(u3, 0, S3), m3 = 0, b3 = o3; m3 < i3; m3++, b3 += o3) {
          const e5 = sanitizeGlyph(g3, y3[m3].offset, y3[m3].endOffset, p3, S3, a3), t5 = e5.length;
          0 === t5 && (x3[m3] = true), e5.sizeOfInstructions > r3 && (r3 = e5.sizeOfInstructions), S3 += t5, c3(u3, b3, S3);
        }
        if (0 === S3) {
          const e5 = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
          for (m3 = 0, b3 = o3; m3 < h3; m3++, b3 += o3) c3(u3, b3, e5.length);
          t4.data = e5;
        } else if (s3) {
          const i4 = l3(u3, o3);
          p3.length > i4 + S3 ? t4.data = p3.subarray(0, i4 + S3) : (t4.data = new Uint8Array(i4 + S3), t4.data.set(p3.subarray(0, S3))), t4.data.set(p3.subarray(0, i4), S3), c3(e4.data, u3.length - o3, S3 + i4);
        } else t4.data = p3.subarray(0, S3);
        return { missingGlyphs: x3, maxSizeOfInstructions: r3 };
      })(r2.loca, r2.glyf, d2, e3, w2, m2, y2);
      x2 = t3.missingGlyphs, h2 >= 65536 && r2.maxp.length >= 32 && (r2.maxp.data[26] = t3.maxSizeOfInstructions >> 8, r2.maxp.data[27] = 255 & t3.maxSizeOfInstructions);
    }
    if (!r2.hhea) throw new ti('Required "hhea" table is not found');
    0 === r2.hhea.data[10] && 0 === r2.hhea.data[11] && (r2.hhea.data[10] = 255, r2.hhea.data[11] = 255);
    const S2 = { unitsPerEm: int16(r2.head.data[18], r2.head.data[19]), yMax: signedInt16(r2.head.data[42], r2.head.data[43]), yMin: signedInt16(r2.head.data[38], r2.head.data[39]), ascent: signedInt16(r2.hhea.data[4], r2.hhea.data[5]), descent: signedInt16(r2.hhea.data[6], r2.hhea.data[7]), lineGap: signedInt16(r2.hhea.data[8], r2.hhea.data[9]) };
    this.ascent = S2.ascent / S2.unitsPerEm, this.descent = S2.descent / S2.unitsPerEm, this.lineGap = S2.lineGap / S2.unitsPerEm, this.cssFontInfo?.lineHeight ? (this.lineHeight = this.cssFontInfo.metrics.lineHeight, this.lineGap = this.cssFontInfo.metrics.lineGap) : this.lineHeight = this.ascent - this.descent + this.lineGap, r2.post && (function(e3, i3, n3) {
      const a3 = (t2.start || 0) + e3.offset;
      t2.pos = a3;
      const s3 = a3 + e3.length, r3 = t2.getInt32();
      let o3;
      t2.skip(28);
      let l3, c3 = true;
      switch (r3) {
        case 65536:
          o3 = Fn;
          break;
        case 131072:
          const e4 = t2.getUint16();
          if (e4 !== n3) {
            c3 = false;
            break;
          }
          const a4 = [];
          for (l3 = 0; l3 < e4; ++l3) {
            const e5 = t2.getUint16();
            if (e5 >= 32768) {
              c3 = false;
              break;
            }
            a4.push(e5);
          }
          if (!c3) break;
          const h3 = [], d3 = [];
          for (; t2.pos < s3; ) {
            const e5 = t2.getByte();
            for (d3.length = e5, l3 = 0; l3 < e5; ++l3) d3[l3] = String.fromCharCode(t2.getByte());
            h3.push(d3.join(""));
          }
          for (o3 = [], l3 = 0; l3 < e4; ++l3) {
            const e5 = a4[l3];
            e5 < 258 ? o3.push(Fn[e5]) : o3.push(h3[e5 - 258]);
          }
          break;
        case 196608:
          break;
        default:
          warn$1("Unknown/unsupported post table version " + r3), c3 = false, i3.defaultEncoding && (o3 = i3.defaultEncoding);
      }
      i3.glyphNames = o3;
    })(r2.post, i2, d2), r2.post = { tag: "post", data: createPostTable(i2) };
    const v2 = /* @__PURE__ */ Object.create(null);
    function hasGlyph(e3) {
      return !x2[e3];
    }
    if (i2.composite) {
      const e3 = i2.cidToGidMap || [], t3 = 0 === e3.length;
      i2.cMap.forEach(function(i3, n3) {
        if ("string" == typeof n3 && (n3 = convertCidString(i3, n3, true)), n3 > 65535) throw new ti("Max size of CID is 65,535");
        let a3 = -1;
        t3 ? a3 = n3 : void 0 !== e3[n3] && (a3 = e3[n3]), a3 >= 0 && a3 < d2 && hasGlyph(a3) && (v2[i3] = a3);
      });
    } else {
      const e3 = (function(e4, t3, i3, n4) {
        if (!e4) return warn$1("No cmap table available."), { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
        let a4, s4 = (t3.start || 0) + e4.offset;
        t3.pos = s4, t3.skip(2);
        const r3 = t3.getUint16();
        let o4, l4 = false;
        for (let e5 = 0; e5 < r3; e5++) {
          const a5 = t3.getUint16(), s5 = t3.getUint16(), c4 = t3.getInt32() >>> 0;
          let h4 = false;
          if (o4?.platformId !== a5 || o4?.encodingId !== s5) {
            if (0 !== a5 || 0 !== s5 && 1 !== s5 && 3 !== s5) if (1 === a5 && 0 === s5) h4 = true;
            else if (3 !== a5 || 1 !== s5 || !n4 && o4) {
              if (i3 && 3 === a5 && 0 === s5) {
                h4 = true;
                let i4 = true;
                if (e5 < r3 - 1) {
                  const e6 = t3.peekBytes(2);
                  int16(e6[0], e6[1]) < a5 && (i4 = false);
                }
                i4 && (l4 = true);
              }
            } else h4 = true, i3 || (l4 = true);
            else h4 = true;
            if (h4 && (o4 = { platformId: a5, encodingId: s5, offset: c4 }), l4) break;
          }
        }
        if (o4 && (t3.pos = s4 + o4.offset), !o4 || -1 === t3.peekByte()) return warn$1("Could not find a preferred cmap table."), { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
        const c3 = t3.getUint16();
        let h3 = false;
        const d3 = [];
        let u3, g3;
        if (0 === c3) {
          for (t3.skip(4), u3 = 0; u3 < 256; u3++) {
            const e5 = t3.getByte();
            e5 && d3.push({ charCode: u3, glyphId: e5 });
          }
          h3 = true;
        } else if (2 === c3) {
          t3.skip(4);
          const e5 = [];
          let i4 = 0;
          for (let n6 = 0; n6 < 256; n6++) {
            const n7 = t3.getUint16() >> 3;
            e5.push(n7), i4 = Math.max(n7, i4);
          }
          const n5 = [];
          for (let e6 = 0; e6 <= i4; e6++) n5.push({ firstCode: t3.getUint16(), entryCount: t3.getUint16(), idDelta: signedInt16(t3.getByte(), t3.getByte()), idRangePos: t3.pos + t3.getUint16() });
          for (let i5 = 0; i5 < 256; i5++) if (0 === e5[i5]) t3.pos = n5[0].idRangePos + 2 * i5, g3 = t3.getUint16(), d3.push({ charCode: i5, glyphId: g3 });
          else {
            const a5 = n5[e5[i5]];
            for (u3 = 0; u3 < a5.entryCount; u3++) {
              const e6 = (i5 << 8) + u3 + a5.firstCode;
              t3.pos = a5.idRangePos + 2 * u3, g3 = t3.getUint16(), 0 !== g3 && (g3 = (g3 + a5.idDelta) % 65536), d3.push({ charCode: e6, glyphId: g3 });
            }
          }
        } else if (4 === c3) {
          t3.skip(4);
          const e5 = t3.getUint16() >> 1;
          t3.skip(6);
          const i4 = [];
          let n5;
          for (n5 = 0; n5 < e5; n5++) i4.push({ end: t3.getUint16() });
          for (t3.skip(2), n5 = 0; n5 < e5; n5++) i4[n5].start = t3.getUint16();
          for (n5 = 0; n5 < e5; n5++) i4[n5].delta = t3.getUint16();
          let r4, o5 = 0;
          for (n5 = 0; n5 < e5; n5++) {
            a4 = i4[n5];
            const s5 = t3.getUint16();
            s5 ? (r4 = (s5 >> 1) - (e5 - n5), a4.offsetIndex = r4, o5 = Math.max(o5, r4 + a4.end - a4.start + 1)) : a4.offsetIndex = -1;
          }
          const l5 = [];
          for (u3 = 0; u3 < o5; u3++) l5.push(t3.getUint16());
          for (n5 = 0; n5 < e5; n5++) {
            a4 = i4[n5], s4 = a4.start;
            const e6 = a4.end, t4 = a4.delta;
            for (r4 = a4.offsetIndex, u3 = s4; u3 <= e6; u3++) 65535 !== u3 && (g3 = r4 < 0 ? u3 : l5[r4 + u3 - s4], g3 = g3 + t4 & 65535, d3.push({ charCode: u3, glyphId: g3 }));
          }
        } else if (6 === c3) {
          t3.skip(4);
          const e5 = t3.getUint16(), i4 = t3.getUint16();
          for (u3 = 0; u3 < i4; u3++) {
            g3 = t3.getUint16();
            const i5 = e5 + u3;
            d3.push({ charCode: i5, glyphId: g3 });
          }
        } else {
          if (12 !== c3) return warn$1("cmap table has unsupported format: " + c3), { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
          {
            t3.skip(10);
            const e5 = t3.getInt32() >>> 0;
            for (u3 = 0; u3 < e5; u3++) {
              const e6 = t3.getInt32() >>> 0, i4 = t3.getInt32() >>> 0;
              let n5 = t3.getInt32() >>> 0;
              for (let t4 = e6; t4 <= i4; t4++) d3.push({ charCode: t4, glyphId: n5++ });
            }
          }
        }
        d3.sort((e5, t4) => e5.charCode - t4.charCode);
        const f3 = [], p3 = /* @__PURE__ */ new Set();
        for (const e5 of d3) {
          const { charCode: t4 } = e5;
          p3.has(t4) || (p3.add(t4), f3.push(e5));
        }
        return { platformId: o4.platformId, encodingId: o4.encodingId, mappings: f3, hasShortCmap: h3 };
      })(r2.cmap, t2, this.isSymbolicFont, i2.hasEncoding), n3 = e3.platformId, a3 = e3.encodingId, s3 = e3.mappings;
      let o3 = [], l3 = false;
      if (!i2.hasEncoding || "MacRomanEncoding" !== i2.baseEncodingName && "WinAnsiEncoding" !== i2.baseEncodingName || (o3 = getEncoding(i2.baseEncodingName)), i2.hasEncoding && !this.isSymbolicFont && (3 === n3 && 1 === a3 || 1 === n3 && 0 === a3)) {
        const e4 = mn();
        for (let t3 = 0; t3 < 256; t3++) {
          let r3;
          if (r3 = void 0 !== this.differences[t3] ? this.differences[t3] : o3.length && "" !== o3[t3] ? o3[t3] : un[t3], !r3) continue;
          const l4 = recoverGlyphName(r3, e4);
          let c3;
          if (3 === n3 && 1 === a3 ? c3 = e4[l4] : 1 === n3 && 0 === a3 && (c3 = dn.indexOf(l4)), void 0 === c3) {
            if (!i2.glyphNames && i2.hasIncludedToUnicodeMap && !(this.toUnicode instanceof IdentityToUnicodeMap)) {
              const e5 = this.toUnicode.get(t3);
              e5 && (c3 = e5.codePointAt(0));
            }
            if (void 0 === c3) continue;
          }
          for (const e5 of s3) if (e5.charCode === c3) {
            v2[t3] = e5.glyphId;
            break;
          }
        }
      } else if (0 === n3) {
        for (const e4 of s3) v2[e4.charCode] = e4.glyphId;
        l3 = true;
      } else if (3 === n3 && 0 === a3) for (const e4 of s3) {
        let t3 = e4.charCode;
        t3 >= 61440 && t3 <= 61695 && (t3 &= 255), v2[t3] = e4.glyphId;
      }
      else for (const e4 of s3) v2[e4.charCode] = e4.glyphId;
      if (i2.glyphNames && (o3.length || this.differences.length)) for (let e4 = 0; e4 < 256; ++e4) {
        if (!l3 && void 0 !== v2[e4]) continue;
        const t3 = this.differences[e4] || o3[e4];
        if (!t3) continue;
        const n4 = i2.glyphNames.indexOf(t3);
        n4 > 0 && hasGlyph(n4) && (v2[e4] = n4);
      }
    }
    0 === v2.length && (v2[0] = 0);
    let C2 = p2 - 1;
    if (m2 || (C2 = 0), !i2.cssFontInfo) {
      const e3 = adjustMapping(v2, hasGlyph, C2, this.toUnicode);
      this.toFontChar = e3.toFontChar, r2.cmap = { tag: "cmap", data: createCmapTable(e3.charCodeToGlyphId, e3.toUnicodeExtraMap, p2) }, r2["OS/2"] && (function(e4, t3) {
        t3.pos = (t3.start || 0) + e4.offset;
        const i3 = t3.getUint16();
        t3.skip(60);
        const n3 = t3.getUint16();
        return !(i3 < 4 && 768 & n3) && (!(t3.getUint16() > t3.getUint16()) && (t3.skip(6), 0 !== t3.getUint16() && (e4.data[8] = e4.data[9] = 0, true)));
      })(r2["OS/2"], t2) || (r2["OS/2"] = { tag: "OS/2", data: createOS2Table(i2, e3.charCodeToGlyphId, S2) });
    }
    if (!c2) try {
      l2 = new Stream(r2["CFF "].data);
      o2 = new CFFParser(l2, i2, Sn).parse(), o2.duplicateFirstGlyph();
      const e3 = new CFFCompiler(o2);
      r2["CFF "].data = e3.compile();
    } catch {
      warn$1("Failed to compile font " + i2.loadedName);
    }
    if (r2.name) {
      const [t3, n3] = readNameTable(r2.name);
      r2.name.data = createNameTable(e2, t3), this.psName = t3[0][6] || null, i2.composite || (function(e3, t4, i3) {
        if (e3.isInternalFont) return;
        if (e3.hasIncludedToUnicodeMap) return;
        if (e3.hasEncoding) return;
        if (e3.toUnicode instanceof IdentityToUnicodeMap) return;
        if (!t4) return;
        if (0 === i3.length) return;
        if (e3.defaultEncoding === gn) return;
        for (const e4 of i3) if (!isWinNameRecord(e4)) return;
        const n4 = gn, a3 = [], s3 = mn();
        for (const e4 in n4) {
          const t5 = n4[e4];
          if ("" === t5) continue;
          const i4 = s3[t5];
          void 0 !== i4 && (a3[e4] = String.fromCharCode(i4));
        }
        a3.length > 0 && e3.toUnicode.amend(a3);
      })(i2, this.isSymbolicFont, n3);
    } else r2.name = { tag: "name", data: createNameTable(this.name) };
    const k2 = new OpenTypeFileBuilder(s2.version);
    for (const e3 in r2) k2.addTable(e3, r2[e3].data);
    return k2.toArray();
  }
  convert(e2, i2, n2) {
    n2.fixedPitch = false, n2.builtInEncoding && (function(e3, t2) {
      if (e3.isInternalFont) return;
      if (e3.hasIncludedToUnicodeMap) return;
      if (t2 === e3.defaultEncoding) return;
      if (e3.toUnicode instanceof IdentityToUnicodeMap) return;
      const i3 = [], n3 = mn();
      for (const a3 in t2) {
        if (e3.hasEncoding && (e3.baseEncodingName || void 0 !== e3.differences[a3])) continue;
        const s3 = getUnicodeForGlyph(t2[a3], n3);
        -1 !== s3 && (i3[a3] = String.fromCharCode(s3));
      }
      i3.length > 0 && e3.toUnicode.amend(i3);
    })(n2, n2.builtInEncoding);
    let a2 = 1;
    i2 instanceof CFFFont && (a2 = i2.numGlyphs - 1);
    const s2 = i2.getGlyphMapping(n2);
    let r2 = null, o2 = s2, l2 = null;
    n2.cssFontInfo || (r2 = adjustMapping(s2, i2.hasGlyphId.bind(i2), a2, this.toUnicode), this.toFontChar = r2.toFontChar, o2 = r2.charCodeToGlyphId, l2 = r2.toUnicodeExtraMap);
    const c2 = i2.numGlyphs;
    function getCharCodes(e3, t2) {
      let i3 = null;
      for (const n3 in e3) t2 === e3[n3] && (i3 ||= []).push(0 | n3);
      return i3;
    }
    function createCharCode(e3, t2) {
      for (const i3 in e3) if (t2 === e3[i3]) return 0 | i3;
      return r2.charCodeToGlyphId[r2.nextAvailableFontCharCode] = t2, r2.nextAvailableFontCharCode++;
    }
    const h2 = i2.seacs;
    if (r2 && h2?.length) {
      const e3 = n2.fontMatrix || t, a3 = i2.getCharset(), o3 = /* @__PURE__ */ Object.create(null);
      for (let t2 in h2) {
        t2 |= 0;
        const i3 = h2[t2], n3 = un[i3[2]], l3 = un[i3[3]], c3 = a3.indexOf(n3), d3 = a3.indexOf(l3);
        if (c3 < 0 || d3 < 0) continue;
        const u3 = { x: i3[0] * e3[0] + i3[1] * e3[2] + e3[4], y: i3[0] * e3[1] + i3[1] * e3[3] + e3[5] }, g2 = getCharCodes(s2, t2);
        if (g2) for (const e4 of g2) {
          const t3 = r2.charCodeToGlyphId, i4 = createCharCode(t3, c3), n4 = createCharCode(t3, d3);
          o3[e4] = { baseFontCharCode: i4, accentFontCharCode: n4, accentOffset: u3 };
        }
      }
      n2.seacMap = o3;
    }
    const d2 = n2.fontMatrix ? 1 / Math.max(...n2.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3, u2 = new OpenTypeFileBuilder("OTTO");
    return u2.addTable("CFF ", i2.data), u2.addTable("OS/2", createOS2Table(n2, o2)), u2.addTable("cmap", createCmapTable(o2, l2, c2)), u2.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<õ\0\0" + safeString16(d2) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + safeString16(n2.descent) + "ÿ" + safeString16(n2.ascent) + string16(n2.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0"), u2.addTable("hhea", "\0\0\0" + safeString16(n2.ascent) + safeString16(n2.descent) + "\0\0ÿÿ\0\0\0\0\0\0" + safeString16(n2.capHeight) + safeString16(Math.tan(n2.italicAngle) * n2.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + string16(c2)), u2.addTable("hmtx", (function() {
      const e3 = i2.charstrings, t2 = i2.cff ? i2.cff.widths : null;
      let n3 = "\0\0\0\0";
      for (let i3 = 1, a3 = c2; i3 < a3; i3++) {
        let a4 = 0;
        if (e3) {
          const t3 = e3[i3 - 1];
          a4 = "width" in t3 ? t3.width : 0;
        } else t2 && (a4 = Math.ceil(t2[i3] || 0));
        n3 += string16(a4) + string16(0);
      }
      return n3;
    })()), u2.addTable("maxp", "\0\0P\0" + string16(c2)), u2.addTable("name", createNameTable(e2)), u2.addTable("post", createPostTable(n2)), u2.toArray();
  }
  get _spaceWidth() {
    const e2 = ["space", "minus", "one", "i", "I"];
    let t2;
    for (const i2 of e2) {
      if (i2 in this.widths) {
        t2 = this.widths[i2];
        break;
      }
      const e3 = mn()[i2];
      let n2 = 0;
      if (this.composite && this.cMap.contains(e3) && (n2 = this.cMap.lookup(e3), "string" == typeof n2 && (n2 = convertCidString(e3, n2))), !n2 && this.toUnicode && (n2 = this.toUnicode.charCodeOf(e3)), n2 <= 0 && (n2 = e3), t2 = this.widths[n2], t2) break;
    }
    return shadow$1(this, "_spaceWidth", t2 || this.defaultWidth);
  }
  _charToGlyph(e2, t2 = false) {
    let i2, n2, a2, s2 = this._glyphCache[e2];
    if (s2?.isSpace === t2) return s2;
    let r2 = e2;
    this.cMap?.contains(e2) && (r2 = this.cMap.lookup(e2), "string" == typeof r2 && (r2 = convertCidString(e2, r2))), n2 = this.widths[r2], "number" != typeof n2 && (n2 = this.defaultWidth);
    const o2 = this.vmetrics?.[r2];
    let l2 = this.toUnicode.get(e2) || e2;
    "number" == typeof l2 && (l2 = String.fromCharCode(l2));
    let c2 = void 0 !== this.toFontChar[e2];
    if (i2 = this.toFontChar[e2] || e2, this.missingFile) {
      const t3 = this.differences[e2] || this.defaultEncoding[e2];
      ".notdef" !== t3 && "" !== t3 || "Type1" !== this.type || (i2 = 32, "" === t3 && (n2 ||= this._spaceWidth, l2 = String.fromCharCode(i2))), i2 = (h2 = i2) >= 65520 && h2 <= 65535 ? 0 : h2 >= 62976 && h2 <= 63743 ? yn()[h2] || h2 : 173 === h2 ? 45 : h2;
    }
    var h2;
    this.isType3Font && (a2 = i2);
    let d2 = null;
    if (this.seacMap?.[e2]) {
      c2 = true;
      const t3 = this.seacMap[e2];
      i2 = t3.baseFontCharCode, d2 = { fontChar: String.fromCodePoint(t3.accentFontCharCode), offset: t3.accentOffset };
    }
    let u2 = "";
    if ("number" == typeof i2 && (i2 <= 1114111 ? u2 = String.fromCodePoint(i2) : warn$1(`charToGlyph - invalid fontCharCode: ${i2}`)), this.missingFile && this.vertical && 1 === u2.length) {
      const e3 = In()[u2.charCodeAt(0)];
      e3 && (u2 = l2 = String.fromCharCode(e3));
    }
    return s2 = new fonts_Glyph(e2, u2, l2, d2, n2, o2, a2, t2, c2), this._glyphCache[e2] = s2;
  }
  charsToGlyphs(e2) {
    let t2 = this._charsCache[e2];
    if (t2) return t2;
    if (t2 = [], this.cMap) {
      const i2 = /* @__PURE__ */ Object.create(null), n2 = e2.length;
      let a2 = 0;
      for (; a2 < n2; ) {
        this.cMap.readCharCode(e2, a2, i2);
        const { charcode: n3, length: s2 } = i2;
        a2 += s2;
        const r2 = this._charToGlyph(n3, 1 === s2 && 32 === e2.charCodeAt(a2 - 1));
        t2.push(r2);
      }
    } else for (let i2 = 0, n2 = e2.length; i2 < n2; ++i2) {
      const n3 = e2.charCodeAt(i2), a2 = this._charToGlyph(n3, 32 === n3);
      t2.push(a2);
    }
    return this._charsCache[e2] = t2;
  }
  getCharPositions(e2) {
    const t2 = [];
    if (this.cMap) {
      const i2 = /* @__PURE__ */ Object.create(null);
      let n2 = 0;
      for (; n2 < e2.length; ) {
        this.cMap.readCharCode(e2, n2, i2);
        const a2 = i2.length;
        t2.push([n2, n2 + a2]), n2 += a2;
      }
    } else for (let i2 = 0, n2 = e2.length; i2 < n2; ++i2) t2.push([i2, i2 + 1]);
    return t2;
  }
  get glyphCacheValues() {
    return Object.values(this._glyphCache);
  }
  encodeString(e2) {
    const t2 = [], i2 = [], hasCurrentBufErrors = () => t2.length % 2 == 1, n2 = this.toUnicode instanceof IdentityToUnicodeMap ? (e3) => this.toUnicode.charCodeOf(e3) : (e3) => this.toUnicode.charCodeOf(String.fromCodePoint(e3));
    for (let a2 = 0, s2 = e2.length; a2 < s2; a2++) {
      const s3 = e2.codePointAt(a2);
      if (s3 > 55295 && (s3 < 57344 || s3 > 65533) && a2++, this.toUnicode) {
        const e3 = n2(s3);
        if (-1 !== e3) {
          hasCurrentBufErrors() && (t2.push(i2.join("")), i2.length = 0);
          for (let t3 = (this.cMap ? this.cMap.getCharCodeLength(e3) : 1) - 1; t3 >= 0; t3--) i2.push(String.fromCharCode(e3 >> 8 * t3 & 255));
          continue;
        }
      }
      hasCurrentBufErrors() || (t2.push(i2.join("")), i2.length = 0), i2.push(String.fromCodePoint(s3));
    }
    return t2.push(i2.join("")), t2;
  }
}
class ErrorFont {
  constructor(e2) {
    this.error = e2, this.loadedName = "g_font_error", this.missingFile = true;
  }
  charsToGlyphs() {
    return [];
  }
  encodeString(e2) {
    return [e2];
  }
  exportData() {
    return { error: this.error };
  }
}
const ha = 2, da = 3, ua = 4, ga = 5, fa = 6, pa = 7;
class Pattern {
  constructor() {
    unreachable$1("Cannot initialize Pattern.");
  }
  static parseShading(e2, t2, i2, n2, a2, s2) {
    const r2 = e2 instanceof BaseStream ? e2.dict : e2, o2 = r2.get("ShadingType");
    try {
      switch (o2) {
        case ha:
        case da:
          return new RadialAxialShading(r2, t2, i2, n2, a2, s2);
        case ua:
        case ga:
        case fa:
        case pa:
          return new MeshShading(e2, t2, i2, n2, a2, s2);
        default:
          throw new ti("Unsupported ShadingType: " + o2);
      }
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      return warn$1(e3), new DummyShading();
    }
  }
}
class BaseShading {
  static SMALL_NUMBER = 1e-6;
  getIR() {
    unreachable$1("Abstract method `getIR` called.");
  }
}
class RadialAxialShading extends BaseShading {
  constructor(e2, t2, i2, n2, a2, s2) {
    super(), this.shadingType = e2.get("ShadingType");
    let r2 = 0;
    if (this.shadingType === ha ? r2 = 4 : this.shadingType === da && (r2 = 6), this.coordsArr = e2.getArray("Coords"), !isNumberArray(this.coordsArr, r2)) throw new ti("RadialAxialShading: Invalid /Coords array.");
    const o2 = ColorSpaceUtils.parse({ cs: e2.getRaw("CS") || e2.getRaw("ColorSpace"), xref: t2, resources: i2, pdfFunctionFactory: n2, globalColorSpaceCache: a2, localColorSpaceCache: s2 });
    this.bbox = lookupNormalRect(e2.getArray("BBox"), null);
    let l2 = 0, c2 = 1;
    const h2 = e2.getArray("Domain");
    isNumberArray(h2, 2) && ([l2, c2] = h2);
    let d2 = false, u2 = false;
    const g2 = e2.getArray("Extend");
    var f2, p2;
    if (f2 = g2, p2 = 2, Array.isArray(f2) && f2.length === p2 && f2.every((e3) => "boolean" == typeof e3) && ([d2, u2] = g2), !(this.shadingType !== da || d2 && u2)) {
      const [e3, t3, i3, n3, a3, s3] = this.coordsArr, r3 = Math.hypot(e3 - n3, t3 - a3);
      i3 <= s3 + r3 && s3 <= i3 + r3 && warn$1("Unsupported radial gradient.");
    }
    this.extendStart = d2, this.extendEnd = u2;
    const m2 = e2.getRaw("Function"), b2 = n2.create(m2, true), y2 = (c2 - l2) / 840, w2 = this.colorStops = [];
    if (l2 >= c2 || y2 <= 0) return void info$1("Bad shading domain.");
    const x2 = new Float32Array(o2.numComps), S2 = new Float32Array(1);
    let v2 = 0;
    S2[0] = l2, b2(S2, 0, x2, 0);
    const C2 = new Uint8ClampedArray(3);
    o2.getRgb(x2, 0, C2);
    let [k2, T2, F2] = C2;
    w2.push([0, ai.makeHexColor(k2, T2, F2)]);
    let E2 = 1;
    S2[0] = l2 + y2, b2(S2, 0, x2, 0), o2.getRgb(x2, 0, C2);
    let [M2, D2, O2] = C2, _2 = M2 - k2 + 1, R2 = D2 - T2 + 1, N2 = O2 - F2 + 1, L2 = M2 - k2 - 1, U2 = D2 - T2 - 1, j2 = O2 - F2 - 1;
    for (let e3 = 2; e3 < 840; e3++) {
      S2[0] = l2 + e3 * y2, b2(S2, 0, x2, 0), o2.getRgb(x2, 0, C2);
      const [t3, i3, n3] = C2, a3 = e3 - v2;
      _2 = Math.min(_2, (t3 - k2 + 1) / a3), R2 = Math.min(R2, (i3 - T2 + 1) / a3), N2 = Math.min(N2, (n3 - F2 + 1) / a3), L2 = Math.max(L2, (t3 - k2 - 1) / a3), U2 = Math.max(U2, (i3 - T2 - 1) / a3), j2 = Math.max(j2, (n3 - F2 - 1) / a3);
      if (!(L2 <= _2 && U2 <= R2 && j2 <= N2)) {
        const e4 = ai.makeHexColor(M2, D2, O2);
        w2.push([E2 / 840, e4]), _2 = t3 - M2 + 1, R2 = i3 - D2 + 1, N2 = n3 - O2 + 1, L2 = t3 - M2 - 1, U2 = i3 - D2 - 1, j2 = n3 - O2 - 1, v2 = E2, k2 = M2, T2 = D2, F2 = O2;
      }
      E2 = e3, M2 = t3, D2 = i3, O2 = n3;
    }
    w2.push([1, ai.makeHexColor(M2, D2, O2)]);
    let $2 = "transparent";
    e2.has("Background") && ($2 = o2.getRgbHex(e2.get("Background"), 0)), d2 || (w2.unshift([0, $2]), w2[1][0] += BaseShading.SMALL_NUMBER), u2 || (w2.at(-1)[0] -= BaseShading.SMALL_NUMBER, w2.push([1, $2])), this.colorStops = w2;
  }
  getIR() {
    const { coordsArr: e2, shadingType: t2 } = this;
    let i2, n2, a2, s2, r2;
    return t2 === ha ? (n2 = [e2[0], e2[1]], a2 = [e2[2], e2[3]], s2 = null, r2 = null, i2 = "axial") : t2 === da ? (n2 = [e2[0], e2[1]], a2 = [e2[3], e2[4]], s2 = e2[2], r2 = e2[5], i2 = "radial") : unreachable$1(`getPattern type unknown: ${t2}`), ["RadialAxial", i2, this.bbox, this.colorStops, n2, a2, s2, r2];
  }
}
class MeshStreamReader {
  constructor(e2, t2) {
    this.stream = e2, this.context = t2, this.buffer = 0, this.bufferLength = 0;
    const i2 = t2.numComps;
    this.tmpCompsBuf = new Float32Array(i2);
    const n2 = t2.colorSpace.numComps;
    this.tmpCsCompsBuf = t2.colorFn ? new Float32Array(n2) : this.tmpCompsBuf;
  }
  get hasData() {
    if (this.stream.end) return this.stream.pos < this.stream.end;
    if (this.bufferLength > 0) return true;
    const e2 = this.stream.getByte();
    return !(e2 < 0) && (this.buffer = e2, this.bufferLength = 8, true);
  }
  readBits(e2) {
    const { stream: t2 } = this;
    let { buffer: i2, bufferLength: n2 } = this;
    if (32 === e2) {
      if (0 === n2) return t2.getInt32() >>> 0;
      i2 = i2 << 24 | t2.getByte() << 16 | t2.getByte() << 8 | t2.getByte();
      const e3 = t2.getByte();
      return this.buffer = e3 & (1 << n2) - 1, (i2 << 8 - n2 | (255 & e3) >> n2) >>> 0;
    }
    if (8 === e2 && 0 === n2) return t2.getByte();
    for (; n2 < e2; ) i2 = i2 << 8 | t2.getByte(), n2 += 8;
    return n2 -= e2, this.bufferLength = n2, this.buffer = i2 & (1 << n2) - 1, i2 >> n2;
  }
  align() {
    this.buffer = 0, this.bufferLength = 0;
  }
  readFlag() {
    return this.readBits(this.context.bitsPerFlag);
  }
  readCoordinate() {
    const { bitsPerCoordinate: e2, decode: t2 } = this.context, i2 = this.readBits(e2), n2 = this.readBits(e2), a2 = e2 < 32 ? 1 / ((1 << e2) - 1) : 23283064365386963e-26;
    return [i2 * a2 * (t2[1] - t2[0]) + t2[0], n2 * a2 * (t2[3] - t2[2]) + t2[2]];
  }
  readComponents() {
    const { bitsPerComponent: e2, colorFn: t2, colorSpace: i2, decode: n2, numComps: a2 } = this.context, s2 = e2 < 32 ? 1 / ((1 << e2) - 1) : 23283064365386963e-26, r2 = this.tmpCompsBuf;
    for (let t3 = 0, i3 = 4; t3 < a2; t3++, i3 += 2) {
      const a3 = this.readBits(e2);
      r2[t3] = a3 * s2 * (n2[i3 + 1] - n2[i3]) + n2[i3];
    }
    const o2 = this.tmpCsCompsBuf;
    return t2?.(r2, 0, o2, 0), i2.getRgb(o2, 0);
  }
}
let ma = /* @__PURE__ */ Object.create(null);
function getB(e2) {
  return ma[e2] ||= (function(e3) {
    const t2 = [];
    for (let i2 = 0; i2 <= e3; i2++) {
      const n2 = i2 / e3, a2 = 1 - n2;
      t2.push(new Float32Array([a2 ** 3, 3 * n2 * a2 ** 2, 3 * n2 ** 2 * a2, n2 ** 3]));
    }
    return t2;
  })(e2);
}
class MeshShading extends BaseShading {
  static MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;
  static MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;
  static TRIANGLE_DENSITY = 20;
  constructor(e2, t2, i2, n2, a2, s2) {
    if (super(), !(e2 instanceof BaseStream)) throw new ti("Mesh data is not a stream");
    const r2 = e2.dict;
    this.shadingType = r2.get("ShadingType"), this.bbox = lookupNormalRect(r2.getArray("BBox"), null);
    const o2 = ColorSpaceUtils.parse({ cs: r2.getRaw("CS") || r2.getRaw("ColorSpace"), xref: t2, resources: i2, pdfFunctionFactory: n2, globalColorSpaceCache: a2, localColorSpaceCache: s2 });
    this.background = r2.has("Background") ? o2.getRgb(r2.get("Background"), 0) : null;
    const l2 = r2.getRaw("Function"), c2 = l2 ? n2.create(l2, true) : null;
    this.coords = [], this.colors = [], this.figures = [];
    const h2 = { bitsPerCoordinate: r2.get("BitsPerCoordinate"), bitsPerComponent: r2.get("BitsPerComponent"), bitsPerFlag: r2.get("BitsPerFlag"), decode: r2.getArray("Decode"), colorFn: c2, colorSpace: o2, numComps: c2 ? 1 : o2.numComps }, d2 = new MeshStreamReader(e2, h2);
    let u2 = false;
    switch (this.shadingType) {
      case ua:
        this._decodeType4Shading(d2);
        break;
      case ga:
        const e3 = 0 | r2.get("VerticesPerRow");
        if (e3 < 2) throw new ti("Invalid VerticesPerRow");
        this._decodeType5Shading(d2, e3);
        break;
      case fa:
        this._decodeType6Shading(d2), u2 = true;
        break;
      case pa:
        this._decodeType7Shading(d2), u2 = true;
        break;
      default:
        unreachable$1("Unsupported mesh type.");
    }
    if (u2) {
      this._updateBounds();
      for (let e3 = 0, t3 = this.figures.length; e3 < t3; e3++) this._buildFigureFromPatch(e3);
    }
    this._updateBounds(), this._packData();
  }
  _decodeType4Shading(e2) {
    const t2 = this.coords, i2 = this.colors, n2 = [];
    let a2 = 0;
    for (; e2.hasData; ) {
      const s2 = e2.readFlag(), r2 = e2.readCoordinate(), o2 = e2.readComponents();
      if (0 === a2) {
        if (!(0 <= s2 && s2 <= 2)) throw new ti("Unknown type4 flag");
        switch (s2) {
          case 0:
            a2 = 3;
            break;
          case 1:
            n2.push(n2.at(-2), n2.at(-1)), a2 = 1;
            break;
          case 2:
            n2.push(n2.at(-3), n2.at(-1)), a2 = 1;
        }
      }
      n2.push(t2.length), t2.push(r2), i2.push(o2), a2--, e2.align();
    }
    this.figures.push({ type: "triangles", coords: new Int32Array(n2), colors: new Int32Array(n2) });
  }
  _decodeType5Shading(e2, t2) {
    const i2 = this.coords, n2 = this.colors, a2 = [];
    for (; e2.hasData; ) {
      const t3 = e2.readCoordinate(), s2 = e2.readComponents();
      a2.push(i2.length), i2.push(t3), n2.push(s2);
    }
    this.figures.push({ type: "lattice", coords: new Int32Array(a2), colors: new Int32Array(a2), verticesPerRow: t2 });
  }
  _decodeType6Shading(e2) {
    const t2 = this.coords, i2 = this.colors, n2 = new Int32Array(16), a2 = new Int32Array(4);
    for (; e2.hasData; ) {
      const s2 = e2.readFlag();
      if (!(0 <= s2 && s2 <= 3)) throw new ti("Unknown type6 flag");
      const r2 = t2.length;
      for (let i3 = 0, n3 = 0 !== s2 ? 8 : 12; i3 < n3; i3++) t2.push(e2.readCoordinate());
      const o2 = i2.length;
      for (let t3 = 0, n3 = 0 !== s2 ? 2 : 4; t3 < n3; t3++) i2.push(e2.readComponents());
      let l2, c2, h2, d2;
      switch (s2) {
        case 0:
          n2[12] = r2 + 3, n2[13] = r2 + 4, n2[14] = r2 + 5, n2[15] = r2 + 6, n2[8] = r2 + 2, n2[11] = r2 + 7, n2[4] = r2 + 1, n2[7] = r2 + 8, n2[0] = r2, n2[1] = r2 + 11, n2[2] = r2 + 10, n2[3] = r2 + 9, a2[2] = o2 + 1, a2[3] = o2 + 2, a2[0] = o2, a2[1] = o2 + 3;
          break;
        case 1:
          l2 = n2[12], c2 = n2[13], h2 = n2[14], d2 = n2[15], n2[12] = d2, n2[13] = r2 + 0, n2[14] = r2 + 1, n2[15] = r2 + 2, n2[8] = h2, n2[11] = r2 + 3, n2[4] = c2, n2[7] = r2 + 4, n2[0] = l2, n2[1] = r2 + 7, n2[2] = r2 + 6, n2[3] = r2 + 5, l2 = a2[2], c2 = a2[3], a2[2] = c2, a2[3] = o2, a2[0] = l2, a2[1] = o2 + 1;
          break;
        case 2:
          l2 = n2[15], c2 = n2[11], n2[12] = n2[3], n2[13] = r2 + 0, n2[14] = r2 + 1, n2[15] = r2 + 2, n2[8] = n2[7], n2[11] = r2 + 3, n2[4] = c2, n2[7] = r2 + 4, n2[0] = l2, n2[1] = r2 + 7, n2[2] = r2 + 6, n2[3] = r2 + 5, l2 = a2[3], a2[2] = a2[1], a2[3] = o2, a2[0] = l2, a2[1] = o2 + 1;
          break;
        case 3:
          n2[12] = n2[0], n2[13] = r2 + 0, n2[14] = r2 + 1, n2[15] = r2 + 2, n2[8] = n2[1], n2[11] = r2 + 3, n2[4] = n2[2], n2[7] = r2 + 4, n2[0] = n2[3], n2[1] = r2 + 7, n2[2] = r2 + 6, n2[3] = r2 + 5, a2[2] = a2[0], a2[3] = o2, a2[0] = a2[1], a2[1] = o2 + 1;
      }
      n2[5] = t2.length, t2.push([(-4 * t2[n2[0]][0] - t2[n2[15]][0] + 6 * (t2[n2[4]][0] + t2[n2[1]][0]) - 2 * (t2[n2[12]][0] + t2[n2[3]][0]) + 3 * (t2[n2[13]][0] + t2[n2[7]][0])) / 9, (-4 * t2[n2[0]][1] - t2[n2[15]][1] + 6 * (t2[n2[4]][1] + t2[n2[1]][1]) - 2 * (t2[n2[12]][1] + t2[n2[3]][1]) + 3 * (t2[n2[13]][1] + t2[n2[7]][1])) / 9]), n2[6] = t2.length, t2.push([(-4 * t2[n2[3]][0] - t2[n2[12]][0] + 6 * (t2[n2[2]][0] + t2[n2[7]][0]) - 2 * (t2[n2[0]][0] + t2[n2[15]][0]) + 3 * (t2[n2[4]][0] + t2[n2[14]][0])) / 9, (-4 * t2[n2[3]][1] - t2[n2[12]][1] + 6 * (t2[n2[2]][1] + t2[n2[7]][1]) - 2 * (t2[n2[0]][1] + t2[n2[15]][1]) + 3 * (t2[n2[4]][1] + t2[n2[14]][1])) / 9]), n2[9] = t2.length, t2.push([(-4 * t2[n2[12]][0] - t2[n2[3]][0] + 6 * (t2[n2[8]][0] + t2[n2[13]][0]) - 2 * (t2[n2[0]][0] + t2[n2[15]][0]) + 3 * (t2[n2[11]][0] + t2[n2[1]][0])) / 9, (-4 * t2[n2[12]][1] - t2[n2[3]][1] + 6 * (t2[n2[8]][1] + t2[n2[13]][1]) - 2 * (t2[n2[0]][1] + t2[n2[15]][1]) + 3 * (t2[n2[11]][1] + t2[n2[1]][1])) / 9]), n2[10] = t2.length, t2.push([(-4 * t2[n2[15]][0] - t2[n2[0]][0] + 6 * (t2[n2[11]][0] + t2[n2[14]][0]) - 2 * (t2[n2[12]][0] + t2[n2[3]][0]) + 3 * (t2[n2[2]][0] + t2[n2[8]][0])) / 9, (-4 * t2[n2[15]][1] - t2[n2[0]][1] + 6 * (t2[n2[11]][1] + t2[n2[14]][1]) - 2 * (t2[n2[12]][1] + t2[n2[3]][1]) + 3 * (t2[n2[2]][1] + t2[n2[8]][1])) / 9]), this.figures.push({ type: "patch", coords: new Int32Array(n2), colors: new Int32Array(a2) });
    }
  }
  _decodeType7Shading(e2) {
    const t2 = this.coords, i2 = this.colors, n2 = new Int32Array(16), a2 = new Int32Array(4);
    for (; e2.hasData; ) {
      const s2 = e2.readFlag();
      if (!(0 <= s2 && s2 <= 3)) throw new ti("Unknown type7 flag");
      const r2 = t2.length;
      for (let i3 = 0, n3 = 0 !== s2 ? 12 : 16; i3 < n3; i3++) t2.push(e2.readCoordinate());
      const o2 = i2.length;
      for (let t3 = 0, n3 = 0 !== s2 ? 2 : 4; t3 < n3; t3++) i2.push(e2.readComponents());
      let l2, c2, h2, d2;
      switch (s2) {
        case 0:
          n2[12] = r2 + 3, n2[13] = r2 + 4, n2[14] = r2 + 5, n2[15] = r2 + 6, n2[8] = r2 + 2, n2[9] = r2 + 13, n2[10] = r2 + 14, n2[11] = r2 + 7, n2[4] = r2 + 1, n2[5] = r2 + 12, n2[6] = r2 + 15, n2[7] = r2 + 8, n2[0] = r2, n2[1] = r2 + 11, n2[2] = r2 + 10, n2[3] = r2 + 9, a2[2] = o2 + 1, a2[3] = o2 + 2, a2[0] = o2, a2[1] = o2 + 3;
          break;
        case 1:
          l2 = n2[12], c2 = n2[13], h2 = n2[14], d2 = n2[15], n2[12] = d2, n2[13] = r2 + 0, n2[14] = r2 + 1, n2[15] = r2 + 2, n2[8] = h2, n2[9] = r2 + 9, n2[10] = r2 + 10, n2[11] = r2 + 3, n2[4] = c2, n2[5] = r2 + 8, n2[6] = r2 + 11, n2[7] = r2 + 4, n2[0] = l2, n2[1] = r2 + 7, n2[2] = r2 + 6, n2[3] = r2 + 5, l2 = a2[2], c2 = a2[3], a2[2] = c2, a2[3] = o2, a2[0] = l2, a2[1] = o2 + 1;
          break;
        case 2:
          l2 = n2[15], c2 = n2[11], n2[12] = n2[3], n2[13] = r2 + 0, n2[14] = r2 + 1, n2[15] = r2 + 2, n2[8] = n2[7], n2[9] = r2 + 9, n2[10] = r2 + 10, n2[11] = r2 + 3, n2[4] = c2, n2[5] = r2 + 8, n2[6] = r2 + 11, n2[7] = r2 + 4, n2[0] = l2, n2[1] = r2 + 7, n2[2] = r2 + 6, n2[3] = r2 + 5, l2 = a2[3], a2[2] = a2[1], a2[3] = o2, a2[0] = l2, a2[1] = o2 + 1;
          break;
        case 3:
          n2[12] = n2[0], n2[13] = r2 + 0, n2[14] = r2 + 1, n2[15] = r2 + 2, n2[8] = n2[1], n2[9] = r2 + 9, n2[10] = r2 + 10, n2[11] = r2 + 3, n2[4] = n2[2], n2[5] = r2 + 8, n2[6] = r2 + 11, n2[7] = r2 + 4, n2[0] = n2[3], n2[1] = r2 + 7, n2[2] = r2 + 6, n2[3] = r2 + 5, a2[2] = a2[0], a2[3] = o2, a2[0] = a2[1], a2[1] = o2 + 1;
      }
      this.figures.push({ type: "patch", coords: new Int32Array(n2), colors: new Int32Array(a2) });
    }
  }
  _buildFigureFromPatch(e2) {
    const t2 = this.figures[e2];
    assert$1("patch" === t2.type, "Unexpected patch mesh figure");
    const i2 = this.coords, n2 = this.colors, a2 = t2.coords, s2 = t2.colors, r2 = Math.min(i2[a2[0]][0], i2[a2[3]][0], i2[a2[12]][0], i2[a2[15]][0]), o2 = Math.min(i2[a2[0]][1], i2[a2[3]][1], i2[a2[12]][1], i2[a2[15]][1]), l2 = Math.max(i2[a2[0]][0], i2[a2[3]][0], i2[a2[12]][0], i2[a2[15]][0]), c2 = Math.max(i2[a2[0]][1], i2[a2[3]][1], i2[a2[12]][1], i2[a2[15]][1]);
    let h2 = Math.ceil((l2 - r2) * MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
    h2 = MathClamp$1(h2, MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT);
    let d2 = Math.ceil((c2 - o2) * MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
    d2 = MathClamp$1(d2, MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT);
    const u2 = h2 + 1, g2 = new Int32Array((d2 + 1) * u2), f2 = new Int32Array((d2 + 1) * u2);
    let p2 = 0;
    const m2 = new Uint8Array(3), b2 = new Uint8Array(3), y2 = n2[s2[0]], w2 = n2[s2[1]], x2 = n2[s2[2]], S2 = n2[s2[3]], v2 = getB(d2), C2 = getB(h2);
    for (let e3 = 0; e3 <= d2; e3++) {
      m2[0] = (y2[0] * (d2 - e3) + x2[0] * e3) / d2 | 0, m2[1] = (y2[1] * (d2 - e3) + x2[1] * e3) / d2 | 0, m2[2] = (y2[2] * (d2 - e3) + x2[2] * e3) / d2 | 0, b2[0] = (w2[0] * (d2 - e3) + S2[0] * e3) / d2 | 0, b2[1] = (w2[1] * (d2 - e3) + S2[1] * e3) / d2 | 0, b2[2] = (w2[2] * (d2 - e3) + S2[2] * e3) / d2 | 0;
      for (let t3 = 0; t3 <= h2; t3++, p2++) {
        if (!(0 !== e3 && e3 !== d2 || 0 !== t3 && t3 !== h2)) continue;
        let s3 = 0, r3 = 0, o3 = 0;
        for (let n3 = 0; n3 <= 3; n3++) for (let l4 = 0; l4 <= 3; l4++, o3++) {
          const c3 = v2[e3][n3] * C2[t3][l4];
          s3 += i2[a2[o3]][0] * c3, r3 += i2[a2[o3]][1] * c3;
        }
        g2[p2] = i2.length, i2.push([s3, r3]), f2[p2] = n2.length;
        const l3 = new Uint8Array(3);
        l3[0] = (m2[0] * (h2 - t3) + b2[0] * t3) / h2 | 0, l3[1] = (m2[1] * (h2 - t3) + b2[1] * t3) / h2 | 0, l3[2] = (m2[2] * (h2 - t3) + b2[2] * t3) / h2 | 0, n2.push(l3);
      }
    }
    g2[0] = a2[0], f2[0] = s2[0], g2[h2] = a2[3], f2[h2] = s2[1], g2[u2 * d2] = a2[12], f2[u2 * d2] = s2[2], g2[u2 * d2 + h2] = a2[15], f2[u2 * d2 + h2] = s2[3], this.figures[e2] = { type: "lattice", coords: g2, colors: f2, verticesPerRow: u2 };
  }
  _updateBounds() {
    let e2 = this.coords[0][0], t2 = this.coords[0][1], i2 = e2, n2 = t2;
    for (let a2 = 1, s2 = this.coords.length; a2 < s2; a2++) {
      const s3 = this.coords[a2][0], r2 = this.coords[a2][1];
      e2 = e2 > s3 ? s3 : e2, t2 = t2 > r2 ? r2 : t2, i2 = i2 < s3 ? s3 : i2, n2 = n2 < r2 ? r2 : n2;
    }
    this.bounds = [e2, t2, i2, n2];
  }
  _packData() {
    let e2, t2, i2, n2;
    const a2 = this.coords, s2 = new Float32Array(2 * a2.length);
    for (e2 = 0, i2 = 0, t2 = a2.length; e2 < t2; e2++) {
      const t3 = a2[e2];
      s2[i2++] = t3[0], s2[i2++] = t3[1];
    }
    this.coords = s2;
    const r2 = this.colors, o2 = new Uint8Array(3 * r2.length);
    for (e2 = 0, i2 = 0, t2 = r2.length; e2 < t2; e2++) {
      const t3 = r2[e2];
      o2[i2++] = t3[0], o2[i2++] = t3[1], o2[i2++] = t3[2];
    }
    this.colors = o2;
    const l2 = this.figures;
    for (e2 = 0, t2 = l2.length; e2 < t2; e2++) {
      const t3 = l2[e2], a3 = t3.coords, s3 = t3.colors;
      for (i2 = 0, n2 = a3.length; i2 < n2; i2++) a3[i2] *= 2, s3[i2] *= 3;
    }
  }
  getIR() {
    const { bounds: e2 } = this;
    if (e2[2] - e2[0] === 0 || e2[3] - e2[1] === 0) throw new ti(`Invalid MeshShading bounds: [${e2}].`);
    return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, e2, this.bbox, this.background];
  }
}
class DummyShading extends BaseShading {
  getIR() {
    return ["Dummy"];
  }
}
function getTilingPatternIR(e2, t2, i2) {
  const n2 = lookupMatrix(t2.getArray("Matrix"), pi), a2 = lookupNormalRect(t2.getArray("BBox"), null);
  if (!a2 || a2[2] - a2[0] === 0 || a2[3] - a2[1] === 0) throw new ti("Invalid getTilingPatternIR /BBox array.");
  const s2 = t2.get("XStep");
  if ("number" != typeof s2) throw new ti("Invalid getTilingPatternIR /XStep value.");
  const r2 = t2.get("YStep");
  if ("number" != typeof r2) throw new ti("Invalid getTilingPatternIR /YStep value.");
  const o2 = t2.get("PaintType");
  if (!Number.isInteger(o2)) throw new ti("Invalid getTilingPatternIR /PaintType value.");
  const l2 = t2.get("TilingType");
  if (!Number.isInteger(l2)) throw new ti("Invalid getTilingPatternIR /TilingType value.");
  return ["TilingPattern", i2, e2, n2, a2, s2, r2, o2, l2];
}
const ba = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], ya = { lineHeight: 1.2207, lineGap: 0.2207 }, wa = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], Aa = { lineHeight: 1.2207, lineGap: 0.2207 }, xa = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], Sa = { lineHeight: 1.2207, lineGap: 0.2207 }, va = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], Ca = { lineHeight: 1.2207, lineGap: 0.2207 }, ka = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], Ta = { lineHeight: 1.2, lineGap: 0.2 }, Fa = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], Ia = { lineHeight: 1.35, lineGap: 0.2 }, Ea = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], Ma = { lineHeight: 1.35, lineGap: 0.2 }, Da = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], Oa = { lineHeight: 1.2, lineGap: 0.2 }, _a = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333], Pa = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], Ra = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333], Ba = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], Na = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285], La = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], Ua = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285], ja = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], $a = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], Ha = { lineHeight: 1.2, lineGap: 0.2 }, Xa = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], qa = { lineHeight: 1.2, lineGap: 0.2 }, za = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], Wa = { lineHeight: 1.2, lineGap: 0.2 }, Ga = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], Va = { lineHeight: 1.2, lineGap: 0.2 }, Ka = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], Ya = { lineHeight: 1.33008, lineGap: 0 }, Ja = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], Za = { lineHeight: 1.33008, lineGap: 0 }, Qa = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], es = { lineHeight: 1.33008, lineGap: 0 }, ts = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], is = { lineHeight: 1.33008, lineGap: 0 }, ns = getLookupTableFactory(function(e2) {
  e2["MyriadPro-Regular"] = e2["PdfJS-Fallback-Regular"] = { name: "LiberationSans-Regular", factors: Ga, baseWidths: Ua, baseMapping: ja, metrics: Va }, e2["MyriadPro-Bold"] = e2["PdfJS-Fallback-Bold"] = { name: "LiberationSans-Bold", factors: $a, baseWidths: _a, baseMapping: Pa, metrics: Ha }, e2["MyriadPro-It"] = e2["MyriadPro-Italic"] = e2["PdfJS-Fallback-Italic"] = { name: "LiberationSans-Italic", factors: za, baseWidths: Na, baseMapping: La, metrics: Wa }, e2["MyriadPro-BoldIt"] = e2["MyriadPro-BoldItalic"] = e2["PdfJS-Fallback-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: Xa, baseWidths: Ra, baseMapping: Ba, metrics: qa }, e2.ArialMT = e2.Arial = e2["Arial-Regular"] = { name: "LiberationSans-Regular", baseWidths: Ua, baseMapping: ja }, e2["Arial-BoldMT"] = e2["Arial-Bold"] = { name: "LiberationSans-Bold", baseWidths: _a, baseMapping: Pa }, e2["Arial-ItalicMT"] = e2["Arial-Italic"] = { name: "LiberationSans-Italic", baseWidths: Na, baseMapping: La }, e2["Arial-BoldItalicMT"] = e2["Arial-BoldItalic"] = { name: "LiberationSans-BoldItalic", baseWidths: Ra, baseMapping: Ba }, e2["Calibri-Regular"] = { name: "LiberationSans-Regular", factors: va, baseWidths: Ua, baseMapping: ja, metrics: Ca }, e2["Calibri-Bold"] = { name: "LiberationSans-Bold", factors: ba, baseWidths: _a, baseMapping: Pa, metrics: ya }, e2["Calibri-Italic"] = { name: "LiberationSans-Italic", factors: xa, baseWidths: Na, baseMapping: La, metrics: Sa }, e2["Calibri-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: wa, baseWidths: Ra, baseMapping: Ba, metrics: Aa }, e2["Segoeui-Regular"] = { name: "LiberationSans-Regular", factors: ts, baseWidths: Ua, baseMapping: ja, metrics: is }, e2["Segoeui-Bold"] = { name: "LiberationSans-Bold", factors: Ka, baseWidths: _a, baseMapping: Pa, metrics: Ya }, e2["Segoeui-Italic"] = { name: "LiberationSans-Italic", factors: Qa, baseWidths: Na, baseMapping: La, metrics: es }, e2["Segoeui-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: Ja, baseWidths: Ra, baseMapping: Ba, metrics: Za }, e2["Helvetica-Regular"] = e2.Helvetica = { name: "LiberationSans-Regular", factors: Da, baseWidths: Ua, baseMapping: ja, metrics: Oa }, e2["Helvetica-Bold"] = { name: "LiberationSans-Bold", factors: ka, baseWidths: _a, baseMapping: Pa, metrics: Ta }, e2["Helvetica-Italic"] = { name: "LiberationSans-Italic", factors: Ea, baseWidths: Na, baseMapping: La, metrics: Ma }, e2["Helvetica-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: Fa, baseWidths: Ra, baseMapping: Ba, metrics: Ia };
});
function getXfaFontName(e2) {
  const t2 = normalizeFontName(e2);
  return ns()[t2];
}
function getXfaFontDict(e2) {
  const t2 = (function(e3) {
    const t3 = getXfaFontName(e3);
    if (!t3) return null;
    const { baseWidths: i3, baseMapping: n3, factors: a3 } = t3, s2 = a3 ? i3.map((e4, t4) => e4 * a3[t4]) : i3;
    let r2, o2 = -2;
    const l2 = [];
    for (const [e4, t4] of n3.map((e5, t5) => [e5, t5]).sort(([e5], [t5]) => e5 - t5)) -1 !== e4 && (e4 === o2 + 1 ? (r2.push(s2[t4]), o2 += 1) : (o2 = e4, r2 = [s2[t4]], l2.push(e4, r2)));
    return l2;
  })(e2), i2 = new Dict(null);
  i2.set("BaseFont", Name.get(e2)), i2.set("Type", Name.get("Font")), i2.set("Subtype", Name.get("CIDFontType2")), i2.set("Encoding", Name.get("Identity-H")), i2.set("CIDToGIDMap", Name.get("Identity")), i2.set("W", t2), i2.set("FirstChar", t2[0]), i2.set("LastChar", t2.at(-2) + t2.at(-1).length - 1);
  const n2 = new Dict(null);
  i2.set("FontDescriptor", n2);
  const a2 = new Dict(null);
  return a2.set("Ordering", "Identity"), a2.set("Registry", "Adobe"), a2.set("Supplement", 0), i2.set("CIDSystemInfo", a2), i2;
}
class PostScriptParser {
  constructor(e2) {
    this.lexer = e2, this.operators = [], this.token = null, this.prev = null;
  }
  nextToken() {
    this.prev = this.token, this.token = this.lexer.getToken();
  }
  accept(e2) {
    return this.token.type === e2 && (this.nextToken(), true);
  }
  expect(e2) {
    if (this.accept(e2)) return true;
    throw new ti(`Unexpected symbol: found ${this.token.type} expected ${e2}.`);
  }
  parse() {
    return this.nextToken(), this.expect(as.LBRACE), this.parseBlock(), this.expect(as.RBRACE), this.operators;
  }
  parseBlock() {
    for (; ; ) if (this.accept(as.NUMBER)) this.operators.push(this.prev.value);
    else if (this.accept(as.OPERATOR)) this.operators.push(this.prev.value);
    else {
      if (!this.accept(as.LBRACE)) return;
      this.parseCondition();
    }
  }
  parseCondition() {
    const e2 = this.operators.length;
    if (this.operators.push(null, null), this.parseBlock(), this.expect(as.RBRACE), this.accept(as.IF)) this.operators[e2] = this.operators.length, this.operators[e2 + 1] = "jz";
    else {
      if (!this.accept(as.LBRACE)) throw new ti("PS Function: error parsing conditional.");
      {
        const t2 = this.operators.length;
        this.operators.push(null, null);
        const i2 = this.operators.length;
        this.parseBlock(), this.expect(as.RBRACE), this.expect(as.IFELSE), this.operators[t2] = this.operators.length, this.operators[t2 + 1] = "j", this.operators[e2] = i2, this.operators[e2 + 1] = "jz";
      }
    }
  }
}
const as = { LBRACE: 0, RBRACE: 1, NUMBER: 2, OPERATOR: 3, IF: 4, IFELSE: 5 };
class PostScriptToken {
  static get opCache() {
    return shadow$1(this, "opCache", /* @__PURE__ */ Object.create(null));
  }
  constructor(e2, t2) {
    this.type = e2, this.value = t2;
  }
  static getOperator(e2) {
    return PostScriptToken.opCache[e2] ||= new PostScriptToken(as.OPERATOR, e2);
  }
  static get LBRACE() {
    return shadow$1(this, "LBRACE", new PostScriptToken(as.LBRACE, "{"));
  }
  static get RBRACE() {
    return shadow$1(this, "RBRACE", new PostScriptToken(as.RBRACE, "}"));
  }
  static get IF() {
    return shadow$1(this, "IF", new PostScriptToken(as.IF, "IF"));
  }
  static get IFELSE() {
    return shadow$1(this, "IFELSE", new PostScriptToken(as.IFELSE, "IFELSE"));
  }
}
class PostScriptLexer {
  constructor(e2) {
    this.stream = e2, this.nextChar(), this.strBuf = [];
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  getToken() {
    let e2 = false, t2 = this.currentChar;
    for (; ; ) {
      if (t2 < 0) return ci;
      if (e2) 10 !== t2 && 13 !== t2 || (e2 = false);
      else if (37 === t2) e2 = true;
      else if (!isWhiteSpace(t2)) break;
      t2 = this.nextChar();
    }
    switch (0 | t2) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 43:
      case 45:
      case 46:
        return new PostScriptToken(as.NUMBER, this.getNumber());
      case 123:
        return this.nextChar(), PostScriptToken.LBRACE;
      case 125:
        return this.nextChar(), PostScriptToken.RBRACE;
    }
    const i2 = this.strBuf;
    for (i2.length = 0, i2[0] = String.fromCharCode(t2); (t2 = this.nextChar()) >= 0 && (t2 >= 65 && t2 <= 90 || t2 >= 97 && t2 <= 122); ) i2.push(String.fromCharCode(t2));
    const n2 = i2.join("");
    switch (n2.toLowerCase()) {
      case "if":
        return PostScriptToken.IF;
      case "ifelse":
        return PostScriptToken.IFELSE;
      default:
        return PostScriptToken.getOperator(n2);
    }
  }
  getNumber() {
    let e2 = this.currentChar;
    const t2 = this.strBuf;
    for (t2.length = 0, t2[0] = String.fromCharCode(e2); (e2 = this.nextChar()) >= 0 && (e2 >= 48 && e2 <= 57 || 45 === e2 || 46 === e2); ) t2.push(String.fromCharCode(e2));
    const i2 = parseFloat(t2.join(""));
    if (isNaN(i2)) throw new ti(`Invalid floating point number: ${i2}`);
    return i2;
  }
}
class BaseLocalCache {
  constructor(e2) {
    this._onlyRefs = true === e2?.onlyRefs, this._onlyRefs || (this._nameRefMap = /* @__PURE__ */ new Map(), this._imageMap = /* @__PURE__ */ new Map()), this._imageCache = new RefSetCache();
  }
  getByName(e2) {
    this._onlyRefs && unreachable$1("Should not call `getByName` method.");
    const t2 = this._nameRefMap.get(e2);
    return t2 ? this.getByRef(t2) : this._imageMap.get(e2) || null;
  }
  getByRef(e2) {
    return this._imageCache.get(e2) || null;
  }
  set(e2, t2, i2) {
    unreachable$1("Abstract method `set` called.");
  }
}
class LocalImageCache extends BaseLocalCache {
  set(e2, t2 = null, i2) {
    if ("string" != typeof e2) throw new Error('LocalImageCache.set - expected "name" argument.');
    if (t2) {
      if (this._imageCache.has(t2)) return;
      return this._nameRefMap.set(e2, t2), void this._imageCache.put(t2, i2);
    }
    this._imageMap.has(e2) || this._imageMap.set(e2, i2);
  }
}
class LocalColorSpaceCache extends BaseLocalCache {
  set(e2 = null, t2 = null, i2) {
    if ("string" != typeof e2 && !t2) throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
    if (t2) {
      if (this._imageCache.has(t2)) return;
      return null !== e2 && this._nameRefMap.set(e2, t2), void this._imageCache.put(t2, i2);
    }
    this._imageMap.has(e2) || this._imageMap.set(e2, i2);
  }
}
class LocalFunctionCache extends BaseLocalCache {
  constructor(e2) {
    super({ onlyRefs: true });
  }
  set(e2 = null, t2, i2) {
    if (!t2) throw new Error('LocalFunctionCache.set - expected "ref" argument.');
    this._imageCache.has(t2) || this._imageCache.put(t2, i2);
  }
}
class LocalGStateCache extends BaseLocalCache {
  set(e2, t2 = null, i2) {
    if ("string" != typeof e2) throw new Error('LocalGStateCache.set - expected "name" argument.');
    if (t2) {
      if (this._imageCache.has(t2)) return;
      return this._nameRefMap.set(e2, t2), void this._imageCache.put(t2, i2);
    }
    this._imageMap.has(e2) || this._imageMap.set(e2, i2);
  }
}
class LocalTilingPatternCache extends BaseLocalCache {
  constructor(e2) {
    super({ onlyRefs: true });
  }
  set(e2 = null, t2, i2) {
    if (!t2) throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
    this._imageCache.has(t2) || this._imageCache.put(t2, i2);
  }
}
class RegionalImageCache extends BaseLocalCache {
  constructor(e2) {
    super({ onlyRefs: true });
  }
  set(e2 = null, t2, i2) {
    if (!t2) throw new Error('RegionalImageCache.set - expected "ref" argument.');
    this._imageCache.has(t2) || this._imageCache.put(t2, i2);
  }
}
class GlobalColorSpaceCache extends BaseLocalCache {
  constructor(e2) {
    super({ onlyRefs: true });
  }
  set(e2 = null, t2, i2) {
    if (!t2) throw new Error('GlobalColorSpaceCache.set - expected "ref" argument.');
    this._imageCache.has(t2) || this._imageCache.put(t2, i2);
  }
  clear() {
    this._imageCache.clear();
  }
}
class GlobalImageCache {
  static NUM_PAGES_THRESHOLD = 2;
  static MIN_IMAGES_TO_CACHE = 10;
  static MAX_BYTE_SIZE = 5e7;
  #X = new RefSet();
  constructor() {
    this._refCache = new RefSetCache(), this._imageCache = new RefSetCache();
  }
  get #q() {
    let e2 = 0;
    for (const t2 of this._imageCache) e2 += t2.byteSize;
    return e2;
  }
  get #z() {
    return !(this._imageCache.size < GlobalImageCache.MIN_IMAGES_TO_CACHE) && !(this.#q < GlobalImageCache.MAX_BYTE_SIZE);
  }
  shouldCache(e2, t2) {
    let i2 = this._refCache.get(e2);
    return i2 || (i2 = /* @__PURE__ */ new Set(), this._refCache.put(e2, i2)), i2.add(t2), !(i2.size < GlobalImageCache.NUM_PAGES_THRESHOLD) && !(!this._imageCache.has(e2) && this.#z);
  }
  addDecodeFailed(e2) {
    this.#X.put(e2);
  }
  hasDecodeFailed(e2) {
    return this.#X.has(e2);
  }
  addByteSize(e2, t2) {
    const i2 = this._imageCache.get(e2);
    i2 && (i2.byteSize || (i2.byteSize = t2));
  }
  getData(e2, t2) {
    const i2 = this._refCache.get(e2);
    if (!i2) return null;
    if (i2.size < GlobalImageCache.NUM_PAGES_THRESHOLD) return null;
    const n2 = this._imageCache.get(e2);
    return n2 ? (i2.add(t2), n2) : null;
  }
  setData(e2, t2) {
    if (!this._refCache.has(e2)) throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
    this._imageCache.has(e2) || (this.#z ? warn$1("GlobalImageCache.setData - cache limit reached.") : this._imageCache.put(e2, t2));
  }
  clear(e2 = false) {
    e2 || (this.#X.clear(), this._refCache.clear()), this._imageCache.clear();
  }
}
class PDFFunctionFactory {
  constructor({ xref: e2, isEvalSupported: t2 = true }) {
    this.xref = e2, this.isEvalSupported = false !== t2;
  }
  create(e2, t2 = false) {
    let i2, n2;
    if (e2 instanceof Ref ? i2 = e2 : e2 instanceof Dict ? i2 = e2.objId : e2 instanceof BaseStream && (i2 = e2.dict?.objId), i2) {
      const e3 = this._localFunctionCache.getByRef(i2);
      if (e3) return e3;
    }
    const a2 = this.xref.fetchIfRef(e2);
    if (Array.isArray(a2)) {
      if (!t2) throw new Error('PDFFunctionFactory.create - expected "parseArray" argument.');
      n2 = PDFFunction.parseArray(this, a2);
    } else n2 = PDFFunction.parse(this, a2);
    return i2 && this._localFunctionCache.set(null, i2, n2), n2;
  }
  get _localFunctionCache() {
    return shadow$1(this, "_localFunctionCache", new LocalFunctionCache());
  }
}
function toNumberArray(e2) {
  return Array.isArray(e2) ? isNumberArray(e2, null) ? e2 : e2.map((e3) => +e3) : null;
}
class PDFFunction {
  static getSampleArray(e2, t2, i2, n2) {
    let a2, s2, r2 = 1;
    for (a2 = 0, s2 = e2.length; a2 < s2; a2++) r2 *= e2[a2];
    r2 *= t2;
    const o2 = new Array(r2);
    let l2 = 0, c2 = 0;
    const h2 = 1 / (2 ** i2 - 1), d2 = n2.getBytes((r2 * i2 + 7) / 8);
    let u2 = 0;
    for (a2 = 0; a2 < r2; a2++) {
      for (; l2 < i2; ) c2 <<= 8, c2 |= d2[u2++], l2 += 8;
      l2 -= i2, o2[a2] = (c2 >> l2) * h2, c2 &= (1 << l2) - 1;
    }
    return o2;
  }
  static parse(e2, t2) {
    const i2 = t2.dict || t2;
    switch (i2.get("FunctionType")) {
      case 0:
        return this.constructSampled(e2, t2, i2);
      case 1:
        break;
      case 2:
        return this.constructInterpolated(e2, i2);
      case 3:
        return this.constructStiched(e2, i2);
      case 4:
        return this.constructPostScript(e2, t2, i2);
    }
    throw new ti("Unknown type of function");
  }
  static parseArray(e2, t2) {
    const { xref: i2 } = e2, n2 = [];
    for (const a2 of t2) n2.push(this.parse(e2, i2.fetchIfRef(a2)));
    return function(e3, t3, i3, a2) {
      for (let s2 = 0, r2 = n2.length; s2 < r2; s2++) n2[s2](e3, t3, i3, a2 + s2);
    };
  }
  static constructSampled(e2, t2, i2) {
    function toMultiArray(e3) {
      const t3 = e3.length, i3 = [];
      let n3 = 0;
      for (let a3 = 0; a3 < t3; a3 += 2) i3[n3++] = [e3[a3], e3[a3 + 1]];
      return i3;
    }
    function interpolate(e3, t3, i3, n3, a3) {
      return n3 + (a3 - n3) / (i3 - t3) * (e3 - t3);
    }
    let n2 = toNumberArray(i2.getArray("Domain")), a2 = toNumberArray(i2.getArray("Range"));
    if (!n2 || !a2) throw new ti("No domain or range");
    const s2 = n2.length / 2, r2 = a2.length / 2;
    n2 = toMultiArray(n2), a2 = toMultiArray(a2);
    const o2 = toNumberArray(i2.getArray("Size")), l2 = i2.get("BitsPerSample"), c2 = i2.get("Order") || 1;
    1 !== c2 && info$1("No support for cubic spline interpolation: " + c2);
    let h2 = toNumberArray(i2.getArray("Encode"));
    if (h2) h2 = toMultiArray(h2);
    else {
      h2 = [];
      for (let e3 = 0; e3 < s2; ++e3) h2.push([0, o2[e3] - 1]);
    }
    let d2 = toNumberArray(i2.getArray("Decode"));
    d2 = d2 ? toMultiArray(d2) : a2;
    const u2 = this.getSampleArray(o2, r2, l2, t2);
    return function(e3, t3, i3, l3) {
      const c3 = 1 << s2, g2 = new Float64Array(c3).fill(1), f2 = new Uint32Array(c3);
      let p2, m2, b2 = r2, y2 = 1;
      for (p2 = 0; p2 < s2; ++p2) {
        const i4 = n2[p2][0], a3 = n2[p2][1];
        let s3 = interpolate(MathClamp$1(e3[t3 + p2], i4, a3), i4, a3, h2[p2][0], h2[p2][1]);
        const r3 = o2[p2];
        s3 = MathClamp$1(s3, 0, r3 - 1);
        const l4 = s3 < r3 - 1 ? Math.floor(s3) : s3 - 1, d3 = l4 + 1 - s3, u3 = s3 - l4, w2 = l4 * b2, x2 = w2 + b2;
        for (m2 = 0; m2 < c3; m2++) m2 & y2 ? (g2[m2] *= u3, f2[m2] += x2) : (g2[m2] *= d3, f2[m2] += w2);
        b2 *= r3, y2 <<= 1;
      }
      for (m2 = 0; m2 < r2; ++m2) {
        let e4 = 0;
        for (p2 = 0; p2 < c3; p2++) e4 += u2[f2[p2] + m2] * g2[p2];
        e4 = interpolate(e4, 0, 1, d2[m2][0], d2[m2][1]), i3[l3 + m2] = MathClamp$1(e4, a2[m2][0], a2[m2][1]);
      }
    };
  }
  static constructInterpolated(e2, t2) {
    const i2 = toNumberArray(t2.getArray("C0")) || [0], n2 = toNumberArray(t2.getArray("C1")) || [1], a2 = t2.get("N"), s2 = [];
    for (let e3 = 0, t3 = i2.length; e3 < t3; ++e3) s2.push(n2[e3] - i2[e3]);
    const r2 = s2.length;
    return function(e3, t3, n3, o2) {
      const l2 = 1 === a2 ? e3[t3] : e3[t3] ** a2;
      for (let e4 = 0; e4 < r2; ++e4) n3[o2 + e4] = i2[e4] + l2 * s2[e4];
    };
  }
  static constructStiched(e2, t2) {
    const i2 = toNumberArray(t2.getArray("Domain"));
    if (!i2) throw new ti("No domain");
    if (1 !== i2.length / 2) throw new ti("Bad domain for stiched function");
    const { xref: n2 } = e2, a2 = [];
    for (const i3 of t2.get("Functions")) a2.push(this.parse(e2, n2.fetchIfRef(i3)));
    const s2 = toNumberArray(t2.getArray("Bounds")), r2 = toNumberArray(t2.getArray("Encode")), o2 = new Float32Array(1);
    return function(e3, t3, n3, l2) {
      const c2 = MathClamp$1(e3[t3], i2[0], i2[1]), h2 = s2.length;
      let d2;
      for (d2 = 0; d2 < h2 && !(c2 < s2[d2]); ++d2) ;
      let u2 = i2[0];
      d2 > 0 && (u2 = s2[d2 - 1]);
      let g2 = i2[1];
      d2 < s2.length && (g2 = s2[d2]);
      const f2 = r2[2 * d2], p2 = r2[2 * d2 + 1];
      o2[0] = u2 === g2 ? f2 : f2 + (c2 - u2) * (p2 - f2) / (g2 - u2), a2[d2](o2, 0, n3, l2);
    };
  }
  static constructPostScript(e2, t2, i2) {
    const n2 = toNumberArray(i2.getArray("Domain")), a2 = toNumberArray(i2.getArray("Range"));
    if (!n2) throw new ti("No domain.");
    if (!a2) throw new ti("No range.");
    const s2 = new PostScriptLexer(t2), r2 = new PostScriptParser(s2).parse();
    if (e2.isEvalSupported && FeatureTest.isEvalSupported) {
      const e3 = new PostScriptCompiler().compile(r2, n2, a2);
      if (e3) return new Function("src", "srcOffset", "dest", "destOffset", e3);
    }
    info$1("Unable to compile PS function");
    const o2 = a2.length >> 1, l2 = n2.length >> 1, c2 = new PostScriptEvaluator(r2), h2 = /* @__PURE__ */ Object.create(null);
    let d2 = 8192;
    const u2 = new Float32Array(l2);
    return function(e3, t3, i3, n3) {
      let s3, r3, g2 = "";
      const f2 = u2;
      for (s3 = 0; s3 < l2; s3++) r3 = e3[t3 + s3], f2[s3] = r3, g2 += r3 + "_";
      const p2 = h2[g2];
      if (void 0 !== p2) return void i3.set(p2, n3);
      const m2 = new Float32Array(o2), b2 = c2.execute(f2), y2 = b2.length - o2;
      for (s3 = 0; s3 < o2; s3++) {
        r3 = b2[y2 + s3];
        let e4 = a2[2 * s3];
        r3 < e4 ? r3 = e4 : (e4 = a2[2 * s3 + 1], r3 > e4 && (r3 = e4)), m2[s3] = r3;
      }
      d2 > 0 && (d2--, h2[g2] = m2), i3.set(m2, n3);
    };
  }
}
function isPDFFunction(e2) {
  let t2;
  if (e2 instanceof Dict) t2 = e2;
  else {
    if (!(e2 instanceof BaseStream)) return false;
    t2 = e2.dict;
  }
  return t2.has("FunctionType");
}
class PostScriptStack {
  static MAX_STACK_SIZE = 100;
  constructor(e2) {
    this.stack = e2 ? Array.from(e2) : [];
  }
  push(e2) {
    if (this.stack.length >= PostScriptStack.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
    this.stack.push(e2);
  }
  pop() {
    if (this.stack.length <= 0) throw new Error("PostScript function stack underflow.");
    return this.stack.pop();
  }
  copy(e2) {
    if (this.stack.length + e2 >= PostScriptStack.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
    const t2 = this.stack;
    for (let i2 = t2.length - e2, n2 = e2 - 1; n2 >= 0; n2--, i2++) t2.push(t2[i2]);
  }
  index(e2) {
    this.push(this.stack[this.stack.length - e2 - 1]);
  }
  roll(e2, t2) {
    const i2 = this.stack, n2 = i2.length - e2, a2 = i2.length - 1, s2 = n2 + (t2 - Math.floor(t2 / e2) * e2);
    for (let e3 = n2, t3 = a2; e3 < t3; e3++, t3--) {
      const n3 = i2[e3];
      i2[e3] = i2[t3], i2[t3] = n3;
    }
    for (let e3 = n2, t3 = s2 - 1; e3 < t3; e3++, t3--) {
      const n3 = i2[e3];
      i2[e3] = i2[t3], i2[t3] = n3;
    }
    for (let e3 = s2, t3 = a2; e3 < t3; e3++, t3--) {
      const n3 = i2[e3];
      i2[e3] = i2[t3], i2[t3] = n3;
    }
  }
}
class PostScriptEvaluator {
  constructor(e2) {
    this.operators = e2;
  }
  execute(e2) {
    const t2 = new PostScriptStack(e2);
    let i2 = 0;
    const n2 = this.operators, a2 = n2.length;
    let s2, r2, o2;
    for (; i2 < a2; ) if (s2 = n2[i2++], "number" != typeof s2) switch (s2) {
      case "jz":
        o2 = t2.pop(), r2 = t2.pop(), r2 || (i2 = o2);
        break;
      case "j":
        r2 = t2.pop(), i2 = r2;
        break;
      case "abs":
        r2 = t2.pop(), t2.push(Math.abs(r2));
        break;
      case "add":
        o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 + o2);
        break;
      case "and":
        o2 = t2.pop(), r2 = t2.pop(), "boolean" == typeof r2 && "boolean" == typeof o2 ? t2.push(r2 && o2) : t2.push(r2 & o2);
        break;
      case "atan":
        o2 = t2.pop(), r2 = t2.pop(), r2 = Math.atan2(r2, o2) / Math.PI * 180, r2 < 0 && (r2 += 360), t2.push(r2);
        break;
      case "bitshift":
        o2 = t2.pop(), r2 = t2.pop(), r2 > 0 ? t2.push(r2 << o2) : t2.push(r2 >> o2);
        break;
      case "ceiling":
        r2 = t2.pop(), t2.push(Math.ceil(r2));
        break;
      case "copy":
        r2 = t2.pop(), t2.copy(r2);
        break;
      case "cos":
        r2 = t2.pop(), t2.push(Math.cos(r2 % 360 / 180 * Math.PI));
        break;
      case "cvi":
        r2 = 0 | t2.pop(), t2.push(r2);
        break;
      case "cvr":
        break;
      case "div":
        o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 / o2);
        break;
      case "dup":
        t2.copy(1);
        break;
      case "eq":
        o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 === o2);
        break;
      case "exch":
        t2.roll(2, 1);
        break;
      case "exp":
        o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 ** o2);
        break;
      case "false":
        t2.push(false);
        break;
      case "floor":
        r2 = t2.pop(), t2.push(Math.floor(r2));
        break;
      case "ge":
        o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 >= o2);
        break;
      case "gt":
        o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 > o2);
        break;
      case "idiv":
        o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 / o2 | 0);
        break;
      case "index":
        r2 = t2.pop(), t2.index(r2);
        break;
      case "le":
        o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 <= o2);
        break;
      case "ln":
        r2 = t2.pop(), t2.push(Math.log(r2));
        break;
      case "log":
        r2 = t2.pop(), t2.push(Math.log10(r2));
        break;
      case "lt":
        o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 < o2);
        break;
      case "mod":
        o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 % o2);
        break;
      case "mul":
        o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 * o2);
        break;
      case "ne":
        o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 !== o2);
        break;
      case "neg":
        r2 = t2.pop(), t2.push(-r2);
        break;
      case "not":
        r2 = t2.pop(), "boolean" == typeof r2 ? t2.push(!r2) : t2.push(~r2);
        break;
      case "or":
        o2 = t2.pop(), r2 = t2.pop(), "boolean" == typeof r2 && "boolean" == typeof o2 ? t2.push(r2 || o2) : t2.push(r2 | o2);
        break;
      case "pop":
        t2.pop();
        break;
      case "roll":
        o2 = t2.pop(), r2 = t2.pop(), t2.roll(r2, o2);
        break;
      case "round":
        r2 = t2.pop(), t2.push(Math.round(r2));
        break;
      case "sin":
        r2 = t2.pop(), t2.push(Math.sin(r2 % 360 / 180 * Math.PI));
        break;
      case "sqrt":
        r2 = t2.pop(), t2.push(Math.sqrt(r2));
        break;
      case "sub":
        o2 = t2.pop(), r2 = t2.pop(), t2.push(r2 - o2);
        break;
      case "true":
        t2.push(true);
        break;
      case "truncate":
        r2 = t2.pop(), r2 = r2 < 0 ? Math.ceil(r2) : Math.floor(r2), t2.push(r2);
        break;
      case "xor":
        o2 = t2.pop(), r2 = t2.pop(), "boolean" == typeof r2 && "boolean" == typeof o2 ? t2.push(r2 !== o2) : t2.push(r2 ^ o2);
        break;
      default:
        throw new ti(`Unknown operator ${s2}`);
    }
    else t2.push(s2);
    return t2.stack;
  }
}
class AstNode {
  constructor(e2) {
    this.type = e2;
  }
  visit(e2) {
    unreachable$1("abstract method");
  }
}
class AstArgument extends AstNode {
  constructor(e2, t2, i2) {
    super("args"), this.index = e2, this.min = t2, this.max = i2;
  }
  visit(e2) {
    e2.visitArgument(this);
  }
}
class AstLiteral extends AstNode {
  constructor(e2) {
    super("literal"), this.number = e2, this.min = e2, this.max = e2;
  }
  visit(e2) {
    e2.visitLiteral(this);
  }
}
class AstBinaryOperation extends AstNode {
  constructor(e2, t2, i2, n2, a2) {
    super("binary"), this.op = e2, this.arg1 = t2, this.arg2 = i2, this.min = n2, this.max = a2;
  }
  visit(e2) {
    e2.visitBinaryOperation(this);
  }
}
class AstMin extends AstNode {
  constructor(e2, t2) {
    super("max"), this.arg = e2, this.min = e2.min, this.max = t2;
  }
  visit(e2) {
    e2.visitMin(this);
  }
}
class AstVariable extends AstNode {
  constructor(e2, t2, i2) {
    super("var"), this.index = e2, this.min = t2, this.max = i2;
  }
  visit(e2) {
    e2.visitVariable(this);
  }
}
class AstVariableDefinition extends AstNode {
  constructor(e2, t2) {
    super("definition"), this.variable = e2, this.arg = t2;
  }
  visit(e2) {
    e2.visitVariableDefinition(this);
  }
}
class ExpressionBuilderVisitor {
  constructor() {
    this.parts = [];
  }
  visitArgument(e2) {
    this.parts.push("Math.max(", e2.min, ", Math.min(", e2.max, ", src[srcOffset + ", e2.index, "]))");
  }
  visitVariable(e2) {
    this.parts.push("v", e2.index);
  }
  visitLiteral(e2) {
    this.parts.push(e2.number);
  }
  visitBinaryOperation(e2) {
    this.parts.push("("), e2.arg1.visit(this), this.parts.push(" ", e2.op, " "), e2.arg2.visit(this), this.parts.push(")");
  }
  visitVariableDefinition(e2) {
    this.parts.push("var "), e2.variable.visit(this), this.parts.push(" = "), e2.arg.visit(this), this.parts.push(";");
  }
  visitMin(e2) {
    this.parts.push("Math.min("), e2.arg.visit(this), this.parts.push(", ", e2.max, ")");
  }
  toString() {
    return this.parts.join("");
  }
}
function buildAddOperation(e2, t2) {
  return "literal" === t2.type && 0 === t2.number ? e2 : "literal" === e2.type && 0 === e2.number ? t2 : "literal" === t2.type && "literal" === e2.type ? new AstLiteral(e2.number + t2.number) : new AstBinaryOperation("+", e2, t2, e2.min + t2.min, e2.max + t2.max);
}
function buildMulOperation(e2, t2) {
  if ("literal" === t2.type) {
    if (0 === t2.number) return new AstLiteral(0);
    if (1 === t2.number) return e2;
    if ("literal" === e2.type) return new AstLiteral(e2.number * t2.number);
  }
  if ("literal" === e2.type) {
    if (0 === e2.number) return new AstLiteral(0);
    if (1 === e2.number) return t2;
  }
  const i2 = Math.min(e2.min * t2.min, e2.min * t2.max, e2.max * t2.min, e2.max * t2.max), n2 = Math.max(e2.min * t2.min, e2.min * t2.max, e2.max * t2.min, e2.max * t2.max);
  return new AstBinaryOperation("*", e2, t2, i2, n2);
}
function buildSubOperation(e2, t2) {
  if ("literal" === t2.type) {
    if (0 === t2.number) return e2;
    if ("literal" === e2.type) return new AstLiteral(e2.number - t2.number);
  }
  return "binary" === t2.type && "-" === t2.op && "literal" === e2.type && 1 === e2.number && "literal" === t2.arg1.type && 1 === t2.arg1.number ? t2.arg2 : new AstBinaryOperation("-", e2, t2, e2.min - t2.max, e2.max - t2.min);
}
function buildMinOperation(e2, t2) {
  return e2.min >= t2 ? new AstLiteral(t2) : e2.max <= t2 ? e2 : new AstMin(e2, t2);
}
class PostScriptCompiler {
  compile(e2, t2, i2) {
    const n2 = [], a2 = [], s2 = t2.length >> 1, r2 = i2.length >> 1;
    let o2, l2, c2, h2, d2, u2, g2, f2, p2 = 0;
    for (let e3 = 0; e3 < s2; e3++) n2.push(new AstArgument(e3, t2[2 * e3], t2[2 * e3 + 1]));
    for (let t3 = 0, i3 = e2.length; t3 < i3; t3++) if (f2 = e2[t3], "number" != typeof f2) switch (f2) {
      case "add":
        if (n2.length < 2) return null;
        h2 = n2.pop(), c2 = n2.pop(), n2.push(buildAddOperation(c2, h2));
        break;
      case "cvr":
        if (n2.length < 1) return null;
        break;
      case "mul":
        if (n2.length < 2) return null;
        h2 = n2.pop(), c2 = n2.pop(), n2.push(buildMulOperation(c2, h2));
        break;
      case "sub":
        if (n2.length < 2) return null;
        h2 = n2.pop(), c2 = n2.pop(), n2.push(buildSubOperation(c2, h2));
        break;
      case "exch":
        if (n2.length < 2) return null;
        d2 = n2.pop(), u2 = n2.pop(), n2.push(d2, u2);
        break;
      case "pop":
        if (n2.length < 1) return null;
        n2.pop();
        break;
      case "index":
        if (n2.length < 1) return null;
        if (c2 = n2.pop(), "literal" !== c2.type) return null;
        if (o2 = c2.number, o2 < 0 || !Number.isInteger(o2) || n2.length < o2) return null;
        if (d2 = n2[n2.length - o2 - 1], "literal" === d2.type || "var" === d2.type) {
          n2.push(d2);
          break;
        }
        g2 = new AstVariable(p2++, d2.min, d2.max), n2[n2.length - o2 - 1] = g2, n2.push(g2), a2.push(new AstVariableDefinition(g2, d2));
        break;
      case "dup":
        if (n2.length < 1) return null;
        if ("number" == typeof e2[t3 + 1] && "gt" === e2[t3 + 2] && e2[t3 + 3] === t3 + 7 && "jz" === e2[t3 + 4] && "pop" === e2[t3 + 5] && e2[t3 + 6] === e2[t3 + 1]) {
          c2 = n2.pop(), n2.push(buildMinOperation(c2, e2[t3 + 1])), t3 += 6;
          break;
        }
        if (d2 = n2.at(-1), "literal" === d2.type || "var" === d2.type) {
          n2.push(d2);
          break;
        }
        g2 = new AstVariable(p2++, d2.min, d2.max), n2[n2.length - 1] = g2, n2.push(g2), a2.push(new AstVariableDefinition(g2, d2));
        break;
      case "roll":
        if (n2.length < 2) return null;
        if (h2 = n2.pop(), c2 = n2.pop(), "literal" !== h2.type || "literal" !== c2.type) return null;
        if (l2 = h2.number, o2 = c2.number, o2 <= 0 || !Number.isInteger(o2) || !Number.isInteger(l2) || n2.length < o2) return null;
        if (l2 = (l2 % o2 + o2) % o2, 0 === l2) break;
        n2.push(...n2.splice(n2.length - o2, o2 - l2));
        break;
      default:
        return null;
    }
    else n2.push(new AstLiteral(f2));
    if (n2.length !== r2) return null;
    const m2 = [];
    for (const e3 of a2) {
      const t3 = new ExpressionBuilderVisitor();
      e3.visit(t3), m2.push(t3.toString());
    }
    for (let e3 = 0, t3 = n2.length; e3 < t3; e3++) {
      const t4 = n2[e3], a3 = new ExpressionBuilderVisitor();
      t4.visit(a3);
      const s3 = i2[2 * e3], r3 = i2[2 * e3 + 1], o3 = [a3.toString()];
      s3 > t4.min && (o3.unshift("Math.max(", s3, ", "), o3.push(")")), r3 < t4.max && (o3.unshift("Math.min(", r3, ", "), o3.push(")")), o3.unshift("dest[destOffset + ", e3, "] = "), o3.push(";"), m2.push(o3.join(""));
    }
    return m2.join("\n");
  }
}
const ss = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"], rs = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
function isOdd(e2) {
  return !!(1 & e2);
}
function isEven(e2) {
  return !(1 & e2);
}
function findUnequal(e2, t2, i2) {
  let n2, a2;
  for (n2 = t2, a2 = e2.length; n2 < a2; ++n2) if (e2[n2] !== i2) return n2;
  return n2;
}
function reverseValues(e2, t2, i2) {
  for (let n2 = t2, a2 = i2 - 1; n2 < a2; ++n2, --a2) {
    const t3 = e2[n2];
    e2[n2] = e2[a2], e2[a2] = t3;
  }
}
function createBidiText(e2, t2, i2 = false) {
  let n2 = "ltr";
  return i2 ? n2 = "ttb" : t2 || (n2 = "rtl"), { str: e2, dir: n2 };
}
const os = [], ls = [];
function bidi(e2, t2 = -1, i2 = false) {
  let n2 = true;
  const a2 = e2.length;
  if (0 === a2 || i2) return createBidiText(e2, n2, i2);
  os.length = a2, ls.length = a2;
  let s2, r2, o2 = 0;
  for (s2 = 0; s2 < a2; ++s2) {
    os[s2] = e2.charAt(s2);
    const t3 = e2.charCodeAt(s2);
    let i3 = "L";
    t3 <= 255 ? i3 = ss[t3] : 1424 <= t3 && t3 <= 1524 ? i3 = "R" : 1536 <= t3 && t3 <= 1791 ? (i3 = rs[255 & t3], i3 || warn$1("Bidi: invalid Unicode character " + t3.toString(16))) : (1792 <= t3 && t3 <= 2220 || 64336 <= t3 && t3 <= 65023 || 65136 <= t3 && t3 <= 65279) && (i3 = "AL"), "R" !== i3 && "AL" !== i3 && "AN" !== i3 || o2++, ls[s2] = i3;
  }
  if (0 === o2) return n2 = true, createBidiText(e2, n2);
  -1 === t2 && (o2 / a2 < 0.3 && a2 > 4 ? (n2 = true, t2 = 0) : (n2 = false, t2 = 1));
  const l2 = [];
  for (s2 = 0; s2 < a2; ++s2) l2[s2] = t2;
  const c2 = isOdd(t2) ? "R" : "L", h2 = c2, d2 = h2;
  let u2, g2 = h2;
  for (s2 = 0; s2 < a2; ++s2) "NSM" === ls[s2] ? ls[s2] = g2 : g2 = ls[s2];
  for (g2 = h2, s2 = 0; s2 < a2; ++s2) u2 = ls[s2], "EN" === u2 ? ls[s2] = "AL" === g2 ? "AN" : "EN" : "R" !== u2 && "L" !== u2 && "AL" !== u2 || (g2 = u2);
  for (s2 = 0; s2 < a2; ++s2) u2 = ls[s2], "AL" === u2 && (ls[s2] = "R");
  for (s2 = 1; s2 < a2 - 1; ++s2) "ES" === ls[s2] && "EN" === ls[s2 - 1] && "EN" === ls[s2 + 1] && (ls[s2] = "EN"), "CS" !== ls[s2] || "EN" !== ls[s2 - 1] && "AN" !== ls[s2 - 1] || ls[s2 + 1] !== ls[s2 - 1] || (ls[s2] = ls[s2 - 1]);
  for (s2 = 0; s2 < a2; ++s2) if ("EN" === ls[s2]) {
    for (let e3 = s2 - 1; e3 >= 0 && "ET" === ls[e3]; --e3) ls[e3] = "EN";
    for (let e3 = s2 + 1; e3 < a2 && "ET" === ls[e3]; ++e3) ls[e3] = "EN";
  }
  for (s2 = 0; s2 < a2; ++s2) u2 = ls[s2], "WS" !== u2 && "ES" !== u2 && "ET" !== u2 && "CS" !== u2 || (ls[s2] = "ON");
  for (g2 = h2, s2 = 0; s2 < a2; ++s2) u2 = ls[s2], "EN" === u2 ? ls[s2] = "L" === g2 ? "L" : "EN" : "R" !== u2 && "L" !== u2 || (g2 = u2);
  for (s2 = 0; s2 < a2; ++s2) if ("ON" === ls[s2]) {
    const e3 = findUnequal(ls, s2 + 1, "ON");
    let t3 = h2;
    s2 > 0 && (t3 = ls[s2 - 1]);
    let i3 = d2;
    e3 + 1 < a2 && (i3 = ls[e3 + 1]), "L" !== t3 && (t3 = "R"), "L" !== i3 && (i3 = "R"), t3 === i3 && ls.fill(t3, s2, e3), s2 = e3 - 1;
  }
  for (s2 = 0; s2 < a2; ++s2) "ON" === ls[s2] && (ls[s2] = c2);
  for (s2 = 0; s2 < a2; ++s2) u2 = ls[s2], isEven(l2[s2]) ? "R" === u2 ? l2[s2] += 1 : "AN" !== u2 && "EN" !== u2 || (l2[s2] += 2) : "L" !== u2 && "AN" !== u2 && "EN" !== u2 || (l2[s2] += 1);
  let f2, p2 = -1, m2 = 99;
  for (s2 = 0, r2 = l2.length; s2 < r2; ++s2) f2 = l2[s2], p2 < f2 && (p2 = f2), m2 > f2 && isOdd(f2) && (m2 = f2);
  for (f2 = p2; f2 >= m2; --f2) {
    let e3 = -1;
    for (s2 = 0, r2 = l2.length; s2 < r2; ++s2) l2[s2] < f2 ? e3 >= 0 && (reverseValues(os, e3, s2), e3 = -1) : e3 < 0 && (e3 = s2);
    e3 >= 0 && reverseValues(os, e3, l2.length);
  }
  for (s2 = 0, r2 = os.length; s2 < r2; ++s2) {
    const e3 = os[s2];
    "<" !== e3 && ">" !== e3 || (os[s2] = "");
  }
  return createBidiText(os.join(""), n2);
}
let cs = class CssFontInfo {
  #R;
  #W;
  #G;
  static strings = ["fontFamily", "fontWeight", "italicAngle"];
  static write(e2) {
    const t2 = new TextEncoder(), i2 = {};
    let n2 = 0;
    for (const a3 of CssFontInfo.strings) {
      const s3 = t2.encode(e2[a3]);
      i2[a3] = s3, n2 += 4 + s3.length;
    }
    const a2 = new ArrayBuffer(n2), s2 = new Uint8Array(a2), r2 = new DataView(a2);
    let o2 = 0;
    for (const e3 of CssFontInfo.strings) {
      const t3 = i2[e3], n3 = t3.length;
      r2.setUint32(o2, n3), s2.set(t3, o2 + 4), o2 += 4 + n3;
    }
    return assert$1(o2 === a2.byteLength, "CssFontInfo.write: Buffer overflow"), a2;
  }
  constructor(e2) {
    this.#R = e2, this.#W = new DataView(this.#R), this.#G = new TextDecoder();
  }
  #V(e2) {
    assert$1(e2 < CssFontInfo.strings.length, "Invalid string index");
    let t2 = 0;
    for (let i3 = 0; i3 < e2; i3++) t2 += this.#W.getUint32(t2) + 4;
    const i2 = this.#W.getUint32(t2);
    return this.#G.decode(new Uint8Array(this.#R, t2 + 4, i2));
  }
  get fontFamily() {
    return this.#V(0);
  }
  get fontWeight() {
    return this.#V(1);
  }
  get italicAngle() {
    return this.#V(2);
  }
}, hs = class SystemFontInfo {
  #R;
  #W;
  #G;
  static strings = ["css", "loadedName", "baseFontName", "src"];
  static write(e2) {
    const t2 = new TextEncoder(), i2 = {};
    let n2 = 0;
    for (const a3 of SystemFontInfo.strings) {
      const s3 = t2.encode(e2[a3]);
      i2[a3] = s3, n2 += 4 + s3.length;
    }
    n2 += 4;
    let a2, s2, r2 = 1 + n2;
    e2.style && (a2 = t2.encode(e2.style.style), s2 = t2.encode(e2.style.weight), r2 += 4 + a2.length + 4 + s2.length);
    const o2 = new ArrayBuffer(r2), l2 = new Uint8Array(o2), c2 = new DataView(o2);
    let h2 = 0;
    c2.setUint8(h2++, e2.guessFallback ? 1 : 0), c2.setUint32(h2, 0), h2 += 4, n2 = 0;
    for (const e3 of SystemFontInfo.strings) {
      const t3 = i2[e3], a3 = t3.length;
      n2 += 4 + a3, c2.setUint32(h2, a3), l2.set(t3, h2 + 4), h2 += 4 + a3;
    }
    return c2.setUint32(h2 - n2 - 4, n2), e2.style && (c2.setUint32(h2, a2.length), l2.set(a2, h2 + 4), h2 += 4 + a2.length, c2.setUint32(h2, s2.length), l2.set(s2, h2 + 4), h2 += 4 + s2.length), assert$1(h2 <= o2.byteLength, "SubstitionInfo.write: Buffer overflow"), o2.transferToFixedLength(h2);
  }
  constructor(e2) {
    this.#R = e2, this.#W = new DataView(this.#R), this.#G = new TextDecoder();
  }
  get guessFallback() {
    return 0 !== this.#W.getUint8(0);
  }
  #V(e2) {
    assert$1(e2 < SystemFontInfo.strings.length, "Invalid string index");
    let t2 = 5;
    for (let i3 = 0; i3 < e2; i3++) t2 += this.#W.getUint32(t2) + 4;
    const i2 = this.#W.getUint32(t2);
    return this.#G.decode(new Uint8Array(this.#R, t2 + 4, i2));
  }
  get css() {
    return this.#V(0);
  }
  get loadedName() {
    return this.#V(1);
  }
  get baseFontName() {
    return this.#V(2);
  }
  get src() {
    return this.#V(3);
  }
  get style() {
    let e2 = 1;
    e2 += 4 + this.#W.getUint32(e2);
    const t2 = this.#W.getUint32(e2), i2 = this.#G.decode(new Uint8Array(this.#R, e2 + 4, t2));
    e2 += 4 + t2;
    const n2 = this.#W.getUint32(e2);
    return { style: i2, weight: this.#G.decode(new Uint8Array(this.#R, e2 + 4, n2)) };
  }
}, ds = class FontInfo {
  static bools = ["black", "bold", "disableFontFace", "fontExtraProperties", "isInvalidPDFjsFont", "isType3Font", "italic", "missingFile", "remeasure", "vertical"];
  static numbers = ["ascent", "defaultWidth", "descent"];
  static strings = ["fallbackName", "loadedName", "mimetype", "name"];
  static #K = Math.ceil(2 * this.bools.length / 8);
  static #Y = this.#K + 8 * this.numbers.length;
  static #J = this.#Y + 1 + 8;
  static #Z = this.#J + 1 + 48;
  static #Q = this.#Z + 1 + 6;
  #R;
  #G;
  #W;
  constructor({ data: e2, extra: t2 }) {
    this.#R = e2, this.#G = new TextDecoder(), this.#W = new DataView(this.#R), t2 && Object.assign(this, t2);
  }
  #ee(e2) {
    assert$1(e2 < FontInfo.bools.length, "Invalid boolean index");
    const t2 = Math.floor(e2 / 4), i2 = 2 * e2 % 8, n2 = this.#W.getUint8(t2) >> i2 & 3;
    return 0 === n2 ? void 0 : 2 === n2;
  }
  get black() {
    return this.#ee(0);
  }
  get bold() {
    return this.#ee(1);
  }
  get disableFontFace() {
    return this.#ee(2);
  }
  get fontExtraProperties() {
    return this.#ee(3);
  }
  get isInvalidPDFjsFont() {
    return this.#ee(4);
  }
  get isType3Font() {
    return this.#ee(5);
  }
  get italic() {
    return this.#ee(6);
  }
  get missingFile() {
    return this.#ee(7);
  }
  get remeasure() {
    return this.#ee(8);
  }
  get vertical() {
    return this.#ee(9);
  }
  #te(e2) {
    return assert$1(e2 < FontInfo.numbers.length, "Invalid number index"), this.#W.getFloat64(FontInfo.#K + 8 * e2);
  }
  get ascent() {
    return this.#te(0);
  }
  get defaultWidth() {
    return this.#te(1);
  }
  get descent() {
    return this.#te(2);
  }
  get bbox() {
    let e2 = FontInfo.#Y;
    if (0 === this.#W.getUint8(e2)) return;
    e2 += 1;
    const t2 = [];
    for (let i2 = 0; i2 < 4; i2++) t2.push(this.#W.getInt16(e2, true)), e2 += 2;
    return t2;
  }
  get fontMatrix() {
    let e2 = FontInfo.#J;
    if (0 === this.#W.getUint8(e2)) return;
    e2 += 1;
    const t2 = [];
    for (let i2 = 0; i2 < 6; i2++) t2.push(this.#W.getFloat64(e2, true)), e2 += 8;
    return t2;
  }
  get defaultVMetrics() {
    let e2 = FontInfo.#Z;
    if (0 === this.#W.getUint8(e2)) return;
    e2 += 1;
    const t2 = [];
    for (let i2 = 0; i2 < 3; i2++) t2.push(this.#W.getInt16(e2, true)), e2 += 2;
    return t2;
  }
  #V(e2) {
    assert$1(e2 < FontInfo.strings.length, "Invalid string index");
    let t2 = FontInfo.#Q + 4;
    for (let i3 = 0; i3 < e2; i3++) t2 += this.#W.getUint32(t2) + 4;
    const i2 = this.#W.getUint32(t2), n2 = new Uint8Array(i2);
    return n2.set(new Uint8Array(this.#R, t2 + 4, i2)), this.#G.decode(n2);
  }
  get fallbackName() {
    return this.#V(0);
  }
  get loadedName() {
    return this.#V(1);
  }
  get mimetype() {
    return this.#V(2);
  }
  get name() {
    return this.#V(3);
  }
  get data() {
    let e2 = FontInfo.#Q;
    e2 += 4 + this.#W.getUint32(e2);
    e2 += 4 + this.#W.getUint32(e2);
    e2 += 4 + this.#W.getUint32(e2);
    const t2 = this.#W.getUint32(e2);
    if (0 !== t2) return new Uint8Array(this.#R, e2 + 4, t2);
  }
  clearData() {
    let e2 = FontInfo.#Q;
    e2 += 4 + this.#W.getUint32(e2);
    e2 += 4 + this.#W.getUint32(e2);
    e2 += 4 + this.#W.getUint32(e2);
    const t2 = this.#W.getUint32(e2);
    new Uint8Array(this.#R, e2 + 4, t2).fill(0), this.#W.setUint32(e2, 0);
  }
  get cssFontInfo() {
    let e2 = FontInfo.#Q;
    e2 += 4 + this.#W.getUint32(e2);
    e2 += 4 + this.#W.getUint32(e2);
    const t2 = this.#W.getUint32(e2);
    if (0 === t2) return null;
    const i2 = new Uint8Array(t2);
    return i2.set(new Uint8Array(this.#R, e2 + 4, t2)), new cs(i2.buffer);
  }
  get systemFontInfo() {
    let e2 = FontInfo.#Q;
    e2 += 4 + this.#W.getUint32(e2);
    const t2 = this.#W.getUint32(e2);
    if (0 === t2) return null;
    const i2 = new Uint8Array(t2);
    return i2.set(new Uint8Array(this.#R, e2 + 4, t2)), new hs(i2.buffer);
  }
  static write(e2) {
    const t2 = e2.systemFontInfo ? hs.write(e2.systemFontInfo) : null, i2 = e2.cssFontInfo ? cs.write(e2.cssFontInfo) : null, n2 = new TextEncoder(), a2 = {};
    let s2 = 0;
    for (const t3 of FontInfo.strings) a2[t3] = n2.encode(e2[t3]), s2 += 4 + a2[t3].length;
    const r2 = FontInfo.#Q + 4 + s2 + 4 + (t2 ? t2.byteLength : 0) + 4 + (i2 ? i2.byteLength : 0) + 4 + (e2.data ? e2.data.length : 0), o2 = new ArrayBuffer(r2), l2 = new Uint8Array(o2), c2 = new DataView(o2);
    let h2 = 0;
    const d2 = FontInfo.bools.length;
    let u2 = 0, g2 = 0;
    for (let t3 = 0; t3 < d2; t3++) {
      const i3 = e2[FontInfo.bools[t3]];
      u2 |= (void 0 === i3 ? 0 : i3 ? 2 : 1) << g2, g2 += 2, 8 !== g2 && t3 !== d2 - 1 || (c2.setUint8(h2++, u2), u2 = 0, g2 = 0);
    }
    assert$1(h2 === FontInfo.#K, "FontInfo.write: Boolean properties offset mismatch");
    for (const t3 of FontInfo.numbers) c2.setFloat64(h2, e2[t3]), h2 += 8;
    if (assert$1(h2 === FontInfo.#Y, "FontInfo.write: Number properties offset mismatch"), e2.bbox) {
      c2.setUint8(h2++, 4);
      for (const t3 of e2.bbox) c2.setInt16(h2, t3, true), h2 += 2;
    } else c2.setUint8(h2++, 0), h2 += 8;
    if (assert$1(h2 === FontInfo.#J, "FontInfo.write: BBox properties offset mismatch"), e2.fontMatrix) {
      c2.setUint8(h2++, 6);
      for (const t3 of e2.fontMatrix) c2.setFloat64(h2, t3, true), h2 += 8;
    } else c2.setUint8(h2++, 0), h2 += 48;
    if (assert$1(h2 === FontInfo.#Z, "FontInfo.write: FontMatrix properties offset mismatch"), e2.defaultVMetrics) {
      c2.setUint8(h2++, 1);
      for (const t3 of e2.defaultVMetrics) c2.setInt16(h2, t3, true), h2 += 2;
    } else c2.setUint8(h2++, 0), h2 += 6;
    assert$1(h2 === FontInfo.#Q, "FontInfo.write: DefaultVMetrics properties offset mismatch"), c2.setUint32(FontInfo.#Q, 0), h2 += 4;
    for (const e3 of FontInfo.strings) {
      const t3 = a2[e3], i3 = t3.length;
      c2.setUint32(h2, i3), l2.set(t3, h2 + 4), h2 += 4 + i3;
    }
    if (c2.setUint32(FontInfo.#Q, h2 - FontInfo.#Q - 4), t2) {
      const e3 = t2.byteLength;
      c2.setUint32(h2, e3), assert$1(h2 + 4 + e3 <= o2.byteLength, "FontInfo.write: Buffer overflow at systemFontInfo"), l2.set(new Uint8Array(t2), h2 + 4), h2 += 4 + e3;
    } else c2.setUint32(h2, 0), h2 += 4;
    if (i2) {
      const e3 = i2.byteLength;
      c2.setUint32(h2, e3), assert$1(h2 + 4 + e3 <= o2.byteLength, "FontInfo.write: Buffer overflow at cssFontInfo"), l2.set(new Uint8Array(i2), h2 + 4), h2 += 4 + e3;
    } else c2.setUint32(h2, 0), h2 += 4;
    return void 0 === e2.data ? (c2.setUint32(h2, 0), h2 += 4) : (c2.setUint32(h2, e2.data.length), l2.set(e2.data, h2 + 4), h2 += 4 + e2.data.length), assert$1(h2 <= o2.byteLength, "FontInfo.write: Buffer overflow"), o2.transferToFixedLength(h2);
  }
};
const us = { style: "normal", weight: "normal" }, gs = { style: "normal", weight: "bold" }, fs = { style: "italic", weight: "normal" }, ps = { style: "italic", weight: "bold" }, ms = /* @__PURE__ */ new Map([["Times-Roman", { local: ["Times New Roman", "Times-Roman", "Times", "Liberation Serif", "Nimbus Roman", "Nimbus Roman L", "Tinos", "Thorndale", "TeX Gyre Termes", "FreeSerif", "Linux Libertine O", "Libertinus Serif", "DejaVu Serif", "Bitstream Vera Serif", "Ubuntu"], style: us, ultimate: "serif" }], ["Times-Bold", { alias: "Times-Roman", style: gs, ultimate: "serif" }], ["Times-Italic", { alias: "Times-Roman", style: fs, ultimate: "serif" }], ["Times-BoldItalic", { alias: "Times-Roman", style: ps, ultimate: "serif" }], ["Helvetica", { local: ["Helvetica", "Helvetica Neue", "Arial", "Arial Nova", "Liberation Sans", "Arimo", "Nimbus Sans", "Nimbus Sans L", "A030", "TeX Gyre Heros", "FreeSans", "DejaVu Sans", "Albany", "Bitstream Vera Sans", "Arial Unicode MS", "Microsoft Sans Serif", "Apple Symbols", "Cantarell"], path: "LiberationSans-Regular.ttf", style: us, ultimate: "sans-serif" }], ["Helvetica-Bold", { alias: "Helvetica", path: "LiberationSans-Bold.ttf", style: gs, ultimate: "sans-serif" }], ["Helvetica-Oblique", { alias: "Helvetica", path: "LiberationSans-Italic.ttf", style: fs, ultimate: "sans-serif" }], ["Helvetica-BoldOblique", { alias: "Helvetica", path: "LiberationSans-BoldItalic.ttf", style: ps, ultimate: "sans-serif" }], ["Courier", { local: ["Courier", "Courier New", "Liberation Mono", "Nimbus Mono", "Nimbus Mono L", "Cousine", "Cumberland", "TeX Gyre Cursor", "FreeMono", "Linux Libertine Mono O", "Libertinus Mono"], style: us, ultimate: "monospace" }], ["Courier-Bold", { alias: "Courier", style: gs, ultimate: "monospace" }], ["Courier-Oblique", { alias: "Courier", style: fs, ultimate: "monospace" }], ["Courier-BoldOblique", { alias: "Courier", style: ps, ultimate: "monospace" }], ["ArialBlack", { local: ["Arial Black"], style: { style: "normal", weight: "900" }, fallback: "Helvetica-Bold" }], ["ArialBlack-Bold", { alias: "ArialBlack" }], ["ArialBlack-Italic", { alias: "ArialBlack", style: { style: "italic", weight: "900" }, fallback: "Helvetica-BoldOblique" }], ["ArialBlack-BoldItalic", { alias: "ArialBlack-Italic" }], ["ArialNarrow", { local: ["Arial Narrow", "Liberation Sans Narrow", "Helvetica Condensed", "Nimbus Sans Narrow", "TeX Gyre Heros Cn"], style: us, fallback: "Helvetica" }], ["ArialNarrow-Bold", { alias: "ArialNarrow", style: gs, fallback: "Helvetica-Bold" }], ["ArialNarrow-Italic", { alias: "ArialNarrow", style: fs, fallback: "Helvetica-Oblique" }], ["ArialNarrow-BoldItalic", { alias: "ArialNarrow", style: ps, fallback: "Helvetica-BoldOblique" }], ["Calibri", { local: ["Calibri", "Carlito"], style: us, fallback: "Helvetica" }], ["Calibri-Bold", { alias: "Calibri", style: gs, fallback: "Helvetica-Bold" }], ["Calibri-Italic", { alias: "Calibri", style: fs, fallback: "Helvetica-Oblique" }], ["Calibri-BoldItalic", { alias: "Calibri", style: ps, fallback: "Helvetica-BoldOblique" }], ["Wingdings", { local: ["Wingdings", "URW Dingbats"], style: us }], ["Wingdings-Regular", { alias: "Wingdings" }], ["Wingdings-Bold", { alias: "Wingdings" }]]), bs = /* @__PURE__ */ new Map([["Arial-Black", "ArialBlack"]]);
function getFamilyName(e2) {
  const t2 = /* @__PURE__ */ new Set(["thin", "extralight", "ultralight", "demilight", "semilight", "light", "book", "regular", "normal", "medium", "demibold", "semibold", "bold", "extrabold", "ultrabold", "black", "heavy", "extrablack", "ultrablack", "roman", "italic", "oblique", "ultracondensed", "extracondensed", "condensed", "semicondensed", "normal", "semiexpanded", "expanded", "extraexpanded", "ultraexpanded", "bolditalic"]);
  return e2.split(/[- ,+]+/g).filter((e3) => !t2.has(e3.toLowerCase())).join(" ");
}
function generateFont({ alias: e2, local: t2, path: i2, fallback: n2, style: a2, ultimate: s2 }, r2, o2, l2 = true, c2 = true, h2 = "") {
  const d2 = { style: null, ultimate: null };
  if (t2) {
    const e3 = h2 ? ` ${h2}` : "";
    for (const i3 of t2) r2.push(`local(${i3}${e3})`);
  }
  if (e2) {
    const t3 = ms.get(e2), s3 = h2 || (function(e3) {
      switch (e3) {
        case gs:
          return "Bold";
        case fs:
          return "Italic";
        case ps:
          return "Bold Italic";
        default:
          if ("bold" === e3?.weight) return "Bold";
          if ("italic" === e3?.style) return "Italic";
      }
      return "";
    })(a2);
    Object.assign(d2, generateFont(t3, r2, o2, l2 && !n2, c2 && !i2, s3));
  }
  if (a2 && (d2.style = a2), s2 && (d2.ultimate = s2), l2 && n2) {
    const e3 = ms.get(n2), { ultimate: t3 } = generateFont(e3, r2, o2, l2, c2 && !i2, h2);
    d2.ultimate ||= t3;
  }
  return c2 && i2 && o2 && r2.push(`url(${o2}${i2})`), d2;
}
function getFontSubstitution(e2, t2, i2, n2, a2, s2) {
  if (n2.startsWith("InvalidPDFjsFont_")) return null;
  "TrueType" !== s2 && "Type1" !== s2 || !/^[A-Z]{6}\+/.test(n2) || (n2 = n2.slice(7));
  const r2 = n2 = normalizeFontName(n2);
  let o2 = e2.get(r2);
  if (o2) return o2;
  let l2 = ms.get(n2);
  if (!l2) {
    for (const [e3, t3] of bs) if (n2.startsWith(e3)) {
      n2 = `${t3}${n2.substring(e3.length)}`, l2 = ms.get(n2);
      break;
    }
  }
  let c2 = false;
  l2 || (l2 = ms.get(a2), c2 = true);
  const h2 = `${t2.getDocId()}_s${t2.createFontId()}`;
  if (!l2) {
    if (!validateFontName(n2)) return warn$1(`Cannot substitute the font because of its name: ${n2}`), e2.set(r2, null), null;
    const t3 = /bold/gi.test(n2), i3 = /oblique|italic/gi.test(n2), a3 = t3 && i3 && ps || t3 && gs || i3 && fs || us;
    return o2 = { css: `"${getFamilyName(n2)}",${h2}`, guessFallback: true, loadedName: h2, baseFontName: n2, src: `local(${n2})`, style: a3 }, e2.set(r2, o2), o2;
  }
  const d2 = [];
  c2 && validateFontName(n2) && d2.push(`local(${n2})`);
  const { style: u2, ultimate: g2 } = generateFont(l2, d2, i2), f2 = null === g2, p2 = f2 ? "" : `,${g2}`;
  return o2 = { css: `"${getFamilyName(n2)}",${h2}${p2}`, guessFallback: f2, loadedName: h2, baseFontName: n2, src: d2.join(","), style: u2 }, e2.set(r2, o2), o2;
}
const ys = 3285377520, ws = 4294901760, As = 65535;
let xs = class {
  constructor(e2) {
    this.h1 = e2 ? 4294967295 & e2 : ys, this.h2 = e2 ? 4294967295 & e2 : ys;
  }
  update(e2) {
    let t2, i2;
    if ("string" == typeof e2) {
      t2 = new Uint8Array(2 * e2.length), i2 = 0;
      for (let n3 = 0, a3 = e2.length; n3 < a3; n3++) {
        const a4 = e2.charCodeAt(n3);
        a4 <= 255 ? t2[i2++] = a4 : (t2[i2++] = a4 >>> 8, t2[i2++] = 255 & a4);
      }
    } else {
      if (!ArrayBuffer.isView(e2)) throw new Error("Invalid data format, must be a string or TypedArray.");
      t2 = e2.slice(), i2 = t2.byteLength;
    }
    const n2 = i2 >> 2, a2 = i2 - 4 * n2, s2 = new Uint32Array(t2.buffer, 0, n2);
    let r2 = 0, o2 = 0, l2 = this.h1, c2 = this.h2;
    const h2 = 3432918353, d2 = 461845907, u2 = 11601, g2 = 13715;
    for (let e3 = 0; e3 < n2; e3++) 1 & e3 ? (r2 = s2[e3], r2 = r2 * h2 & ws | r2 * u2 & As, r2 = r2 << 15 | r2 >>> 17, r2 = r2 * d2 & ws | r2 * g2 & As, l2 ^= r2, l2 = l2 << 13 | l2 >>> 19, l2 = 5 * l2 + 3864292196) : (o2 = s2[e3], o2 = o2 * h2 & ws | o2 * u2 & As, o2 = o2 << 15 | o2 >>> 17, o2 = o2 * d2 & ws | o2 * g2 & As, c2 ^= o2, c2 = c2 << 13 | c2 >>> 19, c2 = 5 * c2 + 3864292196);
    switch (r2 = 0, a2) {
      case 3:
        r2 ^= t2[4 * n2 + 2] << 16;
      case 2:
        r2 ^= t2[4 * n2 + 1] << 8;
      case 1:
        r2 ^= t2[4 * n2], r2 = r2 * h2 & ws | r2 * u2 & As, r2 = r2 << 15 | r2 >>> 17, r2 = r2 * d2 & ws | r2 * g2 & As, 1 & n2 ? l2 ^= r2 : c2 ^= r2;
    }
    this.h1 = l2, this.h2 = c2;
  }
  hexdigest() {
    let e2 = this.h1, t2 = this.h2;
    return e2 ^= t2 >>> 1, e2 = 3981806797 * e2 & ws | 36045 * e2 & As, t2 = 4283543511 * t2 & ws | (2950163797 * (t2 << 16 | e2 >>> 16) & ws) >>> 16, e2 ^= t2 >>> 1, e2 = 444984403 * e2 & ws | 60499 * e2 & As, t2 = 3301882366 * t2 & ws | (3120437893 * (t2 << 16 | e2 >>> 16) & ws) >>> 16, e2 ^= t2 >>> 1, (e2 >>> 0).toString(16).padStart(8, "0") + (t2 >>> 0).toString(16).padStart(8, "0");
  }
};
function resizeImageMask(e2, t2, i2, n2, a2, s2) {
  const r2 = a2 * s2;
  let o2;
  o2 = t2 <= 8 ? new Uint8Array(r2) : t2 <= 16 ? new Uint16Array(r2) : new Uint32Array(r2);
  const l2 = i2 / a2, c2 = n2 / s2;
  let h2, d2, u2, g2, f2 = 0;
  const p2 = new Uint16Array(a2), m2 = i2;
  for (h2 = 0; h2 < a2; h2++) p2[h2] = Math.floor(h2 * l2);
  for (h2 = 0; h2 < s2; h2++) for (u2 = Math.floor(h2 * c2) * m2, d2 = 0; d2 < a2; d2++) g2 = u2 + p2[d2], o2[f2++] = e2[g2];
  return o2;
}
class PDFImage {
  constructor({ xref: e2, res: t2, image: i2, isInline: n2 = false, smask: a2 = null, mask: s2 = null, isMask: r2 = false, pdfFunctionFactory: o2, globalColorSpaceCache: l2, localColorSpaceCache: c2 }) {
    this.image = i2;
    const h2 = i2.dict, d2 = h2.get("F", "Filter");
    let u2;
    if (d2 instanceof Name) u2 = d2.name;
    else if (Array.isArray(d2)) {
      const t3 = e2.fetchIfRef(d2[0]);
      t3 instanceof Name && (u2 = t3.name);
    }
    switch (u2) {
      case "JPXDecode":
        ({ width: i2.width, height: i2.height, componentsCount: i2.numComps, bitsPerComponent: i2.bitsPerComponent } = JpxImage.parseImageProperties(i2.stream)), i2.stream.reset();
        const e3 = ImageResizer.getReducePowerForJPX(i2.width, i2.height, i2.numComps);
        if (this.jpxDecoderOptions = { numComponents: 0, isIndexedColormap: false, smaskInData: h2.has("SMaskInData"), reducePower: e3 }, e3) {
          const t3 = 2 ** e3;
          i2.width = Math.ceil(i2.width / t3), i2.height = Math.ceil(i2.height / t3);
        }
        break;
      case "JBIG2Decode":
        i2.bitsPerComponent = 1, i2.numComps = 1;
    }
    let g2 = h2.get("W", "Width"), f2 = h2.get("H", "Height");
    if (Number.isInteger(i2.width) && i2.width > 0 && Number.isInteger(i2.height) && i2.height > 0 && (i2.width !== g2 || i2.height !== f2)) warn$1("PDFImage - using the Width/Height of the image data, rather than the image dictionary."), g2 = i2.width, f2 = i2.height;
    else {
      const e3 = "number" == typeof g2 && g2 > 0, t3 = "number" == typeof f2 && f2 > 0;
      if (!e3 || !t3) {
        if (!i2.fallbackDims) throw new ti(`Invalid image width: ${g2} or height: ${f2}`);
        warn$1("PDFImage - using the Width/Height of the parent image, for SMask/Mask data."), e3 || (g2 = i2.fallbackDims.width), t3 || (f2 = i2.fallbackDims.height);
      }
    }
    this.width = g2, this.height = f2, this.interpolate = h2.get("I", "Interpolate"), this.imageMask = h2.get("IM", "ImageMask") || false, this.matte = h2.get("Matte") || false;
    let p2 = i2.bitsPerComponent;
    if (!p2 && (p2 = h2.get("BPC", "BitsPerComponent"), !p2)) {
      if (!this.imageMask) throw new ti(`Bits per component missing in image: ${this.imageMask}`);
      p2 = 1;
    }
    if (this.bpc = p2, !this.imageMask) {
      let a3 = h2.getRaw("CS") || h2.getRaw("ColorSpace");
      const s3 = !!a3;
      if (s3) this.jpxDecoderOptions?.smaskInData && (a3 = Name.get("DeviceRGBA"));
      else if (this.jpxDecoderOptions) a3 = Name.get("DeviceRGBA");
      else switch (i2.numComps) {
        case 1:
          a3 = Name.get("DeviceGray");
          break;
        case 3:
          a3 = Name.get("DeviceRGB");
          break;
        case 4:
          a3 = Name.get("DeviceCMYK");
          break;
        default:
          throw new Error(`Images with ${i2.numComps} color components not supported.`);
      }
      this.colorSpace = ColorSpaceUtils.parse({ cs: a3, xref: e2, resources: n2 ? t2 : null, pdfFunctionFactory: o2, globalColorSpaceCache: l2, localColorSpaceCache: c2 }), this.numComps = this.colorSpace.numComps, this.jpxDecoderOptions && (this.jpxDecoderOptions.numComponents = s3 ? this.numComps : 0, this.jpxDecoderOptions.isIndexedColormap = "Indexed" === this.colorSpace.name);
    }
    if (this.decode = h2.getArray("D", "Decode"), this.needsDecode = false, this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, p2) || r2 && !ColorSpace.isDefaultDecode(this.decode, 1))) {
      this.needsDecode = true;
      const e3 = (1 << p2) - 1;
      this.decodeCoefficients = [], this.decodeAddends = [];
      const t3 = "Indexed" === this.colorSpace?.name;
      for (let i3 = 0, n3 = 0; i3 < this.decode.length; i3 += 2, ++n3) {
        const a3 = this.decode[i3], s3 = this.decode[i3 + 1];
        this.decodeCoefficients[n3] = t3 ? (s3 - a3) / e3 : s3 - a3, this.decodeAddends[n3] = t3 ? a3 : e3 * a3;
      }
    }
    if (a2) a2.fallbackDims ??= { width: g2, height: f2 }, this.smask = new PDFImage({ xref: e2, res: t2, image: a2, isInline: n2, pdfFunctionFactory: o2, globalColorSpaceCache: l2, localColorSpaceCache: c2 });
    else if (s2) if (s2 instanceof BaseStream) {
      s2.dict.get("IM", "ImageMask") ? (s2.fallbackDims ??= { width: g2, height: f2 }, this.mask = new PDFImage({ xref: e2, res: t2, image: s2, isInline: n2, isMask: true, pdfFunctionFactory: o2, globalColorSpaceCache: l2, localColorSpaceCache: c2 })) : warn$1("Ignoring /Mask in image without /ImageMask.");
    } else this.mask = s2;
  }
  static async buildImage({ xref: e2, res: t2, image: i2, isInline: n2 = false, pdfFunctionFactory: a2, globalColorSpaceCache: s2, localColorSpaceCache: r2 }) {
    const o2 = i2;
    let l2 = null, c2 = null;
    const h2 = i2.dict.get("SMask"), d2 = i2.dict.get("Mask");
    return h2 ? h2 instanceof BaseStream ? l2 = h2 : warn$1("Unsupported /SMask format.") : d2 && (d2 instanceof BaseStream || Array.isArray(d2) ? c2 = d2 : warn$1("Unsupported /Mask format.")), new PDFImage({ xref: e2, res: t2, image: o2, isInline: n2, smask: l2, mask: c2, pdfFunctionFactory: a2, globalColorSpaceCache: s2, localColorSpaceCache: r2 });
  }
  static async createMask({ image: e2, isOffscreenCanvasSupported: t2 = false }) {
    const { dict: i2 } = e2, n2 = i2.get("W", "Width"), a2 = i2.get("H", "Height"), s2 = i2.get("I", "Interpolate"), r2 = i2.getArray("D", "Decode"), o2 = r2?.[0] > 0, l2 = (n2 + 7 >> 3) * a2, c2 = e2.getBytes(l2), h2 = 1 === n2 && 1 === a2 && o2 === (0 === c2.length || !!(128 & c2[0]));
    if (h2) return { isSingleOpaquePixel: h2 };
    if (t2) {
      if (ImageResizer.needsToBeResized(n2, a2)) {
        const e4 = new Uint8ClampedArray(n2 * a2 * 4);
        return convertBlackAndWhiteToRGBA$1({ src: c2, dest: e4, width: n2, height: a2, nonBlackColor: 0, inverseDecode: o2 }), ImageResizer.createImage({ kind: k, data: e4, width: n2, height: a2, interpolate: s2 });
      }
      const e3 = new OffscreenCanvas(n2, a2), t3 = e3.getContext("2d"), i3 = t3.createImageData(n2, a2);
      convertBlackAndWhiteToRGBA$1({ src: c2, dest: i3.data, width: n2, height: a2, nonBlackColor: 0, inverseDecode: o2 }), t3.putImageData(i3, 0, 0);
      return { data: null, width: n2, height: a2, interpolate: s2, bitmap: e3.transferToImageBitmap() };
    }
    const d2 = c2.byteLength;
    let u2;
    if (e2 instanceof DecodeStream && (!o2 || l2 === d2) ? u2 = c2 : o2 ? (u2 = new Uint8Array(l2), u2.set(c2), u2.fill(255, d2)) : u2 = new Uint8Array(c2), o2) for (let e3 = 0; e3 < d2; e3++) u2[e3] ^= 255;
    return { data: u2, width: n2, height: a2, interpolate: s2 };
  }
  get drawWidth() {
    return Math.max(this.width, this.smask?.width || 0, this.mask?.width || 0);
  }
  get drawHeight() {
    return Math.max(this.height, this.smask?.height || 0, this.mask?.height || 0);
  }
  decodeBuffer(e2) {
    const t2 = this.bpc, i2 = this.numComps, n2 = this.decodeAddends, a2 = this.decodeCoefficients, s2 = (1 << t2) - 1;
    let r2, o2;
    if (1 === t2) {
      for (r2 = 0, o2 = e2.length; r2 < o2; r2++) e2[r2] = +!e2[r2];
      return;
    }
    let l2 = 0;
    for (r2 = 0, o2 = this.width * this.height; r2 < o2; r2++) for (let t3 = 0; t3 < i2; t3++) e2[l2] = MathClamp$1(n2[t3] + e2[l2] * a2[t3], 0, s2), l2++;
  }
  getComponents(e2) {
    const t2 = this.bpc;
    if (8 === t2) return e2;
    const i2 = this.width, n2 = this.height, a2 = this.numComps, s2 = i2 * n2 * a2;
    let r2, o2 = 0;
    r2 = t2 <= 8 ? new Uint8Array(s2) : t2 <= 16 ? new Uint16Array(s2) : new Uint32Array(s2);
    const l2 = i2 * a2, c2 = (1 << t2) - 1;
    let h2, d2, u2 = 0;
    if (1 === t2) {
      let t3, i3, a3;
      for (let s3 = 0; s3 < n2; s3++) {
        for (i3 = u2 + (-8 & l2), a3 = u2 + l2; u2 < i3; ) d2 = e2[o2++], r2[u2] = d2 >> 7 & 1, r2[u2 + 1] = d2 >> 6 & 1, r2[u2 + 2] = d2 >> 5 & 1, r2[u2 + 3] = d2 >> 4 & 1, r2[u2 + 4] = d2 >> 3 & 1, r2[u2 + 5] = d2 >> 2 & 1, r2[u2 + 6] = d2 >> 1 & 1, r2[u2 + 7] = 1 & d2, u2 += 8;
        if (u2 < a3) for (d2 = e2[o2++], t3 = 128; u2 < a3; ) r2[u2++] = +!!(d2 & t3), t3 >>= 1;
      }
    } else {
      let i3 = 0;
      for (d2 = 0, u2 = 0, h2 = s2; u2 < h2; ++u2) {
        for (u2 % l2 === 0 && (d2 = 0, i3 = 0); i3 < t2; ) d2 = d2 << 8 | e2[o2++], i3 += 8;
        const n3 = i3 - t2;
        let a3 = d2 >> n3;
        a3 < 0 ? a3 = 0 : a3 > c2 && (a3 = c2), r2[u2] = a3, d2 &= (1 << n3) - 1, i3 = n3;
      }
    }
    return r2;
  }
  async fillOpacity(e2, t2, i2, n2, a2) {
    const s2 = this.smask, r2 = this.mask;
    let o2, l2, c2, h2, d2, u2;
    if (s2) l2 = s2.width, c2 = s2.height, o2 = new Uint8ClampedArray(l2 * c2), await s2.fillGrayBuffer(o2), l2 === t2 && c2 === i2 || (o2 = resizeImageMask(o2, s2.bpc, l2, c2, t2, i2));
    else if (r2) if (r2 instanceof PDFImage) {
      for (l2 = r2.width, c2 = r2.height, o2 = new Uint8ClampedArray(l2 * c2), r2.numComps = 1, await r2.fillGrayBuffer(o2), h2 = 0, d2 = l2 * c2; h2 < d2; ++h2) o2[h2] = 255 - o2[h2];
      l2 === t2 && c2 === i2 || (o2 = resizeImageMask(o2, r2.bpc, l2, c2, t2, i2));
    } else {
      if (!Array.isArray(r2)) throw new ti("Unknown mask format.");
      {
        o2 = new Uint8ClampedArray(t2 * i2);
        const e3 = this.numComps;
        for (h2 = 0, d2 = t2 * i2; h2 < d2; ++h2) {
          let t3 = 0;
          const i3 = h2 * e3;
          for (u2 = 0; u2 < e3; ++u2) {
            const e4 = a2[i3 + u2], n3 = 2 * u2;
            if (e4 < r2[n3] || e4 > r2[n3 + 1]) {
              t3 = 255;
              break;
            }
          }
          o2[h2] = t3;
        }
      }
    }
    if (o2) for (h2 = 0, u2 = 3, d2 = t2 * n2; h2 < d2; ++h2, u2 += 4) e2[u2] = o2[h2];
    else for (h2 = 0, u2 = 3, d2 = t2 * n2; h2 < d2; ++h2, u2 += 4) e2[u2] = 255;
  }
  undoPreblend(e2, t2, i2) {
    const n2 = this.smask?.matte;
    if (!n2) return;
    const a2 = this.colorSpace.getRgb(n2, 0), s2 = a2[0], r2 = a2[1], o2 = a2[2], l2 = t2 * i2 * 4;
    for (let t3 = 0; t3 < l2; t3 += 4) {
      const i3 = e2[t3 + 3];
      if (0 === i3) {
        e2[t3] = 255, e2[t3 + 1] = 255, e2[t3 + 2] = 255;
        continue;
      }
      const n3 = 255 / i3;
      e2[t3] = (e2[t3] - s2) * n3 + s2, e2[t3 + 1] = (e2[t3 + 1] - r2) * n3 + r2, e2[t3 + 2] = (e2[t3 + 2] - o2) * n3 + o2;
    }
  }
  async createImageData(e2 = false, t2 = false) {
    const i2 = this.drawWidth, n2 = this.drawHeight, a2 = { width: i2, height: n2, interpolate: this.interpolate, kind: 0, data: null }, s2 = this.numComps, r2 = this.width, o2 = this.height, l2 = this.bpc, c2 = r2 * s2 * l2 + 7 >> 3, h2 = t2 && ImageResizer.needsToBeResized(i2, n2);
    if (!this.smask && !this.mask && "DeviceRGBA" === this.colorSpace.name) {
      a2.kind = k;
      const e3 = a2.data = await this.getImageBytes(o2 * r2 * 4, {});
      return t2 ? h2 ? ImageResizer.createImage(a2, false) : this.createBitmap(k, i2, n2, e3) : a2;
    }
    if (!e2) {
      let e3;
      if ("DeviceGray" === this.colorSpace.name && 1 === l2 ? e3 = v : "DeviceRGB" !== this.colorSpace.name || 8 !== l2 || this.needsDecode || (e3 = C), e3 && !this.smask && !this.mask && i2 === r2 && n2 === o2) {
        const s3 = await this.#ie(r2, o2);
        if (s3) return s3;
        const l3 = await this.getImageBytes(o2 * c2, {});
        if (t2) return h2 ? ImageResizer.createImage({ data: l3, kind: e3, width: i2, height: n2, interpolate: this.interpolate }, this.needsDecode) : this.createBitmap(e3, r2, o2, l3);
        if (a2.kind = e3, a2.data = l3, this.needsDecode) {
          assert$1(e3 === v, "PDFImage.createImageData: The image must be grayscale.");
          const t3 = a2.data;
          for (let e4 = 0, i3 = t3.length; e4 < i3; e4++) t3[e4] ^= 255;
        }
        return a2;
      }
      if (this.image instanceof JpegStream && !this.smask && !this.mask && !this.needsDecode) {
        let e4 = o2 * c2;
        if (t2 && !h2) {
          let t3 = false;
          switch (this.colorSpace.name) {
            case "DeviceGray":
              e4 *= 4, t3 = true;
              break;
            case "DeviceRGB":
              e4 = e4 / 3 * 4, t3 = true;
              break;
            case "DeviceCMYK":
              t3 = true;
          }
          if (t3) {
            const t4 = await this.#ie(i2, n2);
            if (t4) return t4;
            const a3 = await this.getImageBytes(e4, { drawWidth: i2, drawHeight: n2, forceRGBA: true });
            return this.createBitmap(k, i2, n2, a3);
          }
        } else switch (this.colorSpace.name) {
          case "DeviceGray":
            e4 *= 3;
          case "DeviceRGB":
          case "DeviceCMYK":
            return a2.kind = C, a2.data = await this.getImageBytes(e4, { drawWidth: i2, drawHeight: n2, forceRGB: true }), h2 ? ImageResizer.createImage(a2) : a2;
        }
      }
    }
    const d2 = await this.getImageBytes(o2 * c2, { internal: true }), u2 = 0 | d2.length / c2 * n2 / o2, g2 = this.getComponents(d2);
    let f2, p2, m2, b2, y2, w2;
    if (t2 && !h2 && (m2 = new OffscreenCanvas(i2, n2), b2 = m2.getContext("2d"), y2 = b2.createImageData(i2, n2), w2 = y2.data), a2.kind = k, e2 || this.smask || this.mask) t2 && !h2 || (w2 = new Uint8ClampedArray(i2 * n2 * 4)), f2 = 1, p2 = true, await this.fillOpacity(w2, i2, n2, u2, g2);
    else {
      if (!t2 || h2) a2.kind = C, w2 = new Uint8ClampedArray(i2 * n2 * 3), f2 = 0;
      else {
        new Uint32Array(w2.buffer).fill(FeatureTest.isLittleEndian ? 4278190080 : 255), f2 = 1;
      }
      p2 = false;
    }
    if (this.needsDecode && this.decodeBuffer(g2), this.colorSpace.fillRgb(w2, r2, o2, i2, n2, u2, l2, g2, f2), p2 && this.undoPreblend(w2, i2, u2), t2 && !h2) {
      b2.putImageData(y2, 0, 0);
      return { data: null, width: i2, height: n2, bitmap: m2.transferToImageBitmap(), interpolate: this.interpolate };
    }
    return a2.data = w2, h2 ? ImageResizer.createImage(a2) : a2;
  }
  async fillGrayBuffer(e2) {
    const t2 = this.numComps;
    if (1 !== t2) throw new ti(`Reading gray scale from a color image: ${t2}`);
    const i2 = this.width, n2 = this.height, a2 = this.bpc, s2 = i2 * t2 * a2 + 7 >> 3, r2 = await this.getImageBytes(n2 * s2, { internal: true }), o2 = this.getComponents(r2);
    let l2, c2;
    if (1 === a2) {
      if (c2 = i2 * n2, this.needsDecode) for (l2 = 0; l2 < c2; ++l2) e2[l2] = o2[l2] - 1 & 255;
      else for (l2 = 0; l2 < c2; ++l2) e2[l2] = 255 & -o2[l2];
      return;
    }
    this.needsDecode && this.decodeBuffer(o2), c2 = i2 * n2;
    const h2 = 255 / ((1 << a2) - 1);
    for (l2 = 0; l2 < c2; ++l2) e2[l2] = h2 * o2[l2];
  }
  createBitmap(e2, t2, i2, n2) {
    const a2 = new OffscreenCanvas(t2, i2), s2 = a2.getContext("2d");
    let r2;
    e2 === k ? r2 = new ImageData(n2, t2, i2) : (r2 = s2.createImageData(t2, i2), convertToRGBA({ kind: e2, src: n2, dest: new Uint32Array(r2.data.buffer), width: t2, height: i2, inverseDecode: this.needsDecode })), s2.putImageData(r2, 0, 0);
    return { data: null, width: t2, height: i2, bitmap: a2.transferToImageBitmap(), interpolate: this.interpolate };
  }
  async #ie(e2, t2) {
    const i2 = await this.image.getTransferableImage();
    return i2 ? { data: null, width: e2, height: t2, bitmap: i2, interpolate: this.interpolate } : null;
  }
  async getImageBytes(e2, { drawWidth: t2, drawHeight: i2, forceRGBA: n2 = false, forceRGB: a2 = false, internal: s2 = false }) {
    this.image.reset(), this.image.drawWidth = t2 || this.width, this.image.drawHeight = i2 || this.height, this.image.forceRGBA = !!n2, this.image.forceRGB = !!a2;
    const r2 = await this.image.getImageData(e2, this.jpxDecoderOptions);
    return s2 || this.image instanceof DecodeStream ? r2 : (assert$1(r2 instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.'), new Uint8Array(r2));
  }
}
const Ss = Object.freeze({ maxImageSize: -1, disableFontFace: false, ignoreErrors: false, isEvalSupported: true, isOffscreenCanvasSupported: false, isImageDecoderSupported: false, canvasMaxAreaInBytes: -1, fontExtraProperties: false, useSystemFonts: true, useWasm: true, useWorkerFetch: true, cMapUrl: null, iccUrl: null, standardFontDataUrl: null, wasmUrl: null }), vs = 1, Cs = 2, ks = Promise.resolve();
function normalizeBlendMode(e2, t2 = false) {
  if (Array.isArray(e2)) {
    for (const t3 of e2) {
      const e3 = normalizeBlendMode(t3, true);
      if (e3) return e3;
    }
    return warn$1(`Unsupported blend mode Array: ${e2}`), "source-over";
  }
  if (!(e2 instanceof Name)) return t2 ? null : "source-over";
  switch (e2.name) {
    case "Normal":
    case "Compatible":
      return "source-over";
    case "Multiply":
      return "multiply";
    case "Screen":
      return "screen";
    case "Overlay":
      return "overlay";
    case "Darken":
      return "darken";
    case "Lighten":
      return "lighten";
    case "ColorDodge":
      return "color-dodge";
    case "ColorBurn":
      return "color-burn";
    case "HardLight":
      return "hard-light";
    case "SoftLight":
      return "soft-light";
    case "Difference":
      return "difference";
    case "Exclusion":
      return "exclusion";
    case "Hue":
      return "hue";
    case "Saturation":
      return "saturation";
    case "Color":
      return "color";
    case "Luminosity":
      return "luminosity";
  }
  return t2 ? null : (warn$1(`Unsupported blend mode: ${e2.name}`), "source-over");
}
function addCachedImageOps(e2, { objId: t2, fn: i2, args: n2, optionalContent: a2, hasMask: s2 }) {
  t2 && e2.addDependency(t2), e2.addImageOps(i2, n2, a2, s2), i2 === Dt && n2[0]?.count > 0 && n2[0].count++;
}
class TimeSlotManager {
  static TIME_SLOT_DURATION_MS = 20;
  static CHECK_TIME_EVERY = 100;
  constructor() {
    this.reset();
  }
  check() {
    return !(++this.checked < TimeSlotManager.CHECK_TIME_EVERY) && (this.checked = 0, this.endTime <= Date.now());
  }
  reset() {
    this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS, this.checked = 0;
  }
}
class PartialEvaluator {
  constructor({ xref: e2, handler: t2, pageIndex: i2, idFactory: n2, fontCache: a2, builtInCMapCache: s2, standardFontDataCache: r2, globalColorSpaceCache: o2, globalImageCache: l2, systemFontCache: c2, options: h2 = null }) {
    this.xref = e2, this.handler = t2, this.pageIndex = i2, this.idFactory = n2, this.fontCache = a2, this.builtInCMapCache = s2, this.standardFontDataCache = r2, this.globalColorSpaceCache = o2, this.globalImageCache = l2, this.systemFontCache = c2, this.options = h2 || Ss, this.type3FontRefs = null, this._regionalImageCache = new RegionalImageCache(), this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
  }
  get _pdfFunctionFactory() {
    return shadow$1(this, "_pdfFunctionFactory", new PDFFunctionFactory({ xref: this.xref, isEvalSupported: this.options.isEvalSupported }));
  }
  get parsingType3Font() {
    return !!this.type3FontRefs;
  }
  clone(e2 = null) {
    const t2 = Object.create(this);
    return t2.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, e2), t2;
  }
  hasBlendModes(e2, t2) {
    if (!(e2 instanceof Dict)) return false;
    if (e2.objId && t2.has(e2.objId)) return false;
    const i2 = new RefSet(t2);
    e2.objId && i2.put(e2.objId);
    const n2 = [e2], a2 = this.xref;
    for (; n2.length; ) {
      const e3 = n2.shift(), t3 = e3.get("ExtGState");
      if (t3 instanceof Dict) for (let e4 of t3.getRawValues()) {
        if (e4 instanceof Ref) {
          if (i2.has(e4)) continue;
          try {
            e4 = a2.fetch(e4);
          } catch (t5) {
            i2.put(e4), info$1(`hasBlendModes - ignoring ExtGState: "${t5}".`);
            continue;
          }
        }
        if (!(e4 instanceof Dict)) continue;
        e4.objId && i2.put(e4.objId);
        const t4 = e4.get("BM");
        if (t4 instanceof Name) {
          if ("Normal" !== t4.name) return true;
        } else if (void 0 !== t4 && Array.isArray(t4)) {
          for (const e5 of t4) if (e5 instanceof Name && "Normal" !== e5.name) return true;
        }
      }
      const s2 = e3.get("XObject");
      if (s2 instanceof Dict) for (let e4 of s2.getRawValues()) {
        if (e4 instanceof Ref) {
          if (i2.has(e4)) continue;
          try {
            e4 = a2.fetch(e4);
          } catch (t5) {
            i2.put(e4), info$1(`hasBlendModes - ignoring XObject: "${t5}".`);
            continue;
          }
        }
        if (!(e4 instanceof BaseStream)) continue;
        e4.dict.objId && i2.put(e4.dict.objId);
        const t4 = e4.dict.get("Resources");
        t4 instanceof Dict && (t4.objId && i2.has(t4.objId) || (n2.push(t4), t4.objId && i2.put(t4.objId)));
      }
    }
    for (const e3 of i2) t2.put(e3);
    return false;
  }
  async fetchBuiltInCMap(e2) {
    const t2 = this.builtInCMapCache.get(e2);
    if (t2) return t2;
    let i2;
    return i2 = this.options.useWorkerFetch ? { cMapData: await fetchBinaryData(`${this.options.cMapUrl}${e2}.bcmap`), isCompressed: true } : await this.handler.sendWithPromise("FetchBinaryData", { type: "cMapReaderFactory", name: e2 }), this.builtInCMapCache.set(e2, i2), i2;
  }
  async fetchStandardFontData(e2) {
    const t2 = this.standardFontDataCache.get(e2);
    if (t2) return new Stream(t2);
    if (this.options.useSystemFonts && "Symbol" !== e2 && "ZapfDingbats" !== e2) return null;
    const i2 = jn()[e2];
    let n2;
    try {
      n2 = this.options.useWorkerFetch ? await fetchBinaryData(`${this.options.standardFontDataUrl}${i2}`) : await this.handler.sendWithPromise("FetchBinaryData", { type: "standardFontDataFactory", filename: i2 });
    } catch (e3) {
      return warn$1(e3), null;
    }
    return this.standardFontDataCache.set(e2, n2), new Stream(n2);
  }
  async buildFormXObject(e2, t2, i2, n2, a2, s2, r2, o2) {
    const { dict: l2 } = t2, c2 = lookupMatrix(l2.getArray("Matrix"), null), h2 = lookupNormalRect(l2.getArray("BBox"), null);
    let d2, u2;
    l2.has("OC") && (d2 = await this.parseMarkedContentProps(l2.get("OC"), e2)), void 0 !== d2 && n2.addOp(xt, ["OC", d2]);
    const g2 = l2.get("Group");
    if (g2) {
      u2 = { matrix: c2, bbox: h2, smask: i2, isolated: false, knockout: false };
      let t3 = null;
      if (isName(g2.get("S"), "Transparency") && (u2.isolated = g2.get("I") || false, u2.knockout = g2.get("K") || false, g2.has("CS"))) {
        const i3 = this._getColorSpace(g2.getRaw("CS"), e2, r2);
        t3 = i3 instanceof ColorSpace ? i3 : await this._handleColorSpace(i3);
      }
      i2?.backdrop && (t3 ||= ColorSpaceUtils.rgb, i2.backdrop = t3.getRgbHex(i2.backdrop, 0)), n2.addOp(Ft, [u2]);
    }
    const f2 = [c2 && new Float32Array(c2), !g2 && h2 && new Float32Array(h2) || null];
    n2.addOp(kt, f2);
    const p2 = l2.get("Resources");
    await this.getOperatorList({ stream: t2, task: a2, resources: p2 instanceof Dict ? p2 : e2, operatorList: n2, initialState: s2, prevRefs: o2 }), n2.addOp(Tt, []), g2 && n2.addOp(It, [u2]), void 0 !== d2 && n2.addOp(St, []);
  }
  _sendImgData(e2, t2, i2 = false) {
    const n2 = t2 ? [t2.bitmap || t2.data.buffer] : null;
    return this.parsingType3Font || i2 ? this.handler.send("commonobj", [e2, "Image", t2], n2) : this.handler.send("obj", [e2, this.pageIndex, "Image", t2], n2);
  }
  async buildPaintImageXObject({ resources: e2, image: t2, isInline: i2 = false, operatorList: n2, cacheKey: a2, localImageCache: s2, localColorSpaceCache: r2 }) {
    const { maxImageSize: o2, ignoreErrors: l2, isOffscreenCanvasSupported: c2 } = this.options, { dict: h2 } = t2, d2 = h2.objId, u2 = h2.get("W", "Width"), g2 = h2.get("H", "Height");
    if (!u2 || "number" != typeof u2 || !g2 || "number" != typeof g2) return void warn$1("Image dimensions are missing, or not numbers.");
    if (-1 !== o2 && u2 * g2 > o2) {
      const e3 = "Image exceeded maximum allowed size and was removed.";
      if (!l2) throw new Error(e3);
      return void warn$1(e3);
    }
    let f2;
    h2.has("OC") && (f2 = await this.parseMarkedContentProps(h2.get("OC"), e2));
    let p2, m2, b2;
    if (h2.get("IM", "ImageMask") || false) {
      if (p2 = await PDFImage.createMask({ image: t2, isOffscreenCanvasSupported: c2 && !this.parsingType3Font }), p2.isSingleOpaquePixel) {
        if (m2 = Lt, b2 = [], n2.addImageOps(m2, b2, f2), a2) {
          const e4 = { fn: m2, args: b2, optionalContent: f2 };
          s2.set(a2, d2, e4), d2 && this._regionalImageCache.set(null, d2, e4);
        }
        return;
      }
      if (this.parsingType3Font) return b2 = (function({ data: e4, width: t3, height: i3 }) {
        if (t3 > 1e3 || i3 > 1e3) return null;
        const n3 = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), a3 = t3 + 1, s3 = new Uint8Array(a3 * (i3 + 1));
        let r3, o3, l3;
        const c3 = t3 + 7 & -8, h3 = new Uint8Array(c3 * i3);
        let d3 = 0;
        for (const t4 of e4) {
          let e5 = 128;
          for (; e5 > 0; ) h3[d3++] = t4 & e5 ? 0 : 255, e5 >>= 1;
        }
        let u3 = 0;
        for (d3 = 0, 0 !== h3[d3] && (s3[0] = 1, ++u3), o3 = 1; o3 < t3; o3++) h3[d3] !== h3[d3 + 1] && (s3[o3] = h3[d3] ? 2 : 1, ++u3), d3++;
        for (0 !== h3[d3] && (s3[o3] = 2, ++u3), r3 = 1; r3 < i3; r3++) {
          d3 = r3 * c3, l3 = r3 * a3, h3[d3 - c3] !== h3[d3] && (s3[l3] = h3[d3] ? 1 : 8, ++u3);
          let e5 = (h3[d3] ? 4 : 0) + (h3[d3 - c3] ? 8 : 0);
          for (o3 = 1; o3 < t3; o3++) e5 = (e5 >> 2) + (h3[d3 + 1] ? 4 : 0) + (h3[d3 - c3 + 1] ? 8 : 0), n3[e5] && (s3[l3 + o3] = n3[e5], ++u3), d3++;
          if (h3[d3 - c3] !== h3[d3] && (s3[l3 + o3] = h3[d3] ? 2 : 4, ++u3), u3 > 1e3) return null;
        }
        for (d3 = c3 * (i3 - 1), l3 = r3 * a3, 0 !== h3[d3] && (s3[l3] = 8, ++u3), o3 = 1; o3 < t3; o3++) h3[d3] !== h3[d3 + 1] && (s3[l3 + o3] = h3[d3] ? 4 : 8, ++u3), d3++;
        if (0 !== h3[d3] && (s3[l3 + o3] = 4, ++u3), u3 > 1e3) return null;
        const g3 = new Int32Array([0, a3, -1, 0, -a3, 0, 0, 0, 1]), f3 = [], { a: p3, b: m3, c: b3, d: y3, e: w3, f: x3 } = new DOMMatrix().scaleSelf(1 / t3, -1 / i3).translateSelf(0, -i3);
        for (r3 = 0; u3 && r3 <= i3; r3++) {
          let e5 = r3 * a3;
          const i4 = e5 + t3;
          for (; e5 < i4 && !s3[e5]; ) e5++;
          if (e5 === i4) continue;
          let n4 = e5 % a3, o4 = r3;
          f3.push(Xt, p3 * n4 + b3 * o4 + w3, m3 * n4 + y3 * o4 + x3);
          const l4 = e5;
          let c4 = s3[e5];
          do {
            const t4 = g3[c4];
            do {
              e5 += t4;
            } while (!s3[e5]);
            const i5 = s3[e5];
            5 !== i5 && 10 !== i5 ? (c4 = i5, s3[e5] = 0) : (c4 = i5 & 51 * c4 >> 4, s3[e5] &= c4 >> 2 | c4 << 2), n4 = e5 % a3, o4 = e5 / a3 | 0, f3.push(qt, p3 * n4 + b3 * o4 + w3, m3 * n4 + y3 * o4 + x3), s3[e5] || --u3;
          } while (l4 !== e5);
          --r3;
        }
        return [Ht, [new Float32Array(f3)], new Float32Array([0, 0, t3, i3])];
      })(p2), b2 ? void n2.addImageOps(Ut, b2, f2) : (warn$1("Cannot compile Type3 glyph."), void n2.addImageOps(Dt, [p2], f2));
      const e3 = `mask_${this.idFactory.createObjId()}`;
      if (n2.addDependency(e3), p2.dataLen = p2.bitmap ? p2.width * p2.height * 4 : p2.data.length, this._sendImgData(e3, p2), m2 = Dt, b2 = [{ data: e3, width: p2.width, height: p2.height, interpolate: p2.interpolate, count: 1 }], n2.addImageOps(m2, b2, f2), a2) {
        const t3 = { objId: e3, fn: m2, args: b2, optionalContent: f2 };
        s2.set(a2, d2, t3), d2 && this._regionalImageCache.set(null, d2, t3);
      }
      return;
    }
    const y2 = h2.has("SMask") || h2.has("Mask");
    if (i2 && u2 + g2 < 200 && !y2) {
      try {
        const a3 = new PDFImage({ xref: this.xref, res: e2, image: t2, isInline: i2, pdfFunctionFactory: this._pdfFunctionFactory, globalColorSpaceCache: this.globalColorSpaceCache, localColorSpaceCache: r2 });
        p2 = await a3.createImageData(true, false), n2.addImageOps(Pt, [p2], f2);
      } catch (e3) {
        const t3 = `Unable to decode inline image: "${e3}".`;
        if (!l2) throw new Error(t3);
        warn$1(t3);
      }
      return;
    }
    let w2 = `img_${this.idFactory.createObjId()}`, x2 = false, S2 = null;
    if (this.parsingType3Font ? w2 = `${this.idFactory.getDocId()}_type3_${w2}` : a2 && d2 && (x2 = this.globalImageCache.shouldCache(d2, this.pageIndex), x2 && (assert$1(!i2, "Cannot cache an inline image globally."), w2 = `${this.idFactory.getDocId()}_${w2}`)), n2.addDependency(w2), m2 = _t, b2 = [w2, u2, g2], n2.addImageOps(m2, b2, f2, y2), x2) {
      if (S2 = { objId: w2, fn: m2, args: b2, optionalContent: f2, hasMask: y2, byteSize: 0 }, this.globalImageCache.hasDecodeFailed(d2)) return this.globalImageCache.setData(d2, S2), void this._sendImgData(w2, null, x2);
      if (u2 * g2 > 25e4 || y2) {
        const e3 = await this.handler.sendWithPromise("commonobj", [w2, "CopyLocalImage", { imageRef: d2 }]);
        if (e3) return this.globalImageCache.setData(d2, S2), void this.globalImageCache.addByteSize(d2, e3);
      }
    }
    if (PDFImage.buildImage({ xref: this.xref, res: e2, image: t2, isInline: i2, pdfFunctionFactory: this._pdfFunctionFactory, globalColorSpaceCache: this.globalColorSpaceCache, localColorSpaceCache: r2 }).then(async (e3) => (p2 = await e3.createImageData(false, c2), p2.dataLen = p2.bitmap ? p2.width * p2.height * 4 : p2.data.length, p2.ref = d2, x2 && this.globalImageCache.addByteSize(d2, p2.dataLen), this._sendImgData(w2, p2, x2))).catch((e3) => (warn$1(`Unable to decode image "${w2}": "${e3}".`), d2 && this.globalImageCache.addDecodeFailed(d2), this._sendImgData(w2, null, x2))), a2) {
      const e3 = { objId: w2, fn: m2, args: b2, optionalContent: f2, hasMask: y2 };
      s2.set(a2, d2, e3), d2 && (this._regionalImageCache.set(null, d2, e3), x2 && (assert$1(S2, "The global cache-data must be available."), this.globalImageCache.setData(d2, S2)));
    }
  }
  handleSMask(e2, t2, i2, n2, a2, s2, r2) {
    const o2 = e2.get("G"), l2 = { subtype: e2.get("S").name, backdrop: e2.get("BC") }, c2 = e2.get("TR");
    if (isPDFFunction(c2)) {
      const e3 = this._pdfFunctionFactory.create(c2), t3 = new Uint8Array(256), i3 = new Float32Array(1);
      for (let n3 = 0; n3 < 256; n3++) i3[0] = n3 / 255, e3(i3, 0, i3, 0), t3[n3] = 255 * i3[0] | 0;
      l2.transferMap = t3;
    }
    return this.buildFormXObject(t2, o2, l2, i2, n2, a2.state.clone({ newPath: true }), s2, r2);
  }
  handleTransferFunction(e2) {
    let t2;
    if (Array.isArray(e2)) t2 = e2;
    else {
      if (!isPDFFunction(e2)) return null;
      t2 = [e2];
    }
    const i2 = [];
    let n2 = 0, a2 = 0;
    for (const e3 of t2) {
      const t3 = this.xref.fetchIfRef(e3);
      if (n2++, isName(t3, "Identity")) {
        i2.push(null);
        continue;
      }
      if (!isPDFFunction(t3)) return null;
      const s2 = this._pdfFunctionFactory.create(t3), r2 = new Uint8Array(256), o2 = new Float32Array(1);
      for (let e4 = 0; e4 < 256; e4++) o2[0] = e4 / 255, s2(o2, 0, o2, 0), r2[e4] = 255 * o2[0] | 0;
      i2.push(r2), a2++;
    }
    return 1 !== n2 && 4 !== n2 || 0 === a2 ? null : i2;
  }
  handleTilingType(e2, t2, i2, n2, a2, s2, r2, o2) {
    const l2 = new OperatorList(), c2 = Dict.merge({ xref: this.xref, dictArray: [a2.get("Resources"), i2] });
    return this.getOperatorList({ stream: n2, task: r2, resources: c2, operatorList: l2 }).then(function() {
      const i3 = l2.getIR(), n3 = getTilingPatternIR(i3, a2, t2);
      s2.addDependencies(l2.dependencies), s2.addOp(e2, n3), a2.objId && o2.set(null, a2.objId, { operatorListIR: i3, dict: a2 });
    }).catch((e3) => {
      if (!(e3 instanceof ii)) {
        if (!this.options.ignoreErrors) throw e3;
        warn$1(`handleTilingType - ignoring pattern: "${e3}".`);
      }
    });
  }
  async handleSetFont(e2, t2, i2, n2, a2, s2, r2 = null, o2 = null) {
    const l2 = t2?.[0] instanceof Name ? t2[0].name : null, c2 = await this.loadFont(l2, i2, e2, a2, r2, o2);
    return c2.font.isType3Font && n2.addDependencies(c2.type3Dependencies), s2.font = c2.font, c2.send(this.handler), c2.loadedName;
  }
  handleText(e2, t2) {
    const i2 = t2.font, n2 = i2.charsToGlyphs(e2);
    if (i2.data) {
      (!!(t2.textRenderingMode & S) || "Pattern" === t2.fillColorSpace.name || i2.disableFontFace) && PartialEvaluator.buildFontPaths(i2, n2, this.handler, this.options);
    }
    return n2;
  }
  ensureStateFont(e2) {
    if (e2.font) return;
    const t2 = new ti("Missing setFont (Tf) operator before text rendering operator.");
    if (!this.options.ignoreErrors) throw t2;
    warn$1(`ensureStateFont: "${t2}".`);
  }
  async setGState({ resources: e2, gState: t2, operatorList: i2, cacheKey: n2, task: a2, stateManager: s2, localGStateCache: r2, localColorSpaceCache: o2, seenRefs: l2 }) {
    const c2 = t2.objId;
    let h2 = true;
    const d2 = [];
    let u2 = Promise.resolve();
    for (const [n3, r3] of t2) switch (n3) {
      case "Type":
        break;
      case "LW":
        if ("number" != typeof r3) {
          warn$1(`Invalid LW (line width): ${r3}`);
          break;
        }
        d2.push([n3, Math.abs(r3)]);
        break;
      case "LC":
      case "LJ":
      case "ML":
      case "D":
      case "RI":
      case "FL":
      case "CA":
      case "ca":
        d2.push([n3, r3]);
        break;
      case "Font":
        h2 = false, u2 = u2.then(() => this.handleSetFont(e2, null, r3[0], i2, a2, s2.state).then(function(e3) {
          i2.addDependency(e3), d2.push([n3, [e3, r3[1]]]);
        }));
        break;
      case "BM":
        d2.push([n3, normalizeBlendMode(r3)]);
        break;
      case "SMask":
        if (isName(r3, "None")) {
          d2.push([n3, false]);
          break;
        }
        r3 instanceof Dict ? (h2 = false, u2 = u2.then(() => this.handleSMask(r3, e2, i2, a2, s2, o2, l2)), d2.push([n3, true])) : warn$1("Unsupported SMask type");
        break;
      case "TR":
        const t3 = this.handleTransferFunction(r3);
        d2.push([n3, t3]);
        break;
      case "OP":
      case "op":
      case "OPM":
      case "BG":
      case "BG2":
      case "UCR":
      case "UCR2":
      case "TR2":
      case "HT":
      case "SM":
      case "SA":
      case "AIS":
      case "TK":
        info$1("graphic state operator " + n3);
        break;
      default:
        info$1("Unknown graphic state operator " + n3);
    }
    await u2, d2.length > 0 && i2.addOp(fe, [d2]), h2 && r2.set(n2, c2, d2);
  }
  loadFont(e2, t2, i2, n2, a2 = null, s2 = null) {
    const errorFont = async () => new TranslatedFont({ loadedName: "g_font_error", font: new ErrorFont(`Font "${e2}" is not available.`), dict: t2 });
    let r2;
    if (t2) t2 instanceof Ref && (r2 = t2);
    else {
      const t3 = i2.get("Font");
      t3 && (r2 = t3.getRaw(e2));
    }
    if (r2) {
      if (this.type3FontRefs?.has(r2)) return errorFont();
      if (this.fontCache.has(r2)) return this.fontCache.get(r2);
      try {
        t2 = this.xref.fetchIfRef(r2);
      } catch (e3) {
        warn$1(`loadFont - lookup failed: "${e3}".`);
      }
    }
    if (!(t2 instanceof Dict)) {
      if (!this.options.ignoreErrors && !this.parsingType3Font) return warn$1(`Font "${e2}" is not available.`), errorFont();
      warn$1(`Font "${e2}" is not available -- attempting to fallback to a default font.`), t2 = a2 || PartialEvaluator.fallbackFontDict;
    }
    if (t2.cacheKey && this.fontCache.has(t2.cacheKey)) return this.fontCache.get(t2.cacheKey);
    const { promise: o2, resolve: l2 } = Promise.withResolvers();
    let c2;
    try {
      c2 = this.preEvaluateFont(t2), c2.cssFontInfo = s2;
    } catch (e3) {
      return warn$1(`loadFont - preEvaluateFont failed: "${e3}".`), errorFont();
    }
    const { descriptor: h2, hash: d2 } = c2, u2 = r2 instanceof Ref;
    let g2;
    if (d2 && h2 instanceof Dict) {
      const e3 = h2.fontAliases ||= /* @__PURE__ */ Object.create(null);
      if (e3[d2]) {
        const t3 = e3[d2].aliasRef;
        if (u2 && t3 && this.fontCache.has(t3)) return this.fontCache.putAlias(r2, t3), this.fontCache.get(r2);
      } else e3[d2] = { fontID: this.idFactory.createFontId() };
      u2 && (e3[d2].aliasRef = r2), g2 = e3[d2].fontID;
    } else g2 = this.idFactory.createFontId();
    return assert$1(g2?.startsWith("f"), 'The "fontID" must be (correctly) defined.'), u2 ? this.fontCache.put(r2, o2) : (t2.cacheKey = `cacheKey_${g2}`, this.fontCache.put(t2.cacheKey, o2)), t2.loadedName = `${this.idFactory.getDocId()}_${g2}`, this.translateFont(c2).then(async (e3) => {
      const a3 = new TranslatedFont({ loadedName: t2.loadedName, font: e3, dict: t2 });
      if (e3.isType3Font) try {
        await a3.loadType3Data(this, i2, n2);
      } catch (e4) {
        throw new Error(`Type3 font load error: ${e4}`);
      }
      l2(a3);
    }).catch((e3) => {
      warn$1(`loadFont - translateFont failed: "${e3}".`), l2(new TranslatedFont({ loadedName: t2.loadedName, font: new ErrorFont(e3?.message), dict: t2 }));
    }), o2;
  }
  buildPath(e2, t2, i2) {
    const { pathMinMax: n2, pathBuffer: a2 } = i2;
    switch (0 | e2) {
      case Ce: {
        const e3 = i2.currentPointX = t2[0], s2 = i2.currentPointY = t2[1], r2 = t2[2], o2 = t2[3], l2 = e3 + r2, c2 = s2 + o2;
        0 === r2 || 0 === o2 ? a2.push(Xt, e3, s2, qt, l2, c2, Wt) : a2.push(Xt, e3, s2, qt, l2, s2, qt, l2, c2, qt, e3, c2, Wt), ai.rectBoundingBox(e3, s2, l2, c2, n2);
        break;
      }
      case ye: {
        const e3 = i2.currentPointX = t2[0], s2 = i2.currentPointY = t2[1];
        a2.push(Xt, e3, s2), ai.pointBoundingBox(e3, s2, n2);
        break;
      }
      case we: {
        const e3 = i2.currentPointX = t2[0], s2 = i2.currentPointY = t2[1];
        a2.push(qt, e3, s2), ai.pointBoundingBox(e3, s2, n2);
        break;
      }
      case Ae: {
        const e3 = i2.currentPointX, s2 = i2.currentPointY, [r2, o2, l2, c2, h2, d2] = t2;
        i2.currentPointX = h2, i2.currentPointY = d2, a2.push(zt, r2, o2, l2, c2, h2, d2), ai.bezierBoundingBox(e3, s2, r2, o2, l2, c2, h2, d2, n2);
        break;
      }
      case xe: {
        const e3 = i2.currentPointX, s2 = i2.currentPointY, [r2, o2, l2, c2] = t2;
        i2.currentPointX = l2, i2.currentPointY = c2, a2.push(zt, e3, s2, r2, o2, l2, c2), ai.bezierBoundingBox(e3, s2, e3, s2, r2, o2, l2, c2, n2);
        break;
      }
      case Se: {
        const e3 = i2.currentPointX, s2 = i2.currentPointY, [r2, o2, l2, c2] = t2;
        i2.currentPointX = l2, i2.currentPointY = c2, a2.push(zt, r2, o2, l2, c2, l2, c2), ai.bezierBoundingBox(e3, s2, r2, o2, l2, c2, l2, c2, n2);
        break;
      }
      case ve:
        a2.push(Wt);
    }
  }
  _getColorSpace(e2, t2, i2) {
    return ColorSpaceUtils.parse({ cs: e2, xref: this.xref, resources: t2, pdfFunctionFactory: this._pdfFunctionFactory, globalColorSpaceCache: this.globalColorSpaceCache, localColorSpaceCache: i2, asyncIfNotCached: true });
  }
  async _handleColorSpace(e2) {
    try {
      return await e2;
    } catch (e3) {
      if (e3 instanceof ii) return null;
      if (this.options.ignoreErrors) return warn$1(`_handleColorSpace - ignoring ColorSpace: "${e3}".`), null;
      throw e3;
    }
  }
  parseShading({ shading: e2, resources: t2, localColorSpaceCache: i2, localShadingPatternCache: n2 }) {
    let a2, s2 = n2.get(e2);
    if (s2) return s2;
    try {
      a2 = Pattern.parseShading(e2, this.xref, t2, this._pdfFunctionFactory, this.globalColorSpaceCache, i2).getIR();
    } catch (t3) {
      if (t3 instanceof ii) return null;
      if (this.options.ignoreErrors) return warn$1(`parseShading - ignoring shading: "${t3}".`), n2.set(e2, null), null;
      throw t3;
    }
    return s2 = `pattern_${this.idFactory.createObjId()}`, this.parsingType3Font && (s2 = `${this.idFactory.getDocId()}_type3_${s2}`), n2.set(e2, s2), this.parsingType3Font ? this.handler.send("commonobj", [s2, "Pattern", a2]) : this.handler.send("obj", [s2, this.pageIndex, "Pattern", a2]), s2;
  }
  handleColorN(e2, t2, i2, n2, a2, s2, r2, o2, l2, c2) {
    const h2 = i2.pop();
    if (h2 instanceof Name) {
      const d2 = a2.getRaw(h2.name), u2 = d2 instanceof Ref && l2.getByRef(d2);
      if (u2) try {
        const a3 = n2.base ? n2.base.getRgbHex(i2, 0) : null, s3 = getTilingPatternIR(u2.operatorListIR, u2.dict, a3);
        return void e2.addOp(t2, s3);
      } catch {
      }
      const g2 = this.xref.fetchIfRef(d2);
      if (g2) {
        const a3 = g2 instanceof BaseStream ? g2.dict : g2, h3 = a3.get("PatternType");
        if (h3 === vs) {
          const o3 = n2.base ? n2.base.getRgbHex(i2, 0) : null;
          return this.handleTilingType(t2, o3, s2, g2, a3, e2, r2, l2);
        }
        if (h3 === Cs) {
          const i3 = a3.get("Shading"), n3 = this.parseShading({ shading: i3, resources: s2, localColorSpaceCache: o2, localShadingPatternCache: c2 });
          if (n3) {
            const i4 = lookupMatrix(a3.getArray("Matrix"), null);
            e2.addOp(t2, ["Shading", n3, i4]);
          }
          return;
        }
        throw new ti(`Unknown PatternType: ${h3}`);
      }
    }
    throw new ti(`Unknown PatternName: ${h2}`);
  }
  _parseVisibilityExpression(e2, t2, i2) {
    if (++t2 > 10) return void warn$1("Visibility expression is too deeply nested");
    const n2 = e2.length, a2 = this.xref.fetchIfRef(e2[0]);
    if (!(n2 < 2) && a2 instanceof Name) {
      switch (a2.name) {
        case "And":
        case "Or":
        case "Not":
          i2.push(a2.name);
          break;
        default:
          return void warn$1(`Invalid operator ${a2.name} in visibility expression`);
      }
      for (let a3 = 1; a3 < n2; a3++) {
        const n3 = e2[a3], s2 = this.xref.fetchIfRef(n3);
        if (Array.isArray(s2)) {
          const e3 = [];
          i2.push(e3), this._parseVisibilityExpression(s2, t2, e3);
        } else n3 instanceof Ref && i2.push(n3.toString());
      }
    } else warn$1("Invalid visibility expression");
  }
  async parseMarkedContentProps(e2, t2) {
    let i2;
    if (e2 instanceof Name) {
      i2 = t2.get("Properties").get(e2.name);
    } else {
      if (!(e2 instanceof Dict)) throw new ti("Optional content properties malformed.");
      i2 = e2;
    }
    const n2 = i2.get("Type")?.name;
    if ("OCG" === n2) return { type: n2, id: i2.objId };
    if ("OCMD" === n2) {
      const e3 = i2.get("VE");
      if (Array.isArray(e3)) {
        const t4 = [];
        if (this._parseVisibilityExpression(e3, 0, t4), t4.length > 0) return { type: "OCMD", expression: t4 };
      }
      const t3 = i2.get("OCGs");
      if (Array.isArray(t3) || t3 instanceof Dict) {
        const e4 = [];
        if (Array.isArray(t3)) for (const i3 of t3) e4.push(i3.toString());
        else e4.push(t3.objId);
        return { type: n2, ids: e4, policy: i2.get("P") instanceof Name ? i2.get("P").name : null, expression: null };
      }
      if (t3 instanceof Ref) return { type: n2, id: t3.toString() };
    }
    return null;
  }
  getOperatorList({ stream: e2, task: t2, resources: i2, operatorList: n2, initialState: a2 = null, fallbackFontDict: s2 = null, prevRefs: r2 = null }) {
    const o2 = e2.dict?.objId, l2 = new RefSet(r2);
    if (o2) {
      if (r2?.has(o2)) throw new Error(`getOperatorList - ignoring circular reference: ${o2}`);
      l2.put(o2);
    }
    if (i2 ||= Dict.empty, a2 ||= new EvalState(), !n2) throw new Error('getOperatorList: missing "operatorList" parameter');
    const c2 = this, h2 = this.xref, d2 = new LocalImageCache(), u2 = new LocalColorSpaceCache(), g2 = new LocalGStateCache(), f2 = new LocalTilingPatternCache(), p2 = /* @__PURE__ */ new Map(), m2 = i2.get("XObject") || Dict.empty, b2 = i2.get("Pattern") || Dict.empty, y2 = new StateManager(a2), w2 = new EvaluatorPreprocessor(e2, h2, y2), x2 = new TimeSlotManager();
    function closePendingRestoreOPS(e3) {
      for (let e4 = 0, t3 = w2.savedStatesDepth; e4 < t3; e4++) n2.addOp(me, []);
    }
    return new Promise(function promiseBody(e3, a3) {
      const next = function(t3) {
        Promise.all([t3, n2.ready]).then(function() {
          try {
            promiseBody(e3, a3);
          } catch (e4) {
            a3(e4);
          }
        }, a3);
      };
      t2.ensureNotTerminated(), x2.reset();
      const r3 = {};
      let o3, S2, v2, C2, k2, T2;
      for (; !(o3 = x2.check()) && (r3.args = null, w2.read(r3)); ) {
        let e4 = r3.args, a4 = r3.fn;
        switch (0 | a4) {
          case bt:
            if (T2 = e4[0] instanceof Name, k2 = e4[0].name, T2) {
              const t3 = d2.getByName(k2);
              if (t3) {
                addCachedImageOps(n2, t3), e4 = null;
                continue;
              }
            }
            return void next(new Promise(function(e5, a5) {
              if (!T2) throw new ti("XObject must be referred to by name.");
              let s3 = m2.getRaw(k2);
              if (s3 instanceof Ref) {
                const t3 = d2.getByRef(s3) || c2._regionalImageCache.getByRef(s3) || c2.globalImageCache.getData(s3, c2.pageIndex);
                if (t3) return addCachedImageOps(n2, t3), void e5();
                s3 = h2.fetch(s3);
              }
              if (!(s3 instanceof BaseStream)) throw new ti("XObject should be a stream");
              const r5 = s3.dict.get("Subtype");
              if (!(r5 instanceof Name)) throw new ti("XObject should have a Name subtype");
              if ("Form" === r5.name) return y2.save(), void c2.buildFormXObject(i2, s3, null, n2, t2, y2.state.clone({ newPath: true }), u2, l2).then(function() {
                y2.restore(), e5();
              }, a5);
              if ("Image" !== r5.name) {
                if ("PS" !== r5.name) throw new ti(`Unhandled XObject subtype ${r5.name}`);
                info$1("Ignored XObject subtype PS"), e5();
              } else c2.buildPaintImageXObject({ resources: i2, image: s3, operatorList: n2, cacheKey: k2, localImageCache: d2, localColorSpaceCache: u2 }).then(e5, a5);
            }).catch(function(e5) {
              if (!(e5 instanceof ii)) {
                if (!c2.options.ignoreErrors) throw e5;
                warn$1(`getOperatorList - ignoring XObject: "${e5}".`);
              }
            }));
          case He:
            const r4 = e4[1];
            return void next(c2.handleSetFont(i2, e4, null, n2, t2, y2.state, s2).then(function(e5) {
              n2.addDependency(e5), n2.addOp(He, [e5, r4]);
            }));
          case mt:
            const o4 = e4[0].cacheKey;
            if (o4) {
              const t3 = d2.getByName(o4);
              if (t3) {
                addCachedImageOps(n2, t3), e4 = null;
                continue;
              }
            }
            return void next(c2.buildPaintImageXObject({ resources: i2, image: e4[0], isInline: true, operatorList: n2, cacheKey: o4, localImageCache: d2, localColorSpaceCache: u2 }));
          case Ke:
            if (!y2.state.font) {
              c2.ensureStateFont(y2.state);
              continue;
            }
            e4[0] = c2.handleText(e4[0], y2.state);
            break;
          case Ye:
            if (!y2.state.font) {
              c2.ensureStateFont(y2.state);
              continue;
            }
            const w3 = [], x3 = y2.state;
            for (const t3 of e4[0]) "string" == typeof t3 ? w3.push(...c2.handleText(t3, x3)) : "number" == typeof t3 && w3.push(t3);
            e4[0] = w3, a4 = Ke;
            break;
          case Je:
            if (!y2.state.font) {
              c2.ensureStateFont(y2.state);
              continue;
            }
            n2.addOp(Ve), e4[0] = c2.handleText(e4[0], y2.state), a4 = Ke;
            break;
          case Ze:
            if (!y2.state.font) {
              c2.ensureStateFont(y2.state);
              continue;
            }
            n2.addOp(Ve), n2.addOp(Ue, [e4.shift()]), n2.addOp(Le, [e4.shift()]), e4[0] = c2.handleText(e4[0], y2.state), a4 = Ke;
            break;
          case Xe:
            y2.state.textRenderingMode = e4[0];
            break;
          case it: {
            const t3 = c2._getColorSpace(e4[0], i2, u2);
            if (t3 instanceof ColorSpace) {
              y2.state.fillColorSpace = t3;
              continue;
            }
            return void next(c2._handleColorSpace(t3).then((e5) => {
              y2.state.fillColorSpace = e5 || ColorSpaceUtils.gray;
            }));
          }
          case tt: {
            const t3 = c2._getColorSpace(e4[0], i2, u2);
            if (t3 instanceof ColorSpace) {
              y2.state.strokeColorSpace = t3;
              continue;
            }
            return void next(c2._handleColorSpace(t3).then((e5) => {
              y2.state.strokeColorSpace = e5 || ColorSpaceUtils.gray;
            }));
          }
          case st:
            C2 = y2.state.fillColorSpace, e4 = [C2.getRgbHex(e4, 0)], a4 = ht;
            break;
          case nt:
            C2 = y2.state.strokeColorSpace, e4 = [C2.getRgbHex(e4, 0)], a4 = ct;
            break;
          case lt:
            y2.state.fillColorSpace = ColorSpaceUtils.gray, e4 = [ColorSpaceUtils.gray.getRgbHex(e4, 0)], a4 = ht;
            break;
          case ot:
            y2.state.strokeColorSpace = ColorSpaceUtils.gray, e4 = [ColorSpaceUtils.gray.getRgbHex(e4, 0)], a4 = ct;
            break;
          case ut:
            y2.state.fillColorSpace = ColorSpaceUtils.cmyk, e4 = [ColorSpaceUtils.cmyk.getRgbHex(e4, 0)], a4 = ht;
            break;
          case dt:
            y2.state.strokeColorSpace = ColorSpaceUtils.cmyk, e4 = [ColorSpaceUtils.cmyk.getRgbHex(e4, 0)], a4 = ct;
            break;
          case ht:
            y2.state.fillColorSpace = ColorSpaceUtils.rgb, e4 = [ColorSpaceUtils.rgb.getRgbHex(e4, 0)];
            break;
          case ct:
            y2.state.strokeColorSpace = ColorSpaceUtils.rgb, e4 = [ColorSpaceUtils.rgb.getRgbHex(e4, 0)];
            break;
          case rt:
            if (C2 = y2.state.patternFillColorSpace, !C2) {
              if (isNumberArray(e4, null)) {
                e4 = [ColorSpaceUtils.gray.getRgbHex(e4, 0)], a4 = ht;
                break;
              }
              e4 = [], a4 = $t;
              break;
            }
            if ("Pattern" === C2.name) return void next(c2.handleColorN(n2, rt, e4, C2, b2, i2, t2, u2, f2, p2));
            e4 = [C2.getRgbHex(e4, 0)], a4 = ht;
            break;
          case at:
            if (C2 = y2.state.patternStrokeColorSpace, !C2) {
              if (isNumberArray(e4, null)) {
                e4 = [ColorSpaceUtils.gray.getRgbHex(e4, 0)], a4 = ct;
                break;
              }
              e4 = [], a4 = jt;
              break;
            }
            if ("Pattern" === C2.name) return void next(c2.handleColorN(n2, at, e4, C2, b2, i2, t2, u2, f2, p2));
            e4 = [C2.getRgbHex(e4, 0)], a4 = ct;
            break;
          case gt:
            let F2;
            try {
              const t3 = i2.get("Shading");
              if (!t3) throw new ti("No shading resource found");
              if (F2 = t3.get(e4[0].name), !F2) throw new ti("No shading object found");
            } catch (e5) {
              if (e5 instanceof ii) continue;
              if (c2.options.ignoreErrors) {
                warn$1(`getOperatorList - ignoring Shading: "${e5}".`);
                continue;
              }
              throw e5;
            }
            const E2 = c2.parseShading({ shading: F2, resources: i2, localColorSpaceCache: u2, localShadingPatternCache: p2 });
            if (!E2) continue;
            e4 = [E2], a4 = gt;
            break;
          case fe:
            if (T2 = e4[0] instanceof Name, k2 = e4[0].name, T2) {
              const t3 = g2.getByName(k2);
              if (t3) {
                t3.length > 0 && n2.addOp(fe, [t3]), e4 = null;
                continue;
              }
            }
            return void next(new Promise(function(e5, a5) {
              if (!T2) throw new ti("GState must be referred to by name.");
              const s3 = i2.get("ExtGState");
              if (!(s3 instanceof Dict)) throw new ti("ExtGState should be a dictionary.");
              const r5 = s3.get(k2);
              if (!(r5 instanceof Dict)) throw new ti("GState should be a dictionary.");
              c2.setGState({ resources: i2, gState: r5, operatorList: n2, cacheKey: k2, task: t2, stateManager: y2, localGStateCache: g2, localColorSpaceCache: u2, seenRefs: l2 }).then(e5, a5);
            }).catch(function(e5) {
              if (!(e5 instanceof ii)) {
                if (!c2.options.ignoreErrors) throw e5;
                warn$1(`getOperatorList - ignoring ExtGState: "${e5}".`);
              }
            }));
          case oe: {
            const [t3] = e4;
            if ("number" != typeof t3) {
              warn$1(`Invalid setLineWidth: ${t3}`);
              continue;
            }
            e4[0] = Math.abs(t3);
            break;
          }
          case de: {
            const t3 = e4[1];
            if ("number" != typeof t3) {
              warn$1(`Invalid setDash: ${t3}`);
              continue;
            }
            const i3 = e4[0];
            if (!Array.isArray(i3)) {
              warn$1(`Invalid setDash: ${i3}`);
              continue;
            }
            i3.some((e5) => "number" != typeof e5) && (e4[0] = i3.filter((e5) => "number" == typeof e5));
            break;
          }
          case ye:
          case we:
          case Ae:
          case xe:
          case Se:
          case ve:
          case Ce:
            c2.buildPath(a4, e4, y2.state);
            continue;
          case ke:
          case Te:
          case Fe:
          case Ie:
          case Ee:
          case Me:
          case De:
          case Oe:
          case _e: {
            const { state: { pathBuffer: e5, pathMinMax: t3 } } = y2;
            a4 !== Te && a4 !== De && a4 !== Oe || e5.push(Wt), 0 === e5.length ? n2.addOp(Ut, [a4, [null], null]) : (n2.addOp(Ut, [a4, [new Float32Array(e5)], t3.slice()]), e5.length = 0, t3.set([1 / 0, 1 / 0, -1 / 0, -1 / 0], 0));
            continue;
          }
          case Ge:
            n2.addOp(a4, [new Float32Array(e4)]);
            continue;
          case yt:
          case wt:
          case vt:
          case Ct:
            continue;
          case xt:
            if (!(e4[0] instanceof Name)) {
              warn$1(`Expected name for beginMarkedContentProps arg0=${e4[0]}`), n2.addOp(xt, ["OC", null]);
              continue;
            }
            if ("OC" === e4[0].name) return void next(c2.parseMarkedContentProps(e4[1], i2).then((e5) => {
              n2.addOp(xt, ["OC", e5]);
            }).catch((e5) => {
              if (!(e5 instanceof ii)) {
                if (c2.options.ignoreErrors) return warn$1(`getOperatorList - ignoring beginMarkedContentProps: "${e5}".`), void n2.addOp(xt, ["OC", null]);
                throw e5;
              }
            }));
            e4 = [e4[0].name, e4[1] instanceof Dict ? e4[1].get("MCID") : null];
            break;
          default:
            if (null !== e4) {
              for (S2 = 0, v2 = e4.length; S2 < v2 && !(e4[S2] instanceof Dict); S2++) ;
              if (S2 < v2) {
                warn$1("getOperatorList - ignoring operator: " + a4);
                continue;
              }
            }
        }
        n2.addOp(a4, e4);
      }
      o3 ? next(ks) : (closePendingRestoreOPS(), e3());
    }).catch((e3) => {
      if (!(e3 instanceof ii)) {
        if (this.options.ignoreErrors) return warn$1(`getOperatorList - ignoring errors during "${t2.name}" task: "${e3}".`), void closePendingRestoreOPS();
        throw e3;
      }
    });
  }
  getTextContent({ stream: e2, task: i2, resources: n2, stateManager: a2 = null, includeMarkedContent: s2 = false, sink: r2, seenStyles: o2 = /* @__PURE__ */ new Set(), viewBox: l2, lang: c2 = null, markedContentData: h2 = null, disableNormalization: d2 = false, keepWhiteSpace: u2 = false, prevRefs: g2 = null, intersector: f2 = null }) {
    const p2 = e2.dict?.objId, m2 = new RefSet(g2);
    if (p2) {
      if (g2?.has(p2)) throw new Error(`getTextContent - ignoring circular reference: ${p2}`);
      m2.put(p2);
    }
    n2 ||= Dict.empty, a2 ||= new StateManager(new TextState()), s2 && (h2 ||= { level: 0 });
    const b2 = { items: [], styles: /* @__PURE__ */ Object.create(null), lang: c2 }, y2 = { initialized: false, str: [], totalWidth: 0, totalHeight: 0, width: 0, height: 0, vertical: false, prevTransform: null, textAdvanceScale: 0, spaceInFlowMin: 0, spaceInFlowMax: 0, trackingSpaceMin: 1 / 0, negativeSpaceMax: -1 / 0, notASpace: -1 / 0, transform: null, fontName: null, hasEOL: false }, w2 = [" ", " "];
    let x2 = 0;
    function saveLastChar(e3) {
      const t2 = (x2 + 1) % 2, i3 = " " !== w2[x2] && " " === w2[t2];
      return w2[x2] = e3, x2 = t2, !u2 && i3;
    }
    function shouldAddWhitepsace() {
      return !u2 && " " !== w2[x2] && " " === w2[(x2 + 1) % 2];
    }
    function resetLastChars() {
      w2[0] = w2[1] = " ", x2 = 0;
    }
    const S2 = this, v2 = this.xref, C2 = [];
    let k2 = null;
    const T2 = new LocalImageCache(), F2 = new LocalGStateCache(), E2 = new EvaluatorPreprocessor(e2, v2, a2);
    let M2;
    function pushWhitespace({ width: e3 = 0, height: t2 = 0, transform: i3 = y2.prevTransform, fontName: n3 = y2.fontName }) {
      f2?.addExtraChar(" "), b2.items.push({ str: " ", dir: "ltr", width: e3, height: t2, transform: i3, fontName: n3, hasEOL: false });
    }
    function getCurrentTextTransform() {
      const e3 = M2.font, i3 = [M2.fontSize * M2.textHScale, 0, 0, M2.fontSize, 0, M2.textRise];
      if (e3.isType3Font && (M2.fontSize <= 1 || e3.isCharBBox) && !isArrayEqual(M2.fontMatrix, t)) {
        const t2 = e3.bbox[3] - e3.bbox[1];
        t2 > 0 && (i3[3] *= t2 * M2.fontMatrix[3]);
      }
      return ai.transform(M2.ctm, ai.transform(M2.textMatrix, i3));
    }
    function ensureTextContentItem() {
      if (y2.initialized) return y2;
      const { font: e3, loadedName: t2 } = M2;
      if (!o2.has(t2) && (o2.add(t2), b2.styles[t2] = { fontFamily: e3.fallbackName, ascent: e3.ascent, descent: e3.descent, vertical: e3.vertical }, S2.options.fontExtraProperties && e3.systemFontInfo)) {
        const i4 = b2.styles[t2];
        i4.fontSubstitution = e3.systemFontInfo.css, i4.fontSubstitutionLoadedName = e3.systemFontInfo.loadedName;
      }
      y2.fontName = t2;
      const i3 = y2.transform = getCurrentTextTransform();
      e3.vertical ? (y2.width = y2.totalWidth = Math.hypot(i3[0], i3[1]), y2.height = y2.totalHeight = 0, y2.vertical = true) : (y2.width = y2.totalWidth = 0, y2.height = y2.totalHeight = Math.hypot(i3[2], i3[3]), y2.vertical = false);
      const n3 = Math.hypot(M2.textLineMatrix[0], M2.textLineMatrix[1]), a3 = Math.hypot(M2.ctm[0], M2.ctm[1]);
      y2.textAdvanceScale = a3 * n3;
      const { fontSize: s3 } = M2;
      return y2.trackingSpaceMin = 0.102 * s3, y2.notASpace = 0.03 * s3, y2.negativeSpaceMax = -0.2 * s3, y2.spaceInFlowMin = 0.102 * s3, y2.spaceInFlowMax = 0.6 * s3, y2.hasEOL = false, y2.initialized = true, y2;
    }
    function updateAdvanceScale() {
      if (!y2.initialized) return;
      const e3 = Math.hypot(M2.textLineMatrix[0], M2.textLineMatrix[1]), t2 = Math.hypot(M2.ctm[0], M2.ctm[1]) * e3;
      t2 !== y2.textAdvanceScale && (y2.vertical ? (y2.totalHeight += y2.height * y2.textAdvanceScale, y2.height = 0) : (y2.totalWidth += y2.width * y2.textAdvanceScale, y2.width = 0), y2.textAdvanceScale = t2);
    }
    function runBidiTransform(e3) {
      let t2 = e3.str.join("");
      var i3;
      d2 || (i3 = t2, ri || (ri = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, oi = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), t2 = i3.replaceAll(ri, (e4, t3, i4) => t3 ? t3.normalize("NFKC") : oi.get(i4)));
      const n3 = bidi(t2, -1, e3.vertical);
      return { str: n3.str, dir: n3.dir, width: Math.abs(e3.totalWidth), height: Math.abs(e3.totalHeight), transform: e3.transform, fontName: e3.fontName, hasEOL: e3.hasEOL };
    }
    async function handleSetFont(e3, a3) {
      const s3 = await S2.loadFont(e3, a3, n2, i2);
      M2.loadedName = s3.loadedName, M2.font = s3.font, M2.fontMatrix = s3.font.fontMatrix || t;
    }
    function applyInverseRotation(e3, t2, i3) {
      const n3 = Math.hypot(i3[0], i3[1]);
      return [(i3[0] * e3 + i3[1] * t2) / n3, (i3[2] * e3 + i3[3] * t2) / n3];
    }
    function compareWithLastPosition(e3) {
      const t2 = getCurrentTextTransform();
      let i3 = t2[4], n3 = t2[5];
      if (M2.font?.vertical) {
        if (i3 < l2[0] || i3 > l2[2] || n3 + e3 < l2[1] || n3 > l2[3]) return false;
      } else if (i3 + e3 < l2[0] || i3 > l2[2] || n3 < l2[1] || n3 > l2[3]) return false;
      if (!M2.font || !y2.prevTransform) return true;
      let a3 = y2.prevTransform[4], s3 = y2.prevTransform[5];
      if (a3 === i3 && s3 === n3) return true;
      let r3 = -1;
      switch (t2[0] && 0 === t2[1] && 0 === t2[2] ? r3 = t2[0] > 0 ? 0 : 180 : t2[1] && 0 === t2[0] && 0 === t2[3] && (r3 = t2[1] > 0 ? 90 : 270), r3) {
        case 0:
          break;
        case 90:
          [i3, n3] = [n3, i3], [a3, s3] = [s3, a3];
          break;
        case 180:
          [i3, n3, a3, s3] = [-i3, -n3, -a3, -s3];
          break;
        case 270:
          [i3, n3] = [-n3, -i3], [a3, s3] = [-s3, -a3];
          break;
        default:
          [i3, n3] = applyInverseRotation(i3, n3, t2), [a3, s3] = applyInverseRotation(a3, s3, y2.prevTransform);
      }
      if (M2.font.vertical) {
        const e4 = (s3 - n3) / y2.textAdvanceScale, t3 = i3 - a3, r4 = Math.sign(y2.height);
        return e4 < r4 * y2.negativeSpaceMax ? Math.abs(t3) > 0.5 * y2.width ? (appendEOL(), true) : (resetLastChars(), flushTextContentItem(), true) : Math.abs(t3) > y2.width ? (appendEOL(), true) : (e4 <= r4 * y2.notASpace && resetLastChars(), e4 <= r4 * y2.trackingSpaceMin ? shouldAddWhitepsace() ? (resetLastChars(), flushTextContentItem(), pushWhitespace({ height: Math.abs(e4) })) : y2.height += e4 : addFakeSpaces(e4, y2.prevTransform, r4) || (0 === y2.str.length ? (resetLastChars(), pushWhitespace({ height: Math.abs(e4) })) : y2.height += e4), Math.abs(t3) > 0.25 * y2.width && flushTextContentItem(), true);
      }
      const o3 = (i3 - a3) / y2.textAdvanceScale, c3 = n3 - s3, h3 = Math.sign(y2.width);
      return o3 < h3 * y2.negativeSpaceMax ? Math.abs(c3) > 0.5 * y2.height ? (appendEOL(), true) : (resetLastChars(), flushTextContentItem(), true) : Math.abs(c3) > y2.height ? (appendEOL(), true) : (o3 <= h3 * y2.notASpace && resetLastChars(), o3 <= h3 * y2.trackingSpaceMin ? shouldAddWhitepsace() ? (resetLastChars(), flushTextContentItem(), pushWhitespace({ width: Math.abs(o3) })) : y2.width += o3 : addFakeSpaces(o3, y2.prevTransform, h3) || (0 === y2.str.length ? (resetLastChars(), pushWhitespace({ width: Math.abs(o3) })) : y2.width += o3), Math.abs(c3) > 0.25 * y2.height && flushTextContentItem(), true);
    }
    function buildTextContentItem({ chars: e3, extraSpacing: t2 }) {
      const i3 = M2.font;
      if (!e3) {
        const e4 = M2.charSpacing + t2;
        return e4 && (i3.vertical ? M2.translateTextMatrix(0, -e4) : M2.translateTextMatrix(e4 * M2.textHScale, 0)), void (u2 && compareWithLastPosition(0));
      }
      const n3 = i3.charsToGlyphs(e3), a3 = M2.fontMatrix[0] * M2.fontSize;
      for (let e4 = 0, s3 = n3.length; e4 < s3; e4++) {
        const r3 = n3[e4], { category: o3, originalCharCode: l3 } = r3;
        if (o3.isInvisibleFormatMark) continue;
        let c3 = M2.charSpacing + (e4 + 1 === s3 ? t2 : 0), h3 = r3.width;
        i3.vertical && (h3 = r3.vmetric ? r3.vmetric[0] : -h3);
        let d3 = h3 * a3;
        if (32 === l3 && (c3 += M2.wordSpacing), !u2 && o3.isWhitespace) {
          i3.vertical ? (c3 += -d3, M2.translateTextMatrix(0, -c3)) : (c3 += d3, M2.translateTextMatrix(c3 * M2.textHScale, 0)), saveLastChar(" ");
          continue;
        }
        if (!o3.isZeroWidthDiacritic && !compareWithLastPosition(d3)) {
          i3.vertical ? M2.translateTextMatrix(0, d3) : M2.translateTextMatrix(d3 * M2.textHScale, 0);
          continue;
        }
        const g3 = ensureTextContentItem();
        o3.isZeroWidthDiacritic && (d3 = 0), i3.vertical ? (f2?.addGlyph(getCurrentTextTransform(), 0, d3, r3.unicode), M2.translateTextMatrix(0, d3), d3 = Math.abs(d3), g3.height += d3) : (d3 *= M2.textHScale, f2?.addGlyph(getCurrentTextTransform(), d3, 0, r3.unicode), M2.translateTextMatrix(d3, 0), g3.width += d3), d3 && (g3.prevTransform = getCurrentTextTransform());
        const p3 = r3.unicode;
        saveLastChar(p3) && (g3.str.push(" "), f2?.addExtraChar(" ")), f2 || g3.str.push(p3), c3 && (i3.vertical ? M2.translateTextMatrix(0, -c3) : M2.translateTextMatrix(c3 * M2.textHScale, 0));
      }
    }
    function appendEOL() {
      f2?.addExtraChar("\n"), resetLastChars(), y2.initialized ? (y2.hasEOL = true, flushTextContentItem()) : b2.items.push({ str: "", dir: "ltr", width: 0, height: 0, transform: getCurrentTextTransform(), fontName: M2.loadedName, hasEOL: true });
    }
    function addFakeSpaces(e3, t2, i3) {
      if (i3 * y2.spaceInFlowMin <= e3 && e3 <= i3 * y2.spaceInFlowMax) return y2.initialized && (resetLastChars(), y2.str.push(" "), f2?.addExtraChar(" ")), false;
      const n3 = y2.fontName;
      let a3 = 0;
      return y2.vertical && (a3 = e3, e3 = 0), flushTextContentItem(), resetLastChars(), pushWhitespace({ width: Math.abs(e3), height: Math.abs(a3), transform: t2 || getCurrentTextTransform(), fontName: n3 }), true;
    }
    function flushTextContentItem() {
      y2.initialized && y2.str && (y2.vertical ? y2.totalHeight += y2.height * y2.textAdvanceScale : y2.totalWidth += y2.width * y2.textAdvanceScale, b2.items.push(runBidiTransform(y2)), y2.initialized = false, y2.str.length = 0);
    }
    function enqueueChunk(e3 = false) {
      const t2 = b2.items.length;
      0 !== t2 && (e3 && t2 < 10 || (r2?.enqueue(b2, t2), b2.items = [], b2.styles = /* @__PURE__ */ Object.create(null)));
    }
    const D2 = new TimeSlotManager();
    return new Promise(function promiseBody(e3, t2) {
      const next = function(i3) {
        enqueueChunk(true), Promise.all([i3, r2?.ready]).then(function() {
          try {
            promiseBody(e3, t2);
          } catch (e4) {
            t2(e4);
          }
        }, t2);
      };
      i2.ensureNotTerminated(), D2.reset();
      const g3 = {};
      let f3, p3, y3, w3 = [];
      for (; !(f3 = D2.check()) && (w3.length = 0, g3.args = w3, E2.read(g3)); ) {
        const e4 = M2;
        M2 = a2.state;
        const t3 = g3.fn;
        switch (w3 = g3.args, 0 | t3) {
          case He:
            const t4 = w3[0].name, g4 = w3[1];
            if (M2.font && t4 === M2.fontName && g4 === M2.fontSize) break;
            return flushTextContentItem(), M2.fontName = t4, M2.fontSize = g4, void next(handleSetFont(t4, null));
          case qe:
            M2.textRise = w3[0];
            break;
          case je:
            M2.textHScale = w3[0] / 100;
            break;
          case $e:
            M2.leading = w3[0];
            break;
          case ze:
            M2.translateTextLineMatrix(w3[0], w3[1]), M2.textMatrix = M2.textLineMatrix.slice();
            break;
          case We:
            M2.leading = -w3[1], M2.translateTextLineMatrix(w3[0], w3[1]), M2.textMatrix = M2.textLineMatrix.slice();
            break;
          case Ve:
            M2.carriageReturn();
            break;
          case Ge:
            M2.setTextMatrix(w3[0], w3[1], w3[2], w3[3], w3[4], w3[5]), M2.setTextLineMatrix(w3[0], w3[1], w3[2], w3[3], w3[4], w3[5]), updateAdvanceScale();
            break;
          case Le:
            M2.charSpacing = w3[0];
            break;
          case Ue:
            M2.wordSpacing = w3[0];
            break;
          case Be:
            M2.textMatrix = pi.slice(), M2.textLineMatrix = pi.slice();
            break;
          case Ye:
            if (!a2.state.font) {
              S2.ensureStateFont(a2.state);
              continue;
            }
            const f4 = (M2.font.vertical ? 1 : -1) * M2.fontSize / 1e3, x3 = w3[0];
            for (let e5 = 0, t5 = x3.length; e5 < t5; e5++) {
              const t6 = x3[e5];
              if ("string" == typeof t6) C2.push(t6);
              else if ("number" == typeof t6 && 0 !== t6) {
                const e6 = C2.join("");
                C2.length = 0, buildTextContentItem({ chars: e6, extraSpacing: t6 * f4 });
              }
            }
            if (C2.length > 0) {
              const e5 = C2.join("");
              C2.length = 0, buildTextContentItem({ chars: e5, extraSpacing: 0 });
            }
            break;
          case Ke:
            if (!a2.state.font) {
              S2.ensureStateFont(a2.state);
              continue;
            }
            buildTextContentItem({ chars: w3[0], extraSpacing: 0 });
            break;
          case Je:
            if (!a2.state.font) {
              S2.ensureStateFont(a2.state);
              continue;
            }
            M2.carriageReturn(), buildTextContentItem({ chars: w3[0], extraSpacing: 0 });
            break;
          case Ze:
            if (!a2.state.font) {
              S2.ensureStateFont(a2.state);
              continue;
            }
            M2.wordSpacing = w3[0], M2.charSpacing = w3[1], M2.carriageReturn(), buildTextContentItem({ chars: w3[2], extraSpacing: 0 });
            break;
          case bt:
            if (flushTextContentItem(), k2 ??= n2.get("XObject") || Dict.empty, y3 = w3[0] instanceof Name, p3 = w3[0].name, y3 && T2.getByName(p3)) break;
            return void next(new Promise(function(e5, t5) {
              if (!y3) throw new ti("XObject must be referred to by name.");
              let g5 = k2.getRaw(p3);
              if (g5 instanceof Ref) {
                if (T2.getByRef(g5)) return void e5();
                if (S2.globalImageCache.getData(g5, S2.pageIndex)) return void e5();
                g5 = v2.fetch(g5);
              }
              if (!(g5 instanceof BaseStream)) throw new ti("XObject should be a stream");
              const { dict: f5 } = g5, b3 = f5.get("Subtype");
              if (!(b3 instanceof Name)) throw new ti("XObject should have a Name subtype");
              if ("Form" !== b3.name) return T2.set(p3, f5.objId, true), void e5();
              const w4 = a2.state.clone(), x4 = new StateManager(w4), C3 = lookupMatrix(f5.getArray("Matrix"), null);
              C3 && x4.transform(C3);
              const F3 = f5.get("Resources");
              enqueueChunk();
              const E3 = { enqueueInvoked: false, enqueue(e6, t6) {
                this.enqueueInvoked = true, r2.enqueue(e6, t6);
              }, get desiredSize() {
                return r2.desiredSize ?? 0;
              }, get ready() {
                return r2.ready;
              } };
              S2.getTextContent({ stream: g5, task: i2, resources: F3 instanceof Dict ? F3 : n2, stateManager: x4, includeMarkedContent: s2, sink: r2 && E3, seenStyles: o2, viewBox: l2, lang: c2, markedContentData: h2, disableNormalization: d2, keepWhiteSpace: u2, prevRefs: m2 }).then(function() {
                E3.enqueueInvoked || T2.set(p3, f5.objId, true), e5();
              }, t5);
            }).catch(function(e5) {
              if (!(e5 instanceof ii)) {
                if (!S2.options.ignoreErrors) throw e5;
                warn$1(`getTextContent - ignoring XObject: "${e5}".`);
              }
            }));
          case fe:
            if (y3 = w3[0] instanceof Name, p3 = w3[0].name, y3 && F2.getByName(p3)) break;
            return void next(new Promise(function(e5, t5) {
              if (!y3) throw new ti("GState must be referred to by name.");
              const i3 = n2.get("ExtGState");
              if (!(i3 instanceof Dict)) throw new ti("ExtGState should be a dictionary.");
              const a3 = i3.get(p3);
              if (!(a3 instanceof Dict)) throw new ti("GState should be a dictionary.");
              const s3 = a3.get("Font");
              if (!s3) return F2.set(p3, a3.objId, true), void e5();
              flushTextContentItem(), M2.fontName = null, M2.fontSize = s3[1], handleSetFont(null, s3[0]).then(e5, t5);
            }).catch(function(e5) {
              if (!(e5 instanceof ii)) {
                if (!S2.options.ignoreErrors) throw e5;
                warn$1(`getTextContent - ignoring ExtGState: "${e5}".`);
              }
            }));
          case At:
            flushTextContentItem(), s2 && (h2.level++, b2.items.push({ type: "beginMarkedContent", tag: w3[0] instanceof Name ? w3[0].name : null }));
            break;
          case xt:
            if (flushTextContentItem(), s2) {
              h2.level++;
              let e5 = null;
              w3[1] instanceof Dict && (e5 = w3[1].get("MCID")), b2.items.push({ type: "beginMarkedContentProps", id: Number.isInteger(e5) ? `${S2.idFactory.getPageObjId()}_mc${e5}` : null, tag: w3[0] instanceof Name ? w3[0].name : null });
            }
            break;
          case St:
            if (flushTextContentItem(), s2) {
              if (0 === h2.level) break;
              h2.level--, b2.items.push({ type: "endMarkedContent" });
            }
            break;
          case me:
            !e4 || e4.font === M2.font && e4.fontSize === M2.fontSize && e4.fontName === M2.fontName || flushTextContentItem();
        }
        if (b2.items.length >= (r2?.desiredSize ?? 1)) {
          f3 = true;
          break;
        }
      }
      f3 ? next(ks) : (flushTextContentItem(), enqueueChunk(), e3());
    }).catch((e3) => {
      if (!(e3 instanceof ii)) {
        if (this.options.ignoreErrors) return warn$1(`getTextContent - ignoring errors during "${i2.name}" task: "${e3}".`), flushTextContentItem(), void enqueueChunk();
        throw e3;
      }
    });
  }
  async extractDataStructures(e2, t2) {
    const i2 = this.xref;
    let n2;
    const a2 = this.readToUnicode(t2.toUnicode);
    if (t2.composite) {
      const i3 = e2.get("CIDSystemInfo");
      i3 instanceof Dict && (t2.cidSystemInfo = { registry: stringToPDFString(i3.get("Registry")), ordering: stringToPDFString(i3.get("Ordering")), supplement: i3.get("Supplement") });
      try {
        const t3 = e2.get("CIDToGIDMap");
        t3 instanceof BaseStream && (n2 = t3.getBytes());
      } catch (e3) {
        if (!this.options.ignoreErrors) throw e3;
        warn$1(`extractDataStructures - ignoring CIDToGIDMap data: "${e3}".`);
      }
    }
    const s2 = [];
    let r2, o2 = null;
    if (e2.has("Encoding")) {
      if (r2 = e2.get("Encoding"), r2 instanceof Dict) {
        if (o2 = r2.get("BaseEncoding"), o2 = o2 instanceof Name ? o2.name : null, r2.has("Differences")) {
          const e3 = r2.get("Differences");
          let t3 = 0;
          for (const n3 of e3) {
            const e4 = i2.fetchIfRef(n3);
            if ("number" == typeof e4) t3 = e4;
            else {
              if (!(e4 instanceof Name)) throw new ti(`Invalid entry in 'Differences' array: ${e4}`);
              s2[t3++] = e4.name;
            }
          }
        }
      } else if (r2 instanceof Name) o2 = r2.name;
      else {
        const e3 = "Encoding is not a Name nor a Dict";
        if (!this.options.ignoreErrors) throw new ti(e3);
        warn$1(e3);
      }
      "MacRomanEncoding" !== o2 && "MacExpertEncoding" !== o2 && "WinAnsiEncoding" !== o2 && (o2 = null);
    }
    const l2 = !t2.file || t2.isInternalFont, c2 = Xn()[t2.name];
    if (o2 && l2 && c2 && (o2 = null), o2) t2.defaultEncoding = getEncoding(o2);
    else {
      let e3 = !!(t2.flags & kn);
      const i3 = !!(t2.flags & Tn);
      "TrueType" === t2.type && e3 && i3 && 0 !== s2.length && (t2.flags &= -5, e3 = false), r2 = un, "TrueType" !== t2.type || i3 || (r2 = gn), (e3 || c2) && (r2 = dn, l2 && (/Symbol/i.test(t2.name) ? r2 = fn : /Dingbats/i.test(t2.name) ? r2 = pn : /Wingdings/i.test(t2.name) && (r2 = gn))), t2.defaultEncoding = r2;
    }
    t2.differences = s2, t2.baseEncodingName = o2, t2.hasEncoding = !!o2 || s2.length > 0, t2.dict = e2, t2.toUnicode = await a2;
    const h2 = await this.buildToUnicode(t2);
    return t2.toUnicode = h2, n2 && (t2.cidToGidMap = this.readCidToGidMap(n2, h2)), t2;
  }
  _simpleFontToUnicode(e2, t2 = false) {
    assert$1(!e2.composite, "Must be a simple font.");
    const i2 = [], n2 = e2.defaultEncoding.slice(), a2 = e2.baseEncodingName, s2 = e2.differences;
    for (const e3 in s2) {
      const t3 = s2[e3];
      ".notdef" !== t3 && (n2[e3] = t3);
    }
    const r2 = mn();
    for (const s3 in n2) {
      let o2 = n2[s3];
      if ("" === o2) continue;
      let l2 = r2[o2];
      if (void 0 !== l2) {
        i2[s3] = String.fromCharCode(l2);
        continue;
      }
      let c2 = 0;
      switch (o2[0]) {
        case "G":
          3 === o2.length && (c2 = parseInt(o2.substring(1), 16));
          break;
        case "g":
          5 === o2.length && (c2 = parseInt(o2.substring(1), 16));
          break;
        case "C":
        case "c":
          if (o2.length >= 3 && o2.length <= 4) {
            const i3 = o2.substring(1);
            if (t2) {
              c2 = parseInt(i3, 16);
              break;
            }
            if (c2 = +i3, Number.isNaN(c2) && Number.isInteger(parseInt(i3, 16))) return this._simpleFontToUnicode(e2, true);
          }
          break;
        case "u":
          l2 = getUnicodeForGlyph(o2, r2), -1 !== l2 && (c2 = l2);
          break;
        default:
          switch (o2) {
            case "f_h":
            case "f_t":
            case "T_h":
              i2[s3] = o2.replaceAll("_", "");
              continue;
          }
      }
      if (c2 > 0 && c2 <= 1114111 && Number.isInteger(c2)) {
        if (a2 && c2 === +s3) {
          const e3 = getEncoding(a2);
          if (e3 && (o2 = e3[s3])) {
            i2[s3] = String.fromCharCode(r2[o2]);
            continue;
          }
        }
        i2[s3] = String.fromCodePoint(c2);
      }
    }
    return i2;
  }
  async buildToUnicode(e2) {
    if (e2.hasIncludedToUnicodeMap = e2.toUnicode?.length > 0, e2.hasIncludedToUnicodeMap) return !e2.composite && e2.hasEncoding && (e2.fallbackToUnicode = this._simpleFontToUnicode(e2)), e2.toUnicode;
    if (!e2.composite) return new ToUnicodeMap(this._simpleFontToUnicode(e2));
    if (e2.composite && (e2.cMap.builtInCMap && !(e2.cMap instanceof IdentityCMap) || "Adobe" === e2.cidSystemInfo?.registry && ("GB1" === e2.cidSystemInfo.ordering || "CNS1" === e2.cidSystemInfo.ordering || "Japan1" === e2.cidSystemInfo.ordering || "Korea1" === e2.cidSystemInfo.ordering))) {
      const { registry: t2, ordering: i2 } = e2.cidSystemInfo, n2 = Name.get(`${t2}-${i2}-UCS2`), a2 = await CMapFactory.create({ encoding: n2, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null }), s2 = [], r2 = [];
      return e2.cMap.forEach(function(e3, t3) {
        if (t3 > 65535) throw new ti("Max size of CID is 65,535");
        const i3 = a2.lookup(t3);
        if (i3) {
          r2.length = 0;
          for (let e4 = 0, t4 = i3.length; e4 < t4; e4 += 2) r2.push((i3.charCodeAt(e4) << 8) + i3.charCodeAt(e4 + 1));
          s2[e3] = String.fromCharCode(...r2);
        }
      }), new ToUnicodeMap(s2);
    }
    return new IdentityToUnicodeMap(e2.firstChar, e2.lastChar);
  }
  async readToUnicode(e2) {
    if (!e2) return null;
    if (e2 instanceof Name) {
      const t2 = await CMapFactory.create({ encoding: e2, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
      return t2 instanceof IdentityCMap ? new IdentityToUnicodeMap(0, 65535) : new ToUnicodeMap(t2.getMap());
    }
    if (e2 instanceof BaseStream) try {
      const t2 = await CMapFactory.create({ encoding: e2, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
      if (t2 instanceof IdentityCMap) return new IdentityToUnicodeMap(0, 65535);
      const i2 = new Array(t2.length);
      return t2.forEach(function(e3, t3) {
        if ("number" == typeof t3) return void (i2[e3] = String.fromCodePoint(t3));
        t3.length % 2 != 0 && (t3 = "\0" + t3);
        const n2 = [];
        for (let e4 = 0; e4 < t3.length; e4 += 2) {
          const i3 = t3.charCodeAt(e4) << 8 | t3.charCodeAt(e4 + 1);
          if (55296 != (63488 & i3)) {
            n2.push(i3);
            continue;
          }
          e4 += 2;
          const a2 = t3.charCodeAt(e4) << 8 | t3.charCodeAt(e4 + 1);
          n2.push(((1023 & i3) << 10) + (1023 & a2) + 65536);
        }
        i2[e3] = String.fromCodePoint(...n2);
      }), new ToUnicodeMap(i2);
    } catch (e3) {
      if (e3 instanceof ii) return null;
      if (this.options.ignoreErrors) return warn$1(`readToUnicode - ignoring ToUnicode data: "${e3}".`), null;
      throw e3;
    }
    return null;
  }
  readCidToGidMap(e2, t2) {
    const i2 = [];
    for (let n2 = 0, a2 = e2.length; n2 < a2; n2++) {
      const a3 = e2[n2++] << 8 | e2[n2], s2 = n2 >> 1;
      (0 !== a3 || t2.has(s2)) && (i2[s2] = a3);
    }
    return i2;
  }
  extractWidths(e2, t2, i2) {
    const n2 = this.xref;
    let a2 = [], s2 = 0;
    const r2 = [];
    let o2;
    if (i2.composite) {
      const t3 = e2.get("DW");
      s2 = "number" == typeof t3 ? Math.ceil(t3) : 1e3;
      const l3 = e2.get("W");
      if (Array.isArray(l3)) for (let e3 = 0, t4 = l3.length; e3 < t4; e3++) {
        let t5 = n2.fetchIfRef(l3[e3++]);
        if (!Number.isInteger(t5)) break;
        const i3 = n2.fetchIfRef(l3[e3]);
        if (Array.isArray(i3)) for (const e4 of i3) {
          const i4 = n2.fetchIfRef(e4);
          "number" == typeof i4 && (a2[t5] = i4), t5++;
        }
        else {
          if (!Number.isInteger(i3)) break;
          {
            const s3 = n2.fetchIfRef(l3[++e3]);
            if ("number" != typeof s3) continue;
            for (let e4 = t5; e4 <= i3; e4++) a2[e4] = s3;
          }
        }
      }
      if (i2.vertical) {
        const t4 = e2.getArray("DW2");
        let i3 = isNumberArray(t4, 2) ? t4 : [880, -1e3];
        if (o2 = [i3[1], 0.5 * s2, i3[0]], i3 = e2.get("W2"), Array.isArray(i3)) for (let e3 = 0, t5 = i3.length; e3 < t5; e3++) {
          let t6 = n2.fetchIfRef(i3[e3++]);
          if (!Number.isInteger(t6)) break;
          const a3 = n2.fetchIfRef(i3[e3]);
          if (Array.isArray(a3)) for (let e4 = 0, i4 = a3.length; e4 < i4; e4++) {
            const i5 = [n2.fetchIfRef(a3[e4++]), n2.fetchIfRef(a3[e4++]), n2.fetchIfRef(a3[e4])];
            isNumberArray(i5, null) && (r2[t6] = i5), t6++;
          }
          else {
            if (!Number.isInteger(a3)) break;
            {
              const s3 = [n2.fetchIfRef(i3[++e3]), n2.fetchIfRef(i3[++e3]), n2.fetchIfRef(i3[++e3])];
              if (!isNumberArray(s3, null)) continue;
              for (let e4 = t6; e4 <= a3; e4++) r2[e4] = s3;
            }
          }
        }
      }
    } else {
      const r3 = e2.get("Widths");
      if (Array.isArray(r3)) {
        let e3 = i2.firstChar;
        for (const t3 of r3) {
          const i3 = n2.fetchIfRef(t3);
          "number" == typeof i3 && (a2[e3] = i3), e3++;
        }
        const o3 = t2.get("MissingWidth");
        s2 = "number" == typeof o3 ? o3 : 0;
      } else {
        const t3 = e2.get("BaseFont");
        if (t3 instanceof Name) {
          const e3 = this.getBaseFontMetrics(t3.name);
          a2 = this.buildCharCodeToWidth(e3.widths, i2), s2 = e3.defaultWidth;
        }
      }
    }
    let l2 = true, c2 = s2;
    for (const e3 in a2) {
      const t3 = a2[e3];
      if (t3) if (c2) {
        if (c2 !== t3) {
          l2 = false;
          break;
        }
      } else c2 = t3;
    }
    l2 ? i2.flags |= vn : i2.flags &= -2, i2.defaultWidth = s2, i2.widths = a2, i2.defaultVMetrics = o2, i2.vmetrics = r2;
  }
  isSerifFont(e2) {
    const t2 = e2.split("-", 1)[0];
    return t2 in Hn() || /serif/gi.test(t2);
  }
  getBaseFontMetrics(e2) {
    let t2 = 0, i2 = /* @__PURE__ */ Object.create(null), n2 = false;
    let a2 = Un()[e2] || e2;
    const s2 = Gn();
    a2 in s2 || (a2 = this.isSerifFont(e2) ? "Times-Roman" : "Helvetica");
    const r2 = s2[a2];
    return "number" == typeof r2 ? (t2 = r2, n2 = true) : i2 = r2(), { defaultWidth: t2, monospace: n2, widths: i2 };
  }
  buildCharCodeToWidth(e2, t2) {
    const i2 = /* @__PURE__ */ Object.create(null), n2 = t2.differences, a2 = t2.defaultEncoding;
    for (let t3 = 0; t3 < 256; t3++) t3 in n2 && e2[n2[t3]] ? i2[t3] = e2[n2[t3]] : t3 in a2 && e2[a2[t3]] && (i2[t3] = e2[a2[t3]]);
    return i2;
  }
  preEvaluateFont(e2) {
    const t2 = e2;
    let i2 = e2.get("Subtype");
    if (!(i2 instanceof Name)) throw new ti("invalid font Subtype");
    let n2, a2 = false;
    if ("Type0" === i2.name) {
      const t3 = e2.get("DescendantFonts");
      if (!t3) throw new ti("Descendant fonts are not specified");
      if (!((e2 = Array.isArray(t3) ? this.xref.fetchIfRef(t3[0]) : t3) instanceof Dict)) throw new ti("Descendant font is not a dictionary.");
      if (i2 = e2.get("Subtype"), !(i2 instanceof Name)) throw new ti("invalid font Subtype");
      a2 = true;
    }
    let s2 = e2.get("FirstChar");
    Number.isInteger(s2) || (s2 = 0);
    let r2 = e2.get("LastChar");
    Number.isInteger(r2) || (r2 = a2 ? 65535 : 255);
    const o2 = e2.get("FontDescriptor"), l2 = e2.get("ToUnicode") || t2.get("ToUnicode");
    if (o2) {
      n2 = new xs();
      const i3 = t2.getRaw("Encoding");
      if (i3 instanceof Name) n2.update(i3.name);
      else if (i3 instanceof Ref) n2.update(i3.toString());
      else if (i3 instanceof Dict) {
        for (const e3 of i3.getRawValues()) if (e3 instanceof Name) n2.update(e3.name);
        else if (e3 instanceof Ref) n2.update(e3.toString());
        else if (Array.isArray(e3)) {
          const t3 = e3.length, i4 = new Array(t3);
          for (let n3 = 0; n3 < t3; n3++) {
            const t4 = e3[n3];
            t4 instanceof Name ? i4[n3] = t4.name : ("number" == typeof t4 || t4 instanceof Ref) && (i4[n3] = t4.toString());
          }
          n2.update(i4.join());
        }
      }
      if (n2.update(`${s2}-${r2}`), l2 instanceof BaseStream) {
        const e3 = l2.str || l2, t3 = e3.buffer ? new Uint8Array(e3.buffer.buffer, 0, e3.bufferLength) : new Uint8Array(e3.bytes.buffer, e3.start, e3.end - e3.start);
        n2.update(t3);
      } else l2 instanceof Name && n2.update(l2.name);
      const o3 = e2.get("Widths") || t2.get("Widths");
      if (Array.isArray(o3)) {
        const e3 = [];
        for (const t3 of o3) ("number" == typeof t3 || t3 instanceof Ref) && e3.push(t3.toString());
        n2.update(e3.join());
      }
      if (a2) {
        n2.update("compositeFont");
        const i4 = e2.get("W") || t2.get("W");
        if (Array.isArray(i4)) {
          const e3 = [];
          for (const t3 of i4) if ("number" == typeof t3 || t3 instanceof Ref) e3.push(t3.toString());
          else if (Array.isArray(t3)) {
            const i5 = [];
            for (const e4 of t3) ("number" == typeof e4 || e4 instanceof Ref) && i5.push(e4.toString());
            e3.push(`[${i5.join()}]`);
          }
          n2.update(e3.join());
        }
        const a3 = e2.getRaw("CIDToGIDMap") || t2.getRaw("CIDToGIDMap");
        a3 instanceof Name ? n2.update(a3.name) : a3 instanceof Ref ? n2.update(a3.toString()) : a3 instanceof BaseStream && n2.update(a3.peekBytes());
      }
    }
    return { descriptor: o2, dict: e2, baseDict: t2, composite: a2, type: i2.name, firstChar: s2, lastChar: r2, toUnicode: l2, hash: n2 ? n2.hexdigest() : "" };
  }
  async translateFont({ descriptor: e2, dict: i2, baseDict: n2, composite: a2, type: s2, firstChar: r2, lastChar: o2, toUnicode: l2, cssFontInfo: c2 }) {
    const h2 = "Type3" === s2;
    if (!e2) {
      if (!h2) {
        let e3 = i2.get("BaseFont");
        if (!(e3 instanceof Name)) throw new ti("Base font is not specified");
        e3 = e3.name.replaceAll(/[,_]/g, "-");
        const t2 = this.getBaseFontMetrics(e3), a3 = e3.split("-", 1)[0], c3 = (this.isSerifFont(a3) ? Cn : 0) | (t2.monospace ? vn : 0) | (Xn()[a3] ? kn : Tn), d3 = { type: s2, name: e3, loadedName: n2.loadedName, systemFontInfo: null, widths: t2.widths, defaultWidth: t2.defaultWidth, isSimulatedFlags: true, flags: c3, firstChar: r2, lastChar: o2, toUnicode: l2, xHeight: 0, capHeight: 0, italicAngle: 0, isType3Font: h2 }, u3 = i2.get("Widths"), g3 = getStandardFontName(e3);
        let f3 = null;
        g3 && (f3 = await this.fetchStandardFontData(g3), d3.isInternalFont = !!f3), !d3.isInternalFont && this.options.useSystemFonts && (d3.systemFontInfo = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, e3, g3, s2));
        const p3 = await this.extractDataStructures(i2, d3);
        if (Array.isArray(u3)) {
          const e4 = [];
          let t3 = r2;
          for (const i3 of u3) {
            const n3 = this.xref.fetchIfRef(i3);
            "number" == typeof n3 && (e4[t3] = n3), t3++;
          }
          p3.widths = e4;
        } else p3.widths = this.buildCharCodeToWidth(t2.widths, p3);
        return new Font(e3, f3, p3, this.options);
      }
      e2 = Dict.empty;
    }
    let d2 = e2.get("FontName"), u2 = i2.get("BaseFont");
    "string" == typeof d2 && (d2 = Name.get(d2)), "string" == typeof u2 && (u2 = Name.get(u2));
    const g2 = d2?.name, f2 = u2?.name;
    if (h2 ? g2 || (d2 = Name.get(s2)) : g2 !== f2 && (info$1(`The FontDescriptor's FontName is "${g2}" but should be the same as the Font's BaseFont "${f2}".`), g2 && f2 && (f2.startsWith(g2) || !isKnownFontName(g2) && isKnownFontName(f2)) && (d2 = null), d2 ||= u2), !(d2 instanceof Name)) throw new ti("invalid font name");
    let p2, m2, b2, y2, w2;
    try {
      if (p2 = e2.get("FontFile", "FontFile2", "FontFile3"), p2) {
        if (!(p2 instanceof BaseStream)) throw new ti("FontFile should be a stream");
        if (p2.isEmpty) throw new ti("FontFile is empty");
      }
    } catch (e3) {
      if (!this.options.ignoreErrors) throw e3;
      warn$1(`translateFont - fetching "${d2.name}" font file: "${e3}".`), p2 = null;
    }
    let x2 = false, S2 = null, v2 = null;
    if (p2) {
      if (p2.dict) {
        const e3 = p2.dict.get("Subtype");
        e3 instanceof Name && (m2 = e3.name), b2 = p2.dict.get("Length1"), y2 = p2.dict.get("Length2"), w2 = p2.dict.get("Length3");
      }
    } else if (c2) {
      const e3 = getXfaFontName(d2.name);
      e3 && (c2.fontFamily = `${c2.fontFamily}-PdfJS-XFA`, c2.metrics = e3.metrics || null, S2 = e3.factors || null, p2 = await this.fetchStandardFontData(e3.name), x2 = !!p2, n2 = i2 = getXfaFontDict(d2.name), a2 = true);
    } else if (!h2) {
      const e3 = getStandardFontName(d2.name);
      e3 && (p2 = await this.fetchStandardFontData(e3), x2 = !!p2), !x2 && this.options.useSystemFonts && (v2 = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, d2.name, e3, s2));
    }
    const C2 = lookupMatrix(i2.getArray("FontMatrix"), t), k2 = lookupNormalRect(e2.getArray("FontBBox") || i2.getArray("FontBBox"), h2 ? [0, 0, 0, 0] : void 0);
    let T2 = e2.get("Ascent");
    "number" != typeof T2 && (T2 = void 0);
    let F2 = e2.get("Descent");
    "number" != typeof F2 && (F2 = void 0);
    let E2 = e2.get("XHeight");
    "number" != typeof E2 && (E2 = 0);
    let M2 = e2.get("CapHeight");
    "number" != typeof M2 && (M2 = 0);
    let D2 = e2.get("Flags");
    Number.isInteger(D2) || (D2 = 0);
    let O2 = e2.get("ItalicAngle");
    "number" != typeof O2 && (O2 = 0);
    const _2 = { type: s2, name: d2.name, subtype: m2, file: p2, length1: b2, length2: y2, length3: w2, isInternalFont: x2, loadedName: n2.loadedName, composite: a2, fixedPitch: false, fontMatrix: C2, firstChar: r2, lastChar: o2, toUnicode: l2, bbox: k2, ascent: T2, descent: F2, xHeight: E2, capHeight: M2, flags: D2, italicAngle: O2, isType3Font: h2, cssFontInfo: c2, scaleFactors: S2, systemFontInfo: v2 };
    if (a2) {
      const e3 = n2.get("Encoding");
      e3 instanceof Name && (_2.cidEncoding = e3.name);
      const t2 = await CMapFactory.create({ encoding: e3, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
      _2.cMap = t2, _2.vertical = _2.cMap.vertical;
    }
    const R2 = await this.extractDataStructures(i2, _2);
    return this.extractWidths(i2, e2, R2), new Font(d2.name, p2, R2, this.options);
  }
  static buildFontPaths(e2, t2, i2, n2) {
    function buildPath(t3) {
      const a2 = `${e2.loadedName}_path_${t3}`;
      try {
        if (e2.renderer.hasBuiltPath(t3)) return;
        i2.send("commonobj", [a2, "FontPath", e2.renderer.getPathJs(t3)]);
      } catch (e3) {
        if (n2.ignoreErrors) return void warn$1(`buildFontPaths - ignoring ${a2} glyph: "${e3}".`);
        throw e3;
      }
    }
    for (const e3 of t2) {
      buildPath(e3.fontChar);
      const t3 = e3.accent;
      t3?.fontChar && buildPath(t3.fontChar);
    }
  }
  static get fallbackFontDict() {
    const e2 = new Dict();
    return e2.set("BaseFont", Name.get("Helvetica")), e2.set("Type", Name.get("FallbackType")), e2.set("Subtype", Name.get("FallbackType")), e2.set("Encoding", Name.get("WinAnsiEncoding")), shadow$1(this, "fallbackFontDict", e2);
  }
}
class TranslatedFont {
  #ne = false;
  #ae = null;
  constructor({ loadedName: e2, font: t2, dict: i2 }) {
    this.loadedName = e2, this.font = t2, this.dict = i2, this.type3Dependencies = t2.isType3Font ? /* @__PURE__ */ new Set() : null;
  }
  send(e2) {
    if (this.#ne) return;
    this.#ne = true;
    const t2 = this.font.exportData(), i2 = [];
    t2.data && (t2.data.charProcOperatorList && (t2.charProcOperatorList = t2.data.charProcOperatorList), t2.data = ds.write(t2.data), i2.push(t2.data)), e2.send("commonobj", [this.loadedName, "Font", t2], i2);
  }
  fallback(e2, t2) {
    this.font.data && (this.font.disableFontFace = true, PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, e2, t2));
  }
  loadType3Data(e2, t2, i2) {
    if (this.#ae) return this.#ae;
    const { font: n2, type3Dependencies: a2 } = this;
    assert$1(n2.isType3Font, "Must be a Type3 font.");
    const s2 = e2.clone({ ignoreErrors: false }), r2 = new RefSet(e2.type3FontRefs);
    this.dict.objId && !r2.has(this.dict.objId) && r2.put(this.dict.objId), s2.type3FontRefs = r2;
    let o2 = Promise.resolve();
    const l2 = this.dict.get("CharProcs"), c2 = this.dict.get("Resources") || t2, h2 = /* @__PURE__ */ Object.create(null), [d2, u2, g2, f2] = n2.bbox, p2 = g2 - d2, m2 = f2 - u2, b2 = Math.hypot(p2, m2);
    for (const e3 of l2.getKeys()) o2 = o2.then(() => {
      const t3 = l2.get(e3), n3 = new OperatorList();
      return s2.getOperatorList({ stream: t3, task: i2, resources: c2, operatorList: n3 }).then(() => {
        switch (n3.fnArray[0]) {
          case et:
            this.#se(n3, b2);
            break;
          case Qe:
            b2 || this.#re(n3);
        }
        h2[e3] = n3.getIR();
        for (const e4 of n3.dependencies) a2.add(e4);
      }).catch(function(t4) {
        warn$1(`Type3 font resource "${e3}" is not available.`);
        const i3 = new OperatorList();
        h2[e3] = i3.getIR();
      });
    });
    return this.#ae = o2.then(() => {
      n2.charProcOperatorList = h2, this._bbox && (n2.isCharBBox = true, n2.bbox = this._bbox);
    }), this.#ae;
  }
  #se(e2, t2 = NaN) {
    const i2 = ai.normalizeRect(e2.argsArray[0].slice(2)), n2 = i2[2] - i2[0], a2 = i2[3] - i2[1], s2 = Math.hypot(n2, a2);
    0 === n2 || 0 === a2 ? (e2.fnArray.splice(0, 1), e2.argsArray.splice(0, 1)) : (0 === t2 || Math.round(s2 / t2) >= 10) && (this._bbox ??= [1 / 0, 1 / 0, -1 / 0, -1 / 0], ai.rectBoundingBox(...i2, this._bbox));
    let r2 = 0, o2 = e2.length;
    for (; r2 < o2; ) {
      switch (e2.fnArray[r2]) {
        case et:
          break;
        case tt:
        case it:
        case nt:
        case at:
        case st:
        case rt:
        case ot:
        case lt:
        case ct:
        case ht:
        case dt:
        case ut:
        case gt:
        case ue:
          e2.fnArray.splice(r2, 1), e2.argsArray.splice(r2, 1), o2--;
          continue;
        case fe:
          const [t3] = e2.argsArray[r2];
          let i3 = 0, n3 = t3.length;
          for (; i3 < n3; ) {
            const [e3] = t3[i3];
            switch (e3) {
              case "TR":
              case "TR2":
              case "HT":
              case "BG":
              case "BG2":
              case "UCR":
              case "UCR2":
                t3.splice(i3, 1), n3--;
                continue;
            }
            i3++;
          }
      }
      r2++;
    }
  }
  #re(e2) {
    let t2 = 1;
    const i2 = e2.length;
    for (; t2 < i2; ) {
      if (e2.fnArray[t2] === Ut) {
        const i3 = e2.argsArray[t2][2];
        this._bbox ??= [1 / 0, 1 / 0, -1 / 0, -1 / 0], ai.rectBoundingBox(...i3, this._bbox);
      }
      t2++;
    }
  }
}
class StateManager {
  constructor(e2 = new EvalState()) {
    this.state = e2, this.stateStack = [];
  }
  save() {
    const e2 = this.state;
    this.stateStack.push(this.state), this.state = e2.clone();
  }
  restore() {
    const e2 = this.stateStack.pop();
    e2 && (this.state = e2);
  }
  transform(e2) {
    this.state.ctm = ai.transform(this.state.ctm, e2);
  }
}
class TextState {
  constructor() {
    this.ctm = new Float32Array(pi), this.fontName = null, this.fontSize = 0, this.loadedName = null, this.font = null, this.fontMatrix = t, this.textMatrix = pi.slice(), this.textLineMatrix = pi.slice(), this.charSpacing = 0, this.wordSpacing = 0, this.leading = 0, this.textHScale = 1, this.textRise = 0;
  }
  setTextMatrix(e2, t2, i2, n2, a2, s2) {
    const r2 = this.textMatrix;
    r2[0] = e2, r2[1] = t2, r2[2] = i2, r2[3] = n2, r2[4] = a2, r2[5] = s2;
  }
  setTextLineMatrix(e2, t2, i2, n2, a2, s2) {
    const r2 = this.textLineMatrix;
    r2[0] = e2, r2[1] = t2, r2[2] = i2, r2[3] = n2, r2[4] = a2, r2[5] = s2;
  }
  translateTextMatrix(e2, t2) {
    const i2 = this.textMatrix;
    i2[4] = i2[0] * e2 + i2[2] * t2 + i2[4], i2[5] = i2[1] * e2 + i2[3] * t2 + i2[5];
  }
  translateTextLineMatrix(e2, t2) {
    const i2 = this.textLineMatrix;
    i2[4] = i2[0] * e2 + i2[2] * t2 + i2[4], i2[5] = i2[1] * e2 + i2[3] * t2 + i2[5];
  }
  carriageReturn() {
    this.translateTextLineMatrix(0, -this.leading), this.textMatrix = this.textLineMatrix.slice();
  }
  clone() {
    const e2 = Object.create(this);
    return e2.textMatrix = this.textMatrix.slice(), e2.textLineMatrix = this.textLineMatrix.slice(), e2.fontMatrix = this.fontMatrix.slice(), e2;
  }
}
class EvalState {
  constructor() {
    this.ctm = new Float32Array(pi), this.font = null, this.textRenderingMode = x, this._fillColorSpace = this._strokeColorSpace = ColorSpaceUtils.gray, this.patternFillColorSpace = null, this.patternStrokeColorSpace = null, this.currentPointX = this.currentPointY = 0, this.pathMinMax = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]), this.pathBuffer = [];
  }
  get fillColorSpace() {
    return this._fillColorSpace;
  }
  set fillColorSpace(e2) {
    this._fillColorSpace = this.patternFillColorSpace = e2;
  }
  get strokeColorSpace() {
    return this._strokeColorSpace;
  }
  set strokeColorSpace(e2) {
    this._strokeColorSpace = this.patternStrokeColorSpace = e2;
  }
  clone({ newPath: e2 = false } = {}) {
    const t2 = Object.create(this);
    return e2 && (t2.pathBuffer = [], t2.pathMinMax = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0])), t2;
  }
}
class EvaluatorPreprocessor {
  static get opMap() {
    return shadow$1(this, "opMap", Object.assign(/* @__PURE__ */ Object.create(null), { w: { id: oe, numArgs: 1, variableArgs: false }, J: { id: le, numArgs: 1, variableArgs: false }, j: { id: ce, numArgs: 1, variableArgs: false }, M: { id: he, numArgs: 1, variableArgs: false }, d: { id: de, numArgs: 2, variableArgs: false }, ri: { id: ue, numArgs: 1, variableArgs: false }, i: { id: ge, numArgs: 1, variableArgs: false }, gs: { id: fe, numArgs: 1, variableArgs: false }, q: { id: pe, numArgs: 0, variableArgs: false }, Q: { id: me, numArgs: 0, variableArgs: false }, cm: { id: be, numArgs: 6, variableArgs: false }, m: { id: ye, numArgs: 2, variableArgs: false }, l: { id: we, numArgs: 2, variableArgs: false }, c: { id: Ae, numArgs: 6, variableArgs: false }, v: { id: xe, numArgs: 4, variableArgs: false }, y: { id: Se, numArgs: 4, variableArgs: false }, h: { id: ve, numArgs: 0, variableArgs: false }, re: { id: Ce, numArgs: 4, variableArgs: false }, S: { id: ke, numArgs: 0, variableArgs: false }, s: { id: Te, numArgs: 0, variableArgs: false }, f: { id: Fe, numArgs: 0, variableArgs: false }, F: { id: Fe, numArgs: 0, variableArgs: false }, "f*": { id: Ie, numArgs: 0, variableArgs: false }, B: { id: Ee, numArgs: 0, variableArgs: false }, "B*": { id: Me, numArgs: 0, variableArgs: false }, b: { id: De, numArgs: 0, variableArgs: false }, "b*": { id: Oe, numArgs: 0, variableArgs: false }, n: { id: _e, numArgs: 0, variableArgs: false }, W: { id: Pe, numArgs: 0, variableArgs: false }, "W*": { id: Re, numArgs: 0, variableArgs: false }, BT: { id: Be, numArgs: 0, variableArgs: false }, ET: { id: Ne, numArgs: 0, variableArgs: false }, Tc: { id: Le, numArgs: 1, variableArgs: false }, Tw: { id: Ue, numArgs: 1, variableArgs: false }, Tz: { id: je, numArgs: 1, variableArgs: false }, TL: { id: $e, numArgs: 1, variableArgs: false }, Tf: { id: He, numArgs: 2, variableArgs: false }, Tr: { id: Xe, numArgs: 1, variableArgs: false }, Ts: { id: qe, numArgs: 1, variableArgs: false }, Td: { id: ze, numArgs: 2, variableArgs: false }, TD: { id: We, numArgs: 2, variableArgs: false }, Tm: { id: Ge, numArgs: 6, variableArgs: false }, "T*": { id: Ve, numArgs: 0, variableArgs: false }, Tj: { id: Ke, numArgs: 1, variableArgs: false }, TJ: { id: Ye, numArgs: 1, variableArgs: false }, "'": { id: Je, numArgs: 1, variableArgs: false }, '"': { id: Ze, numArgs: 3, variableArgs: false }, d0: { id: Qe, numArgs: 2, variableArgs: false }, d1: { id: et, numArgs: 6, variableArgs: false }, CS: { id: tt, numArgs: 1, variableArgs: false }, cs: { id: it, numArgs: 1, variableArgs: false }, SC: { id: nt, numArgs: 4, variableArgs: true }, SCN: { id: at, numArgs: 33, variableArgs: true }, sc: { id: st, numArgs: 4, variableArgs: true }, scn: { id: rt, numArgs: 33, variableArgs: true }, G: { id: ot, numArgs: 1, variableArgs: false }, g: { id: lt, numArgs: 1, variableArgs: false }, RG: { id: ct, numArgs: 3, variableArgs: false }, rg: { id: ht, numArgs: 3, variableArgs: false }, K: { id: dt, numArgs: 4, variableArgs: false }, k: { id: ut, numArgs: 4, variableArgs: false }, sh: { id: gt, numArgs: 1, variableArgs: false }, BI: { id: ft, numArgs: 0, variableArgs: false }, ID: { id: pt, numArgs: 0, variableArgs: false }, EI: { id: mt, numArgs: 1, variableArgs: false }, Do: { id: bt, numArgs: 1, variableArgs: false }, MP: { id: yt, numArgs: 1, variableArgs: false }, DP: { id: wt, numArgs: 2, variableArgs: false }, BMC: { id: At, numArgs: 1, variableArgs: false }, BDC: { id: xt, numArgs: 2, variableArgs: false }, EMC: { id: St, numArgs: 0, variableArgs: false }, BX: { id: vt, numArgs: 0, variableArgs: false }, EX: { id: Ct, numArgs: 0, variableArgs: false }, BM: null, BD: null, true: null, fa: null, fal: null, fals: null, false: null, nu: null, nul: null, null: null }));
  }
  static MAX_INVALID_PATH_OPS = 10;
  constructor(e2, t2, i2 = new StateManager()) {
    this.parser = new Parser({ lexer: new Lexer(e2, EvaluatorPreprocessor.opMap), xref: t2 }), this.stateManager = i2, this.nonProcessedArgs = [], this._isPathOp = false, this._numInvalidPathOPS = 0;
  }
  get savedStatesDepth() {
    return this.stateManager.stateStack.length;
  }
  read(e2) {
    let t2 = e2.args;
    for (; ; ) {
      const i2 = this.parser.getObj();
      if (i2 instanceof Cmd) {
        const n2 = i2.cmd, a2 = EvaluatorPreprocessor.opMap[n2];
        if (!a2) {
          warn$1(`Unknown command "${n2}".`);
          continue;
        }
        const s2 = a2.id, r2 = a2.numArgs;
        let o2 = null !== t2 ? t2.length : 0;
        if (this._isPathOp || (this._numInvalidPathOPS = 0), this._isPathOp = s2 >= ye && s2 <= _e, a2.variableArgs) o2 > r2 && info$1(`Command ${n2}: expected [0, ${r2}] args, but received ${o2} args.`);
        else {
          if (o2 !== r2) {
            const e3 = this.nonProcessedArgs;
            for (; o2 > r2; ) e3.push(t2.shift()), o2--;
            for (; o2 < r2 && 0 !== e3.length; ) null === t2 && (t2 = []), t2.unshift(e3.pop()), o2++;
          }
          if (o2 < r2) {
            const e3 = `command ${n2}: expected ${r2} args, but received ${o2} args.`;
            if (this._isPathOp && ++this._numInvalidPathOPS > EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) throw new ti(`Invalid ${e3}`);
            warn$1(`Skipping ${e3}`), null !== t2 && (t2.length = 0);
            continue;
          }
        }
        return this.preprocessCommand(s2, t2), e2.fn = s2, e2.args = t2, true;
      }
      if (i2 === ci) return false;
      if (null !== i2 && (null === t2 && (t2 = []), t2.push(i2), t2.length > 33)) throw new ti("Too many arguments");
    }
  }
  preprocessCommand(e2, t2) {
    switch (0 | e2) {
      case pe:
        this.stateManager.save();
        break;
      case me:
        this.stateManager.restore();
        break;
      case be:
        this.stateManager.transform(t2);
    }
  }
}
class DefaultAppearanceEvaluator extends EvaluatorPreprocessor {
  constructor(e2) {
    super(new StringStream(e2));
  }
  parse() {
    const e2 = { fn: 0, args: [] }, t2 = { fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3) };
    try {
      for (; e2.args.length = 0, this.read(e2); ) {
        if (0 !== this.savedStatesDepth) continue;
        const { fn: i2, args: n2 } = e2;
        switch (0 | i2) {
          case He:
            const [e3, i3] = n2;
            e3 instanceof Name && (t2.fontName = e3.name), "number" == typeof i3 && i3 > 0 && (t2.fontSize = i3);
            break;
          case ht:
            ColorSpaceUtils.rgb.getRgbItem(n2, 0, t2.fontColor, 0);
            break;
          case lt:
            ColorSpaceUtils.gray.getRgbItem(n2, 0, t2.fontColor, 0);
            break;
          case ut:
            ColorSpaceUtils.cmyk.getRgbItem(n2, 0, t2.fontColor, 0);
        }
      }
    } catch (e3) {
      warn$1(`parseDefaultAppearance - ignoring errors: "${e3}".`);
    }
    return t2;
  }
}
function parseDefaultAppearance(e2) {
  return new DefaultAppearanceEvaluator(e2).parse();
}
class AppearanceStreamEvaluator extends EvaluatorPreprocessor {
  constructor(e2, t2, i2, n2) {
    super(e2), this.stream = e2, this.evaluatorOptions = t2, this.xref = i2, this.globalColorSpaceCache = n2, this.resources = e2.dict?.get("Resources");
  }
  parse() {
    const e2 = { fn: 0, args: [] };
    let t2 = { scaleFactor: 1, fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3), fillColorSpace: ColorSpaceUtils.gray }, i2 = false;
    const n2 = [];
    try {
      for (; e2.args.length = 0, !i2 && this.read(e2); ) {
        const { fn: a2, args: s2 } = e2;
        switch (0 | a2) {
          case pe:
            n2.push({ scaleFactor: t2.scaleFactor, fontSize: t2.fontSize, fontName: t2.fontName, fontColor: t2.fontColor.slice(), fillColorSpace: t2.fillColorSpace });
            break;
          case me:
            t2 = n2.pop() || t2;
            break;
          case Ge:
            t2.scaleFactor *= Math.hypot(s2[0], s2[1]);
            break;
          case He:
            const [e3, a3] = s2;
            e3 instanceof Name && (t2.fontName = e3.name), "number" == typeof a3 && a3 > 0 && (t2.fontSize = a3 * t2.scaleFactor);
            break;
          case it:
            t2.fillColorSpace = ColorSpaceUtils.parse({ cs: s2[0], xref: this.xref, resources: this.resources, pdfFunctionFactory: this._pdfFunctionFactory, globalColorSpaceCache: this.globalColorSpaceCache, localColorSpaceCache: this._localColorSpaceCache });
            break;
          case st:
            t2.fillColorSpace.getRgbItem(s2, 0, t2.fontColor, 0);
            break;
          case ht:
            ColorSpaceUtils.rgb.getRgbItem(s2, 0, t2.fontColor, 0);
            break;
          case lt:
            ColorSpaceUtils.gray.getRgbItem(s2, 0, t2.fontColor, 0);
            break;
          case ut:
            ColorSpaceUtils.cmyk.getRgbItem(s2, 0, t2.fontColor, 0);
            break;
          case Ke:
          case Ye:
          case Je:
          case Ze:
            i2 = true;
        }
      }
    } catch (e3) {
      warn$1(`parseAppearanceStream - ignoring errors: "${e3}".`);
    }
    return this.stream.reset(), delete t2.scaleFactor, delete t2.fillColorSpace, t2;
  }
  get _localColorSpaceCache() {
    return shadow$1(this, "_localColorSpaceCache", new LocalColorSpaceCache());
  }
  get _pdfFunctionFactory() {
    return shadow$1(this, "_pdfFunctionFactory", new PDFFunctionFactory({ xref: this.xref, isEvalSupported: this.evaluatorOptions.isEvalSupported }));
  }
}
function getPdfColor(e2, t2) {
  if (e2[0] === e2[1] && e2[1] === e2[2]) {
    return `${numberToString(e2[0] / 255)} ${t2 ? "g" : "G"}`;
  }
  return Array.from(e2, (e3) => numberToString(e3 / 255)).join(" ") + " " + (t2 ? "rg" : "RG");
}
class FakeUnicodeFont {
  constructor(e2, t2) {
    this.xref = e2, this.widths = null, this.firstChar = 1 / 0, this.lastChar = -1 / 0, this.fontFamily = t2;
    const i2 = new OffscreenCanvas(1, 1);
    this.ctxMeasure = i2.getContext("2d", { willReadFrequently: true }), FakeUnicodeFont._fontNameId || (FakeUnicodeFont._fontNameId = 1), this.fontName = Name.get(`InvalidPDFjsFont_${t2}_${FakeUnicodeFont._fontNameId++}`);
  }
  get fontDescriptorRef() {
    if (!FakeUnicodeFont._fontDescriptorRef) {
      const e2 = new Dict(this.xref);
      e2.setIfName("Type", "FontDescriptor"), e2.set("FontName", this.fontName), e2.set("FontFamily", "MyriadPro Regular"), e2.set("FontBBox", [0, 0, 0, 0]), e2.setIfName("FontStretch", "Normal"), e2.set("FontWeight", 400), e2.set("ItalicAngle", 0), FakeUnicodeFont._fontDescriptorRef = this.xref.getNewPersistentRef(e2);
    }
    return FakeUnicodeFont._fontDescriptorRef;
  }
  get descendantFontRef() {
    const e2 = new Dict(this.xref);
    e2.set("BaseFont", this.fontName), e2.setIfName("Type", "Font"), e2.setIfName("Subtype", "CIDFontType0"), e2.setIfName("CIDToGIDMap", "Identity"), e2.set("FirstChar", this.firstChar), e2.set("LastChar", this.lastChar), e2.set("FontDescriptor", this.fontDescriptorRef), e2.set("DW", 1e3);
    const t2 = [], i2 = [...this.widths.entries()].sort();
    let n2 = null, a2 = null;
    for (const [e3, s3] of i2) n2 ? e3 === n2 + a2.length ? a2.push(s3) : (t2.push(n2, a2), n2 = e3, a2 = [s3]) : (n2 = e3, a2 = [s3]);
    n2 && t2.push(n2, a2), e2.set("W", t2);
    const s2 = new Dict(this.xref);
    return s2.set("Ordering", "Identity"), s2.set("Registry", "Adobe"), s2.set("Supplement", 0), e2.set("CIDSystemInfo", s2), this.xref.getNewPersistentRef(e2);
  }
  get baseFontRef() {
    const e2 = new Dict(this.xref);
    return e2.set("BaseFont", this.fontName), e2.setIfName("Type", "Font"), e2.setIfName("Subtype", "Type0"), e2.setIfName("Encoding", "Identity-H"), e2.set("DescendantFonts", [this.descendantFontRef]), e2.setIfName("ToUnicode", "Identity-H"), this.xref.getNewPersistentRef(e2);
  }
  get resources() {
    const e2 = new Dict(this.xref), t2 = new Dict(this.xref);
    return t2.set(this.fontName.name, this.baseFontRef), e2.set("Font", t2), e2;
  }
  _createContext() {
    return this.widths = /* @__PURE__ */ new Map(), this.ctxMeasure.font = `1000px ${this.fontFamily}`, this.ctxMeasure;
  }
  createFontResources(e2) {
    const t2 = this._createContext();
    for (const i2 of e2.split(/\r\n?|\n/)) for (const e3 of i2.split("")) {
      const i3 = e3.charCodeAt(0);
      if (this.widths.has(i3)) continue;
      const n2 = t2.measureText(e3), a2 = Math.ceil(n2.width);
      this.widths.set(i3, a2), this.firstChar = Math.min(i3, this.firstChar), this.lastChar = Math.max(i3, this.lastChar);
    }
    return this.resources;
  }
  static getFirstPositionInfo(e2, t2, a2) {
    const [s2, r2, o2, l2] = e2;
    let c2 = o2 - s2, h2 = l2 - r2;
    t2 % 180 != 0 && ([c2, h2] = [h2, c2]);
    const d2 = i * a2;
    return { coords: [0, h2 + n * a2 - d2], bbox: [0, 0, c2, h2], matrix: 0 !== t2 ? getRotationMatrix(t2, h2, d2) : void 0 };
  }
  createAppearance(e2, t2, a2, s2, r2, o2) {
    const l2 = this._createContext(), c2 = [];
    let h2 = -1 / 0;
    for (const t3 of e2.split(/\r\n?|\n/)) {
      c2.push(t3);
      const e3 = l2.measureText(t3).width;
      h2 = Math.max(h2, e3);
      for (const e4 of codePointIter(t3)) {
        const t4 = String.fromCodePoint(e4);
        let i2 = this.widths.get(e4);
        if (void 0 === i2) {
          const n2 = l2.measureText(t4);
          i2 = Math.ceil(n2.width), this.widths.set(e4, i2), this.firstChar = Math.min(e4, this.firstChar), this.lastChar = Math.max(e4, this.lastChar);
        }
      }
    }
    h2 *= s2 / 1e3;
    const [d2, u2, g2, f2] = t2;
    let p2 = g2 - d2, m2 = f2 - u2;
    a2 % 180 != 0 && ([p2, m2] = [m2, p2]);
    let b2 = 1;
    h2 > p2 && (b2 = p2 / h2);
    let y2 = 1;
    const w2 = i * s2, x2 = n * s2, S2 = w2 * c2.length;
    S2 > m2 && (y2 = m2 / S2);
    const v2 = s2 * Math.min(b2, y2), C2 = ["q", `0 0 ${numberToString(p2)} ${numberToString(m2)} re W n`, "BT", `1 0 0 1 0 ${numberToString(m2 + x2)} Tm 0 Tc ${getPdfColor(r2, true)}`, `/${this.fontName.name} ${numberToString(v2)} Tf`], { resources: k2 } = this;
    if (1 !== (o2 = "number" == typeof o2 && o2 >= 0 && o2 <= 1 ? o2 : 1)) {
      C2.push("/R0 gs");
      const e3 = new Dict(this.xref), t3 = new Dict(this.xref);
      t3.set("ca", o2), t3.set("CA", o2), t3.setIfName("Type", "ExtGState"), e3.set("R0", t3), k2.set("ExtGState", e3);
    }
    const T2 = numberToString(w2);
    for (const e3 of c2) C2.push(`0 -${T2} Td <${stringToUTF16HexString(e3)}> Tj`);
    C2.push("ET", "Q");
    const F2 = C2.join("\n"), E2 = new Dict(this.xref);
    if (E2.setIfName("Subtype", "Form"), E2.setIfName("Type", "XObject"), E2.set("BBox", [0, 0, p2, m2]), E2.set("Length", F2.length), E2.set("Resources", k2), a2) {
      const e3 = getRotationMatrix(a2, p2, m2);
      E2.set("Matrix", e3);
    }
    const M2 = new StringStream(F2);
    return M2.dict = E2, M2;
  }
}
const Ts = ["m/d", "m/d/yy", "mm/dd/yy", "mm/yy", "d-mmm", "d-mmm-yy", "dd-mmm-yy", "yy-mm-dd", "mmm-yy", "mmmm-yy", "mmm d, yyyy", "mmmm d, yyyy", "m/d/yy h:MM tt", "m/d/yy HH:MM"], Fs = ["HH:MM", "h:MM tt", "HH:MM:ss", "h:MM:ss tt"];
class NameOrNumberTree {
  constructor(e2, t2, i2) {
    this.root = e2, this.xref = t2, this._type = i2;
  }
  getAll() {
    const e2 = /* @__PURE__ */ new Map();
    if (!this.root) return e2;
    const t2 = this.xref, i2 = new RefSet();
    i2.put(this.root);
    const n2 = [this.root];
    for (; n2.length > 0; ) {
      const a2 = t2.fetchIfRef(n2.shift());
      if (!(a2 instanceof Dict)) continue;
      if (a2.has("Kids")) {
        const e3 = a2.get("Kids");
        if (!Array.isArray(e3)) continue;
        for (const t3 of e3) {
          if (i2.has(t3)) throw new ti(`Duplicate entry in "${this._type}" tree.`);
          n2.push(t3), i2.put(t3);
        }
        continue;
      }
      const s2 = a2.get(this._type);
      if (Array.isArray(s2)) for (let i3 = 0, n3 = s2.length; i3 < n3; i3 += 2) e2.set(t2.fetchIfRef(s2[i3]), t2.fetchIfRef(s2[i3 + 1]));
    }
    return e2;
  }
  getRaw(e2) {
    if (!this.root) return null;
    const t2 = this.xref;
    let i2 = t2.fetchIfRef(this.root), n2 = 0;
    for (; i2.has("Kids"); ) {
      if (++n2 > 10) return warn$1(`Search depth limit reached for "${this._type}" tree.`), null;
      const a3 = i2.get("Kids");
      if (!Array.isArray(a3)) return null;
      let s2 = 0, r2 = a3.length - 1;
      for (; s2 <= r2; ) {
        const n3 = s2 + r2 >> 1, o2 = t2.fetchIfRef(a3[n3]), l2 = o2.get("Limits");
        if (e2 < t2.fetchIfRef(l2[0])) r2 = n3 - 1;
        else {
          if (!(e2 > t2.fetchIfRef(l2[1]))) {
            i2 = o2;
            break;
          }
          s2 = n3 + 1;
        }
      }
      if (s2 > r2) return null;
    }
    const a2 = i2.get(this._type);
    if (Array.isArray(a2)) {
      let i3 = 0, n3 = a2.length - 2;
      for (; i3 <= n3; ) {
        const s2 = i3 + n3 >> 1, r2 = s2 + (1 & s2), o2 = t2.fetchIfRef(a2[r2]);
        if (e2 < o2) n3 = r2 - 2;
        else {
          if (!(e2 > o2)) return a2[r2 + 1];
          i3 = r2 + 2;
        }
      }
    }
    return null;
  }
  get(e2) {
    return this.xref.fetchIfRef(this.getRaw(e2));
  }
}
class NameTree extends NameOrNumberTree {
  constructor(e2, t2) {
    super(e2, t2, "Names");
  }
}
class NumberTree extends NameOrNumberTree {
  constructor(e2, t2) {
    super(e2, t2, "Nums");
  }
}
function clearGlobalCaches() {
  ma = /* @__PURE__ */ Object.create(null), hi = /* @__PURE__ */ Object.create(null), di = /* @__PURE__ */ Object.create(null), ui = /* @__PURE__ */ Object.create(null), xn.clear(), JpxImage.cleanup();
}
function pickPlatformItem(e2) {
  return e2 instanceof Dict ? e2.has("UF") ? e2.get("UF") : e2.has("F") ? e2.get("F") : e2.has("Unix") ? e2.get("Unix") : e2.has("Mac") ? e2.get("Mac") : e2.has("DOS") ? e2.get("DOS") : null : null;
}
class FileSpec {
  #oe = false;
  constructor(e2, t2, i2 = false) {
    e2 instanceof Dict && (this.xref = t2, this.root = e2, e2.has("FS") && (this.fs = e2.get("FS")), e2.has("RF") && warn$1("Related file specifications are not supported"), i2 || (e2.has("EF") ? this.#oe = true : warn$1("Non-embedded file specifications are not supported")));
  }
  get filename() {
    let e2 = "";
    const t2 = pickPlatformItem(this.root);
    return t2 && "string" == typeof t2 && (e2 = stringToPDFString(t2, true).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/")), shadow$1(this, "filename", e2 || "unnamed");
  }
  get content() {
    if (!this.#oe) return null;
    this._contentRef ||= pickPlatformItem(this.root?.get("EF"));
    let e2 = null;
    if (this._contentRef) {
      const t2 = this.xref.fetchIfRef(this._contentRef);
      t2 instanceof BaseStream ? e2 = t2.getBytes() : warn$1("Embedded file specification points to non-existing/invalid content");
    } else warn$1("Embedded file specification does not have any content");
    return e2;
  }
  get description() {
    let e2 = "";
    const t2 = this.root?.get("Desc");
    return t2 && "string" == typeof t2 && (e2 = stringToPDFString(t2)), shadow$1(this, "description", e2);
  }
  get serializable() {
    return { rawFilename: this.filename, filename: (e2 = this.filename, e2.substring(e2.lastIndexOf("/") + 1)), content: this.content, description: this.description };
    var e2;
  }
}
const Is = 0, Es = -2, Ms = -3, Ds = -4, Os = -5, _s = -6, Rs = -9;
function isWhitespace(e2, t2) {
  const i2 = e2[t2];
  return " " === i2 || "\n" === i2 || "\r" === i2 || "	" === i2;
}
class XMLParserBase {
  _resolveEntities(e2) {
    return e2.replaceAll(/&([^;]+);/g, (e3, t2) => {
      if ("#x" === t2.substring(0, 2)) return String.fromCodePoint(parseInt(t2.substring(2), 16));
      if ("#" === t2.substring(0, 1)) return String.fromCodePoint(parseInt(t2.substring(1), 10));
      switch (t2) {
        case "lt":
          return "<";
        case "gt":
          return ">";
        case "amp":
          return "&";
        case "quot":
          return '"';
        case "apos":
          return "'";
      }
      return this.onResolveEntity(t2);
    });
  }
  _parseContent(e2, t2) {
    const i2 = [];
    let n2 = t2;
    function skipWs() {
      for (; n2 < e2.length && isWhitespace(e2, n2); ) ++n2;
    }
    for (; n2 < e2.length && !isWhitespace(e2, n2) && ">" !== e2[n2] && "/" !== e2[n2]; ) ++n2;
    const a2 = e2.substring(t2, n2);
    for (skipWs(); n2 < e2.length && ">" !== e2[n2] && "/" !== e2[n2] && "?" !== e2[n2]; ) {
      skipWs();
      let t3 = "", a3 = "";
      for (; n2 < e2.length && !isWhitespace(e2, n2) && "=" !== e2[n2]; ) t3 += e2[n2], ++n2;
      if (skipWs(), "=" !== e2[n2]) return null;
      ++n2, skipWs();
      const s2 = e2[n2];
      if ('"' !== s2 && "'" !== s2) return null;
      const r2 = e2.indexOf(s2, ++n2);
      if (r2 < 0) return null;
      a3 = e2.substring(n2, r2), i2.push({ name: t3, value: this._resolveEntities(a3) }), n2 = r2 + 1, skipWs();
    }
    return { name: a2, attributes: i2, parsed: n2 - t2 };
  }
  _parseProcessingInstruction(e2, t2) {
    let i2 = t2;
    for (; i2 < e2.length && !isWhitespace(e2, i2) && ">" !== e2[i2] && "?" !== e2[i2] && "/" !== e2[i2]; ) ++i2;
    const n2 = e2.substring(t2, i2);
    !(function() {
      for (; i2 < e2.length && isWhitespace(e2, i2); ) ++i2;
    })();
    const a2 = i2;
    for (; i2 < e2.length && ("?" !== e2[i2] || ">" !== e2[i2 + 1]); ) ++i2;
    return { name: n2, value: e2.substring(a2, i2), parsed: i2 - t2 };
  }
  parseXml(e2) {
    let t2 = 0;
    for (; t2 < e2.length; ) {
      let i2 = t2;
      if ("<" === e2[t2]) {
        ++i2;
        let t3;
        switch (e2[i2]) {
          case "/":
            if (++i2, t3 = e2.indexOf(">", i2), t3 < 0) return void this.onError(Rs);
            this.onEndElement(e2.substring(i2, t3)), i2 = t3 + 1;
            break;
          case "?":
            ++i2;
            const n2 = this._parseProcessingInstruction(e2, i2);
            if ("?>" !== e2.substring(i2 + n2.parsed, i2 + n2.parsed + 2)) return void this.onError(Ms);
            this.onPi(n2.name, n2.value), i2 += n2.parsed + 2;
            break;
          case "!":
            if ("--" === e2.substring(i2 + 1, i2 + 3)) {
              if (t3 = e2.indexOf("-->", i2 + 3), t3 < 0) return void this.onError(Os);
              this.onComment(e2.substring(i2 + 3, t3)), i2 = t3 + 3;
            } else if ("[CDATA[" === e2.substring(i2 + 1, i2 + 8)) {
              if (t3 = e2.indexOf("]]>", i2 + 8), t3 < 0) return void this.onError(Es);
              this.onCdata(e2.substring(i2 + 8, t3)), i2 = t3 + 3;
            } else {
              if ("DOCTYPE" !== e2.substring(i2 + 1, i2 + 8)) return void this.onError(_s);
              {
                const n3 = e2.indexOf("[", i2 + 8);
                let a3 = false;
                if (t3 = e2.indexOf(">", i2 + 8), t3 < 0) return void this.onError(Ds);
                if (n3 > 0 && t3 > n3) {
                  if (t3 = e2.indexOf("]>", i2 + 8), t3 < 0) return void this.onError(Ds);
                  a3 = true;
                }
                const s3 = e2.substring(i2 + 8, t3 + (a3 ? 1 : 0));
                this.onDoctype(s3), i2 = t3 + (a3 ? 2 : 1);
              }
            }
            break;
          default:
            const a2 = this._parseContent(e2, i2);
            if (null === a2) return void this.onError(_s);
            let s2 = false;
            if ("/>" === e2.substring(i2 + a2.parsed, i2 + a2.parsed + 2)) s2 = true;
            else if (">" !== e2.substring(i2 + a2.parsed, i2 + a2.parsed + 1)) return void this.onError(Rs);
            this.onBeginElement(a2.name, a2.attributes, s2), i2 += a2.parsed + (s2 ? 2 : 1);
        }
      } else {
        for (; i2 < e2.length && "<" !== e2[i2]; ) i2++;
        const n2 = e2.substring(t2, i2);
        this.onText(this._resolveEntities(n2));
      }
      t2 = i2;
    }
  }
  onResolveEntity(e2) {
    return `&${e2};`;
  }
  onPi(e2, t2) {
  }
  onComment(e2) {
  }
  onCdata(e2) {
  }
  onDoctype(e2) {
  }
  onText(e2) {
  }
  onBeginElement(e2, t2, i2) {
  }
  onEndElement(e2) {
  }
  onError(e2) {
  }
}
class SimpleDOMNode {
  constructor(e2, t2) {
    this.nodeName = e2, this.nodeValue = t2, Object.defineProperty(this, "parentNode", { value: null, writable: true });
  }
  get firstChild() {
    return this.childNodes?.[0];
  }
  get nextSibling() {
    const e2 = this.parentNode.childNodes;
    if (!e2) return;
    const t2 = e2.indexOf(this);
    return -1 !== t2 ? e2[t2 + 1] : void 0;
  }
  get textContent() {
    return this.childNodes ? this.childNodes.map((e2) => e2.textContent).join("") : this.nodeValue || "";
  }
  get children() {
    return this.childNodes || [];
  }
  hasChildNodes() {
    return this.childNodes?.length > 0;
  }
  searchNode(e2, t2) {
    if (t2 >= e2.length) return this;
    const i2 = e2[t2];
    if (i2.name.startsWith("#") && t2 < e2.length - 1) return this.searchNode(e2, t2 + 1);
    const n2 = [];
    let a2 = this;
    for (; ; ) {
      if (i2.name === a2.nodeName) {
        if (0 !== i2.pos) {
          if (0 === n2.length) return null;
          {
            const [s2] = n2.pop();
            let r2 = 0;
            for (const n3 of s2.childNodes) if (i2.name === n3.nodeName) {
              if (r2 === i2.pos) return n3.searchNode(e2, t2 + 1);
              r2++;
            }
            return a2.searchNode(e2, t2 + 1);
          }
        }
        {
          const i3 = a2.searchNode(e2, t2 + 1);
          if (null !== i3) return i3;
        }
      }
      if (a2.childNodes?.length > 0) n2.push([a2, 0]), a2 = a2.childNodes[0];
      else {
        if (0 === n2.length) return null;
        for (; 0 !== n2.length; ) {
          const [e3, t3] = n2.pop(), i3 = t3 + 1;
          if (i3 < e3.childNodes.length) {
            n2.push([e3, i3]), a2 = e3.childNodes[i3];
            break;
          }
        }
        if (0 === n2.length) return null;
      }
    }
  }
  dump(e2) {
    if ("#text" !== this.nodeName) {
      if (e2.push(`<${this.nodeName}`), this.attributes) for (const t2 of this.attributes) e2.push(` ${t2.name}="${encodeToXmlString(t2.value)}"`);
      if (this.hasChildNodes()) {
        e2.push(">");
        for (const t2 of this.childNodes) t2.dump(e2);
        e2.push(`</${this.nodeName}>`);
      } else this.nodeValue ? e2.push(`>${encodeToXmlString(this.nodeValue)}</${this.nodeName}>`) : e2.push("/>");
    } else e2.push(encodeToXmlString(this.nodeValue));
  }
}
class SimpleXMLParser extends XMLParserBase {
  constructor({ hasAttributes: e2 = false, lowerCaseName: t2 = false }) {
    super(), this._currentFragment = null, this._stack = null, this._errorCode = Is, this._hasAttributes = e2, this._lowerCaseName = t2;
  }
  parseFromString(e2) {
    if (this._currentFragment = [], this._stack = [], this._errorCode = Is, this.parseXml(e2), this._errorCode !== Is) return;
    const [t2] = this._currentFragment;
    return t2 ? { documentElement: t2 } : void 0;
  }
  onText(e2) {
    if ((function(e3) {
      for (let t3 = 0, i2 = e3.length; t3 < i2; t3++) if (!isWhitespace(e3, t3)) return false;
      return true;
    })(e2)) return;
    const t2 = new SimpleDOMNode("#text", e2);
    this._currentFragment.push(t2);
  }
  onCdata(e2) {
    const t2 = new SimpleDOMNode("#text", e2);
    this._currentFragment.push(t2);
  }
  onBeginElement(e2, t2, i2) {
    this._lowerCaseName && (e2 = e2.toLowerCase());
    const n2 = new SimpleDOMNode(e2);
    n2.childNodes = [], this._hasAttributes && (n2.attributes = t2), this._currentFragment.push(n2), i2 || (this._stack.push(this._currentFragment), this._currentFragment = n2.childNodes);
  }
  onEndElement(e2) {
    this._currentFragment = this._stack.pop() || [];
    const t2 = this._currentFragment.at(-1);
    if (!t2) return null;
    for (const e3 of t2.childNodes) e3.parentNode = t2;
    return t2;
  }
  onError(e2) {
    this._errorCode = e2;
  }
}
class MetadataParser {
  constructor(e2) {
    e2 = this._repair(e2);
    const t2 = new SimpleXMLParser({ lowerCaseName: true }).parseFromString(e2);
    this._metadataMap = /* @__PURE__ */ new Map(), this._data = e2, t2 && this._parse(t2);
  }
  _repair(e2) {
    return e2.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function(e3, t2) {
      const i2 = t2.replaceAll(/\\([0-3])([0-7])([0-7])/g, function(e4, t3, i3, n3) {
        return String.fromCharCode(64 * t3 + 8 * i3 + 1 * n3);
      }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function(e4, t3) {
        switch (t3) {
          case "amp":
            return "&";
          case "apos":
            return "'";
          case "gt":
            return ">";
          case "lt":
            return "<";
          case "quot":
            return '"';
        }
        throw new Error(`_repair: ${t3} isn't defined.`);
      }), n2 = [">"];
      for (let e4 = 0, t3 = i2.length; e4 < t3; e4 += 2) {
        const t4 = 256 * i2.charCodeAt(e4) + i2.charCodeAt(e4 + 1);
        t4 >= 32 && t4 < 127 && 60 !== t4 && 62 !== t4 && 38 !== t4 ? n2.push(String.fromCharCode(t4)) : n2.push("&#x" + (65536 + t4).toString(16).substring(1) + ";");
      }
      return n2.join("");
    });
  }
  _getSequence(e2) {
    const t2 = e2.nodeName;
    return "rdf:bag" !== t2 && "rdf:seq" !== t2 && "rdf:alt" !== t2 ? null : e2.childNodes.filter((e3) => "rdf:li" === e3.nodeName);
  }
  _parseArray(e2) {
    if (!e2.hasChildNodes()) return;
    const [t2] = e2.childNodes, i2 = this._getSequence(t2) || [];
    this._metadataMap.set(e2.nodeName, i2.map((e3) => e3.textContent.trim()));
  }
  _parse(e2) {
    let t2 = e2.documentElement;
    if ("rdf:rdf" !== t2.nodeName) for (t2 = t2.firstChild; t2 && "rdf:rdf" !== t2.nodeName; ) t2 = t2.nextSibling;
    if (t2 && "rdf:rdf" === t2.nodeName && t2.hasChildNodes()) {
      for (const e3 of t2.childNodes) if ("rdf:description" === e3.nodeName) for (const t3 of e3.childNodes) {
        const e4 = t3.nodeName;
        switch (e4) {
          case "#text":
            continue;
          case "dc:creator":
          case "dc:subject":
            this._parseArray(t3);
            continue;
        }
        this._metadataMap.set(e4, t3.textContent.trim());
      }
    }
  }
  get serializable() {
    return { parsedData: this._metadataMap, rawData: this._data };
  }
}
const Bs = 1, Ns = 2, Ls = 3, Us = 4, js = 5;
class StructTreeRoot {
  constructor(e2, t2, i2) {
    this.xref = e2, this.dict = t2, this.ref = i2 instanceof Ref ? i2 : null, this.roleMap = /* @__PURE__ */ new Map(), this.structParentIds = null;
  }
  init() {
    this.readRoleMap();
  }
  #le(e2, t2, i2) {
    if (!(e2 instanceof Ref) || t2 < 0) return;
    this.structParentIds ||= new RefSetCache();
    let n2 = this.structParentIds.get(e2);
    n2 || (n2 = [], this.structParentIds.put(e2, n2)), n2.push([t2, i2]);
  }
  addAnnotationIdToPage(e2, t2) {
    this.#le(e2, t2, Us);
  }
  readRoleMap() {
    const e2 = this.dict.get("RoleMap");
    if (e2 instanceof Dict) for (const [t2, i2] of e2) i2 instanceof Name && this.roleMap.set(t2, i2.name);
  }
  static async canCreateStructureTree({ catalogRef: e2, pdfManager: t2, newAnnotationsByPage: i2 }) {
    if (!(e2 instanceof Ref)) return warn$1("Cannot save the struct tree: no catalog reference."), false;
    let n2 = 0, a2 = true;
    for (const [e3, s2] of i2) {
      const { ref: i3 } = await t2.getPage(e3);
      if (!(i3 instanceof Ref)) {
        warn$1(`Cannot save the struct tree: page ${e3} has no ref.`), a2 = true;
        break;
      }
      for (const e4 of s2) e4.accessibilityData?.type && (e4.parentTreeId = n2++, a2 = false);
    }
    if (a2) {
      for (const e3 of i2.values()) for (const t3 of e3) delete t3.parentTreeId;
      return false;
    }
    return true;
  }
  static async createStructureTree({ newAnnotationsByPage: e2, xref: t2, catalogRef: i2, pdfManager: n2, changes: a2 }) {
    const s2 = await n2.ensureCatalog("cloneDict"), r2 = new RefSetCache();
    r2.put(i2, s2);
    const o2 = t2.getNewTemporaryRef();
    s2.set("StructTreeRoot", o2);
    const l2 = new Dict(t2);
    l2.set("Type", Name.get("StructTreeRoot"));
    const c2 = t2.getNewTemporaryRef();
    l2.set("ParentTree", c2);
    const h2 = [];
    l2.set("K", h2), r2.put(o2, l2);
    const d2 = new Dict(t2), u2 = [];
    d2.set("Nums", u2);
    const g2 = await this.#ce({ newAnnotationsByPage: e2, structTreeRootRef: o2, structTreeRoot: null, kids: h2, nums: u2, xref: t2, pdfManager: n2, changes: a2, cache: r2 });
    l2.set("ParentTreeNextKey", g2), r2.put(c2, d2);
    for (const [e3, t3] of r2.items()) a2.put(e3, { data: t3 });
  }
  async canUpdateStructTree({ pdfManager: e2, newAnnotationsByPage: t2 }) {
    if (!this.ref) return warn$1("Cannot update the struct tree: no root reference."), false;
    let i2 = this.dict.get("ParentTreeNextKey");
    if (!Number.isInteger(i2) || i2 < 0) return warn$1("Cannot update the struct tree: invalid next key."), false;
    const n2 = this.dict.get("ParentTree");
    if (!(n2 instanceof Dict)) return warn$1("Cannot update the struct tree: ParentTree isn't a dict."), false;
    const a2 = n2.get("Nums");
    if (!Array.isArray(a2)) return warn$1("Cannot update the struct tree: nums isn't an array."), false;
    const s2 = new NumberTree(n2, this.xref);
    for (const i3 of t2.keys()) {
      const { pageDict: t3 } = await e2.getPage(i3);
      if (!t3.has("StructParents")) continue;
      const n3 = t3.get("StructParents");
      if (!Number.isInteger(n3) || !Array.isArray(s2.get(n3))) return warn$1(`Cannot save the struct tree: page ${i3} has a wrong id.`), false;
    }
    let r2 = true;
    for (const [n3, a3] of t2) {
      const { pageDict: t3 } = await e2.getPage(n3);
      StructTreeRoot.#he({ elements: a3, xref: this.xref, pageDict: t3, numberTree: s2 });
      for (const e3 of a3) e3.accessibilityData?.type && (e3.accessibilityData.structParent >= 0 || (e3.parentTreeId = i2++), r2 = false);
    }
    if (r2) {
      for (const e3 of t2.values()) for (const t3 of e3) delete t3.parentTreeId, delete t3.structTreeParent;
      return false;
    }
    return true;
  }
  async updateStructureTree({ newAnnotationsByPage: e2, pdfManager: t2, changes: i2 }) {
    const { ref: n2, xref: a2 } = this, s2 = this.dict.clone(), r2 = new RefSetCache();
    r2.put(n2, s2);
    let o2, l2 = s2.getRaw("ParentTree");
    l2 instanceof Ref ? o2 = a2.fetch(l2) : (o2 = l2, l2 = a2.getNewTemporaryRef(), s2.set("ParentTree", l2)), o2 = o2.clone(), r2.put(l2, o2);
    let c2 = o2.getRaw("Nums"), h2 = null;
    c2 instanceof Ref && (h2 = c2, c2 = a2.fetch(h2)), c2 = c2.slice(), h2 || o2.set("Nums", c2);
    const d2 = await StructTreeRoot.#ce({ newAnnotationsByPage: e2, structTreeRootRef: n2, structTreeRoot: this, kids: null, nums: c2, xref: a2, pdfManager: t2, changes: i2, cache: r2 });
    if (-1 !== d2) {
      s2.set("ParentTreeNextKey", d2), h2 && r2.put(h2, c2);
      for (const [e3, t3] of r2.items()) i2.put(e3, { data: t3 });
    }
  }
  static async #ce({ newAnnotationsByPage: e2, structTreeRootRef: t2, structTreeRoot: i2, kids: n2, nums: a2, xref: s2, pdfManager: r2, changes: o2, cache: l2 }) {
    const c2 = Name.get("OBJR");
    let h2, d2 = -1;
    for (const [u2, g2] of e2) {
      const e3 = await r2.getPage(u2), { ref: f2 } = e3, p2 = f2 instanceof Ref;
      for (const { accessibilityData: r3, ref: m2, parentTreeId: b2, structTreeParent: y2 } of g2) {
        if (!r3?.type) continue;
        const { structParent: g3 } = r3;
        if (i2 && Number.isInteger(g3) && g3 >= 0) {
          let t3 = (h2 ||= /* @__PURE__ */ new Map()).get(u2);
          if (void 0 === t3) {
            t3 = new StructTreePage(i2, e3.pageDict).collectObjects(f2), h2.set(u2, t3);
          }
          const n3 = t3?.get(g3);
          if (n3) {
            const e4 = s2.fetch(n3).clone();
            StructTreeRoot.#de(e4, r3), o2.put(n3, { data: e4 });
            continue;
          }
        }
        d2 = Math.max(d2, b2);
        const w2 = s2.getNewTemporaryRef(), x2 = new Dict(s2);
        StructTreeRoot.#de(x2, r3), await this.#ue({ structTreeParent: y2, tagDict: x2, newTagRef: w2, structTreeRootRef: t2, fallbackKids: n2, xref: s2, cache: l2 });
        const S2 = new Dict(s2);
        x2.set("K", S2), S2.set("Type", c2), p2 && S2.set("Pg", f2), S2.set("Obj", m2), l2.put(w2, x2), a2.push(b2, w2);
      }
    }
    return d2 + 1;
  }
  static #de(e2, { type: t2, title: i2, lang: n2, alt: a2, expanded: s2, actualText: r2 }) {
    e2.set("S", Name.get(t2)), i2 && e2.set("T", stringToAsciiOrUTF16BE(i2)), n2 && e2.set("Lang", stringToAsciiOrUTF16BE(n2)), a2 && e2.set("Alt", stringToAsciiOrUTF16BE(a2)), s2 && e2.set("E", stringToAsciiOrUTF16BE(s2)), r2 && e2.set("ActualText", stringToAsciiOrUTF16BE(r2));
  }
  static #he({ elements: e2, xref: t2, pageDict: i2, numberTree: n2 }) {
    const a2 = /* @__PURE__ */ new Map();
    for (const t3 of e2) if (t3.structTreeParentId) {
      const e3 = parseInt(t3.structTreeParentId.split("_mc")[1], 10);
      let i3 = a2.get(e3);
      i3 || (i3 = [], a2.set(e3, i3)), i3.push(t3);
    }
    const s2 = i2.get("StructParents");
    if (!Number.isInteger(s2)) return;
    const r2 = n2.get(s2), updateElement = (e3, i3, n3) => {
      const s3 = a2.get(e3);
      if (s3) {
        const e4 = i3.getRaw("P"), a3 = t2.fetchIfRef(e4);
        if (e4 instanceof Ref && a3 instanceof Dict) {
          const e5 = { ref: n3, dict: i3 };
          for (const t3 of s3) t3.structTreeParent = e5;
        }
        return true;
      }
      return false;
    };
    for (const e3 of r2) {
      if (!(e3 instanceof Ref)) continue;
      const i3 = t2.fetch(e3), n3 = i3.get("K");
      if (Number.isInteger(n3)) updateElement(n3, i3, e3);
      else if (Array.isArray(n3)) for (let a3 of n3) {
        if (a3 = t2.fetchIfRef(a3), Number.isInteger(a3) && updateElement(a3, i3, e3)) break;
        if (!(a3 instanceof Dict)) continue;
        if (!isName(a3.get("Type"), "MCR")) break;
        const n4 = a3.get("MCID");
        if (Number.isInteger(n4) && updateElement(n4, i3, e3)) break;
      }
    }
  }
  static async #ue({ structTreeParent: e2, tagDict: t2, newTagRef: i2, structTreeRootRef: n2, fallbackKids: a2, xref: s2, cache: r2 }) {
    let o2, l2 = null;
    e2 ? ({ ref: l2 } = e2, o2 = e2.dict.getRaw("P") || n2) : o2 = n2, t2.set("P", o2);
    const c2 = s2.fetchIfRef(o2);
    if (!c2) return void a2.push(i2);
    let h2 = r2.get(o2);
    h2 || (h2 = c2.clone(), r2.put(o2, h2));
    const d2 = h2.getRaw("K");
    let u2 = d2 instanceof Ref ? r2.get(d2) : null;
    if (!u2) {
      u2 = s2.fetchIfRef(d2), u2 = Array.isArray(u2) ? u2.slice() : [d2];
      const e3 = s2.getNewTemporaryRef();
      h2.set("K", e3), r2.put(e3, u2);
    }
    const g2 = u2.indexOf(l2);
    u2.splice(g2 >= 0 ? g2 + 1 : u2.length, 0, i2);
  }
}
class StructElementNode {
  constructor(e2, t2) {
    this.tree = e2, this.xref = e2.xref, this.dict = t2, this.kids = [], this.parseKids();
  }
  get role() {
    const e2 = this.dict.get("S"), t2 = e2 instanceof Name ? e2.name : "", { root: i2 } = this.tree;
    return i2.roleMap.get(t2) ?? t2;
  }
  parseKids() {
    let e2 = null;
    const t2 = this.dict.getRaw("Pg");
    t2 instanceof Ref && (e2 = t2.toString());
    const i2 = this.dict.get("K");
    if (Array.isArray(i2)) for (const t3 of i2) {
      const i3 = this.parseKid(e2, this.xref.fetchIfRef(t3));
      i3 && this.kids.push(i3);
    }
    else {
      const t3 = this.parseKid(e2, i2);
      t3 && this.kids.push(t3);
    }
  }
  parseKid(e2, t2) {
    if (Number.isInteger(t2)) return this.tree.pageDict.objId !== e2 ? null : new StructElement({ type: Bs, mcid: t2, pageObjId: e2 });
    if (!(t2 instanceof Dict)) return null;
    const i2 = t2.getRaw("Pg");
    i2 instanceof Ref && (e2 = i2.toString());
    const n2 = t2.get("Type") instanceof Name ? t2.get("Type").name : null;
    if ("MCR" === n2) {
      if (this.tree.pageDict.objId !== e2) return null;
      const i3 = t2.getRaw("Stm");
      return new StructElement({ type: Ns, refObjId: i3 instanceof Ref ? i3.toString() : null, pageObjId: e2, mcid: t2.get("MCID") });
    }
    if ("OBJR" === n2) {
      if (this.tree.pageDict.objId !== e2) return null;
      const i3 = t2.getRaw("Obj");
      return new StructElement({ type: Ls, refObjId: i3 instanceof Ref ? i3.toString() : null, pageObjId: e2 });
    }
    return new StructElement({ type: js, dict: t2 });
  }
}
class StructElement {
  constructor({ type: e2, dict: t2 = null, mcid: i2 = null, pageObjId: n2 = null, refObjId: a2 = null }) {
    this.type = e2, this.dict = t2, this.mcid = i2, this.pageObjId = n2, this.refObjId = a2, this.parentNode = null;
  }
}
class StructTreePage {
  constructor(e2, t2) {
    this.root = e2, this.xref = e2?.xref ?? null, this.rootDict = e2?.dict ?? null, this.pageDict = t2, this.nodes = [];
  }
  collectObjects(e2) {
    if (!(this.root && this.rootDict && e2 instanceof Ref)) return null;
    const t2 = this.rootDict.get("ParentTree");
    if (!t2) return null;
    const i2 = this.root.structParentIds?.get(e2);
    if (!i2) return null;
    const n2 = /* @__PURE__ */ new Map(), a2 = new NumberTree(t2, this.xref);
    for (const [e3] of i2) {
      const t3 = a2.getRaw(e3);
      t3 instanceof Ref && n2.set(e3, t3);
    }
    return n2;
  }
  parse(e2) {
    if (!(this.root && this.rootDict && e2 instanceof Ref)) return;
    const t2 = this.rootDict.get("ParentTree");
    if (!t2) return;
    const i2 = this.pageDict.get("StructParents"), n2 = this.root.structParentIds?.get(e2);
    if (!Number.isInteger(i2) && !n2) return;
    const a2 = /* @__PURE__ */ new Map(), s2 = new NumberTree(t2, this.xref);
    if (Number.isInteger(i2)) {
      const e3 = s2.get(i2);
      if (Array.isArray(e3)) for (const t3 of e3) t3 instanceof Ref && this.addNode(this.xref.fetch(t3), a2);
    }
    if (n2) for (const [e3, t3] of n2) {
      const i3 = s2.get(e3);
      if (i3) {
        const e4 = this.addNode(this.xref.fetchIfRef(i3), a2);
        1 === e4?.kids?.length && e4.kids[0].type === Ls && (e4.kids[0].type = t3);
      }
    }
  }
  addNode(e2, t2, i2 = 0) {
    if (i2 > 40) return warn$1("StructTree MAX_DEPTH reached."), null;
    if (!(e2 instanceof Dict)) return null;
    if (t2.has(e2)) return t2.get(e2);
    const n2 = new StructElementNode(this, e2);
    t2.set(e2, n2);
    const a2 = e2.get("P");
    if (!(a2 instanceof Dict) || isName(a2.get("Type"), "StructTreeRoot")) return this.addTopLevelNode(e2, n2) || t2.delete(e2), n2;
    const s2 = this.addNode(a2, t2, i2 + 1);
    if (!s2) return n2;
    let r2 = false;
    for (const t3 of s2.kids) t3.type === js && t3.dict === e2 && (t3.parentNode = n2, r2 = true);
    return r2 || t2.delete(e2), n2;
  }
  addTopLevelNode(e2, t2) {
    const i2 = this.rootDict.get("K");
    if (!i2) return false;
    if (i2 instanceof Dict) return i2.objId === e2.objId && (this.nodes[0] = t2, true);
    if (!Array.isArray(i2)) return true;
    let n2 = false;
    for (let a2 = 0; a2 < i2.length; a2++) {
      const s2 = i2[a2];
      s2?.toString() === e2.objId && (this.nodes[a2] = t2, n2 = true);
    }
    return n2;
  }
  get serializable() {
    function nodeToSerializable(e3, t2, i2 = 0) {
      if (i2 > 40) return void warn$1("StructTree too deep to be fully serialized.");
      const n2 = /* @__PURE__ */ Object.create(null);
      n2.role = e3.role, n2.children = [], t2.children.push(n2);
      let a2 = e3.dict.get("Alt");
      "string" != typeof a2 && (a2 = e3.dict.get("ActualText")), "string" == typeof a2 && (n2.alt = stringToPDFString(a2));
      const s2 = e3.dict.get("A");
      if (s2 instanceof Dict) {
        const e4 = lookupNormalRect(s2.getArray("BBox"), null);
        if (e4) n2.bbox = e4;
        else {
          const e5 = s2.get("Width"), t3 = s2.get("Height");
          "number" == typeof e5 && e5 > 0 && "number" == typeof t3 && t3 > 0 && (n2.bbox = [0, 0, e5, t3]);
        }
      }
      const r2 = e3.dict.get("Lang");
      "string" == typeof r2 && (n2.lang = stringToPDFString(r2));
      for (const t3 of e3.kids) {
        const e4 = t3.type === js ? t3.parentNode : null;
        e4 ? nodeToSerializable(e4, n2, i2 + 1) : t3.type === Bs || t3.type === Ns ? n2.children.push({ type: "content", id: `p${t3.pageObjId}_mc${t3.mcid}` }) : t3.type === Ls ? n2.children.push({ type: "object", id: t3.refObjId }) : t3.type === Us && n2.children.push({ type: "annotation", id: `pdfjs_internal_id_${t3.refObjId}` });
      }
    }
    const e2 = /* @__PURE__ */ Object.create(null);
    e2.children = [], e2.role = "Root";
    for (const t2 of this.nodes) t2 && nodeToSerializable(t2, e2);
    return e2;
  }
}
const $s = (function(e2, t2, i2) {
  if (!Array.isArray(i2) || i2.length < 2) return false;
  const [n2, a2, ...s2] = i2;
  if (!e2(n2) && !Number.isInteger(n2)) return false;
  if (!t2(a2)) return false;
  const r2 = s2.length;
  let o2 = true;
  switch (a2.name) {
    case "XYZ":
      if (r2 < 2 || r2 > 3) return false;
      break;
    case "Fit":
    case "FitB":
      return 0 === r2;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (r2 > 1) return false;
      break;
    case "FitR":
      if (4 !== r2) return false;
      o2 = false;
      break;
    default:
      return false;
  }
  for (const e3 of s2) if (!("number" == typeof e3 || o2 && null === e3)) return false;
  return true;
}).bind(null, (e2) => e2 instanceof Ref, isName);
function fetchDest(e2) {
  return e2 instanceof Dict && (e2 = e2.get("D")), $s(e2) ? e2 : null;
}
function fetchRemoteDest(e2) {
  let t2 = e2.get("D");
  if (t2) {
    if (t2 instanceof Name && (t2 = t2.name), "string" == typeof t2) return stringToPDFString(t2, true);
    if ($s(t2)) return JSON.stringify(t2);
  }
  return null;
}
class Catalog {
  #ge = null;
  #fe = null;
  builtInCMapCache = /* @__PURE__ */ new Map();
  fontCache = new RefSetCache();
  globalColorSpaceCache = new GlobalColorSpaceCache();
  globalImageCache = new GlobalImageCache();
  nonBlendModesSet = new RefSet();
  pageDictCache = new RefSetCache();
  pageIndexCache = new RefSetCache();
  pageKidsCountCache = new RefSetCache();
  standardFontDataCache = /* @__PURE__ */ new Map();
  systemFontCache = /* @__PURE__ */ new Map();
  constructor(e2, t2) {
    if (this.pdfManager = e2, this.xref = t2, this.#fe = t2.getCatalogObj(), !(this.#fe instanceof Dict)) throw new ti("Catalog object is not a dictionary.");
    this.toplevelPagesDict;
  }
  cloneDict() {
    return this.#fe.clone();
  }
  get version() {
    const e2 = this.#fe.get("Version");
    if (e2 instanceof Name) {
      if (gi.test(e2.name)) return shadow$1(this, "version", e2.name);
      warn$1(`Invalid PDF catalog version: ${e2.name}`);
    }
    return shadow$1(this, "version", null);
  }
  get lang() {
    const e2 = this.#fe.get("Lang");
    return shadow$1(this, "lang", e2 && "string" == typeof e2 ? stringToPDFString(e2) : null);
  }
  get needsRendering() {
    const e2 = this.#fe.get("NeedsRendering");
    return shadow$1(this, "needsRendering", "boolean" == typeof e2 && e2);
  }
  get collection() {
    let e2 = null;
    try {
      const t2 = this.#fe.get("Collection");
      t2 instanceof Dict && t2.size > 0 && (e2 = t2);
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      info$1("Cannot fetch Collection entry; assuming no collection is present.");
    }
    return shadow$1(this, "collection", e2);
  }
  get acroForm() {
    let e2 = null;
    try {
      const t2 = this.#fe.get("AcroForm");
      t2 instanceof Dict && t2.size > 0 && (e2 = t2);
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      info$1("Cannot fetch AcroForm entry; assuming no forms are present.");
    }
    return shadow$1(this, "acroForm", e2);
  }
  get acroFormRef() {
    const e2 = this.#fe.getRaw("AcroForm");
    return shadow$1(this, "acroFormRef", e2 instanceof Ref ? e2 : null);
  }
  get metadata() {
    const e2 = this.#fe.getRaw("Metadata");
    if (!(e2 instanceof Ref)) return shadow$1(this, "metadata", null);
    let t2 = null;
    try {
      const i2 = this.xref.fetch(e2, !this.xref.encrypt?.encryptMetadata);
      if (i2 instanceof BaseStream && i2.dict instanceof Dict) {
        const e3 = i2.dict.get("Type"), n2 = i2.dict.get("Subtype");
        if (isName(e3, "Metadata") && isName(n2, "XML")) {
          const e4 = stringToUTF8String$1(i2.getString());
          e4 && (t2 = new MetadataParser(e4).serializable);
        }
      }
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      info$1(`Skipping invalid Metadata: "${e3}".`);
    }
    return shadow$1(this, "metadata", t2);
  }
  get markInfo() {
    let e2 = null;
    try {
      e2 = this.#pe();
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn$1("Unable to read mark info.");
    }
    return shadow$1(this, "markInfo", e2);
  }
  #pe() {
    const e2 = this.#fe.get("MarkInfo");
    if (!(e2 instanceof Dict)) return null;
    const t2 = { Marked: false, UserProperties: false, Suspects: false };
    for (const i2 in t2) {
      const n2 = e2.get(i2);
      "boolean" == typeof n2 && (t2[i2] = n2);
    }
    return t2;
  }
  get structTreeRoot() {
    let e2 = null;
    try {
      e2 = this.#me();
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn$1("Unable read to structTreeRoot info.");
    }
    return shadow$1(this, "structTreeRoot", e2);
  }
  #me() {
    const e2 = this.#fe.getRaw("StructTreeRoot"), t2 = this.xref.fetchIfRef(e2);
    if (!(t2 instanceof Dict)) return null;
    const i2 = new StructTreeRoot(this.xref, t2, e2);
    return i2.init(), i2;
  }
  get toplevelPagesDict() {
    const e2 = this.#fe.get("Pages");
    if (!(e2 instanceof Dict)) throw new ti("Invalid top-level pages dictionary.");
    return shadow$1(this, "toplevelPagesDict", e2);
  }
  get documentOutline() {
    let e2 = null;
    try {
      e2 = this.#be();
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn$1("Unable to read document outline.");
    }
    return shadow$1(this, "documentOutline", e2);
  }
  #be() {
    let e2 = this.#fe.get("Outlines");
    if (!(e2 instanceof Dict)) return null;
    if (e2 = e2.getRaw("First"), !(e2 instanceof Ref)) return null;
    const t2 = { items: [] }, i2 = [{ obj: e2, parent: t2 }], n2 = new RefSet();
    n2.put(e2);
    const a2 = this.xref, s2 = new Uint8ClampedArray(3);
    for (; i2.length > 0; ) {
      const t3 = i2.shift(), r2 = a2.fetchIfRef(t3.obj);
      if (null === r2) continue;
      r2.has("Title") || warn$1("Invalid outline item encountered.");
      const o2 = { url: null, dest: null, action: null };
      Catalog.parseDestDictionary({ destDict: r2, resultObj: o2, docBaseUrl: this.baseUrl, docAttachments: this.attachments });
      const l2 = r2.get("Title"), c2 = r2.get("F") || 0, h2 = r2.getArray("C"), d2 = r2.get("Count");
      let u2 = s2;
      !isNumberArray(h2, 3) || 0 === h2[0] && 0 === h2[1] && 0 === h2[2] || (u2 = ColorSpaceUtils.rgb.getRgb(h2, 0));
      const g2 = { action: o2.action, attachment: o2.attachment, dest: o2.dest, url: o2.url, unsafeUrl: o2.unsafeUrl, newWindow: o2.newWindow, setOCGState: o2.setOCGState, title: "string" == typeof l2 ? stringToPDFString(l2) : "", color: u2, count: Number.isInteger(d2) ? d2 : void 0, bold: !!(2 & c2), italic: !!(1 & c2), items: [] };
      t3.parent.items.push(g2), e2 = r2.getRaw("First"), e2 instanceof Ref && !n2.has(e2) && (i2.push({ obj: e2, parent: g2 }), n2.put(e2)), e2 = r2.getRaw("Next"), e2 instanceof Ref && !n2.has(e2) && (i2.push({ obj: e2, parent: t3.parent }), n2.put(e2));
    }
    return t2.items.length > 0 ? t2.items : null;
  }
  get permissions() {
    let e2 = null;
    try {
      e2 = this.#ye();
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn$1("Unable to read permissions.");
    }
    return shadow$1(this, "permissions", e2);
  }
  #ye() {
    const e2 = this.xref.trailer.get("Encrypt");
    if (!(e2 instanceof Dict)) return null;
    let t2 = e2.get("P");
    if ("number" != typeof t2) return null;
    t2 += 2 ** 32;
    const i2 = [];
    for (const e3 in w) {
      const n2 = w[e3];
      t2 & n2 && i2.push(n2);
    }
    return i2;
  }
  get optionalContentConfig() {
    let e2 = null;
    try {
      const t2 = this.#fe.get("OCProperties");
      if (!t2) return shadow$1(this, "optionalContentConfig", null);
      const i2 = t2.get("D");
      if (!i2) return shadow$1(this, "optionalContentConfig", null);
      const n2 = t2.get("OCGs");
      if (!Array.isArray(n2)) return shadow$1(this, "optionalContentConfig", null);
      const a2 = new RefSetCache();
      for (const e3 of n2) e3 instanceof Ref && !a2.has(e3) && a2.put(e3, this.#we(e3));
      e2 = this.#Ae(i2, a2);
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn$1(`Unable to read optional content config: ${e3}`);
    }
    return shadow$1(this, "optionalContentConfig", e2);
  }
  #we(e2) {
    const t2 = this.xref.fetch(e2), i2 = { id: e2.toString(), name: null, intent: null, usage: { print: null, view: null }, rbGroups: [] }, n2 = t2.get("Name");
    "string" == typeof n2 && (i2.name = stringToPDFString(n2));
    let a2 = t2.getArray("Intent");
    Array.isArray(a2) || (a2 = [a2]), a2.every((e3) => e3 instanceof Name) && (i2.intent = a2.map((e3) => e3.name));
    const s2 = t2.get("Usage");
    if (!(s2 instanceof Dict)) return i2;
    const r2 = i2.usage, o2 = s2.get("Print");
    if (o2 instanceof Dict) {
      const e3 = o2.get("PrintState");
      if (e3 instanceof Name) switch (e3.name) {
        case "ON":
        case "OFF":
          r2.print = { printState: e3.name };
      }
    }
    const l2 = s2.get("View");
    if (l2 instanceof Dict) {
      const e3 = l2.get("ViewState");
      if (e3 instanceof Name) switch (e3.name) {
        case "ON":
        case "OFF":
          r2.view = { viewState: e3.name };
      }
    }
    return i2;
  }
  #Ae(e2, t2) {
    function parseOnOff(e3) {
      const i3 = [];
      if (Array.isArray(e3)) for (const n3 of e3) n3 instanceof Ref && t2.has(n3) && i3.push(n3.toString());
      return i3;
    }
    function parseOrder(e3, i3 = 0) {
      if (!Array.isArray(e3)) return null;
      const a3 = [];
      for (const s3 of e3) {
        if (s3 instanceof Ref && t2.has(s3)) {
          n2.put(s3), a3.push(s3.toString());
          continue;
        }
        const e4 = parseNestedOrder(s3, i3);
        e4 && a3.push(e4);
      }
      if (i3 > 0) return a3;
      const s2 = [];
      for (const [e4] of t2.items()) n2.has(e4) || s2.push(e4.toString());
      return s2.length && a3.push({ name: null, order: s2 }), a3;
    }
    function parseNestedOrder(e3, t3) {
      if (++t3 > a2) return warn$1("parseNestedOrder - reached MAX_NESTED_LEVELS."), null;
      const n3 = i2.fetchIfRef(e3);
      if (!Array.isArray(n3)) return null;
      const s2 = i2.fetchIfRef(n3[0]);
      if ("string" != typeof s2) return null;
      const r2 = parseOrder(n3.slice(1), t3);
      return r2?.length ? { name: stringToPDFString(s2), order: r2 } : null;
    }
    const i2 = this.xref, n2 = new RefSet(), a2 = 10;
    return (function(e3) {
      if (Array.isArray(e3)) for (const n3 of e3) {
        const e4 = i2.fetchIfRef(n3);
        if (!Array.isArray(e4) || !e4.length) continue;
        const a3 = /* @__PURE__ */ new Set();
        for (const i3 of e4) i3 instanceof Ref && t2.has(i3) && !a3.has(i3.toString()) && (a3.add(i3.toString()), t2.get(i3).rbGroups.push(a3));
      }
    })(e2.get("RBGroups")), { name: "string" == typeof e2.get("Name") ? stringToPDFString(e2.get("Name")) : null, creator: "string" == typeof e2.get("Creator") ? stringToPDFString(e2.get("Creator")) : null, baseState: e2.get("BaseState") instanceof Name ? e2.get("BaseState").name : null, on: parseOnOff(e2.get("ON")), off: parseOnOff(e2.get("OFF")), order: parseOrder(e2.get("Order")), groups: [...t2] };
  }
  setActualNumPages(e2 = null) {
    this.#ge = e2;
  }
  get hasActualNumPages() {
    return null !== this.#ge;
  }
  get _pagesCount() {
    const e2 = this.toplevelPagesDict.get("Count");
    if (!Number.isInteger(e2)) throw new ti("Page count in top-level pages dictionary is not an integer.");
    return shadow$1(this, "_pagesCount", e2);
  }
  get numPages() {
    return this.#ge ?? this._pagesCount;
  }
  get destinations() {
    const e2 = this.#xe(), t2 = /* @__PURE__ */ Object.create(null);
    for (const i2 of e2) if (i2 instanceof NameTree) for (const [e3, n2] of i2.getAll()) {
      const i3 = fetchDest(n2);
      i3 && (t2[stringToPDFString(e3, true)] = i3);
    }
    else if (i2 instanceof Dict) for (const [e3, n2] of i2) {
      const i3 = fetchDest(n2);
      i3 && (t2[stringToPDFString(e3, true)] ||= i3);
    }
    return shadow$1(this, "destinations", t2);
  }
  getDestination(e2) {
    if (this.hasOwnProperty("destinations")) return this.destinations[e2] ?? null;
    const t2 = this.#xe();
    for (const i2 of t2) if (i2 instanceof NameTree || i2 instanceof Dict) {
      const t3 = fetchDest(i2.get(e2));
      if (t3) return t3;
    }
    if (t2.length) {
      const t3 = this.destinations[e2];
      if (t3) return t3;
    }
    return null;
  }
  #xe() {
    const e2 = this.#fe.get("Names"), t2 = [];
    return e2?.has("Dests") && t2.push(new NameTree(e2.getRaw("Dests"), this.xref)), this.#fe.has("Dests") && t2.push(this.#fe.get("Dests")), t2;
  }
  get pageLabels() {
    let e2 = null;
    try {
      e2 = this.#Se();
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn$1("Unable to read page labels.");
    }
    return shadow$1(this, "pageLabels", e2);
  }
  #Se() {
    const e2 = this.#fe.getRaw("PageLabels");
    if (!e2) return null;
    const t2 = new Array(this.numPages);
    let i2 = null, n2 = "";
    const a2 = new NumberTree(e2, this.xref).getAll();
    let s2 = "", r2 = 1;
    for (let e3 = 0, o2 = this.numPages; e3 < o2; e3++) {
      const o3 = a2.get(e3);
      if (void 0 !== o3) {
        if (!(o3 instanceof Dict)) throw new ti("PageLabel is not a dictionary.");
        if (o3.has("Type") && !isName(o3.get("Type"), "PageLabel")) throw new ti("Invalid type in PageLabel dictionary.");
        if (o3.has("S")) {
          const e4 = o3.get("S");
          if (!(e4 instanceof Name)) throw new ti("Invalid style in PageLabel dictionary.");
          i2 = e4.name;
        } else i2 = null;
        if (o3.has("P")) {
          const e4 = o3.get("P");
          if ("string" != typeof e4) throw new ti("Invalid prefix in PageLabel dictionary.");
          n2 = stringToPDFString(e4);
        } else n2 = "";
        if (o3.has("St")) {
          const e4 = o3.get("St");
          if (!(Number.isInteger(e4) && e4 >= 1)) throw new ti("Invalid start in PageLabel dictionary.");
          r2 = e4;
        } else r2 = 1;
      }
      switch (i2) {
        case "D":
          s2 = r2;
          break;
        case "R":
        case "r":
          s2 = toRomanNumerals(r2, "r" === i2);
          break;
        case "A":
        case "a":
          const e4 = 26, t3 = "a" === i2 ? 97 : 65, n3 = r2 - 1;
          s2 = String.fromCharCode(t3 + n3 % e4).repeat(Math.floor(n3 / e4) + 1);
          break;
        default:
          if (i2) throw new ti(`Invalid style "${i2}" in PageLabel dictionary.`);
          s2 = "";
      }
      t2[e3] = n2 + s2, r2++;
    }
    return t2;
  }
  get pageLayout() {
    const e2 = this.#fe.get("PageLayout");
    let t2 = "";
    if (e2 instanceof Name) switch (e2.name) {
      case "SinglePage":
      case "OneColumn":
      case "TwoColumnLeft":
      case "TwoColumnRight":
      case "TwoPageLeft":
      case "TwoPageRight":
        t2 = e2.name;
    }
    return shadow$1(this, "pageLayout", t2);
  }
  get pageMode() {
    const e2 = this.#fe.get("PageMode");
    let t2 = "UseNone";
    if (e2 instanceof Name) switch (e2.name) {
      case "UseNone":
      case "UseOutlines":
      case "UseThumbs":
      case "FullScreen":
      case "UseOC":
      case "UseAttachments":
        t2 = e2.name;
    }
    return shadow$1(this, "pageMode", t2);
  }
  get viewerPreferences() {
    const e2 = this.#fe.get("ViewerPreferences");
    if (!(e2 instanceof Dict)) return shadow$1(this, "viewerPreferences", null);
    let t2 = null;
    for (const [i2, n2] of e2) {
      let e3;
      switch (i2) {
        case "HideToolbar":
        case "HideMenubar":
        case "HideWindowUI":
        case "FitWindow":
        case "CenterWindow":
        case "DisplayDocTitle":
        case "PickTrayByPDFSize":
          "boolean" == typeof n2 && (e3 = n2);
          break;
        case "NonFullScreenPageMode":
          if (n2 instanceof Name) switch (n2.name) {
            case "UseNone":
            case "UseOutlines":
            case "UseThumbs":
            case "UseOC":
              e3 = n2.name;
              break;
            default:
              e3 = "UseNone";
          }
          break;
        case "Direction":
          if (n2 instanceof Name) switch (n2.name) {
            case "L2R":
            case "R2L":
              e3 = n2.name;
              break;
            default:
              e3 = "L2R";
          }
          break;
        case "ViewArea":
        case "ViewClip":
        case "PrintArea":
        case "PrintClip":
          if (n2 instanceof Name) switch (n2.name) {
            case "MediaBox":
            case "CropBox":
            case "BleedBox":
            case "TrimBox":
            case "ArtBox":
              e3 = n2.name;
              break;
            default:
              e3 = "CropBox";
          }
          break;
        case "PrintScaling":
          if (n2 instanceof Name) switch (n2.name) {
            case "None":
            case "AppDefault":
              e3 = n2.name;
              break;
            default:
              e3 = "AppDefault";
          }
          break;
        case "Duplex":
          if (n2 instanceof Name) switch (n2.name) {
            case "Simplex":
            case "DuplexFlipShortEdge":
            case "DuplexFlipLongEdge":
              e3 = n2.name;
              break;
            default:
              e3 = "None";
          }
          break;
        case "PrintPageRange":
          if (Array.isArray(n2) && n2.length % 2 == 0) {
            n2.every((e4, t3, i3) => Number.isInteger(e4) && e4 > 0 && (0 === t3 || e4 >= i3[t3 - 1]) && e4 <= this.numPages) && (e3 = n2);
          }
          break;
        case "NumCopies":
          Number.isInteger(n2) && n2 > 0 && (e3 = n2);
          break;
        default:
          warn$1(`Ignoring non-standard key in ViewerPreferences: ${i2}.`);
          continue;
      }
      void 0 !== e3 ? (t2 ??= /* @__PURE__ */ Object.create(null), t2[i2] = e3) : warn$1(`Bad value, for key "${i2}", in ViewerPreferences: ${n2}.`);
    }
    return shadow$1(this, "viewerPreferences", t2);
  }
  get openAction() {
    const e2 = this.#fe.get("OpenAction"), t2 = /* @__PURE__ */ Object.create(null);
    if (e2 instanceof Dict) {
      const i2 = new Dict(this.xref);
      i2.set("A", e2);
      const n2 = { url: null, dest: null, action: null };
      Catalog.parseDestDictionary({ destDict: i2, resultObj: n2 }), Array.isArray(n2.dest) ? t2.dest = n2.dest : n2.action && (t2.action = n2.action);
    } else $s(e2) && (t2.dest = e2);
    return shadow$1(this, "openAction", objectSize(t2) > 0 ? t2 : null);
  }
  get attachments() {
    const e2 = this.#fe.get("Names");
    let t2 = null;
    if (e2 instanceof Dict && e2.has("EmbeddedFiles")) {
      const i2 = new NameTree(e2.getRaw("EmbeddedFiles"), this.xref);
      for (const [e3, n2] of i2.getAll()) {
        const i3 = new FileSpec(n2, this.xref);
        t2 ??= /* @__PURE__ */ Object.create(null), t2[stringToPDFString(e3, true)] = i3.serializable;
      }
    }
    return shadow$1(this, "attachments", t2);
  }
  get xfaImages() {
    const e2 = this.#fe.get("Names");
    let t2 = null;
    if (e2 instanceof Dict && e2.has("XFAImages")) {
      const i2 = new NameTree(e2.getRaw("XFAImages"), this.xref);
      for (const [e3, n2] of i2.getAll()) n2 instanceof BaseStream && (t2 ??= /* @__PURE__ */ new Map(), t2.set(stringToPDFString(e3, true), n2.getBytes()));
    }
    return shadow$1(this, "xfaImages", t2);
  }
  #ve() {
    const e2 = this.#fe.get("Names");
    let t2 = null;
    function appendIfJavaScriptDict(e3, i3) {
      if (!(i3 instanceof Dict)) return;
      if (!isName(i3.get("S"), "JavaScript")) return;
      let n2 = i3.get("JS");
      if (n2 instanceof BaseStream) n2 = n2.getString();
      else if ("string" != typeof n2) return;
      n2 = stringToPDFString(n2, true).replaceAll("\0", ""), n2 && (t2 ||= /* @__PURE__ */ new Map()).set(e3, n2);
    }
    if (e2 instanceof Dict && e2.has("JavaScript")) {
      const t3 = new NameTree(e2.getRaw("JavaScript"), this.xref);
      for (const [e3, i3] of t3.getAll()) appendIfJavaScriptDict(stringToPDFString(e3, true), i3);
    }
    const i2 = this.#fe.get("OpenAction");
    return i2 && appendIfJavaScriptDict("OpenAction", i2), t2;
  }
  get jsActions() {
    const e2 = this.#ve();
    let t2 = collectActions(this.xref, this.#fe, ie);
    if (e2) {
      t2 ||= /* @__PURE__ */ Object.create(null);
      for (const [i2, n2] of e2) i2 in t2 ? t2[i2].push(n2) : t2[i2] = [n2];
    }
    return shadow$1(this, "jsActions", t2);
  }
  async cleanup(e2 = false) {
    clearGlobalCaches(), this.globalColorSpaceCache.clear(), this.globalImageCache.clear(e2), this.pageKidsCountCache.clear(), this.pageIndexCache.clear(), this.pageDictCache.clear(), this.nonBlendModesSet.clear();
    for (const { dict: e3 } of await Promise.all(this.fontCache)) delete e3.cacheKey;
    this.fontCache.clear(), this.builtInCMapCache.clear(), this.standardFontDataCache.clear(), this.systemFontCache.clear();
  }
  async getPageDict(e2) {
    const t2 = [this.toplevelPagesDict], i2 = new RefSet(), n2 = this.#fe.getRaw("Pages");
    n2 instanceof Ref && i2.put(n2);
    const a2 = this.xref, s2 = this.pageKidsCountCache, r2 = this.pageIndexCache, o2 = this.pageDictCache;
    let l2 = 0;
    for (; t2.length; ) {
      const n3 = t2.pop();
      if (n3 instanceof Ref) {
        const c3 = s2.get(n3);
        if (c3 >= 0 && l2 + c3 <= e2) {
          l2 += c3;
          continue;
        }
        if (i2.has(n3)) throw new ti("Pages tree contains circular reference.");
        i2.put(n3);
        const h3 = await (o2.get(n3) || a2.fetchAsync(n3));
        if (h3 instanceof Dict) {
          let t3 = h3.getRaw("Type");
          if (t3 instanceof Ref && (t3 = await a2.fetchAsync(t3)), isName(t3, "Page") || !h3.has("Kids")) {
            if (s2.has(n3) || s2.put(n3, 1), r2.has(n3) || r2.put(n3, l2), l2 === e2) return [h3, n3];
            l2++;
            continue;
          }
        }
        t2.push(h3);
        continue;
      }
      if (!(n3 instanceof Dict)) throw new ti("Page dictionary kid reference points to wrong type of object.");
      const { objId: c2 } = n3;
      let h2 = n3.getRaw("Count");
      if (h2 instanceof Ref && (h2 = await a2.fetchAsync(h2)), Number.isInteger(h2) && h2 >= 0 && (c2 && !s2.has(c2) && s2.put(c2, h2), l2 + h2 <= e2)) {
        l2 += h2;
        continue;
      }
      let d2 = n3.getRaw("Kids");
      if (d2 instanceof Ref && (d2 = await a2.fetchAsync(d2)), !Array.isArray(d2)) {
        let t3 = n3.getRaw("Type");
        if (t3 instanceof Ref && (t3 = await a2.fetchAsync(t3)), isName(t3, "Page") || !n3.has("Kids")) {
          if (l2 === e2) return [n3, null];
          l2++;
          continue;
        }
        throw new ti("Page dictionary kids object is not an array.");
      }
      for (let e3 = d2.length - 1; e3 >= 0; e3--) {
        const i3 = d2[e3];
        t2.push(i3), n3 === this.toplevelPagesDict && i3 instanceof Ref && !o2.has(i3) && o2.put(i3, a2.fetchAsync(i3));
      }
    }
    throw new Error(`Page index ${e2} not found.`);
  }
  async getAllPageDicts(e2 = false) {
    const { ignoreErrors: t2 } = this.pdfManager.evaluatorOptions, i2 = [{ currentNode: this.toplevelPagesDict, posInKids: 0 }], n2 = new RefSet(), a2 = this.#fe.getRaw("Pages");
    a2 instanceof Ref && n2.put(a2);
    const s2 = /* @__PURE__ */ new Map(), r2 = this.xref, o2 = this.pageIndexCache;
    let l2 = 0;
    function addPageDict(e3, t3) {
      t3 && !o2.has(t3) && o2.put(t3, l2), s2.set(l2++, [e3, t3]);
    }
    function addPageError(i3) {
      if (i3 instanceof XRefEntryException && !e2) throw i3;
      e2 && t2 && 0 === l2 && (warn$1(`getAllPageDicts - Skipping invalid first page: "${i3}".`), i3 = Dict.empty), s2.set(l2++, [i3, null]);
    }
    for (; i2.length > 0; ) {
      const e3 = i2.at(-1), { currentNode: t3, posInKids: a3 } = e3;
      let s3 = t3.getRaw("Kids");
      if (s3 instanceof Ref) try {
        s3 = await r2.fetchAsync(s3);
      } catch (e4) {
        addPageError(e4);
        break;
      }
      if (!Array.isArray(s3)) {
        addPageError(new ti("Page dictionary kids object is not an array."));
        break;
      }
      if (a3 >= s3.length) {
        i2.pop();
        continue;
      }
      const o3 = s3[a3];
      let l3;
      if (o3 instanceof Ref) {
        if (n2.has(o3)) {
          addPageError(new ti("Pages tree contains circular reference."));
          break;
        }
        n2.put(o3);
        try {
          l3 = await r2.fetchAsync(o3);
        } catch (e4) {
          addPageError(e4);
          break;
        }
      } else l3 = o3;
      if (!(l3 instanceof Dict)) {
        addPageError(new ti("Page dictionary kid reference points to wrong type of object."));
        break;
      }
      let c2 = l3.getRaw("Type");
      if (c2 instanceof Ref) try {
        c2 = await r2.fetchAsync(c2);
      } catch (e4) {
        addPageError(e4);
        break;
      }
      isName(c2, "Page") || !l3.has("Kids") ? addPageDict(l3, o3 instanceof Ref ? o3 : null) : i2.push({ currentNode: l3, posInKids: 0 }), e3.posInKids++;
    }
    return s2;
  }
  getPageIndex(e2) {
    const t2 = this.pageIndexCache.get(e2);
    if (void 0 !== t2) return Promise.resolve(t2);
    const i2 = this.xref;
    let n2 = 0;
    const next = (t3) => (function(t4) {
      let n3, a2 = 0;
      return i2.fetchAsync(t4).then(function(i3) {
        if (isRefsEqual(t4, e2) && !isDict(i3, "Page") && !(i3 instanceof Dict && !i3.has("Type") && i3.has("Contents"))) throw new ti("The reference does not point to a /Page dictionary.");
        if (!i3) return null;
        if (!(i3 instanceof Dict)) throw new ti("Node must be a dictionary.");
        return n3 = i3.getRaw("Parent"), i3.getAsync("Parent");
      }).then(function(e3) {
        if (!e3) return null;
        if (!(e3 instanceof Dict)) throw new ti("Parent must be a dictionary.");
        return e3.getAsync("Kids");
      }).then(function(e3) {
        if (!e3) return null;
        const s2 = [];
        let r2 = false;
        for (const n4 of e3) {
          if (!(n4 instanceof Ref)) throw new ti("Kid must be a reference.");
          if (isRefsEqual(n4, t4)) {
            r2 = true;
            break;
          }
          s2.push(i2.fetchAsync(n4).then(function(e4) {
            if (!(e4 instanceof Dict)) throw new ti("Kid node must be a dictionary.");
            e4.has("Count") ? a2 += e4.get("Count") : a2++;
          }));
        }
        if (!r2) throw new ti("Kid reference not found in parent's kids.");
        return Promise.all(s2).then(() => [a2, n3]);
      });
    })(t3).then((t4) => {
      if (!t4) return this.pageIndexCache.put(e2, n2), n2;
      const [i3, a2] = t4;
      return n2 += i3, next(a2);
    });
    return next(e2);
  }
  get baseUrl() {
    const e2 = this.#fe.get("URI");
    if (e2 instanceof Dict) {
      const t2 = e2.get("Base");
      if ("string" == typeof t2) {
        const e3 = createValidAbsoluteUrl$1(t2, null, { tryConvertEncoding: true });
        if (e3) return shadow$1(this, "baseUrl", e3.href);
      }
    }
    return shadow$1(this, "baseUrl", this.pdfManager.docBaseUrl);
  }
  static parseDestDictionary({ destDict: e2, resultObj: t2, docBaseUrl: i2 = null, docAttachments: n2 = null }) {
    if (!(e2 instanceof Dict)) return void warn$1("parseDestDictionary: `destDict` must be a dictionary.");
    let a2, s2, r2 = e2.get("A");
    if (r2 instanceof Dict || (e2.has("Dest") ? r2 = e2.get("Dest") : (r2 = e2.get("AA"), r2 instanceof Dict && (r2.has("D") ? r2 = r2.get("D") : r2.has("U") && (r2 = r2.get("U"))))), r2 instanceof Dict) {
      const e3 = r2.get("S");
      if (!(e3 instanceof Name)) return void warn$1("parseDestDictionary: Invalid type in Action dictionary.");
      const i3 = e3.name;
      switch (i3) {
        case "ResetForm":
          const e4 = r2.get("Flags"), o2 = !(1 & ("number" == typeof e4 ? e4 : 0)), l2 = [], c2 = [];
          for (const e5 of r2.get("Fields") || []) e5 instanceof Ref ? c2.push(e5.toString()) : "string" == typeof e5 && l2.push(stringToPDFString(e5));
          t2.resetForm = { fields: l2, refs: c2, include: o2 };
          break;
        case "URI":
          a2 = r2.get("URI"), a2 instanceof Name && (a2 = "/" + a2.name);
          break;
        case "GoTo":
          s2 = r2.get("D");
          break;
        case "Launch":
        case "GoToR":
          const h2 = r2.get("F");
          if (h2 instanceof Dict) {
            const e5 = new FileSpec(h2, null, true), { rawFilename: t3 } = e5.serializable;
            a2 = t3;
          } else "string" == typeof h2 && (a2 = h2);
          const d2 = fetchRemoteDest(r2);
          d2 && "string" == typeof a2 && (a2 = a2.split("#", 1)[0] + "#" + d2);
          const u2 = r2.get("NewWindow");
          "boolean" == typeof u2 && (t2.newWindow = u2);
          break;
        case "GoToE":
          const g2 = r2.get("T");
          let f2;
          if (n2 && g2 instanceof Dict) {
            const e5 = g2.get("R"), t3 = g2.get("N");
            isName(e5, "C") && "string" == typeof t3 && (f2 = n2[stringToPDFString(t3, true)]);
          }
          if (f2) {
            t2.attachment = f2;
            const e5 = fetchRemoteDest(r2);
            e5 && (t2.attachmentDest = e5);
          } else warn$1('parseDestDictionary - unimplemented "GoToE" action.');
          break;
        case "Named":
          const p2 = r2.get("N");
          p2 instanceof Name && (t2.action = p2.name);
          break;
        case "SetOCGState":
          const m2 = r2.get("State"), b2 = r2.get("PreserveRB");
          if (!Array.isArray(m2) || 0 === m2.length) break;
          const y2 = [];
          for (const e5 of m2) if (e5 instanceof Name) switch (e5.name) {
            case "ON":
            case "OFF":
            case "Toggle":
              y2.push(e5.name);
          }
          else e5 instanceof Ref && y2.push(e5.toString());
          if (y2.length !== m2.length) break;
          t2.setOCGState = { state: y2, preserveRB: "boolean" != typeof b2 || b2 };
          break;
        case "JavaScript":
          const w2 = r2.get("JS");
          let x2;
          w2 instanceof BaseStream ? x2 = w2.getString() : "string" == typeof w2 && (x2 = w2);
          const S2 = x2 && recoverJsURL(stringToPDFString(x2, true));
          if (S2) {
            a2 = S2.url, t2.newWindow = S2.newWindow;
            break;
          }
        default:
          if ("JavaScript" === i3 || "SubmitForm" === i3) break;
          warn$1(`parseDestDictionary - unsupported action: "${i3}".`);
      }
    } else e2.has("Dest") && (s2 = e2.get("Dest"));
    if ("string" == typeof a2) {
      const e3 = createValidAbsoluteUrl$1(a2, i2, { addDefaultProtocol: true, tryConvertEncoding: true });
      e3 && (t2.url = e3.href), t2.unsafeUrl = a2;
    }
    s2 && (s2 instanceof Name && (s2 = s2.name), "string" == typeof s2 ? t2.dest = stringToPDFString(s2, true) : $s(s2) && (t2.dest = s2));
  }
}
function mayHaveChildren(e2) {
  return e2 instanceof Ref || e2 instanceof Dict || e2 instanceof BaseStream || Array.isArray(e2);
}
function addChildren(e2, t2) {
  if (e2 instanceof Dict) e2 = e2.getRawValues();
  else if (e2 instanceof BaseStream) e2 = e2.dict.getRawValues();
  else if (!Array.isArray(e2)) return;
  for (const i2 of e2) mayHaveChildren(i2) && t2.push(i2);
}
class ObjectLoader {
  refSet = new RefSet();
  constructor(e2, t2, i2) {
    this.dict = e2, this.keys = t2, this.xref = i2;
  }
  async load() {
    const { keys: e2, dict: t2 } = this, i2 = [];
    for (const n2 of e2) {
      const e3 = t2.getRaw(n2);
      void 0 !== e3 && i2.push(e3);
    }
    await this.#Ce(i2), this.refSet = null;
  }
  async #Ce(e2) {
    const t2 = [], i2 = [];
    for (; e2.length; ) {
      let n2 = e2.pop();
      if (n2 instanceof Ref) {
        if (this.refSet.has(n2)) continue;
        try {
          this.refSet.put(n2), n2 = this.xref.fetch(n2);
        } catch (e3) {
          if (!(e3 instanceof MissingDataException)) return warn$1(`ObjectLoader.#walk - requesting all data: "${e3}".`), void await this.xref.stream.manager.requestAllChunks();
          t2.push(n2), i2.push({ begin: e3.begin, end: e3.end });
        }
      }
      if (n2 instanceof BaseStream) {
        const e3 = n2.getBaseStreams();
        if (e3) {
          let a2 = false;
          for (const t3 of e3) t3.isDataLoaded || (a2 = true, i2.push({ begin: t3.start, end: t3.end }));
          a2 && t2.push(n2);
        }
      }
      addChildren(n2, e2);
    }
    if (i2.length) {
      await this.xref.stream.manager.requestRanges(i2);
      for (const e3 of t2) e3 instanceof Ref && this.refSet.remove(e3);
      await this.#Ce(t2);
    }
  }
  static async load(e2, t2, i2) {
    if (i2.stream.isDataLoaded) return;
    const n2 = new ObjectLoader(e2, t2, i2);
    await n2.load();
  }
}
const Hs = Symbol(), Xs = Symbol(), qs = Symbol(), zs = Symbol(), Ws = Symbol(), Gs = Symbol(), Vs = Symbol(), Ks = Symbol(), Ys = Symbol(), Js = Symbol("content"), Zs = Symbol("data"), Qs = Symbol(), er = Symbol("extra"), tr = Symbol(), ir = Symbol(), nr = Symbol(), ar = Symbol(), sr = Symbol(), rr = Symbol(), or = Symbol(), lr = Symbol(), cr = Symbol(), hr = Symbol(), dr = Symbol(), ur = Symbol(), gr = Symbol(), fr = Symbol(), pr = Symbol(), mr = Symbol(), br = Symbol(), yr = Symbol(), wr = Symbol(), Ar = Symbol(), xr = Symbol(), Sr = Symbol(), vr = Symbol(), Cr = Symbol(), kr = Symbol(), Tr = Symbol(), Fr = Symbol(), Ir = Symbol(), Er = Symbol(), Mr = Symbol(), Dr = Symbol(), Or = Symbol(), _r = Symbol("namespaceId"), Pr = Symbol("nodeName"), Rr = Symbol(), Nr = Symbol(), Lr = Symbol(), Ur = Symbol(), jr = Symbol(), $r = Symbol(), Hr = Symbol(), Xr = Symbol(), qr = Symbol("root"), zr = Symbol(), Wr = Symbol(), Gr = Symbol(), Vr = Symbol(), Kr = Symbol(), Yr = Symbol(), Jr = Symbol(), Zr = Symbol(), Qr = Symbol(), eo = Symbol(), to = Symbol(), io = Symbol("uid"), no = Symbol(), ao = { config: { id: 0, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xci/") }, connectionSet: { id: 1, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-connection-set/") }, datasets: { id: 2, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-data/") }, form: { id: 3, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-form/") }, localeSet: { id: 4, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-locale-set/") }, pdf: { id: 5, check: (e2) => "http://ns.adobe.com/xdp/pdf/" === e2 }, signature: { id: 6, check: (e2) => "http://www.w3.org/2000/09/xmldsig#" === e2 }, sourceSet: { id: 7, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-source-set/") }, stylesheet: { id: 8, check: (e2) => "http://www.w3.org/1999/XSL/Transform" === e2 }, template: { id: 9, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-template/") }, xdc: { id: 10, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xdc/") }, xdp: { id: 11, check: (e2) => "http://ns.adobe.com/xdp/" === e2 }, xfdf: { id: 12, check: (e2) => "http://ns.adobe.com/xfdf/" === e2 }, xhtml: { id: 13, check: (e2) => "http://www.w3.org/1999/xhtml" === e2 }, xmpmeta: { id: 14, check: (e2) => "http://ns.adobe.com/xmpmeta/" === e2 } }, so = { pt: (e2) => e2, cm: (e2) => e2 / 2.54 * 72, mm: (e2) => e2 / 25.4 * 72, in: (e2) => 72 * e2, px: (e2) => e2 }, ro = /([+-]?\d+\.?\d*)(.*)/;
function stripQuotes(e2) {
  return e2.startsWith("'") || e2.startsWith('"') ? e2.slice(1, -1) : e2;
}
function getInteger({ data: e2, defaultValue: t2, validate: i2 }) {
  if (!e2) return t2;
  e2 = e2.trim();
  const n2 = parseInt(e2, 10);
  return !isNaN(n2) && i2(n2) ? n2 : t2;
}
function getFloat({ data: e2, defaultValue: t2, validate: i2 }) {
  if (!e2) return t2;
  e2 = e2.trim();
  const n2 = parseFloat(e2);
  return !isNaN(n2) && i2(n2) ? n2 : t2;
}
function getKeyword({ data: e2, defaultValue: t2, validate: i2 }) {
  return e2 && i2(e2 = e2.trim()) ? e2 : t2;
}
function getStringOption(e2, t2) {
  return getKeyword({ data: e2, defaultValue: t2[0], validate: (e3) => t2.includes(e3) });
}
function getMeasurement(e2, t2 = "0") {
  if (t2 ||= "0", !e2) return getMeasurement(t2);
  const i2 = e2.trim().match(ro);
  if (!i2) return getMeasurement(t2);
  const [, n2, a2] = i2, s2 = parseFloat(n2);
  if (isNaN(s2)) return getMeasurement(t2);
  if (0 === s2) return 0;
  const r2 = so[a2];
  return r2 ? r2(s2) : s2;
}
function getRatio(e2) {
  if (!e2) return { num: 1, den: 1 };
  const t2 = e2.split(":", 2).map((e3) => parseFloat(e3.trim())).filter((e3) => !isNaN(e3));
  if (1 === t2.length && t2.push(1), 0 === t2.length) return { num: 1, den: 1 };
  const [i2, n2] = t2;
  return { num: i2, den: n2 };
}
function getRelevant(e2) {
  return e2 ? e2.trim().split(/\s+/).map((e3) => ({ excluded: "-" === e3[0], viewname: e3.substring(1) })) : [];
}
class HTMLResult {
  static get FAILURE() {
    return shadow$1(this, "FAILURE", new HTMLResult(false, null, null, null));
  }
  static get EMPTY() {
    return shadow$1(this, "EMPTY", new HTMLResult(true, null, null, null));
  }
  constructor(e2, t2, i2, n2) {
    this.success = e2, this.html = t2, this.bbox = i2, this.breakNode = n2;
  }
  isBreak() {
    return !!this.breakNode;
  }
  static breakNode(e2) {
    return new HTMLResult(false, null, null, e2);
  }
  static success(e2, t2 = null) {
    return new HTMLResult(true, e2, t2, null);
  }
}
class FontFinder {
  constructor(e2) {
    this.fonts = /* @__PURE__ */ new Map(), this.cache = /* @__PURE__ */ new Map(), this.warned = /* @__PURE__ */ new Set(), this.defaultFont = null, this.add(e2);
  }
  add(e2, t2 = null) {
    for (const t3 of e2) this.addPdfFont(t3);
    for (const e3 of this.fonts.values()) e3.regular || (e3.regular = e3.italic || e3.bold || e3.bolditalic);
    if (!t2 || 0 === t2.size) return;
    const i2 = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
    for (const e3 of t2) this.fonts.set(e3, i2);
  }
  addPdfFont(e2) {
    const t2 = e2.cssFontInfo, i2 = t2.fontFamily;
    let n2 = this.fonts.get(i2);
    n2 || (n2 = /* @__PURE__ */ Object.create(null), this.fonts.set(i2, n2), this.defaultFont || (this.defaultFont = n2));
    let a2 = "";
    const s2 = parseFloat(t2.fontWeight);
    0 !== parseFloat(t2.italicAngle) ? a2 = s2 >= 700 ? "bolditalic" : "italic" : s2 >= 700 && (a2 = "bold"), a2 || ((e2.name.includes("Bold") || e2.psName?.includes("Bold")) && (a2 = "bold"), (e2.name.includes("Italic") || e2.name.endsWith("It") || e2.psName?.includes("Italic") || e2.psName?.endsWith("It")) && (a2 += "italic")), a2 || (a2 = "regular"), n2[a2] = e2;
  }
  getDefault() {
    return this.defaultFont;
  }
  find(e2, t2 = true) {
    let i2 = this.fonts.get(e2) || this.cache.get(e2);
    if (i2) return i2;
    const n2 = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
    let a2 = e2.replaceAll(n2, "");
    if (i2 = this.fonts.get(a2), i2) return this.cache.set(e2, i2), i2;
    a2 = a2.toLowerCase();
    const s2 = [];
    for (const [e3, t3] of this.fonts.entries()) e3.replaceAll(n2, "").toLowerCase().startsWith(a2) && s2.push(t3);
    if (0 === s2.length) for (const [, e3] of this.fonts.entries()) e3.regular.name?.replaceAll(n2, "").toLowerCase().startsWith(a2) && s2.push(e3);
    if (0 === s2.length) {
      a2 = a2.replaceAll(/psmt|mt/gi, "");
      for (const [e3, t3] of this.fonts.entries()) e3.replaceAll(n2, "").toLowerCase().startsWith(a2) && s2.push(t3);
    }
    if (0 === s2.length) for (const e3 of this.fonts.values()) e3.regular.name?.replaceAll(n2, "").toLowerCase().startsWith(a2) && s2.push(e3);
    return s2.length >= 1 ? (1 !== s2.length && t2 && warn$1(`XFA - Too many choices to guess the correct font: ${e2}`), this.cache.set(e2, s2[0]), s2[0]) : (t2 && !this.warned.has(e2) && (this.warned.add(e2), warn$1(`XFA - Cannot find the font: ${e2}`)), null);
  }
}
function selectFont(e2, t2) {
  return "italic" === e2.posture ? "bold" === e2.weight ? t2.bolditalic : t2.italic : "bold" === e2.weight ? t2.bold : t2.regular;
}
class text_FontInfo {
  constructor(e2, t2, i2, n2) {
    if (this.lineHeight = i2, this.paraMargin = t2 || { top: 0, bottom: 0, left: 0, right: 0 }, !e2) return void ([this.pdfFont, this.xfaFont] = this.defaultFont(n2));
    this.xfaFont = { typeface: e2.typeface, posture: e2.posture, weight: e2.weight, size: e2.size, letterSpacing: e2.letterSpacing };
    const a2 = n2.find(e2.typeface);
    a2 ? (this.pdfFont = selectFont(e2, a2), this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(n2))) : [this.pdfFont, this.xfaFont] = this.defaultFont(n2);
  }
  defaultFont(e2) {
    const t2 = e2.find("Helvetica", false) || e2.find("Myriad Pro", false) || e2.find("Arial", false) || e2.getDefault();
    if (t2?.regular) {
      const e3 = t2.regular;
      return [e3, { typeface: e3.cssFontInfo.fontFamily, posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
    }
    return [null, { typeface: "Courier", posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
  }
}
class FontSelector {
  constructor(e2, t2, i2, n2) {
    this.fontFinder = n2, this.stack = [new text_FontInfo(e2, t2, i2, n2)];
  }
  pushData(e2, t2, i2) {
    const n2 = this.stack.at(-1);
    for (const t3 of ["typeface", "posture", "weight", "size", "letterSpacing"]) e2[t3] || (e2[t3] = n2.xfaFont[t3]);
    for (const e3 of ["top", "bottom", "left", "right"]) isNaN(t2[e3]) && (t2[e3] = n2.paraMargin[e3]);
    const a2 = new text_FontInfo(e2, t2, i2 || n2.lineHeight, this.fontFinder);
    a2.pdfFont || (a2.pdfFont = n2.pdfFont), this.stack.push(a2);
  }
  popFont() {
    this.stack.pop();
  }
  topFont() {
    return this.stack.at(-1);
  }
}
class TextMeasure {
  constructor(e2, t2, i2, n2) {
    this.glyphs = [], this.fontSelector = new FontSelector(e2, t2, i2, n2), this.extraHeight = 0;
  }
  pushData(e2, t2, i2) {
    this.fontSelector.pushData(e2, t2, i2);
  }
  popFont(e2) {
    return this.fontSelector.popFont();
  }
  addPara() {
    const e2 = this.fontSelector.topFont();
    this.extraHeight += e2.paraMargin.top + e2.paraMargin.bottom;
  }
  addString(e2) {
    if (!e2) return;
    const t2 = this.fontSelector.topFont(), i2 = t2.xfaFont.size;
    if (t2.pdfFont) {
      const n2 = t2.xfaFont.letterSpacing, a2 = t2.pdfFont, s2 = a2.lineHeight || 1.2, r2 = t2.lineHeight || Math.max(1.2, s2) * i2, o2 = s2 - (void 0 === a2.lineGap ? 0.2 : a2.lineGap), l2 = Math.max(1, o2) * i2, c2 = i2 / 1e3, h2 = a2.defaultWidth || a2.charsToGlyphs(" ")[0].width;
      for (const t3 of e2.split(/[\u2029\n]/)) {
        const e3 = a2.encodeString(t3).join(""), i3 = a2.charsToGlyphs(e3);
        for (const e4 of i3) {
          const t4 = e4.width || h2;
          this.glyphs.push([t4 * c2 + n2, r2, l2, e4.unicode, false]);
        }
        this.glyphs.push([0, 0, 0, "\n", true]);
      }
      return void this.glyphs.pop();
    }
    for (const t3 of e2.split(/[\u2029\n]/)) {
      for (const e3 of t3.split("")) this.glyphs.push([i2, 1.2 * i2, i2, e3, false]);
      this.glyphs.push([0, 0, 0, "\n", true]);
    }
    this.glyphs.pop();
  }
  compute(e2) {
    let t2 = -1, i2 = 0, n2 = 0, a2 = 0, s2 = 0, r2 = 0, o2 = false, l2 = true;
    for (let c2 = 0, h2 = this.glyphs.length; c2 < h2; c2++) {
      const [h3, d2, u2, g2, f2] = this.glyphs[c2], p2 = " " === g2, m2 = l2 ? u2 : d2;
      f2 ? (n2 = Math.max(n2, s2), s2 = 0, a2 += r2, r2 = m2, t2 = -1, i2 = 0, l2 = false) : p2 ? s2 + h3 > e2 ? (n2 = Math.max(n2, s2), s2 = 0, a2 += r2, r2 = m2, t2 = -1, i2 = 0, o2 = true, l2 = false) : (r2 = Math.max(m2, r2), i2 = s2, s2 += h3, t2 = c2) : s2 + h3 > e2 ? (a2 += r2, r2 = m2, -1 !== t2 ? (c2 = t2, n2 = Math.max(n2, i2), s2 = 0, t2 = -1, i2 = 0) : (n2 = Math.max(n2, s2), s2 = h3), o2 = true, l2 = false) : (s2 += h3, r2 = Math.max(m2, r2));
    }
    return n2 = Math.max(n2, s2), a2 += r2 + this.extraHeight, { width: 1.02 * n2, height: a2, isBroken: o2 };
  }
}
const oo = /^[^.[]+/, lo = /^[^\]]+/, co = 0, ho = 1, uo = 2, go = 3, fo = 4, po = /* @__PURE__ */ new Map([["$data", (e2, t2) => e2.datasets ? e2.datasets.data : e2], ["$record", (e2, t2) => (e2.datasets ? e2.datasets.data : e2)[ur]()[0]], ["$template", (e2, t2) => e2.template], ["$connectionSet", (e2, t2) => e2.connectionSet], ["$form", (e2, t2) => e2.form], ["$layout", (e2, t2) => e2.layout], ["$host", (e2, t2) => e2.host], ["$dataWindow", (e2, t2) => e2.dataWindow], ["$event", (e2, t2) => e2.event], ["!", (e2, t2) => e2.datasets], ["$xfa", (e2, t2) => e2], ["xfa", (e2, t2) => e2], ["$", (e2, t2) => t2]]), mo = /* @__PURE__ */ new WeakMap();
function parseIndex(e2) {
  return "*" === (e2 = e2.trim()) ? 1 / 0 : parseInt(e2, 10) || 0;
}
function parseExpression(e2, t2, i2 = true) {
  let n2 = e2.match(oo);
  if (!n2) return null;
  let [a2] = n2;
  const s2 = [{ name: a2, cacheName: "." + a2, index: 0, js: null, formCalc: null, operator: co }];
  let r2 = a2.length;
  for (; r2 < e2.length; ) {
    const o2 = r2;
    if ("[" === e2.charAt(r2++)) {
      if (n2 = e2.slice(r2).match(lo), !n2) return warn$1("XFA - Invalid index in SOM expression"), null;
      s2.at(-1).index = parseIndex(n2[0]), r2 += n2[0].length + 1;
      continue;
    }
    let l2;
    switch (e2.charAt(r2)) {
      case ".":
        if (!t2) return null;
        r2++, l2 = ho;
        break;
      case "#":
        r2++, l2 = uo;
        break;
      case "[":
        if (i2) return warn$1("XFA - SOM expression contains a FormCalc subexpression which is not supported for now."), null;
        l2 = go;
        break;
      case "(":
        if (i2) return warn$1("XFA - SOM expression contains a JavaScript subexpression which is not supported for now."), null;
        l2 = fo;
        break;
      default:
        l2 = co;
    }
    if (n2 = e2.slice(r2).match(oo), !n2) break;
    [a2] = n2, r2 += a2.length, s2.push({ name: a2, cacheName: e2.slice(o2, r2), operator: l2, index: 0, js: null, formCalc: null });
  }
  return s2;
}
function searchNode(e2, t2, i2, n2 = true, a2 = true) {
  const s2 = parseExpression(i2, n2);
  if (!s2) return null;
  const r2 = po.get(s2[0].name);
  let o2, l2 = 0;
  r2 ? (o2 = true, e2 = [r2(e2, t2)], l2 = 1) : (o2 = null === t2, e2 = [t2 || e2]);
  for (let i3 = s2.length; l2 < i3; l2++) {
    const { name: i4, cacheName: n3, operator: r3, index: c2 } = s2[l2], h2 = [];
    for (const t3 of e2) {
      if (!t3.isXFAObject) continue;
      let e3, s3;
      if (a2 && (s3 = mo.get(t3), s3 || (s3 = /* @__PURE__ */ new Map(), mo.set(t3, s3)), e3 = s3.get(n3)), !e3) {
        switch (r3) {
          case co:
            e3 = t3[or](i4, false);
            break;
          case ho:
            e3 = t3[or](i4, true);
            break;
          case uo:
            e3 = t3[rr](i4), e3 = e3.isXFAObjectArray ? e3.children : [e3];
        }
        a2 && s3.set(n3, e3);
      }
      e3.length > 0 && h2.push(e3);
    }
    if (0 === h2.length && !o2 && 0 === l2) {
      const i5 = t2[mr]();
      if (!(t2 = i5)) return null;
      l2 = -1, e2 = [t2];
      continue;
    }
    e2 = isFinite(c2) ? h2.filter((e3) => c2 < e3.length).map((e3) => e3[c2]) : h2.flat();
  }
  return 0 === e2.length ? null : e2;
}
function createDataNode(e2, t2, i2) {
  const n2 = parseExpression(i2);
  if (!n2) return null;
  if (n2.some((e3) => e3.operator === ho)) return null;
  const a2 = po.get(n2[0].name);
  let s2 = 0;
  a2 ? (e2 = a2(e2, t2), s2 = 1) : e2 = t2 || e2;
  for (let t3 = n2.length; s2 < t3; s2++) {
    const { name: t4, operator: i3, index: a3 } = n2[s2];
    if (!isFinite(a3)) return n2[s2].index = 0, e2.createNodes(n2.slice(s2));
    let r2;
    switch (i3) {
      case co:
        r2 = e2[or](t4, false);
        break;
      case ho:
        r2 = e2[or](t4, true);
        break;
      case uo:
        r2 = e2[rr](t4), r2 = r2.isXFAObjectArray ? r2.children : [r2];
    }
    if (0 === r2.length) return e2.createNodes(n2.slice(s2));
    if (!(a3 < r2.length)) return n2[s2].index = a3 - r2.length, e2.createNodes(n2.slice(s2));
    {
      const t5 = r2[a3];
      if (!t5.isXFAObject) return warn$1("XFA - Cannot create a node."), null;
      e2 = t5;
    }
  }
  return null;
}
const bo = Symbol(), yo = Symbol(), wo = Symbol(), Ao = Symbol("_children"), xo = Symbol(), So = Symbol(), vo = Symbol(), Co = Symbol(), ko = Symbol(), Fo = Symbol(), Io = Symbol(), Eo = Symbol(), Mo = Symbol(), Do = Symbol("parent"), Oo = Symbol(), _o = Symbol(), Po = Symbol();
let Ro = 0;
const Bo = ao.datasets.id;
class XFAObject {
  constructor(e2, t2, i2 = false) {
    this[_r] = e2, this[Pr] = t2, this[Io] = i2, this[Do] = null, this[Ao] = [], this[io] = `${t2}${Ro++}`, this[yr] = null;
  }
  get isXFAObject() {
    return true;
  }
  get isXFAObjectArray() {
    return false;
  }
  createNodes(e2) {
    let t2 = this, i2 = null;
    for (const { name: n2, index: a2 } of e2) {
      for (let e3 = 0, s2 = isFinite(a2) ? a2 : 0; e3 <= s2; e3++) {
        const e4 = t2[_r] === Bo ? -1 : t2[_r];
        i2 = new XmlObject(e4, n2), t2[qs](i2);
      }
      t2 = i2;
    }
    return i2;
  }
  [Nr](e2) {
    if (!this[Io] || !this[Lr](e2)) return false;
    const t2 = e2[Pr], i2 = this[t2];
    if (!(i2 instanceof XFAObjectArray)) return null !== i2 && this[Xr](i2), this[t2] = e2, this[qs](e2), true;
    if (i2.push(e2)) return this[qs](e2), true;
    let n2 = "";
    return this.id ? n2 = ` (id: ${this.id})` : this.name && (n2 = ` (name: ${this.name} ${this.h.value})`), warn$1(`XFA - node "${this[Pr]}"${n2} has already enough "${t2}"!`), false;
  }
  [Lr](e2) {
    return this.hasOwnProperty(e2[Pr]) && e2[_r] === this[_r];
  }
  [Fr]() {
    return false;
  }
  [Hs]() {
    return false;
  }
  [vr]() {
    return false;
  }
  [Cr]() {
    return false;
  }
  [$r]() {
    this.para && this[br]()[er].paraStack.pop();
  }
  [Hr]() {
    this[br]()[er].paraStack.push(this.para);
  }
  [Gr](e2) {
    this.id && this[_r] === ao.template.id && e2.set(this.id, this);
  }
  [br]() {
    return this[yr].template;
  }
  [Ir]() {
    return false;
  }
  [Er]() {
    return false;
  }
  [qs](e2) {
    e2[Do] = this, this[Ao].push(e2), !e2[yr] && this[yr] && (e2[yr] = this[yr]);
  }
  [Xr](e2) {
    const t2 = this[Ao].indexOf(e2);
    this[Ao].splice(t2, 1);
  }
  [wr]() {
    return this.hasOwnProperty("value");
  }
  [Kr](e2) {
  }
  [Ur](e2) {
  }
  [tr]() {
  }
  [Ws](e2) {
    delete this[Io], this[Vs] && (e2.clean(this[Vs]), delete this[Vs]);
  }
  [xr](e2) {
    return this[Ao].indexOf(e2);
  }
  [Sr](e2, t2) {
    t2[Do] = this, this[Ao].splice(e2, 0, t2), !t2[yr] && this[yr] && (t2[yr] = this[yr]);
  }
  [Mr]() {
    return !this.name;
  }
  [Or]() {
    return "";
  }
  [Jr]() {
    return 0 === this[Ao].length ? this[Js] : this[Ao].map((e2) => e2[Jr]()).join("");
  }
  get [wo]() {
    const e2 = Object.getPrototypeOf(this);
    if (!e2._attributes) {
      const t2 = e2._attributes = /* @__PURE__ */ new Set();
      for (const e3 of Object.getOwnPropertyNames(this)) {
        if (null === this[e3] || this[e3] instanceof XFAObject || this[e3] instanceof XFAObjectArray) break;
        t2.add(e3);
      }
    }
    return shadow$1(this, wo, e2._attributes);
  }
  [Tr](e2) {
    let t2 = this;
    for (; t2; ) {
      if (t2 === e2) return true;
      t2 = t2[mr]();
    }
    return false;
  }
  [mr]() {
    return this[Do];
  }
  [pr]() {
    return this[mr]();
  }
  [ur](e2 = null) {
    return e2 ? this[e2] : this[Ao];
  }
  [Qs]() {
    const e2 = /* @__PURE__ */ Object.create(null);
    this[Js] && (e2.$content = this[Js]);
    for (const t2 of Object.getOwnPropertyNames(this)) {
      const i2 = this[t2];
      null !== i2 && (i2 instanceof XFAObject ? e2[t2] = i2[Qs]() : i2 instanceof XFAObjectArray ? i2.isEmpty() || (e2[t2] = i2.dump()) : e2[t2] = i2);
    }
    return e2;
  }
  [to]() {
    return null;
  }
  [Qr]() {
    return HTMLResult.EMPTY;
  }
  *[gr]() {
    for (const e2 of this[ur]()) yield e2;
  }
  *[Co](e2, t2) {
    for (const i2 of this[gr]()) if (!e2 || t2 === e2.has(i2[Pr])) {
      const e3 = this[sr](), t3 = i2[Qr](e3);
      t3.success || (this[er].failingNode = i2), yield t3;
    }
  }
  [ir]() {
    return null;
  }
  [Xs](e2, t2) {
    this[er].children.push(e2);
  }
  [sr]() {
  }
  [zs]({ filter: e2 = null, include: t2 = true }) {
    if (this[er].generator) {
      const e3 = this[sr](), t3 = this[er].failingNode[Qr](e3);
      if (!t3.success) return t3;
      t3.html && this[Xs](t3.html, t3.bbox), delete this[er].failingNode;
    } else this[er].generator = this[Co](e2, t2);
    for (; ; ) {
      const e3 = this[er].generator.next();
      if (e3.done) break;
      const t3 = e3.value;
      if (!t3.success) return t3;
      t3.html && this[Xs](t3.html, t3.bbox);
    }
    return this[er].generator = null, HTMLResult.EMPTY;
  }
  [Vr](e2) {
    this[_o] = new Set(Object.keys(e2));
  }
  [Fo](e2) {
    const t2 = this[wo], i2 = this[_o];
    return [...e2].filter((e3) => t2.has(e3) && !i2.has(e3));
  }
  [zr](e2, t2 = /* @__PURE__ */ new Set()) {
    for (const i2 of this[Ao]) i2[Oo](e2, t2);
  }
  [Oo](e2, t2) {
    const i2 = this[ko](e2, t2);
    i2 ? this[bo](i2, e2, t2) : this[zr](e2, t2);
  }
  [ko](e2, t2) {
    const { use: i2, usehref: n2 } = this;
    if (!i2 && !n2) return null;
    let a2 = null, s2 = null, r2 = null, o2 = i2;
    if (n2 ? (o2 = n2, n2.startsWith("#som(") && n2.endsWith(")") ? s2 = n2.slice(5, -1) : n2.startsWith(".#som(") && n2.endsWith(")") ? s2 = n2.slice(6, -1) : n2.startsWith("#") ? r2 = n2.slice(1) : n2.startsWith(".#") && (r2 = n2.slice(2))) : i2.startsWith("#") ? r2 = i2.slice(1) : s2 = i2, this.use = this.usehref = "", r2 ? a2 = e2.get(r2) : (a2 = searchNode(e2.get(qr), this, s2, true, false), a2 && (a2 = a2[0])), !a2) return warn$1(`XFA - Invalid prototype reference: ${o2}.`), null;
    if (a2[Pr] !== this[Pr]) return warn$1(`XFA - Incompatible prototype: ${a2[Pr]} !== ${this[Pr]}.`), null;
    if (t2.has(a2)) return warn$1("XFA - Cycle detected in prototypes use."), null;
    t2.add(a2);
    const l2 = a2[ko](e2, t2);
    return l2 && a2[bo](l2, e2, t2), a2[zr](e2, t2), t2.delete(a2), a2;
  }
  [bo](e2, t2, i2) {
    if (i2.has(e2)) return void warn$1("XFA - Cycle detected in prototypes use.");
    !this[Js] && e2[Js] && (this[Js] = e2[Js]);
    new Set(i2).add(e2);
    for (const t3 of this[Fo](e2[_o])) this[t3] = e2[t3], this[_o] && this[_o].add(t3);
    for (const n2 of Object.getOwnPropertyNames(this)) {
      if (this[wo].has(n2)) continue;
      const a2 = this[n2], s2 = e2[n2];
      if (a2 instanceof XFAObjectArray) {
        for (const e3 of a2[Ao]) e3[Oo](t2, i2);
        for (let n3 = a2[Ao].length, r2 = s2[Ao].length; n3 < r2; n3++) {
          const s3 = e2[Ao][n3][Ks]();
          if (!a2.push(s3)) break;
          s3[Do] = this, this[Ao].push(s3), s3[Oo](t2, i2);
        }
      } else if (null === a2) {
        if (null !== s2) {
          const e3 = s2[Ks]();
          e3[Do] = this, this[n2] = e3, this[Ao].push(e3), e3[Oo](t2, i2);
        }
      } else a2[zr](t2, i2), s2 && a2[bo](s2, t2, i2);
    }
  }
  static [xo](e2) {
    return Array.isArray(e2) ? e2.map((e3) => XFAObject[xo](e3)) : "object" == typeof e2 && null !== e2 ? Object.assign({}, e2) : e2;
  }
  [Ks]() {
    const e2 = Object.create(Object.getPrototypeOf(this));
    for (const t2 of Object.getOwnPropertySymbols(this)) try {
      e2[t2] = this[t2];
    } catch {
      shadow$1(e2, t2, this[t2]);
    }
    e2[io] = `${e2[Pr]}${Ro++}`, e2[Ao] = [];
    for (const t2 of Object.getOwnPropertyNames(this)) {
      if (this[wo].has(t2)) {
        e2[t2] = XFAObject[xo](this[t2]);
        continue;
      }
      const i2 = this[t2];
      e2[t2] = i2 instanceof XFAObjectArray ? new XFAObjectArray(i2[Eo]) : null;
    }
    for (const t2 of this[Ao]) {
      const i2 = t2[Pr], n2 = t2[Ks]();
      e2[Ao].push(n2), n2[Do] = e2, null === e2[i2] ? e2[i2] = n2 : e2[i2][Ao].push(n2);
    }
    return e2;
  }
  [ur](e2 = null) {
    return e2 ? this[Ao].filter((t2) => t2[Pr] === e2) : this[Ao];
  }
  [rr](e2) {
    return this[e2];
  }
  [or](e2, t2, i2 = true) {
    return Array.from(this[lr](e2, t2, i2));
  }
  *[lr](e2, t2, i2 = true) {
    if ("parent" !== e2) {
      for (const i3 of this[Ao]) i3[Pr] === e2 && (yield i3), i3.name === e2 && (yield i3), (t2 || i3[Mr]()) && (yield* i3[lr](e2, t2, false));
      i2 && this[wo].has(e2) && (yield new XFAAttribute(this, e2, this[e2]));
    } else yield this[Do];
  }
}
class XFAObjectArray {
  constructor(e2 = 1 / 0) {
    this[Eo] = e2, this[Ao] = [];
  }
  get isXFAObject() {
    return false;
  }
  get isXFAObjectArray() {
    return true;
  }
  push(e2) {
    return this[Ao].length <= this[Eo] ? (this[Ao].push(e2), true) : (warn$1(`XFA - node "${e2[Pr]}" accepts no more than ${this[Eo]} children`), false);
  }
  isEmpty() {
    return 0 === this[Ao].length;
  }
  dump() {
    return 1 === this[Ao].length ? this[Ao][0][Qs]() : this[Ao].map((e2) => e2[Qs]());
  }
  [Ks]() {
    const e2 = new XFAObjectArray(this[Eo]);
    return e2[Ao] = this[Ao].map((e3) => e3[Ks]()), e2;
  }
  get children() {
    return this[Ao];
  }
  clear() {
    this[Ao].length = 0;
  }
}
class XFAAttribute {
  constructor(e2, t2, i2) {
    this[Do] = e2, this[Pr] = t2, this[Js] = i2, this[Ys] = false, this[io] = "attribute" + Ro++;
  }
  [mr]() {
    return this[Do];
  }
  [kr]() {
    return true;
  }
  [cr]() {
    return this[Js].trim();
  }
  [Kr](e2) {
    e2 = e2.value || "", this[Js] = e2.toString();
  }
  [Jr]() {
    return this[Js];
  }
  [Tr](e2) {
    return this[Do] === e2 || this[Do][Tr](e2);
  }
}
class XmlObject extends XFAObject {
  constructor(e2, t2, i2 = {}) {
    if (super(e2, t2), this[Js] = "", this[So] = null, "#text" !== t2) {
      const e3 = /* @__PURE__ */ new Map();
      this[yo] = e3;
      for (const [t3, n2] of Object.entries(i2)) e3.set(t3, new XFAAttribute(this, t3, n2));
      if (i2.hasOwnProperty(Rr)) {
        const e4 = i2[Rr].xfa.dataNode;
        void 0 !== e4 && ("dataGroup" === e4 ? this[So] = false : "dataValue" === e4 && (this[So] = true));
      }
    }
    this[Ys] = false;
  }
  [eo](e2) {
    const t2 = this[Pr];
    if ("#text" === t2) return void e2.push(encodeToXmlString(this[Js]));
    const i2 = utf8StringToString(t2), n2 = this[_r] === Bo ? "xfa:" : "";
    e2.push(`<${n2}${i2}`);
    for (const [t3, i3] of this[yo].entries()) {
      const n3 = utf8StringToString(t3);
      e2.push(` ${n3}="${encodeToXmlString(i3[Js])}"`);
    }
    if (null !== this[So] && (this[So] ? e2.push(' xfa:dataNode="dataValue"') : e2.push(' xfa:dataNode="dataGroup"')), this[Js] || 0 !== this[Ao].length) {
      if (e2.push(">"), this[Js]) "string" == typeof this[Js] ? e2.push(encodeToXmlString(this[Js])) : this[Js][eo](e2);
      else for (const t3 of this[Ao]) t3[eo](e2);
      e2.push(`</${n2}${i2}>`);
    } else e2.push("/>");
  }
  [Nr](e2) {
    if (this[Js]) {
      const e3 = new XmlObject(this[_r], "#text");
      this[qs](e3), e3[Js] = this[Js], this[Js] = "";
    }
    return this[qs](e2), true;
  }
  [Ur](e2) {
    this[Js] += e2;
  }
  [tr]() {
    if (this[Js] && this[Ao].length > 0) {
      const e2 = new XmlObject(this[_r], "#text");
      this[qs](e2), e2[Js] = this[Js], delete this[Js];
    }
  }
  [Qr]() {
    return "#text" === this[Pr] ? HTMLResult.success({ name: "#text", value: this[Js] }) : HTMLResult.EMPTY;
  }
  [ur](e2 = null) {
    return e2 ? this[Ao].filter((t2) => t2[Pr] === e2) : this[Ao];
  }
  [ar]() {
    return this[yo];
  }
  [rr](e2) {
    const t2 = this[yo].get(e2);
    return void 0 !== t2 ? t2 : this[ur](e2);
  }
  *[lr](e2, t2) {
    const i2 = this[yo].get(e2);
    i2 && (yield i2);
    for (const i3 of this[Ao]) i3[Pr] === e2 && (yield i3), t2 && (yield* i3[lr](e2, t2));
  }
  *[nr](e2, t2) {
    const i2 = this[yo].get(e2);
    !i2 || t2 && i2[Ys] || (yield i2);
    for (const i3 of this[Ao]) yield* i3[nr](e2, t2);
  }
  *[dr](e2, t2, i2) {
    for (const n2 of this[Ao]) n2[Pr] !== e2 || i2 && n2[Ys] || (yield n2), t2 && (yield* n2[dr](e2, t2, i2));
  }
  [kr]() {
    return null === this[So] ? 0 === this[Ao].length || this[Ao][0][_r] === ao.xhtml.id : this[So];
  }
  [cr]() {
    return null === this[So] ? 0 === this[Ao].length ? this[Js].trim() : this[Ao][0][_r] === ao.xhtml.id ? this[Ao][0][Jr]().trim() : null : this[Js].trim();
  }
  [Kr](e2) {
    e2 = e2.value || "", this[Js] = e2.toString();
  }
  [Qs](e2 = false) {
    const t2 = /* @__PURE__ */ Object.create(null);
    e2 && (t2.$ns = this[_r]), this[Js] && (t2.$content = this[Js]), t2.$name = this[Pr], t2.children = [];
    for (const i2 of this[Ao]) t2.children.push(i2[Qs](e2));
    t2.attributes = /* @__PURE__ */ Object.create(null);
    for (const [e3, i2] of this[yo]) t2.attributes[e3] = i2[Js];
    return t2;
  }
}
class ContentObject extends XFAObject {
  constructor(e2, t2) {
    super(e2, t2), this[Js] = "";
  }
  [Ur](e2) {
    this[Js] += e2;
  }
  [tr]() {
  }
}
class OptionObject extends ContentObject {
  constructor(e2, t2, i2) {
    super(e2, t2), this[Mo] = i2;
  }
  [tr]() {
    this[Js] = getKeyword({ data: this[Js], defaultValue: this[Mo][0], validate: (e2) => this[Mo].includes(e2) });
  }
  [Ws](e2) {
    super[Ws](e2), delete this[Mo];
  }
}
class StringObject extends ContentObject {
  [tr]() {
    this[Js] = this[Js].trim();
  }
}
class IntegerObject extends ContentObject {
  constructor(e2, t2, i2, n2) {
    super(e2, t2), this[vo] = i2, this[Po] = n2;
  }
  [tr]() {
    this[Js] = getInteger({ data: this[Js], defaultValue: this[vo], validate: this[Po] });
  }
  [Ws](e2) {
    super[Ws](e2), delete this[vo], delete this[Po];
  }
}
class Option01 extends IntegerObject {
  constructor(e2, t2) {
    super(e2, t2, 0, (e3) => 1 === e3);
  }
}
class Option10 extends IntegerObject {
  constructor(e2, t2) {
    super(e2, t2, 1, (e3) => 0 === e3);
  }
}
function measureToString(e2) {
  return "string" == typeof e2 ? "0px" : Number.isInteger(e2) ? `${e2}px` : `${e2.toFixed(2)}px`;
}
const No = { anchorType(e2, t2) {
  const i2 = e2[pr]();
  if (i2 && (!i2.layout || "position" === i2.layout)) switch ("transform" in t2 || (t2.transform = ""), e2.anchorType) {
    case "bottomCenter":
      t2.transform += "translate(-50%, -100%)";
      break;
    case "bottomLeft":
      t2.transform += "translate(0,-100%)";
      break;
    case "bottomRight":
      t2.transform += "translate(-100%,-100%)";
      break;
    case "middleCenter":
      t2.transform += "translate(-50%,-50%)";
      break;
    case "middleLeft":
      t2.transform += "translate(0,-50%)";
      break;
    case "middleRight":
      t2.transform += "translate(-100%,-50%)";
      break;
    case "topCenter":
      t2.transform += "translate(-50%,0)";
      break;
    case "topRight":
      t2.transform += "translate(-100%,0)";
  }
}, dimensions(e2, t2) {
  const i2 = e2[pr]();
  let n2 = e2.w;
  const a2 = e2.h;
  if (i2.layout?.includes("row")) {
    const t3 = i2[er], a3 = e2.colSpan;
    let s2;
    -1 === a3 ? (s2 = Math.sumPrecise(t3.columnWidths.slice(t3.currentColumn)), t3.currentColumn = 0) : (s2 = Math.sumPrecise(t3.columnWidths.slice(t3.currentColumn, t3.currentColumn + a3)), t3.currentColumn = (t3.currentColumn + e2.colSpan) % t3.columnWidths.length), isNaN(s2) || (n2 = e2.w = s2);
  }
  t2.width = "" !== n2 ? measureToString(n2) : "auto", t2.height = "" !== a2 ? measureToString(a2) : "auto";
}, position(e2, t2) {
  const i2 = e2[pr]();
  i2?.layout && "position" !== i2.layout || (t2.position = "absolute", t2.left = measureToString(e2.x), t2.top = measureToString(e2.y));
}, rotate(e2, t2) {
  e2.rotate && ("transform" in t2 || (t2.transform = ""), t2.transform += `rotate(-${e2.rotate}deg)`, t2.transformOrigin = "top left");
}, presence(e2, t2) {
  switch (e2.presence) {
    case "invisible":
      t2.visibility = "hidden";
      break;
    case "hidden":
    case "inactive":
      t2.display = "none";
  }
}, hAlign(e2, t2) {
  if ("para" === e2[Pr]) switch (e2.hAlign) {
    case "justifyAll":
      t2.textAlign = "justify-all";
      break;
    case "radix":
      t2.textAlign = "left";
      break;
    default:
      t2.textAlign = e2.hAlign;
  }
  else switch (e2.hAlign) {
    case "left":
      t2.alignSelf = "start";
      break;
    case "center":
      t2.alignSelf = "center";
      break;
    case "right":
      t2.alignSelf = "end";
  }
}, margin(e2, t2) {
  e2.margin && (t2.margin = e2.margin[to]().margin);
} };
function setMinMaxDimensions(e2, t2) {
  "position" === e2[pr]().layout && (e2.minW > 0 && (t2.minWidth = measureToString(e2.minW)), e2.maxW > 0 && (t2.maxWidth = measureToString(e2.maxW)), e2.minH > 0 && (t2.minHeight = measureToString(e2.minH)), e2.maxH > 0 && (t2.maxHeight = measureToString(e2.maxH)));
}
function layoutText(e2, t2, i2, n2, a2, s2) {
  const r2 = new TextMeasure(t2, i2, n2, a2);
  return "string" == typeof e2 ? r2.addString(e2) : e2[jr](r2), r2.compute(s2);
}
function layoutNode(e2, t2) {
  let i2 = null, n2 = null, a2 = false;
  if ((!e2.w || !e2.h) && e2.value) {
    let s2 = 0, r2 = 0;
    e2.margin && (s2 = e2.margin.leftInset + e2.margin.rightInset, r2 = e2.margin.topInset + e2.margin.bottomInset);
    let o2 = null, l2 = null;
    e2.para && (l2 = /* @__PURE__ */ Object.create(null), o2 = "" === e2.para.lineHeight ? null : e2.para.lineHeight, l2.top = "" === e2.para.spaceAbove ? 0 : e2.para.spaceAbove, l2.bottom = "" === e2.para.spaceBelow ? 0 : e2.para.spaceBelow, l2.left = "" === e2.para.marginLeft ? 0 : e2.para.marginLeft, l2.right = "" === e2.para.marginRight ? 0 : e2.para.marginRight);
    let c2 = e2.font;
    if (!c2) {
      const t3 = e2[br]();
      let i3 = e2[mr]();
      for (; i3 && i3 !== t3; ) {
        if (i3.font) {
          c2 = i3.font;
          break;
        }
        i3 = i3[mr]();
      }
    }
    const h2 = (e2.w || t2.width) - s2, d2 = e2[yr].fontFinder;
    if (e2.value.exData && e2.value.exData[Js] && "text/html" === e2.value.exData.contentType) {
      const t3 = layoutText(e2.value.exData[Js], c2, l2, o2, d2, h2);
      n2 = t3.width, i2 = t3.height, a2 = t3.isBroken;
    } else {
      const t3 = e2.value[Jr]();
      if (t3) {
        const e3 = layoutText(t3, c2, l2, o2, d2, h2);
        n2 = e3.width, i2 = e3.height, a2 = e3.isBroken;
      }
    }
    null === n2 || e2.w || (n2 += s2), null === i2 || e2.h || (i2 += r2);
  }
  return { w: n2, h: i2, isBroken: a2 };
}
function computeBbox(e2, t2, i2) {
  let n2;
  if ("" !== e2.w && "" !== e2.h) n2 = [e2.x, e2.y, e2.w, e2.h];
  else {
    if (!i2) return null;
    let a2 = e2.w;
    if ("" === a2) {
      if (0 === e2.maxW) {
        const t3 = e2[pr]();
        a2 = "position" === t3.layout && "" !== t3.w ? 0 : e2.minW;
      } else a2 = Math.min(e2.maxW, i2.width);
      t2.attributes.style.width = measureToString(a2);
    }
    let s2 = e2.h;
    if ("" === s2) {
      if (0 === e2.maxH) {
        const t3 = e2[pr]();
        s2 = "position" === t3.layout && "" !== t3.h ? 0 : e2.minH;
      } else s2 = Math.min(e2.maxH, i2.height);
      t2.attributes.style.height = measureToString(s2);
    }
    n2 = [e2.x, e2.y, a2, s2];
  }
  return n2;
}
function fixDimensions(e2) {
  const t2 = e2[pr]();
  if (t2.layout?.includes("row")) {
    const i2 = t2[er], n2 = e2.colSpan;
    let a2;
    a2 = -1 === n2 ? Math.sumPrecise(i2.columnWidths.slice(i2.currentColumn)) : Math.sumPrecise(i2.columnWidths.slice(i2.currentColumn, i2.currentColumn + n2)), isNaN(a2) || (e2.w = a2);
  }
  t2.layout && "position" !== t2.layout && (e2.x = e2.y = 0), "table" === e2.layout && "" === e2.w && Array.isArray(e2.columnWidths) && (e2.w = Math.sumPrecise(e2.columnWidths));
}
function layoutClass(e2) {
  switch (e2.layout) {
    case "position":
    default:
      return "xfaPosition";
    case "lr-tb":
      return "xfaLrTb";
    case "rl-row":
      return "xfaRlRow";
    case "rl-tb":
      return "xfaRlTb";
    case "row":
      return "xfaRow";
    case "table":
      return "xfaTable";
    case "tb":
      return "xfaTb";
  }
}
function toStyle(e2, ...t2) {
  const i2 = /* @__PURE__ */ Object.create(null);
  for (const n2 of t2) {
    const t3 = e2[n2];
    if (null !== t3) {
      if (No.hasOwnProperty(n2)) No[n2](e2, i2);
      else if (t3 instanceof XFAObject) {
        const e3 = t3[to]();
        e3 ? Object.assign(i2, e3) : warn$1(`(DEBUG) - XFA - style for ${n2} not implemented yet`);
      }
    }
  }
  return i2;
}
function createWrapper(e2, t2) {
  const { attributes: i2 } = t2, { style: n2 } = i2, a2 = { name: "div", attributes: { class: ["xfaWrapper"], style: /* @__PURE__ */ Object.create(null) }, children: [] };
  if (i2.class.push("xfaWrapped"), e2.border) {
    const { widths: i3, insets: s2 } = e2.border[er];
    let r2, o2, l2 = s2[0], c2 = s2[3];
    const h2 = s2[0] + s2[2], d2 = s2[1] + s2[3];
    switch (e2.border.hand) {
      case "even":
        l2 -= i3[0] / 2, c2 -= i3[3] / 2, r2 = `calc(100% + ${(i3[1] + i3[3]) / 2 - d2}px)`, o2 = `calc(100% + ${(i3[0] + i3[2]) / 2 - h2}px)`;
        break;
      case "left":
        l2 -= i3[0], c2 -= i3[3], r2 = `calc(100% + ${i3[1] + i3[3] - d2}px)`, o2 = `calc(100% + ${i3[0] + i3[2] - h2}px)`;
        break;
      case "right":
        r2 = d2 ? `calc(100% - ${d2}px)` : "100%", o2 = h2 ? `calc(100% - ${h2}px)` : "100%";
    }
    const u2 = ["xfaBorder"];
    isPrintOnly(e2.border) && u2.push("xfaPrintOnly");
    const g2 = { name: "div", attributes: { class: u2, style: { top: `${l2}px`, left: `${c2}px`, width: r2, height: o2 } }, children: [] };
    for (const e3 of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"]) void 0 !== n2[e3] && (g2.attributes.style[e3] = n2[e3], delete n2[e3]);
    a2.children.push(g2, t2);
  } else a2.children.push(t2);
  for (const e3 of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"]) void 0 !== n2[e3] && (a2.attributes.style[e3] = n2[e3], delete n2[e3]);
  return a2.attributes.style.position = "absolute" === n2.position ? "absolute" : "relative", delete n2.position, n2.alignSelf && (a2.attributes.style.alignSelf = n2.alignSelf, delete n2.alignSelf), a2;
}
function fixTextIndent(e2) {
  const t2 = getMeasurement(e2.textIndent, "0px");
  if (t2 >= 0) return;
  const i2 = "padding" + ("left" === ("right" === e2.textAlign ? "right" : "left") ? "Left" : "Right"), n2 = getMeasurement(e2[i2], "0px");
  e2[i2] = n2 - t2 + "px";
}
function setAccess(e2, t2) {
  switch (e2.access) {
    case "nonInteractive":
      t2.push("xfaNonInteractive");
      break;
    case "readOnly":
      t2.push("xfaReadOnly");
      break;
    case "protected":
      t2.push("xfaDisabled");
  }
}
function isPrintOnly(e2) {
  return e2.relevant.length > 0 && !e2.relevant[0].excluded && "print" === e2.relevant[0].viewname;
}
function getCurrentPara(e2) {
  const t2 = e2[br]()[er].paraStack;
  return t2.length ? t2.at(-1) : null;
}
function setPara(e2, t2, i2) {
  if (i2.attributes.class?.includes("xfaRich")) {
    t2 && ("" === e2.h && (t2.height = "auto"), "" === e2.w && (t2.width = "auto"));
    const n2 = getCurrentPara(e2);
    if (n2) {
      const e3 = i2.attributes.style;
      switch (e3.display = "flex", e3.flexDirection = "column", n2.vAlign) {
        case "top":
          e3.justifyContent = "start";
          break;
        case "bottom":
          e3.justifyContent = "end";
          break;
        case "middle":
          e3.justifyContent = "center";
      }
      const t3 = n2[to]();
      for (const [i3, n3] of Object.entries(t3)) i3 in e3 || (e3[i3] = n3);
    }
  }
}
function setFontFamily(e2, t2, i2, n2) {
  if (!i2) return void delete n2.fontFamily;
  const a2 = stripQuotes(e2.typeface);
  n2.fontFamily = `"${a2}"`;
  const s2 = i2.find(a2);
  if (s2) {
    const { fontFamily: i3 } = s2.regular.cssFontInfo;
    i3 !== a2 && (n2.fontFamily = `"${i3}"`);
    const r2 = getCurrentPara(t2);
    if (r2 && "" !== r2.lineHeight) return;
    if (n2.lineHeight) return;
    const o2 = selectFont(e2, s2);
    o2 && (n2.lineHeight = Math.max(1.2, o2.lineHeight));
  }
}
function fixURL(e2) {
  const t2 = createValidAbsoluteUrl$1(e2, null, { addDefaultProtocol: true, tryConvertEncoding: true });
  return t2 ? t2.href : null;
}
function createLine(e2, t2) {
  return { name: "div", attributes: { class: ["lr-tb" === e2.layout ? "xfaLr" : "xfaRl"] }, children: t2 };
}
function flushHTML(e2) {
  if (!e2[er]) return null;
  const t2 = { name: "div", attributes: e2[er].attributes, children: e2[er].children };
  if (e2[er].failingNode) {
    const i2 = e2[er].failingNode[ir]();
    i2 && (e2.layout.endsWith("-tb") ? t2.children.push(createLine(e2, [i2])) : t2.children.push(i2));
  }
  return 0 === t2.children.length ? null : t2;
}
function addHTML(e2, t2, i2) {
  const n2 = e2[er], a2 = n2.availableSpace, [s2, r2, o2, l2] = i2;
  switch (e2.layout) {
    case "position":
      n2.width = Math.max(n2.width, s2 + o2), n2.height = Math.max(n2.height, r2 + l2), n2.children.push(t2);
      break;
    case "lr-tb":
    case "rl-tb":
      n2.line && 1 !== n2.attempt || (n2.line = createLine(e2, []), n2.children.push(n2.line), n2.numberInLine = 0), n2.numberInLine += 1, n2.line.children.push(t2), 0 === n2.attempt ? (n2.currentWidth += o2, n2.height = Math.max(n2.height, n2.prevHeight + l2)) : (n2.currentWidth = o2, n2.prevHeight = n2.height, n2.height += l2, n2.attempt = 0), n2.width = Math.max(n2.width, n2.currentWidth);
      break;
    case "rl-row":
    case "row": {
      n2.children.push(t2), n2.width += o2, n2.height = Math.max(n2.height, l2);
      const e3 = measureToString(n2.height);
      for (const t3 of n2.children) t3.attributes.style.height = e3;
      break;
    }
    case "table":
    case "tb":
      n2.width = MathClamp$1(o2, n2.width, a2.width), n2.height += l2, n2.children.push(t2);
  }
}
function getAvailableSpace(e2) {
  const t2 = e2[er].availableSpace, i2 = e2.margin ? e2.margin.topInset + e2.margin.bottomInset : 0, n2 = e2.margin ? e2.margin.leftInset + e2.margin.rightInset : 0;
  switch (e2.layout) {
    case "lr-tb":
    case "rl-tb":
      return 0 === e2[er].attempt ? { width: t2.width - n2 - e2[er].currentWidth, height: t2.height - i2 - e2[er].prevHeight } : { width: t2.width - n2, height: t2.height - i2 - e2[er].height };
    case "rl-row":
    case "row":
      return { width: Math.sumPrecise(e2[er].columnWidths.slice(e2[er].currentColumn)), height: t2.height - n2 };
    case "table":
    case "tb":
      return { width: t2.width - n2, height: t2.height - i2 - e2[er].height };
    default:
      return t2;
  }
}
function checkDimensions(e2, t2) {
  if (null === e2[br]()[er].firstUnsplittable) return true;
  if (0 === e2.w || 0 === e2.h) return true;
  const i2 = e2[pr](), n2 = i2[er]?.attempt || 0, [, a2, s2, r2] = (function(e3) {
    let t3, i3, n3 = "" === e3.w ? NaN : e3.w, a3 = "" === e3.h ? NaN : e3.h, [s3, r3] = [0, 0];
    switch (e3.anchorType || "") {
      case "bottomCenter":
        [s3, r3] = [n3 / 2, a3];
        break;
      case "bottomLeft":
        [s3, r3] = [0, a3];
        break;
      case "bottomRight":
        [s3, r3] = [n3, a3];
        break;
      case "middleCenter":
        [s3, r3] = [n3 / 2, a3 / 2];
        break;
      case "middleLeft":
        [s3, r3] = [0, a3 / 2];
        break;
      case "middleRight":
        [s3, r3] = [n3, a3 / 2];
        break;
      case "topCenter":
        [s3, r3] = [n3 / 2, 0];
        break;
      case "topRight":
        [s3, r3] = [n3, 0];
    }
    switch (e3.rotate || 0) {
      case 0:
        [t3, i3] = [-s3, -r3];
        break;
      case 90:
        [t3, i3] = [-r3, s3], [n3, a3] = [a3, -n3];
        break;
      case 180:
        [t3, i3] = [s3, r3], [n3, a3] = [-n3, -a3];
        break;
      case 270:
        [t3, i3] = [r3, -s3], [n3, a3] = [-a3, n3];
    }
    return [e3.x + t3 + Math.min(0, n3), e3.y + i3 + Math.min(0, a3), Math.abs(n3), Math.abs(a3)];
  })(e2);
  switch (i2.layout) {
    case "lr-tb":
    case "rl-tb":
      return 0 === n2 ? e2[br]()[er].noLayoutFailure ? "" !== e2.w ? Math.round(s2 - t2.width) <= 2 : t2.width > 2 : !("" !== e2.h && Math.round(r2 - t2.height) > 2) && ("" !== e2.w ? Math.round(s2 - t2.width) <= 2 || 0 === i2[er].numberInLine && t2.height > 2 : t2.width > 2) : !!e2[br]()[er].noLayoutFailure || !("" !== e2.h && Math.round(r2 - t2.height) > 2) && (("" === e2.w || Math.round(s2 - t2.width) <= 2 || !i2[Er]()) && t2.height > 2);
    case "table":
    case "tb":
      return !!e2[br]()[er].noLayoutFailure || ("" === e2.h || e2[Ir]() ? ("" === e2.w || Math.round(s2 - t2.width) <= 2 || !i2[Er]()) && t2.height > 2 : Math.round(r2 - t2.height) <= 2);
    case "position":
      if (e2[br]()[er].noLayoutFailure) return true;
      if ("" === e2.h || Math.round(r2 + a2 - t2.height) <= 2) return true;
      return r2 + a2 > e2[br]()[er].currentContentArea.h;
    case "rl-row":
    case "row":
      return !!e2[br]()[er].noLayoutFailure || ("" === e2.h || Math.round(r2 - t2.height) <= 2);
    default:
      return true;
  }
}
const Lo = ao.template.id, Uo = "http://www.w3.org/2000/svg", jo = /^H(\d+)$/, $o = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]), Ho = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
function getBorderDims(e2) {
  if (!e2 || !e2.border) return { w: 0, h: 0 };
  const t2 = e2.border[hr]();
  return t2 ? { w: t2.widths[0] + t2.widths[2] + t2.insets[0] + t2.insets[2], h: t2.widths[1] + t2.widths[3] + t2.insets[1] + t2.insets[3] } : { w: 0, h: 0 };
}
function hasMargin(e2) {
  return e2.margin && (e2.margin.topInset || e2.margin.rightInset || e2.margin.bottomInset || e2.margin.leftInset);
}
function _setValue(e2, t2) {
  if (!e2.value) {
    const t3 = new Value({});
    e2[qs](t3), e2.value = t3;
  }
  e2.value[Kr](t2);
}
function* getContainedChildren(e2) {
  for (const t2 of e2[ur]()) t2 instanceof SubformSet ? yield* t2[gr]() : yield t2;
}
function isRequired(e2) {
  return "error" === e2.validate?.nullTest;
}
function setTabIndex(e2) {
  for (; e2; ) {
    if (!e2.traversal) return void (e2[Yr] = e2[mr]()[Yr]);
    if (e2[Yr]) return;
    let t2 = null;
    for (const i3 of e2.traversal[ur]()) if ("next" === i3.operation) {
      t2 = i3;
      break;
    }
    if (!t2 || !t2.ref) return void (e2[Yr] = e2[mr]()[Yr]);
    const i2 = e2[br]();
    e2[Yr] = ++i2[Yr];
    const n2 = i2[Wr](t2.ref, e2);
    if (!n2) return;
    e2 = n2[0];
  }
}
function applyAssist(e2, t2) {
  const i2 = e2.assist;
  if (i2) {
    const e3 = i2[Qr]();
    e3 && (t2.title = e3);
    const n2 = i2.role.match(jo);
    if (n2) {
      const e4 = "heading", i3 = n2[1];
      t2.role = e4, t2["aria-level"] = i3;
    }
  }
  if ("table" === e2.layout) t2.role = "table";
  else if ("row" === e2.layout) t2.role = "row";
  else {
    const i3 = e2[mr]();
    "row" === i3.layout && (t2.role = "TH" === i3.assist?.role ? "columnheader" : "cell");
  }
}
function ariaLabel(e2) {
  if (!e2.assist) return null;
  const t2 = e2.assist;
  return t2.speak && "" !== t2.speak[Js] ? t2.speak[Js] : t2.toolTip ? t2.toolTip[Js] : null;
}
function valueToHtml(e2) {
  return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: /* @__PURE__ */ Object.create(null) }, children: [{ name: "span", attributes: { style: /* @__PURE__ */ Object.create(null) }, value: e2 }] });
}
function setFirstUnsplittable(e2) {
  const t2 = e2[br]();
  null === t2[er].firstUnsplittable && (t2[er].firstUnsplittable = e2, t2[er].noLayoutFailure = true);
}
function unsetFirstUnsplittable(e2) {
  const t2 = e2[br]();
  t2[er].firstUnsplittable === e2 && (t2[er].noLayoutFailure = false);
}
function handleBreak(e2) {
  if (e2[er]) return false;
  if (e2[er] = /* @__PURE__ */ Object.create(null), "auto" === e2.targetType) return false;
  const t2 = e2[br]();
  let i2 = null;
  if (e2.target) {
    if (i2 = t2[Wr](e2.target, e2[mr]()), !i2) return false;
    i2 = i2[0];
  }
  const { currentPageArea: n2, currentContentArea: a2 } = t2[er];
  if ("pageArea" === e2.targetType) return i2 instanceof PageArea || (i2 = null), e2.startNew ? (e2[er].target = i2 || n2, true) : !(!i2 || i2 === n2) && (e2[er].target = i2, true);
  i2 instanceof ContentArea || (i2 = null);
  const s2 = i2 && i2[mr]();
  let r2, o2 = s2;
  if (e2.startNew) if (i2) {
    const e3 = s2.contentArea.children, t3 = e3.indexOf(a2), n3 = e3.indexOf(i2);
    -1 !== t3 && t3 < n3 && (o2 = null), r2 = n3 - 1;
  } else r2 = n2.contentArea.children.indexOf(a2);
  else {
    if (!i2 || i2 === a2) return false;
    r2 = s2.contentArea.children.indexOf(i2) - 1, o2 = s2 === n2 ? null : s2;
  }
  return e2[er].target = o2, e2[er].index = r2, true;
}
function handleOverflow(e2, t2, i2) {
  const n2 = e2[br](), a2 = n2[er].noLayoutFailure, s2 = t2[pr];
  t2[pr] = () => e2, n2[er].noLayoutFailure = true;
  const r2 = t2[Qr](i2);
  e2[Xs](r2.html, r2.bbox), n2[er].noLayoutFailure = a2, t2[pr] = s2;
}
class AppearanceFilter extends StringObject {
  constructor(e2) {
    super(Lo, "appearanceFilter"), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class Arc extends XFAObject {
  constructor(e2) {
    super(Lo, "arc", true), this.circular = getInteger({ data: e2.circular, defaultValue: 0, validate: (e3) => 1 === e3 }), this.hand = getStringOption(e2.hand, ["even", "left", "right"]), this.id = e2.id || "", this.startAngle = getFloat({ data: e2.startAngle, defaultValue: 0, validate: (e3) => true }), this.sweepAngle = getFloat({ data: e2.sweepAngle, defaultValue: 360, validate: (e3) => true }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.edge = null, this.fill = null;
  }
  [Qr]() {
    const e2 = this.edge || new Edge({}), t2 = e2[to](), i2 = /* @__PURE__ */ Object.create(null);
    let n2;
    "visible" === this.fill?.presence ? Object.assign(i2, this.fill[to]()) : i2.fill = "transparent", i2.strokeWidth = measureToString("visible" === e2.presence ? e2.thickness : 0), i2.stroke = t2.color;
    const a2 = { xmlns: Uo, style: { width: "100%", height: "100%", overflow: "visible" } };
    if (360 === this.sweepAngle) n2 = { name: "ellipse", attributes: { xmlns: Uo, cx: "50%", cy: "50%", rx: "50%", ry: "50%", style: i2 } };
    else {
      const e3 = this.startAngle * Math.PI / 180, t3 = this.sweepAngle * Math.PI / 180, s3 = this.sweepAngle > 180 ? 1 : 0, [r2, o2, l2, c2] = [50 * (1 + Math.cos(e3)), 50 * (1 - Math.sin(e3)), 50 * (1 + Math.cos(e3 + t3)), 50 * (1 - Math.sin(e3 + t3))];
      n2 = { name: "path", attributes: { xmlns: Uo, d: `M ${r2} ${o2} A 50 50 0 ${s3} 0 ${l2} ${c2}`, vectorEffect: "non-scaling-stroke", style: i2 } }, Object.assign(a2, { viewBox: "0 0 100 100", preserveAspectRatio: "none" });
    }
    const s2 = { name: "svg", children: [n2], attributes: a2 };
    return hasMargin(this[mr]()[mr]()) ? HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [s2] }) : (s2.attributes.style.position = "absolute", HTMLResult.success(s2));
  }
}
class Area extends XFAObject {
  constructor(e2) {
    super(Lo, "area", true), this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 }), this.id = e2.id || "", this.name = e2.name || "", this.relevant = getRelevant(e2.relevant), this.use = e2.use || "", this.usehref = e2.usehref || "", this.x = getMeasurement(e2.x, "0pt"), this.y = getMeasurement(e2.y, "0pt"), this.desc = null, this.extras = null, this.area = new XFAObjectArray(), this.draw = new XFAObjectArray(), this.exObject = new XFAObjectArray(), this.exclGroup = new XFAObjectArray(), this.field = new XFAObjectArray(), this.subform = new XFAObjectArray(), this.subformSet = new XFAObjectArray();
  }
  *[gr]() {
    yield* getContainedChildren(this);
  }
  [Mr]() {
    return true;
  }
  [Cr]() {
    return true;
  }
  [Xs](e2, t2) {
    const [i2, n2, a2, s2] = t2;
    this[er].width = Math.max(this[er].width, i2 + a2), this[er].height = Math.max(this[er].height, n2 + s2), this[er].children.push(e2);
  }
  [sr]() {
    return this[er].availableSpace;
  }
  [Qr](e2) {
    const t2 = toStyle(this, "position"), i2 = { style: t2, id: this[io], class: ["xfaArea"] };
    isPrintOnly(this) && i2.class.push("xfaPrintOnly"), this.name && (i2.xfaName = this.name);
    const n2 = [];
    this[er] = { children: n2, width: 0, height: 0, availableSpace: e2 };
    const a2 = this[zs]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]), include: true });
    if (!a2.success) return a2.isBreak() ? a2 : (delete this[er], HTMLResult.FAILURE);
    t2.width = measureToString(this[er].width), t2.height = measureToString(this[er].height);
    const s2 = { name: "div", attributes: i2, children: n2 }, r2 = [this.x, this.y, this[er].width, this[er].height];
    return delete this[er], HTMLResult.success(s2, r2);
  }
}
class Assist extends XFAObject {
  constructor(e2) {
    super(Lo, "assist", true), this.id = e2.id || "", this.role = e2.role || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.speak = null, this.toolTip = null;
  }
  [Qr]() {
    return this.toolTip?.[Js] || null;
  }
}
class Barcode extends XFAObject {
  constructor(e2) {
    super(Lo, "barcode", true), this.charEncoding = getKeyword({ data: e2.charEncoding ? e2.charEncoding.toLowerCase() : "", defaultValue: "", validate: (e3) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e3) || e3.match(/iso-8859-\d{2}/) }), this.checksum = getStringOption(e2.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]), this.dataColumnCount = getInteger({ data: e2.dataColumnCount, defaultValue: -1, validate: (e3) => e3 >= 0 }), this.dataLength = getInteger({ data: e2.dataLength, defaultValue: -1, validate: (e3) => e3 >= 0 }), this.dataPrep = getStringOption(e2.dataPrep, ["none", "flateCompress"]), this.dataRowCount = getInteger({ data: e2.dataRowCount, defaultValue: -1, validate: (e3) => e3 >= 0 }), this.endChar = e2.endChar || "", this.errorCorrectionLevel = getInteger({ data: e2.errorCorrectionLevel, defaultValue: -1, validate: (e3) => e3 >= 0 && e3 <= 8 }), this.id = e2.id || "", this.moduleHeight = getMeasurement(e2.moduleHeight, "5mm"), this.moduleWidth = getMeasurement(e2.moduleWidth, "0.25mm"), this.printCheckDigit = getInteger({ data: e2.printCheckDigit, defaultValue: 0, validate: (e3) => 1 === e3 }), this.rowColumnRatio = getRatio(e2.rowColumnRatio), this.startChar = e2.startChar || "", this.textLocation = getStringOption(e2.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]), this.truncate = getInteger({ data: e2.truncate, defaultValue: 0, validate: (e3) => 1 === e3 }), this.type = getStringOption(e2.type ? e2.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]), this.upsMode = getStringOption(e2.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.wideNarrowRatio = getRatio(e2.wideNarrowRatio), this.encrypt = null, this.extras = null;
  }
}
class Bind extends XFAObject {
  constructor(e2) {
    super(Lo, "bind", true), this.match = getStringOption(e2.match, ["once", "dataRef", "global", "none"]), this.ref = e2.ref || "", this.picture = null;
  }
}
class BindItems extends XFAObject {
  constructor(e2) {
    super(Lo, "bindItems"), this.connection = e2.connection || "", this.labelRef = e2.labelRef || "", this.ref = e2.ref || "", this.valueRef = e2.valueRef || "";
  }
}
class Bookend extends XFAObject {
  constructor(e2) {
    super(Lo, "bookend"), this.id = e2.id || "", this.leader = e2.leader || "", this.trailer = e2.trailer || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class BooleanElement extends Option01 {
  constructor(e2) {
    super(Lo, "boolean"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
  [Qr](e2) {
    return valueToHtml(1 === this[Js] ? "1" : "0");
  }
}
class Border extends XFAObject {
  constructor(e2) {
    super(Lo, "border", true), this.break = getStringOption(e2.break, ["close", "open"]), this.hand = getStringOption(e2.hand, ["even", "left", "right"]), this.id = e2.id || "", this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = getRelevant(e2.relevant), this.use = e2.use || "", this.usehref = e2.usehref || "", this.corner = new XFAObjectArray(4), this.edge = new XFAObjectArray(4), this.extras = null, this.fill = null, this.margin = null;
  }
  [hr]() {
    if (!this[er]) {
      const e2 = this.edge.children.slice();
      if (e2.length < 4) {
        const t3 = e2.at(-1) || new Edge({});
        for (let i3 = e2.length; i3 < 4; i3++) e2.push(t3);
      }
      const t2 = e2.map((e3) => e3.thickness), i2 = [0, 0, 0, 0];
      this.margin && (i2[0] = this.margin.topInset, i2[1] = this.margin.rightInset, i2[2] = this.margin.bottomInset, i2[3] = this.margin.leftInset), this[er] = { widths: t2, insets: i2, edges: e2 };
    }
    return this[er];
  }
  [to]() {
    const { edges: e2 } = this[hr](), t2 = e2.map((e3) => {
      const t3 = e3[to]();
      return t3.color ||= "#000000", t3;
    }), i2 = /* @__PURE__ */ Object.create(null);
    if (this.margin && Object.assign(i2, this.margin[to]()), "visible" === this.fill?.presence && Object.assign(i2, this.fill[to]()), this.corner.children.some((e3) => 0 !== e3.radius)) {
      const e3 = this.corner.children.map((e4) => e4[to]());
      if (2 === e3.length || 3 === e3.length) {
        const t3 = e3.at(-1);
        for (let i3 = e3.length; i3 < 4; i3++) e3.push(t3);
      }
      i2.borderRadius = e3.map((e4) => e4.radius).join(" ");
    }
    switch (this.presence) {
      case "invisible":
      case "hidden":
        i2.borderStyle = "";
        break;
      case "inactive":
        i2.borderStyle = "none";
        break;
      default:
        i2.borderStyle = t2.map((e3) => e3.style).join(" ");
    }
    return i2.borderWidth = t2.map((e3) => e3.width).join(" "), i2.borderColor = t2.map((e3) => e3.color).join(" "), i2;
  }
}
class Break extends XFAObject {
  constructor(e2) {
    super(Lo, "break", true), this.after = getStringOption(e2.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.afterTarget = e2.afterTarget || "", this.before = getStringOption(e2.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.beforeTarget = e2.beforeTarget || "", this.bookendLeader = e2.bookendLeader || "", this.bookendTrailer = e2.bookendTrailer || "", this.id = e2.id || "", this.overflowLeader = e2.overflowLeader || "", this.overflowTarget = e2.overflowTarget || "", this.overflowTrailer = e2.overflowTrailer || "", this.startNew = getInteger({ data: e2.startNew, defaultValue: 0, validate: (e3) => 1 === e3 }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null;
  }
}
class BreakAfter extends XFAObject {
  constructor(e2) {
    super(Lo, "breakAfter", true), this.id = e2.id || "", this.leader = e2.leader || "", this.startNew = getInteger({ data: e2.startNew, defaultValue: 0, validate: (e3) => 1 === e3 }), this.target = e2.target || "", this.targetType = getStringOption(e2.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = e2.trailer || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.script = null;
  }
}
class BreakBefore extends XFAObject {
  constructor(e2) {
    super(Lo, "breakBefore", true), this.id = e2.id || "", this.leader = e2.leader || "", this.startNew = getInteger({ data: e2.startNew, defaultValue: 0, validate: (e3) => 1 === e3 }), this.target = e2.target || "", this.targetType = getStringOption(e2.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = e2.trailer || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.script = null;
  }
  [Qr](e2) {
    return this[er] = {}, HTMLResult.FAILURE;
  }
}
class Button extends XFAObject {
  constructor(e2) {
    super(Lo, "button", true), this.highlight = getStringOption(e2.highlight, ["inverted", "none", "outline", "push"]), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null;
  }
  [Qr](e2) {
    const t2 = this[mr]()[mr](), i2 = { name: "button", attributes: { id: this[io], class: ["xfaButton"], style: {} }, children: [] };
    for (const e3 of t2.event.children) {
      if ("click" !== e3.activity || !e3.script) continue;
      const t3 = recoverJsURL(e3.script[Js]);
      if (!t3) continue;
      const n2 = fixURL(t3.url);
      n2 && i2.children.push({ name: "a", attributes: { id: "link" + this[io], href: n2, newWindow: t3.newWindow, class: ["xfaLink"], style: {} }, children: [] });
    }
    return HTMLResult.success(i2);
  }
}
class Calculate extends XFAObject {
  constructor(e2) {
    super(Lo, "calculate", true), this.id = e2.id || "", this.override = getStringOption(e2.override, ["disabled", "error", "ignore", "warning"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.message = null, this.script = null;
  }
}
class Caption extends XFAObject {
  constructor(e2) {
    super(Lo, "caption", true), this.id = e2.id || "", this.placement = getStringOption(e2.placement, ["left", "bottom", "inline", "right", "top"]), this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.reserve = Math.ceil(getMeasurement(e2.reserve)), this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.font = null, this.margin = null, this.para = null, this.value = null;
  }
  [Kr](e2) {
    _setValue(this, e2);
  }
  [hr](e2) {
    if (!this[er]) {
      let { width: t2, height: i2 } = e2;
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          t2 = this.reserve <= 0 ? t2 : this.reserve;
          break;
        case "top":
        case "bottom":
          i2 = this.reserve <= 0 ? i2 : this.reserve;
      }
      this[er] = layoutNode(this, { width: t2 });
    }
    return this[er];
  }
  [Qr](e2) {
    if (!this.value) return HTMLResult.EMPTY;
    this[Hr]();
    const t2 = this.value[Qr](e2).html;
    if (!t2) return this[$r](), HTMLResult.EMPTY;
    const i2 = this.reserve;
    if (this.reserve <= 0) {
      const { w: t3, h: i3 } = this[hr](e2);
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          this.reserve = t3;
          break;
        case "top":
        case "bottom":
          this.reserve = i3;
      }
    }
    const n2 = [];
    "string" == typeof t2 ? n2.push({ name: "#text", value: t2 }) : n2.push(t2);
    const a2 = toStyle(this, "font", "margin", "visibility");
    switch (this.placement) {
      case "left":
      case "right":
        this.reserve > 0 && (a2.width = measureToString(this.reserve));
        break;
      case "top":
      case "bottom":
        this.reserve > 0 && (a2.height = measureToString(this.reserve));
    }
    return setPara(this, null, t2), this[$r](), this.reserve = i2, HTMLResult.success({ name: "div", attributes: { style: a2, class: ["xfaCaption"] }, children: n2 });
  }
}
class Certificate extends StringObject {
  constructor(e2) {
    super(Lo, "certificate"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class Certificates extends XFAObject {
  constructor(e2) {
    super(Lo, "certificates", true), this.credentialServerPolicy = getStringOption(e2.credentialServerPolicy, ["optional", "required"]), this.id = e2.id || "", this.url = e2.url || "", this.urlPolicy = e2.urlPolicy || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.encryption = null, this.issuers = null, this.keyUsage = null, this.oids = null, this.signing = null, this.subjectDNs = null;
  }
}
class CheckButton extends XFAObject {
  constructor(e2) {
    super(Lo, "checkButton", true), this.id = e2.id || "", this.mark = getStringOption(e2.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]), this.shape = getStringOption(e2.shape, ["square", "round"]), this.size = getMeasurement(e2.size, "10pt"), this.use = e2.use || "", this.usehref = e2.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
  [Qr](e2) {
    const t2 = toStyle(this, "margin"), i2 = measureToString(this.size);
    let n2, a2, s2;
    t2.width = t2.height = i2;
    const r2 = this[mr]()[mr](), o2 = r2.items.children.length && r2.items.children[0][Qr]().html || [], l2 = { on: (void 0 !== o2[0] ? o2[0] : "on").toString(), off: (void 0 !== o2[1] ? o2[1] : "off").toString() }, c2 = (r2.value?.[Jr]() || "off") === l2.on || void 0, h2 = r2[pr](), d2 = r2[io];
    let u2;
    h2 instanceof ExclGroup ? (s2 = h2[io], n2 = "radio", a2 = "xfaRadio", u2 = h2[Zs]?.[io] || h2[io]) : (n2 = "checkbox", a2 = "xfaCheckbox", u2 = r2[Zs]?.[io] || r2[io]);
    const g2 = { name: "input", attributes: { class: [a2], style: t2, fieldId: d2, dataId: u2, type: n2, checked: c2, xfaOn: l2.on, xfaOff: l2.off, "aria-label": ariaLabel(r2), "aria-required": false } };
    return s2 && (g2.attributes.name = s2), isRequired(r2) && (g2.attributes["aria-required"] = true, g2.attributes.required = true), HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [g2] });
  }
}
class ChoiceList extends XFAObject {
  constructor(e2) {
    super(Lo, "choiceList", true), this.commitOn = getStringOption(e2.commitOn, ["select", "exit"]), this.id = e2.id || "", this.open = getStringOption(e2.open, ["userControl", "always", "multiSelect", "onEntry"]), this.textEntry = getInteger({ data: e2.textEntry, defaultValue: 0, validate: (e3) => 1 === e3 }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
  [Qr](e2) {
    const t2 = toStyle(this, "border", "margin"), i2 = this[mr]()[mr](), n2 = { fontSize: `calc(${i2.font?.size || 10}px * var(--total-scale-factor))` }, a2 = [];
    if (i2.items.children.length > 0) {
      const e3 = i2.items;
      let t3 = 0, s3 = 0;
      2 === e3.children.length && (t3 = e3.children[0].save, s3 = 1 - t3);
      const r2 = e3.children[t3][Qr]().html, o2 = e3.children[s3][Qr]().html;
      let l2 = false;
      const c2 = i2.value?.[Jr]() || "";
      for (let e4 = 0, t4 = r2.length; e4 < t4; e4++) {
        const t5 = { name: "option", attributes: { value: o2[e4] || r2[e4], style: n2 }, value: r2[e4] };
        o2[e4] === c2 && (t5.attributes.selected = l2 = true), a2.push(t5);
      }
      l2 || a2.splice(0, 0, { name: "option", attributes: { hidden: true, selected: true }, value: " " });
    }
    const s2 = { class: ["xfaSelect"], fieldId: i2[io], dataId: i2[Zs]?.[io] || i2[io], style: t2, "aria-label": ariaLabel(i2), "aria-required": false };
    return isRequired(i2) && (s2["aria-required"] = true, s2.required = true), "multiSelect" === this.open && (s2.multiple = true), HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [{ name: "select", children: a2, attributes: s2 }] });
  }
}
class Color extends XFAObject {
  constructor(e2) {
    super(Lo, "color", true), this.cSpace = getStringOption(e2.cSpace, ["SRGB"]), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.value = e2.value ? (function(e3, t2 = [0, 0, 0]) {
      let [i2, n2, a2] = t2;
      if (!e3) return { r: i2, g: n2, b: a2 };
      const s2 = e3.split(",", 3).map((e4) => MathClamp$1(parseInt(e4.trim(), 10), 0, 255)).map((e4) => isNaN(e4) ? 0 : e4);
      return s2.length < 3 || ([i2, n2, a2] = s2), { r: i2, g: n2, b: a2 };
    })(e2.value) : "", this.extras = null;
  }
  [wr]() {
    return false;
  }
  [to]() {
    return this.value ? ai.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
  }
}
class Comb extends XFAObject {
  constructor(e2) {
    super(Lo, "comb"), this.id = e2.id || "", this.numberOfCells = getInteger({ data: e2.numberOfCells, defaultValue: 0, validate: (e3) => e3 >= 0 }), this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class Connect extends XFAObject {
  constructor(e2) {
    super(Lo, "connect", true), this.connection = e2.connection || "", this.id = e2.id || "", this.ref = e2.ref || "", this.usage = getStringOption(e2.usage, ["exportAndImport", "exportOnly", "importOnly"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.picture = null;
  }
}
class ContentArea extends XFAObject {
  constructor(e2) {
    super(Lo, "contentArea", true), this.h = getMeasurement(e2.h), this.id = e2.id || "", this.name = e2.name || "", this.relevant = getRelevant(e2.relevant), this.use = e2.use || "", this.usehref = e2.usehref || "", this.w = getMeasurement(e2.w), this.x = getMeasurement(e2.x, "0pt"), this.y = getMeasurement(e2.y, "0pt"), this.desc = null, this.extras = null;
  }
  [Qr](e2) {
    const t2 = { left: measureToString(this.x), top: measureToString(this.y), width: measureToString(this.w), height: measureToString(this.h) }, i2 = ["xfaContentarea"];
    return isPrintOnly(this) && i2.push("xfaPrintOnly"), HTMLResult.success({ name: "div", children: [], attributes: { style: t2, class: i2, id: this[io] } });
  }
}
class Corner extends XFAObject {
  constructor(e2) {
    super(Lo, "corner", true), this.id = e2.id || "", this.inverted = getInteger({ data: e2.inverted, defaultValue: 0, validate: (e3) => 1 === e3 }), this.join = getStringOption(e2.join, ["square", "round"]), this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.radius = getMeasurement(e2.radius), this.stroke = getStringOption(e2.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = getMeasurement(e2.thickness, "0.5pt"), this.use = e2.use || "", this.usehref = e2.usehref || "", this.color = null, this.extras = null;
  }
  [to]() {
    const e2 = toStyle(this, "visibility");
    return e2.radius = measureToString("square" === this.join ? 0 : this.radius), e2;
  }
}
class DateElement extends ContentObject {
  constructor(e2) {
    super(Lo, "date"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
  [tr]() {
    const e2 = this[Js].trim();
    this[Js] = e2 ? new Date(e2) : null;
  }
  [Qr](e2) {
    return valueToHtml(this[Js] ? this[Js].toString() : "");
  }
}
class DateTime extends ContentObject {
  constructor(e2) {
    super(Lo, "dateTime"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
  [tr]() {
    const e2 = this[Js].trim();
    this[Js] = e2 ? new Date(e2) : null;
  }
  [Qr](e2) {
    return valueToHtml(this[Js] ? this[Js].toString() : "");
  }
}
class DateTimeEdit extends XFAObject {
  constructor(e2) {
    super(Lo, "dateTimeEdit", true), this.hScrollPolicy = getStringOption(e2.hScrollPolicy, ["auto", "off", "on"]), this.id = e2.id || "", this.picker = getStringOption(e2.picker, ["host", "none"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
  }
  [Qr](e2) {
    const t2 = toStyle(this, "border", "font", "margin"), i2 = this[mr]()[mr](), n2 = { name: "input", attributes: { type: "text", fieldId: i2[io], dataId: i2[Zs]?.[io] || i2[io], class: ["xfaTextfield"], style: t2, "aria-label": ariaLabel(i2), "aria-required": false } };
    return isRequired(i2) && (n2.attributes["aria-required"] = true, n2.attributes.required = true), HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [n2] });
  }
}
class Decimal extends ContentObject {
  constructor(e2) {
    super(Lo, "decimal"), this.fracDigits = getInteger({ data: e2.fracDigits, defaultValue: 2, validate: (e3) => true }), this.id = e2.id || "", this.leadDigits = getInteger({ data: e2.leadDigits, defaultValue: -1, validate: (e3) => true }), this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
  [tr]() {
    const e2 = parseFloat(this[Js].trim());
    this[Js] = isNaN(e2) ? null : e2;
  }
  [Qr](e2) {
    return valueToHtml(null !== this[Js] ? this[Js].toString() : "");
  }
}
class DefaultUi extends XFAObject {
  constructor(e2) {
    super(Lo, "defaultUi", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null;
  }
}
class Desc extends XFAObject {
  constructor(e2) {
    super(Lo, "desc", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.boolean = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.float = new XFAObjectArray(), this.image = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.text = new XFAObjectArray(), this.time = new XFAObjectArray();
  }
}
class DigestMethod extends OptionObject {
  constructor(e2) {
    super(Lo, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class DigestMethods extends XFAObject {
  constructor(e2) {
    super(Lo, "digestMethods", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.digestMethod = new XFAObjectArray();
  }
}
class Draw extends XFAObject {
  constructor(e2) {
    super(Lo, "draw", true), this.anchorType = getStringOption(e2.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 }), this.h = e2.h ? getMeasurement(e2.h) : "", this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e2.id || "", this.locale = e2.locale || "", this.maxH = getMeasurement(e2.maxH, "0pt"), this.maxW = getMeasurement(e2.maxW, "0pt"), this.minH = getMeasurement(e2.minH, "0pt"), this.minW = getMeasurement(e2.minW, "0pt"), this.name = e2.name || "", this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = getRelevant(e2.relevant), this.rotate = getInteger({ data: e2.rotate, defaultValue: 0, validate: (e3) => e3 % 90 == 0 }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.w = e2.w ? getMeasurement(e2.w) : "", this.x = getMeasurement(e2.x, "0pt"), this.y = getMeasurement(e2.y, "0pt"), this.assist = null, this.border = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.value = null, this.setProperty = new XFAObjectArray();
  }
  [Kr](e2) {
    _setValue(this, e2);
  }
  [Qr](e2) {
    if (setTabIndex(this), "hidden" === this.presence || "inactive" === this.presence) return HTMLResult.EMPTY;
    fixDimensions(this), this[Hr]();
    const t2 = this.w, i2 = this.h, { w: n2, h: a2, isBroken: s2 } = layoutNode(this, e2);
    if (n2 && "" === this.w) {
      if (s2 && this[pr]()[Er]()) return this[$r](), HTMLResult.FAILURE;
      this.w = n2;
    }
    if (a2 && "" === this.h && (this.h = a2), setFirstUnsplittable(this), !checkDimensions(this, e2)) return this.w = t2, this.h = i2, this[$r](), HTMLResult.FAILURE;
    unsetFirstUnsplittable(this);
    const r2 = toStyle(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
    setMinMaxDimensions(this, r2), r2.margin && (r2.padding = r2.margin, delete r2.margin);
    const o2 = ["xfaDraw"];
    this.font && o2.push("xfaFont"), isPrintOnly(this) && o2.push("xfaPrintOnly");
    const l2 = { style: r2, id: this[io], class: o2 };
    this.name && (l2.xfaName = this.name);
    const c2 = { name: "div", attributes: l2, children: [] };
    applyAssist(this, l2);
    const h2 = computeBbox(this, c2, e2), d2 = this.value ? this.value[Qr](e2).html : null;
    return null === d2 ? (this.w = t2, this.h = i2, this[$r](), HTMLResult.success(createWrapper(this, c2), h2)) : (c2.children.push(d2), setPara(this, r2, d2), this.w = t2, this.h = i2, this[$r](), HTMLResult.success(createWrapper(this, c2), h2));
  }
}
class Edge extends XFAObject {
  constructor(e2) {
    super(Lo, "edge", true), this.cap = getStringOption(e2.cap, ["square", "butt", "round"]), this.id = e2.id || "", this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.stroke = getStringOption(e2.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = getMeasurement(e2.thickness, "0.5pt"), this.use = e2.use || "", this.usehref = e2.usehref || "", this.color = null, this.extras = null;
  }
  [to]() {
    const e2 = toStyle(this, "visibility");
    if (Object.assign(e2, { linecap: this.cap, width: measureToString(this.thickness), color: this.color ? this.color[to]() : "#000000", style: "" }), "visible" !== this.presence) e2.style = "none";
    else switch (this.stroke) {
      case "solid":
        e2.style = "solid";
        break;
      case "dashDot":
      case "dashDotDot":
      case "dashed":
        e2.style = "dashed";
        break;
      case "dotted":
        e2.style = "dotted";
        break;
      case "embossed":
        e2.style = "ridge";
        break;
      case "etched":
        e2.style = "groove";
        break;
      case "lowered":
        e2.style = "inset";
        break;
      case "raised":
        e2.style = "outset";
    }
    return e2;
  }
}
class Encoding extends OptionObject {
  constructor(e2) {
    super(Lo, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class Encodings extends XFAObject {
  constructor(e2) {
    super(Lo, "encodings", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.encoding = new XFAObjectArray();
  }
}
class Encrypt extends XFAObject {
  constructor(e2) {
    super(Lo, "encrypt", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.certificate = null;
  }
}
class EncryptData extends XFAObject {
  constructor(e2) {
    super(Lo, "encryptData", true), this.id = e2.id || "", this.operation = getStringOption(e2.operation, ["encrypt", "decrypt"]), this.target = e2.target || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.filter = null, this.manifest = null;
  }
}
class Encryption extends XFAObject {
  constructor(e2) {
    super(Lo, "encryption", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.certificate = new XFAObjectArray();
  }
}
class EncryptionMethod extends OptionObject {
  constructor(e2) {
    super(Lo, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class EncryptionMethods extends XFAObject {
  constructor(e2) {
    super(Lo, "encryptionMethods", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.encryptionMethod = new XFAObjectArray();
  }
}
let Xo = class extends XFAObject {
  constructor(e2) {
    super(Lo, "event", true), this.activity = getStringOption(e2.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]), this.id = e2.id || "", this.listen = getStringOption(e2.listen, ["refOnly", "refAndDescendents"]), this.name = e2.name || "", this.ref = e2.ref || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.encryptData = null, this.execute = null, this.script = null, this.signData = null, this.submit = null;
  }
};
class ExData extends ContentObject {
  constructor(e2) {
    super(Lo, "exData"), this.contentType = e2.contentType || "", this.href = e2.href || "", this.id = e2.id || "", this.maxLength = getInteger({ data: e2.maxLength, defaultValue: -1, validate: (e3) => e3 >= -1 }), this.name = e2.name || "", this.rid = e2.rid || "", this.transferEncoding = getStringOption(e2.transferEncoding, ["none", "base64", "package"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
  [vr]() {
    return "text/html" === this.contentType;
  }
  [Nr](e2) {
    return ("text/html" === this.contentType && e2[_r] === ao.xhtml.id || "text/xml" === this.contentType) && (this[Js] = e2, true);
  }
  [Qr](e2) {
    return "text/html" === this.contentType && this[Js] ? this[Js][Qr](e2) : HTMLResult.EMPTY;
  }
}
class ExObject extends XFAObject {
  constructor(e2) {
    super(Lo, "exObject", true), this.archive = e2.archive || "", this.classId = e2.classId || "", this.codeBase = e2.codeBase || "", this.codeType = e2.codeType || "", this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.boolean = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.exObject = new XFAObjectArray(), this.float = new XFAObjectArray(), this.image = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.text = new XFAObjectArray(), this.time = new XFAObjectArray();
  }
}
class ExclGroup extends XFAObject {
  constructor(e2) {
    super(Lo, "exclGroup", true), this.access = getStringOption(e2.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = e2.accessKey || "", this.anchorType = getStringOption(e2.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 }), this.h = e2.h ? getMeasurement(e2.h) : "", this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e2.id || "", this.layout = getStringOption(e2.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.maxH = getMeasurement(e2.maxH, "0pt"), this.maxW = getMeasurement(e2.maxW, "0pt"), this.minH = getMeasurement(e2.minH, "0pt"), this.minW = getMeasurement(e2.minW, "0pt"), this.name = e2.name || "", this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = getRelevant(e2.relevant), this.use = e2.use || "", this.usehref = e2.usehref || "", this.w = e2.w ? getMeasurement(e2.w) : "", this.x = getMeasurement(e2.x, "0pt"), this.y = getMeasurement(e2.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.margin = null, this.para = null, this.traversal = null, this.validate = null, this.connect = new XFAObjectArray(), this.event = new XFAObjectArray(), this.field = new XFAObjectArray(), this.setProperty = new XFAObjectArray();
  }
  [Cr]() {
    return true;
  }
  [wr]() {
    return true;
  }
  [Kr](e2) {
    for (const t2 of this.field.children) {
      if (!t2.value) {
        const e3 = new Value({});
        t2[qs](e3), t2.value = e3;
      }
      t2.value[Kr](e2);
    }
  }
  [Er]() {
    return this.layout.endsWith("-tb") && 0 === this[er].attempt && this[er].numberInLine > 0 || this[mr]()[Er]();
  }
  [Ir]() {
    const e2 = this[pr]();
    return !!e2[Ir]() && (void 0 !== this[er]._isSplittable ? this[er]._isSplittable : "position" === this.layout || this.layout.includes("row") ? (this[er]._isSplittable = false, false) : (!e2.layout?.endsWith("-tb") || 0 === e2[er].numberInLine) && (this[er]._isSplittable = true, true));
  }
  [ir]() {
    return flushHTML(this);
  }
  [Xs](e2, t2) {
    addHTML(this, e2, t2);
  }
  [sr]() {
    return getAvailableSpace(this);
  }
  [Qr](e2) {
    if (setTabIndex(this), "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return HTMLResult.EMPTY;
    fixDimensions(this);
    const t2 = [], i2 = { id: this[io], class: [] };
    setAccess(this, i2.class), this[er] ||= /* @__PURE__ */ Object.create(null), Object.assign(this[er], { children: t2, attributes: i2, attempt: 0, line: null, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, e2.width), height: Math.min(this.h || 1 / 0, e2.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
    const n2 = this[Ir]();
    if (n2 || setFirstUnsplittable(this), !checkDimensions(this, e2)) return HTMLResult.FAILURE;
    const a2 = /* @__PURE__ */ new Set(["field"]);
    if (this.layout.includes("row")) {
      const e3 = this[pr]().columnWidths;
      Array.isArray(e3) && e3.length > 0 && (this[er].columnWidths = e3, this[er].currentColumn = 0);
    }
    const s2 = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), r2 = ["xfaExclgroup"], o2 = layoutClass(this);
    o2 && r2.push(o2), isPrintOnly(this) && r2.push("xfaPrintOnly"), i2.style = s2, i2.class = r2, this.name && (i2.xfaName = this.name), this[Hr]();
    const l2 = "lr-tb" === this.layout || "rl-tb" === this.layout, c2 = l2 ? 2 : 1;
    for (; this[er].attempt < c2; this[er].attempt++) {
      l2 && 1 === this[er].attempt && (this[er].numberInLine = 0);
      const e3 = this[zs]({ filter: a2, include: true });
      if (e3.success) break;
      if (e3.isBreak()) return this[$r](), e3;
      if (l2 && 0 === this[er].attempt && 0 === this[er].numberInLine && !this[br]()[er].noLayoutFailure) {
        this[er].attempt = c2;
        break;
      }
    }
    if (this[$r](), n2 || unsetFirstUnsplittable(this), this[er].attempt === c2) return n2 || delete this[er], HTMLResult.FAILURE;
    let h2 = 0, d2 = 0;
    this.margin && (h2 = this.margin.leftInset + this.margin.rightInset, d2 = this.margin.topInset + this.margin.bottomInset);
    const u2 = Math.max(this[er].width + h2, this.w || 0), g2 = Math.max(this[er].height + d2, this.h || 0), f2 = [this.x, this.y, u2, g2];
    "" === this.w && (s2.width = measureToString(u2)), "" === this.h && (s2.height = measureToString(g2));
    const p2 = { name: "div", attributes: i2, children: t2 };
    return applyAssist(this, i2), delete this[er], HTMLResult.success(createWrapper(this, p2), f2);
  }
}
class Execute extends XFAObject {
  constructor(e2) {
    super(Lo, "execute"), this.connection = e2.connection || "", this.executeType = getStringOption(e2.executeType, ["import", "remerge"]), this.id = e2.id || "", this.runAt = getStringOption(e2.runAt, ["client", "both", "server"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class Extras extends XFAObject {
  constructor(e2) {
    super(Lo, "extras", true), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.boolean = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.extras = new XFAObjectArray(), this.float = new XFAObjectArray(), this.image = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.text = new XFAObjectArray(), this.time = new XFAObjectArray();
  }
}
class Field extends XFAObject {
  constructor(e2) {
    super(Lo, "field", true), this.access = getStringOption(e2.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = e2.accessKey || "", this.anchorType = getStringOption(e2.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 }), this.h = e2.h ? getMeasurement(e2.h) : "", this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e2.id || "", this.locale = e2.locale || "", this.maxH = getMeasurement(e2.maxH, "0pt"), this.maxW = getMeasurement(e2.maxW, "0pt"), this.minH = getMeasurement(e2.minH, "0pt"), this.minW = getMeasurement(e2.minW, "0pt"), this.name = e2.name || "", this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = getRelevant(e2.relevant), this.rotate = getInteger({ data: e2.rotate, defaultValue: 0, validate: (e3) => e3 % 90 == 0 }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.w = e2.w ? getMeasurement(e2.w) : "", this.x = getMeasurement(e2.x, "0pt"), this.y = getMeasurement(e2.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.format = null, this.items = new XFAObjectArray(2), this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.validate = null, this.value = null, this.bindItems = new XFAObjectArray(), this.connect = new XFAObjectArray(), this.event = new XFAObjectArray(), this.setProperty = new XFAObjectArray();
  }
  [Cr]() {
    return true;
  }
  [Kr](e2) {
    _setValue(this, e2);
  }
  [Qr](e2) {
    if (setTabIndex(this), !this.ui) {
      let e3;
      switch (this.ui = new Ui({}), this.ui[yr] = this[yr], this[qs](this.ui), this.items.children.length) {
        case 0:
          e3 = new TextEdit({}), this.ui.textEdit = e3;
          break;
        case 1:
          e3 = new CheckButton({}), this.ui.checkButton = e3;
          break;
        case 2:
          e3 = new ChoiceList({}), this.ui.choiceList = e3;
      }
      this.ui[qs](e3);
    }
    if (!this.ui || "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return HTMLResult.EMPTY;
    this.caption && delete this.caption[er], this[Hr]();
    const t2 = this.caption ? this.caption[Qr](e2).html : null, i2 = this.w, n2 = this.h;
    let a2 = 0, s2 = 0;
    this.margin && (a2 = this.margin.leftInset + this.margin.rightInset, s2 = this.margin.topInset + this.margin.bottomInset);
    let r2 = null;
    if ("" === this.w || "" === this.h) {
      let t3 = null, i3 = null, n3 = 0, o3 = 0;
      if (this.ui.checkButton) n3 = o3 = this.ui.checkButton.size;
      else {
        const { w: t4, h: i4 } = layoutNode(this, e2);
        null !== t4 ? (n3 = t4, o3 = i4) : o3 = (function(e3, t5 = false) {
          let i5 = null;
          if (e3) {
            const t6 = stripQuotes(e3.typeface), n5 = e3[yr].fontFinder.find(t6);
            i5 = selectFont(e3, n5);
          }
          if (!i5) return { lineHeight: 12, lineGap: 2, lineNoGap: 10 };
          const n4 = e3.size || 10, a3 = i5.lineHeight ? Math.max(t5 ? 0 : 1.2, i5.lineHeight) : 1.2, s3 = void 0 === i5.lineGap ? 0.2 : i5.lineGap;
          return { lineHeight: a3 * n4, lineGap: s3 * n4, lineNoGap: Math.max(1, a3 - s3) * n4 };
        })(this.font, true).lineNoGap;
      }
      if (r2 = getBorderDims(this.ui[hr]()), n3 += r2.w, o3 += r2.h, this.caption) {
        const { w: a3, h: s3, isBroken: r3 } = this.caption[hr](e2);
        if (r3 && this[pr]()[Er]()) return this[$r](), HTMLResult.FAILURE;
        switch (t3 = a3, i3 = s3, this.caption.placement) {
          case "left":
          case "right":
          case "inline":
            t3 += n3;
            break;
          case "top":
          case "bottom":
            i3 += o3;
        }
      } else t3 = n3, i3 = o3;
      t3 && "" === this.w && (t3 += a2, this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < t3 ? t3 : this.minW)), i3 && "" === this.h && (i3 += s2, this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < i3 ? i3 : this.minH));
    }
    if (this[$r](), fixDimensions(this), setFirstUnsplittable(this), !checkDimensions(this, e2)) return this.w = i2, this.h = n2, this[$r](), HTMLResult.FAILURE;
    unsetFirstUnsplittable(this);
    const o2 = toStyle(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
    setMinMaxDimensions(this, o2);
    const l2 = ["xfaField"];
    this.font && l2.push("xfaFont"), isPrintOnly(this) && l2.push("xfaPrintOnly");
    const c2 = { style: o2, id: this[io], class: l2 };
    o2.margin && (o2.padding = o2.margin, delete o2.margin), setAccess(this, l2), this.name && (c2.xfaName = this.name);
    const h2 = [], d2 = { name: "div", attributes: c2, children: h2 };
    applyAssist(this, c2);
    const u2 = this.border ? this.border[to]() : null, g2 = computeBbox(this, d2, e2), f2 = this.ui[Qr]().html;
    if (!f2) return Object.assign(o2, u2), HTMLResult.success(createWrapper(this, d2), g2);
    this[Yr] && (f2.children?.[0] ? f2.children[0].attributes.tabindex = this[Yr] : f2.attributes.tabindex = this[Yr]), f2.attributes.style ||= /* @__PURE__ */ Object.create(null);
    let p2 = null;
    if (this.ui.button ? (1 === f2.children.length && ([p2] = f2.children.splice(0, 1)), Object.assign(f2.attributes.style, u2)) : Object.assign(o2, u2), h2.push(f2), this.value) {
      if (this.ui.imageEdit) f2.children.push(this.value[Qr]().html);
      else if (!this.ui.button) {
        let e3 = "";
        if (this.value.exData) e3 = this.value.exData[Jr]();
        else if (this.value.text) e3 = this.value.text[hr]();
        else {
          const t3 = this.value[Qr]().html;
          null !== t3 && (e3 = t3.children[0].value);
        }
        this.ui.textEdit && this.value.text?.maxChars && (f2.children[0].attributes.maxLength = this.value.text.maxChars), e3 && (this.ui.numericEdit && (e3 = parseFloat(e3), e3 = isNaN(e3) ? "" : e3.toString()), "textarea" === f2.children[0].name ? f2.children[0].attributes.textContent = e3 : f2.children[0].attributes.value = e3);
      }
    }
    if (!this.ui.imageEdit && f2.children?.[0] && this.h) {
      r2 = r2 || getBorderDims(this.ui[hr]());
      let t3 = 0;
      if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
        t3 = this.caption.reserve, t3 <= 0 && (t3 = this.caption[hr](e2).h);
        const i3 = this.h - t3 - s2 - r2.h;
        f2.children[0].attributes.style.height = measureToString(i3);
      } else f2.children[0].attributes.style.height = "100%";
    }
    if (p2 && f2.children.push(p2), !t2) return f2.attributes.class && f2.attributes.class.push("xfaLeft"), this.w = i2, this.h = n2, HTMLResult.success(createWrapper(this, d2), g2);
    if (this.ui.button) return o2.padding && delete o2.padding, "div" === t2.name && (t2.name = "span"), f2.children.push(t2), HTMLResult.success(d2, g2);
    switch (this.ui.checkButton && (t2.attributes.class[0] = "xfaCaptionForCheckButton"), f2.attributes.class ||= [], f2.children.splice(0, 0, t2), this.caption.placement) {
      case "left":
      case "inline":
        f2.attributes.class.push("xfaLeft");
        break;
      case "right":
        f2.attributes.class.push("xfaRight");
        break;
      case "top":
        f2.attributes.class.push("xfaTop");
        break;
      case "bottom":
        f2.attributes.class.push("xfaBottom");
    }
    return this.w = i2, this.h = n2, HTMLResult.success(createWrapper(this, d2), g2);
  }
}
class Fill extends XFAObject {
  constructor(e2) {
    super(Lo, "fill", true), this.id = e2.id || "", this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.color = null, this.extras = null, this.linear = null, this.pattern = null, this.radial = null, this.solid = null, this.stipple = null;
  }
  [to]() {
    const e2 = this[mr](), t2 = e2[mr]()[mr](), i2 = /* @__PURE__ */ Object.create(null);
    let n2 = "color", a2 = n2;
    e2 instanceof Border && (n2 = "background-color", a2 = "background", t2 instanceof Ui && (i2.backgroundColor = "white")), (e2 instanceof Rectangle || e2 instanceof Arc) && (n2 = a2 = "fill", i2.fill = "white");
    for (const e3 of Object.getOwnPropertyNames(this)) {
      if ("extras" === e3 || "color" === e3) continue;
      const t3 = this[e3];
      if (!(t3 instanceof XFAObject)) continue;
      const s2 = t3[to](this.color);
      return s2 && (i2[s2.startsWith("#") ? n2 : a2] = s2), i2;
    }
    if (this.color?.value) {
      const e3 = this.color[to]();
      i2[e3.startsWith("#") ? n2 : a2] = e3;
    }
    return i2;
  }
}
class Filter extends XFAObject {
  constructor(e2) {
    super(Lo, "filter", true), this.addRevocationInfo = getStringOption(e2.addRevocationInfo, ["", "required", "optional", "none"]), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.version = getInteger({ data: this.version, defaultValue: 5, validate: (e3) => e3 >= 1 && e3 <= 5 }), this.appearanceFilter = null, this.certificates = null, this.digestMethods = null, this.encodings = null, this.encryptionMethods = null, this.handler = null, this.lockDocument = null, this.mdp = null, this.reasons = null, this.timeStamp = null;
  }
}
class Float extends ContentObject {
  constructor(e2) {
    super(Lo, "float"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
  [tr]() {
    const e2 = parseFloat(this[Js].trim());
    this[Js] = isNaN(e2) ? null : e2;
  }
  [Qr](e2) {
    return valueToHtml(null !== this[Js] ? this[Js].toString() : "");
  }
}
class template_Font extends XFAObject {
  constructor(e2) {
    super(Lo, "font", true), this.baselineShift = getMeasurement(e2.baselineShift), this.fontHorizontalScale = getFloat({ data: e2.fontHorizontalScale, defaultValue: 100, validate: (e3) => e3 >= 0 }), this.fontVerticalScale = getFloat({ data: e2.fontVerticalScale, defaultValue: 100, validate: (e3) => e3 >= 0 }), this.id = e2.id || "", this.kerningMode = getStringOption(e2.kerningMode, ["none", "pair"]), this.letterSpacing = getMeasurement(e2.letterSpacing, "0"), this.lineThrough = getInteger({ data: e2.lineThrough, defaultValue: 0, validate: (e3) => 1 === e3 || 2 === e3 }), this.lineThroughPeriod = getStringOption(e2.lineThroughPeriod, ["all", "word"]), this.overline = getInteger({ data: e2.overline, defaultValue: 0, validate: (e3) => 1 === e3 || 2 === e3 }), this.overlinePeriod = getStringOption(e2.overlinePeriod, ["all", "word"]), this.posture = getStringOption(e2.posture, ["normal", "italic"]), this.size = getMeasurement(e2.size, "10pt"), this.typeface = e2.typeface || "Courier", this.underline = getInteger({ data: e2.underline, defaultValue: 0, validate: (e3) => 1 === e3 || 2 === e3 }), this.underlinePeriod = getStringOption(e2.underlinePeriod, ["all", "word"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.weight = getStringOption(e2.weight, ["normal", "bold"]), this.extras = null, this.fill = null;
  }
  [Ws](e2) {
    super[Ws](e2), this[yr].usedTypefaces.add(this.typeface);
  }
  [to]() {
    const e2 = toStyle(this, "fill"), t2 = e2.color;
    return t2 && ("#000000" === t2 ? delete e2.color : t2.startsWith("#") || (e2.background = t2, e2.backgroundClip = "text", e2.color = "transparent")), this.baselineShift && (e2.verticalAlign = measureToString(this.baselineShift)), e2.fontKerning = "none" === this.kerningMode ? "none" : "normal", e2.letterSpacing = measureToString(this.letterSpacing), 0 !== this.lineThrough && (e2.textDecoration = "line-through", 2 === this.lineThrough && (e2.textDecorationStyle = "double")), 0 !== this.overline && (e2.textDecoration = "overline", 2 === this.overline && (e2.textDecorationStyle = "double")), e2.fontStyle = this.posture, e2.fontSize = measureToString(0.99 * this.size), setFontFamily(this, this, this[yr].fontFinder, e2), 0 !== this.underline && (e2.textDecoration = "underline", 2 === this.underline && (e2.textDecorationStyle = "double")), e2.fontWeight = this.weight, e2;
  }
}
class Format extends XFAObject {
  constructor(e2) {
    super(Lo, "format", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.picture = null;
  }
}
class Handler extends StringObject {
  constructor(e2) {
    super(Lo, "handler"), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class Hyphenation extends XFAObject {
  constructor(e2) {
    super(Lo, "hyphenation"), this.excludeAllCaps = getInteger({ data: e2.excludeAllCaps, defaultValue: 0, validate: (e3) => 1 === e3 }), this.excludeInitialCap = getInteger({ data: e2.excludeInitialCap, defaultValue: 0, validate: (e3) => 1 === e3 }), this.hyphenate = getInteger({ data: e2.hyphenate, defaultValue: 0, validate: (e3) => 1 === e3 }), this.id = e2.id || "", this.pushCharacterCount = getInteger({ data: e2.pushCharacterCount, defaultValue: 3, validate: (e3) => e3 >= 0 }), this.remainCharacterCount = getInteger({ data: e2.remainCharacterCount, defaultValue: 3, validate: (e3) => e3 >= 0 }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.wordCharacterCount = getInteger({ data: e2.wordCharacterCount, defaultValue: 7, validate: (e3) => e3 >= 0 });
  }
}
let qo = class extends StringObject {
  constructor(e2) {
    super(Lo, "image"), this.aspect = getStringOption(e2.aspect, ["fit", "actual", "height", "none", "width"]), this.contentType = e2.contentType || "", this.href = e2.href || "", this.id = e2.id || "", this.name = e2.name || "", this.transferEncoding = getStringOption(e2.transferEncoding, ["base64", "none", "package"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
  [Qr]() {
    if (this.contentType && !$o.has(this.contentType.toLowerCase())) return HTMLResult.EMPTY;
    let e2 = this[yr].images?.get(this.href);
    if (!e2 && (this.href || !this[Js])) return HTMLResult.EMPTY;
    var t2;
    if (e2 || "base64" !== this.transferEncoding || (t2 = this[Js], e2 = Uint8Array.fromBase64 ? Uint8Array.fromBase64(t2) : stringToBytes$1(atob(t2))), !e2) return HTMLResult.EMPTY;
    if (!this.contentType) {
      for (const [t3, i3] of Ho) if (e2.length > t3.length && t3.every((t4, i4) => t4 === e2[i4])) {
        this.contentType = i3;
        break;
      }
      if (!this.contentType) return HTMLResult.EMPTY;
    }
    const i2 = new Blob([e2], { type: this.contentType });
    let n2;
    switch (this.aspect) {
      case "fit":
      case "actual":
        break;
      case "height":
        n2 = { height: "100%", objectFit: "fill" };
        break;
      case "none":
        n2 = { width: "100%", height: "100%", objectFit: "fill" };
        break;
      case "width":
        n2 = { width: "100%", objectFit: "fill" };
    }
    const a2 = this[mr]();
    return HTMLResult.success({ name: "img", attributes: { class: ["xfaImage"], style: n2, src: URL.createObjectURL(i2), alt: a2 ? ariaLabel(a2[mr]()) : null } });
  }
};
class ImageEdit extends XFAObject {
  constructor(e2) {
    super(Lo, "imageEdit", true), this.data = getStringOption(e2.data, ["link", "embed"]), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
  [Qr](e2) {
    return "embed" === this.data ? HTMLResult.success({ name: "div", children: [], attributes: {} }) : HTMLResult.EMPTY;
  }
}
class Integer extends ContentObject {
  constructor(e2) {
    super(Lo, "integer"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
  [tr]() {
    const e2 = parseInt(this[Js].trim(), 10);
    this[Js] = isNaN(e2) ? null : e2;
  }
  [Qr](e2) {
    return valueToHtml(null !== this[Js] ? this[Js].toString() : "");
  }
}
class Issuers extends XFAObject {
  constructor(e2) {
    super(Lo, "issuers", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.certificate = new XFAObjectArray();
  }
}
class Items extends XFAObject {
  constructor(e2) {
    super(Lo, "items", true), this.id = e2.id || "", this.name = e2.name || "", this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.ref = e2.ref || "", this.save = getInteger({ data: e2.save, defaultValue: 0, validate: (e3) => 1 === e3 }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.boolean = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.float = new XFAObjectArray(), this.image = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.text = new XFAObjectArray(), this.time = new XFAObjectArray();
  }
  [Qr]() {
    const e2 = [];
    for (const t2 of this[ur]()) e2.push(t2[Jr]());
    return HTMLResult.success(e2);
  }
}
class Keep extends XFAObject {
  constructor(e2) {
    super(Lo, "keep", true), this.id = e2.id || "";
    const t2 = ["none", "contentArea", "pageArea"];
    this.intact = getStringOption(e2.intact, t2), this.next = getStringOption(e2.next, t2), this.previous = getStringOption(e2.previous, t2), this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null;
  }
}
class KeyUsage extends XFAObject {
  constructor(e2) {
    super(Lo, "keyUsage");
    const t2 = ["", "yes", "no"];
    this.crlSign = getStringOption(e2.crlSign, t2), this.dataEncipherment = getStringOption(e2.dataEncipherment, t2), this.decipherOnly = getStringOption(e2.decipherOnly, t2), this.digitalSignature = getStringOption(e2.digitalSignature, t2), this.encipherOnly = getStringOption(e2.encipherOnly, t2), this.id = e2.id || "", this.keyAgreement = getStringOption(e2.keyAgreement, t2), this.keyCertSign = getStringOption(e2.keyCertSign, t2), this.keyEncipherment = getStringOption(e2.keyEncipherment, t2), this.nonRepudiation = getStringOption(e2.nonRepudiation, t2), this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class Line extends XFAObject {
  constructor(e2) {
    super(Lo, "line", true), this.hand = getStringOption(e2.hand, ["even", "left", "right"]), this.id = e2.id || "", this.slope = getStringOption(e2.slope, ["\\", "/"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.edge = null;
  }
  [Qr]() {
    const e2 = this[mr]()[mr](), t2 = this.edge || new Edge({}), i2 = t2[to](), n2 = /* @__PURE__ */ Object.create(null), a2 = "visible" === t2.presence ? t2.thickness : 0;
    let s2, r2, o2, l2;
    n2.strokeWidth = measureToString(a2), n2.stroke = i2.color;
    let c2 = "100%", h2 = "100%";
    e2.w <= a2 ? ([s2, r2, o2, l2] = ["50%", 0, "50%", "100%"], c2 = n2.strokeWidth) : e2.h <= a2 ? ([s2, r2, o2, l2] = [0, "50%", "100%", "50%"], h2 = n2.strokeWidth) : "\\" === this.slope ? [s2, r2, o2, l2] = [0, 0, "100%", "100%"] : [s2, r2, o2, l2] = [0, "100%", "100%", 0];
    const d2 = { name: "svg", children: [{ name: "line", attributes: { xmlns: Uo, x1: s2, y1: r2, x2: o2, y2: l2, style: n2 } }], attributes: { xmlns: Uo, width: c2, height: h2, style: { overflow: "visible" } } };
    return hasMargin(e2) ? HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [d2] }) : (d2.attributes.style.position = "absolute", HTMLResult.success(d2));
  }
}
class Linear extends XFAObject {
  constructor(e2) {
    super(Lo, "linear", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["toRight", "toBottom", "toLeft", "toTop"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.color = null, this.extras = null;
  }
  [to](e2) {
    e2 = e2 ? e2[to]() : "#FFFFFF";
    return `linear-gradient(${this.type.replace(/([RBLT])/, " $1").toLowerCase()}, ${e2}, ${this.color ? this.color[to]() : "#000000"})`;
  }
}
class LockDocument extends ContentObject {
  constructor(e2) {
    super(Lo, "lockDocument"), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
  [tr]() {
    this[Js] = getStringOption(this[Js], ["auto", "0", "1"]);
  }
}
class Manifest extends XFAObject {
  constructor(e2) {
    super(Lo, "manifest", true), this.action = getStringOption(e2.action, ["include", "all", "exclude"]), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.ref = new XFAObjectArray();
  }
}
class Margin extends XFAObject {
  constructor(e2) {
    super(Lo, "margin", true), this.bottomInset = getMeasurement(e2.bottomInset, "0"), this.id = e2.id || "", this.leftInset = getMeasurement(e2.leftInset, "0"), this.rightInset = getMeasurement(e2.rightInset, "0"), this.topInset = getMeasurement(e2.topInset, "0"), this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null;
  }
  [to]() {
    return { margin: measureToString(this.topInset) + " " + measureToString(this.rightInset) + " " + measureToString(this.bottomInset) + " " + measureToString(this.leftInset) };
  }
}
class Mdp extends XFAObject {
  constructor(e2) {
    super(Lo, "mdp"), this.id = e2.id || "", this.permissions = getInteger({ data: e2.permissions, defaultValue: 2, validate: (e3) => 1 === e3 || 3 === e3 }), this.signatureType = getStringOption(e2.signatureType, ["filler", "author"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class Medium extends XFAObject {
  constructor(e2) {
    super(Lo, "medium"), this.id = e2.id || "", this.imagingBBox = (function(e3) {
      const t2 = -1;
      if (!e3) return { x: t2, y: t2, width: t2, height: t2 };
      const i2 = e3.split(",", 4).map((e4) => getMeasurement(e4.trim(), "-1"));
      if (i2.length < 4 || i2[2] < 0 || i2[3] < 0) return { x: t2, y: t2, width: t2, height: t2 };
      const [n2, a2, s2, r2] = i2;
      return { x: n2, y: a2, width: s2, height: r2 };
    })(e2.imagingBBox), this.long = getMeasurement(e2.long), this.orientation = getStringOption(e2.orientation, ["portrait", "landscape"]), this.short = getMeasurement(e2.short), this.stock = e2.stock || "", this.trayIn = getStringOption(e2.trayIn, ["auto", "delegate", "pageFront"]), this.trayOut = getStringOption(e2.trayOut, ["auto", "delegate"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class Message extends XFAObject {
  constructor(e2) {
    super(Lo, "message", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.text = new XFAObjectArray();
  }
}
class NumericEdit extends XFAObject {
  constructor(e2) {
    super(Lo, "numericEdit", true), this.hScrollPolicy = getStringOption(e2.hScrollPolicy, ["auto", "off", "on"]), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
  }
  [Qr](e2) {
    const t2 = toStyle(this, "border", "font", "margin"), i2 = this[mr]()[mr](), n2 = { name: "input", attributes: { type: "text", fieldId: i2[io], dataId: i2[Zs]?.[io] || i2[io], class: ["xfaTextfield"], style: t2, "aria-label": ariaLabel(i2), "aria-required": false } };
    return isRequired(i2) && (n2.attributes["aria-required"] = true, n2.attributes.required = true), HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [n2] });
  }
}
class Occur extends XFAObject {
  constructor(e2) {
    super(Lo, "occur", true), this.id = e2.id || "", this.initial = "" !== e2.initial ? getInteger({ data: e2.initial, defaultValue: "", validate: (e3) => true }) : "", this.max = "" !== e2.max ? getInteger({ data: e2.max, defaultValue: 1, validate: (e3) => true }) : "", this.min = "" !== e2.min ? getInteger({ data: e2.min, defaultValue: 1, validate: (e3) => true }) : "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null;
  }
  [Ws]() {
    const e2 = this[mr](), t2 = this.min;
    "" === this.min && (this.min = e2 instanceof PageArea || e2 instanceof PageSet ? 0 : 1), "" === this.max && (this.max = "" === t2 ? e2 instanceof PageArea || e2 instanceof PageSet ? -1 : 1 : this.min), -1 !== this.max && this.max < this.min && (this.max = this.min), "" === this.initial && (this.initial = e2 instanceof Template ? 1 : this.min);
  }
}
class Oid extends StringObject {
  constructor(e2) {
    super(Lo, "oid"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class Oids extends XFAObject {
  constructor(e2) {
    super(Lo, "oids", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.oid = new XFAObjectArray();
  }
}
class Overflow extends XFAObject {
  constructor(e2) {
    super(Lo, "overflow"), this.id = e2.id || "", this.leader = e2.leader || "", this.target = e2.target || "", this.trailer = e2.trailer || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
  [hr]() {
    if (!this[er]) {
      const e2 = this[mr](), t2 = this[br](), i2 = t2[Wr](this.target, e2), n2 = t2[Wr](this.leader, e2), a2 = t2[Wr](this.trailer, e2);
      this[er] = { target: i2?.[0] || null, leader: n2?.[0] || null, trailer: a2?.[0] || null, addLeader: false, addTrailer: false };
    }
    return this[er];
  }
}
class PageArea extends XFAObject {
  constructor(e2) {
    super(Lo, "pageArea", true), this.blankOrNotBlank = getStringOption(e2.blankOrNotBlank, ["any", "blank", "notBlank"]), this.id = e2.id || "", this.initialNumber = getInteger({ data: e2.initialNumber, defaultValue: 1, validate: (e3) => true }), this.name = e2.name || "", this.numbered = getInteger({ data: e2.numbered, defaultValue: 1, validate: (e3) => true }), this.oddOrEven = getStringOption(e2.oddOrEven, ["any", "even", "odd"]), this.pagePosition = getStringOption(e2.pagePosition, ["any", "first", "last", "only", "rest"]), this.relevant = getRelevant(e2.relevant), this.use = e2.use || "", this.usehref = e2.usehref || "", this.desc = null, this.extras = null, this.medium = null, this.occur = null, this.area = new XFAObjectArray(), this.contentArea = new XFAObjectArray(), this.draw = new XFAObjectArray(), this.exclGroup = new XFAObjectArray(), this.field = new XFAObjectArray(), this.subform = new XFAObjectArray();
  }
  [Dr]() {
    return this[er] ? !this.occur || -1 === this.occur.max || this[er].numberOfUse < this.occur.max : (this[er] = { numberOfUse: 0 }, true);
  }
  [Gs]() {
    delete this[er];
  }
  [fr]() {
    this[er] ||= { numberOfUse: 0 };
    const e2 = this[mr]();
    return "orderedOccurrence" === e2.relation && this[Dr]() ? (this[er].numberOfUse += 1, this) : e2[fr]();
  }
  [sr]() {
    return this[er].space || { width: 0, height: 0 };
  }
  [Qr]() {
    this[er] ||= { numberOfUse: 1 };
    const e2 = [];
    this[er].children = e2;
    const t2 = /* @__PURE__ */ Object.create(null);
    if (this.medium && this.medium.short && this.medium.long) {
      if (t2.width = measureToString(this.medium.short), t2.height = measureToString(this.medium.long), this[er].space = { width: this.medium.short, height: this.medium.long }, "landscape" === this.medium.orientation) {
        const e3 = t2.width;
        t2.width = t2.height, t2.height = e3, this[er].space = { width: this.medium.long, height: this.medium.short };
      }
    } else warn$1("XFA - No medium specified in pageArea: please file a bug.");
    return this[zs]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]), include: true }), this[zs]({ filter: /* @__PURE__ */ new Set(["contentArea"]), include: true }), HTMLResult.success({ name: "div", children: e2, attributes: { class: ["xfaPage"], id: this[io], style: t2, xfaName: this.name } });
  }
}
class PageSet extends XFAObject {
  constructor(e2) {
    super(Lo, "pageSet", true), this.duplexImposition = getStringOption(e2.duplexImposition, ["longEdge", "shortEdge"]), this.id = e2.id || "", this.name = e2.name || "", this.relation = getStringOption(e2.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]), this.relevant = getRelevant(e2.relevant), this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.occur = null, this.pageArea = new XFAObjectArray(), this.pageSet = new XFAObjectArray();
  }
  [Gs]() {
    for (const e2 of this.pageArea.children) e2[Gs]();
    for (const e2 of this.pageSet.children) e2[Gs]();
  }
  [Dr]() {
    return !this.occur || -1 === this.occur.max || this[er].numberOfUse < this.occur.max;
  }
  [fr]() {
    if (this[er] ||= { numberOfUse: 1, pageIndex: -1, pageSetIndex: -1 }, "orderedOccurrence" === this.relation) {
      if (this[er].pageIndex + 1 < this.pageArea.children.length) {
        this[er].pageIndex += 1;
        return this.pageArea.children[this[er].pageIndex][fr]();
      }
      if (this[er].pageSetIndex + 1 < this.pageSet.children.length) return this[er].pageSetIndex += 1, this.pageSet.children[this[er].pageSetIndex][fr]();
      if (this[Dr]()) return this[er].numberOfUse += 1, this[er].pageIndex = -1, this[er].pageSetIndex = -1, this[fr]();
      const e3 = this[mr]();
      return e3 instanceof PageSet ? e3[fr]() : (this[Gs](), this[fr]());
    }
    const e2 = this[br]()[er].pageNumber, t2 = e2 % 2 == 0 ? "even" : "odd", i2 = 0 === e2 ? "first" : "rest";
    let n2 = this.pageArea.children.find((e3) => e3.oddOrEven === t2 && e3.pagePosition === i2);
    return n2 || (n2 = this.pageArea.children.find((e3) => "any" === e3.oddOrEven && e3.pagePosition === i2), n2 || (n2 = this.pageArea.children.find((e3) => "any" === e3.oddOrEven && "any" === e3.pagePosition), n2 || this.pageArea.children[0]));
  }
}
class Para extends XFAObject {
  constructor(e2) {
    super(Lo, "para", true), this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e2.id || "", this.lineHeight = e2.lineHeight ? getMeasurement(e2.lineHeight, "0pt") : "", this.marginLeft = e2.marginLeft ? getMeasurement(e2.marginLeft, "0pt") : "", this.marginRight = e2.marginRight ? getMeasurement(e2.marginRight, "0pt") : "", this.orphans = getInteger({ data: e2.orphans, defaultValue: 0, validate: (e3) => e3 >= 0 }), this.preserve = e2.preserve || "", this.radixOffset = e2.radixOffset ? getMeasurement(e2.radixOffset, "0pt") : "", this.spaceAbove = e2.spaceAbove ? getMeasurement(e2.spaceAbove, "0pt") : "", this.spaceBelow = e2.spaceBelow ? getMeasurement(e2.spaceBelow, "0pt") : "", this.tabDefault = e2.tabDefault ? getMeasurement(this.tabDefault) : "", this.tabStops = (e2.tabStops || "").trim().split(/\s+/).map((e3, t2) => t2 % 2 == 1 ? getMeasurement(e3) : e3), this.textIndent = e2.textIndent ? getMeasurement(e2.textIndent, "0pt") : "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.vAlign = getStringOption(e2.vAlign, ["top", "bottom", "middle"]), this.widows = getInteger({ data: e2.widows, defaultValue: 0, validate: (e3) => e3 >= 0 }), this.hyphenation = null;
  }
  [to]() {
    const e2 = toStyle(this, "hAlign");
    return "" !== this.marginLeft && (e2.paddingLeft = measureToString(this.marginLeft)), "" !== this.marginRight && (e2.paddingRight = measureToString(this.marginRight)), "" !== this.spaceAbove && (e2.paddingTop = measureToString(this.spaceAbove)), "" !== this.spaceBelow && (e2.paddingBottom = measureToString(this.spaceBelow)), "" !== this.textIndent && (e2.textIndent = measureToString(this.textIndent), fixTextIndent(e2)), this.lineHeight > 0 && (e2.lineHeight = measureToString(this.lineHeight)), "" !== this.tabDefault && (e2.tabSize = measureToString(this.tabDefault)), this.tabStops.length, this.hyphenatation && Object.assign(e2, this.hyphenatation[to]()), e2;
  }
}
class PasswordEdit extends XFAObject {
  constructor(e2) {
    super(Lo, "passwordEdit", true), this.hScrollPolicy = getStringOption(e2.hScrollPolicy, ["auto", "off", "on"]), this.id = e2.id || "", this.passwordChar = e2.passwordChar || "*", this.use = e2.use || "", this.usehref = e2.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
}
class template_Pattern extends XFAObject {
  constructor(e2) {
    super(Lo, "pattern", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.color = null, this.extras = null;
  }
  [to](e2) {
    e2 = e2 ? e2[to]() : "#FFFFFF";
    const t2 = this.color ? this.color[to]() : "#000000", i2 = "repeating-linear-gradient", n2 = `${e2},${e2} 5px,${t2} 5px,${t2} 10px`;
    switch (this.type) {
      case "crossHatch":
        return `${i2}(to top,${n2}) ${i2}(to right,${n2})`;
      case "crossDiagonal":
        return `${i2}(45deg,${n2}) ${i2}(-45deg,${n2})`;
      case "diagonalLeft":
        return `${i2}(45deg,${n2})`;
      case "diagonalRight":
        return `${i2}(-45deg,${n2})`;
      case "horizontal":
        return `${i2}(to top,${n2})`;
      case "vertical":
        return `${i2}(to right,${n2})`;
    }
    return "";
  }
}
class Picture extends StringObject {
  constructor(e2) {
    super(Lo, "picture"), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class Proto extends XFAObject {
  constructor(e2) {
    super(Lo, "proto", true), this.appearanceFilter = new XFAObjectArray(), this.arc = new XFAObjectArray(), this.area = new XFAObjectArray(), this.assist = new XFAObjectArray(), this.barcode = new XFAObjectArray(), this.bindItems = new XFAObjectArray(), this.bookend = new XFAObjectArray(), this.boolean = new XFAObjectArray(), this.border = new XFAObjectArray(), this.break = new XFAObjectArray(), this.breakAfter = new XFAObjectArray(), this.breakBefore = new XFAObjectArray(), this.button = new XFAObjectArray(), this.calculate = new XFAObjectArray(), this.caption = new XFAObjectArray(), this.certificate = new XFAObjectArray(), this.certificates = new XFAObjectArray(), this.checkButton = new XFAObjectArray(), this.choiceList = new XFAObjectArray(), this.color = new XFAObjectArray(), this.comb = new XFAObjectArray(), this.connect = new XFAObjectArray(), this.contentArea = new XFAObjectArray(), this.corner = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.dateTimeEdit = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.defaultUi = new XFAObjectArray(), this.desc = new XFAObjectArray(), this.digestMethod = new XFAObjectArray(), this.digestMethods = new XFAObjectArray(), this.draw = new XFAObjectArray(), this.edge = new XFAObjectArray(), this.encoding = new XFAObjectArray(), this.encodings = new XFAObjectArray(), this.encrypt = new XFAObjectArray(), this.encryptData = new XFAObjectArray(), this.encryption = new XFAObjectArray(), this.encryptionMethod = new XFAObjectArray(), this.encryptionMethods = new XFAObjectArray(), this.event = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.exObject = new XFAObjectArray(), this.exclGroup = new XFAObjectArray(), this.execute = new XFAObjectArray(), this.extras = new XFAObjectArray(), this.field = new XFAObjectArray(), this.fill = new XFAObjectArray(), this.filter = new XFAObjectArray(), this.float = new XFAObjectArray(), this.font = new XFAObjectArray(), this.format = new XFAObjectArray(), this.handler = new XFAObjectArray(), this.hyphenation = new XFAObjectArray(), this.image = new XFAObjectArray(), this.imageEdit = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.issuers = new XFAObjectArray(), this.items = new XFAObjectArray(), this.keep = new XFAObjectArray(), this.keyUsage = new XFAObjectArray(), this.line = new XFAObjectArray(), this.linear = new XFAObjectArray(), this.lockDocument = new XFAObjectArray(), this.manifest = new XFAObjectArray(), this.margin = new XFAObjectArray(), this.mdp = new XFAObjectArray(), this.medium = new XFAObjectArray(), this.message = new XFAObjectArray(), this.numericEdit = new XFAObjectArray(), this.occur = new XFAObjectArray(), this.oid = new XFAObjectArray(), this.oids = new XFAObjectArray(), this.overflow = new XFAObjectArray(), this.pageArea = new XFAObjectArray(), this.pageSet = new XFAObjectArray(), this.para = new XFAObjectArray(), this.passwordEdit = new XFAObjectArray(), this.pattern = new XFAObjectArray(), this.picture = new XFAObjectArray(), this.radial = new XFAObjectArray(), this.reason = new XFAObjectArray(), this.reasons = new XFAObjectArray(), this.rectangle = new XFAObjectArray(), this.ref = new XFAObjectArray(), this.script = new XFAObjectArray(), this.setProperty = new XFAObjectArray(), this.signData = new XFAObjectArray(), this.signature = new XFAObjectArray(), this.signing = new XFAObjectArray(), this.solid = new XFAObjectArray(), this.speak = new XFAObjectArray(), this.stipple = new XFAObjectArray(), this.subform = new XFAObjectArray(), this.subformSet = new XFAObjectArray(), this.subjectDN = new XFAObjectArray(), this.subjectDNs = new XFAObjectArray(), this.submit = new XFAObjectArray(), this.text = new XFAObjectArray(), this.textEdit = new XFAObjectArray(), this.time = new XFAObjectArray(), this.timeStamp = new XFAObjectArray(), this.toolTip = new XFAObjectArray(), this.traversal = new XFAObjectArray(), this.traverse = new XFAObjectArray(), this.ui = new XFAObjectArray(), this.validate = new XFAObjectArray(), this.value = new XFAObjectArray(), this.variables = new XFAObjectArray();
  }
}
class Radial extends XFAObject {
  constructor(e2) {
    super(Lo, "radial", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["toEdge", "toCenter"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.color = null, this.extras = null;
  }
  [to](e2) {
    e2 = e2 ? e2[to]() : "#FFFFFF";
    const t2 = this.color ? this.color[to]() : "#000000";
    return `radial-gradient(circle at center, ${"toEdge" === this.type ? `${e2},${t2}` : `${t2},${e2}`})`;
  }
}
class Reason extends StringObject {
  constructor(e2) {
    super(Lo, "reason"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class Reasons extends XFAObject {
  constructor(e2) {
    super(Lo, "reasons", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.reason = new XFAObjectArray();
  }
}
class Rectangle extends XFAObject {
  constructor(e2) {
    super(Lo, "rectangle", true), this.hand = getStringOption(e2.hand, ["even", "left", "right"]), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.corner = new XFAObjectArray(4), this.edge = new XFAObjectArray(4), this.fill = null;
  }
  [Qr]() {
    const e2 = this.edge.children.length ? this.edge.children[0] : new Edge({}), t2 = e2[to](), i2 = /* @__PURE__ */ Object.create(null);
    "visible" === this.fill?.presence ? Object.assign(i2, this.fill[to]()) : i2.fill = "transparent", i2.strokeWidth = measureToString("visible" === e2.presence ? e2.thickness : 0), i2.stroke = t2.color;
    const n2 = (this.corner.children.length ? this.corner.children[0] : new Corner({}))[to](), a2 = { name: "svg", children: [{ name: "rect", attributes: { xmlns: Uo, width: "100%", height: "100%", x: 0, y: 0, rx: n2.radius, ry: n2.radius, style: i2 } }], attributes: { xmlns: Uo, style: { overflow: "visible" }, width: "100%", height: "100%" } };
    return hasMargin(this[mr]()[mr]()) ? HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [a2] }) : (a2.attributes.style.position = "absolute", HTMLResult.success(a2));
  }
}
class RefElement extends StringObject {
  constructor(e2) {
    super(Lo, "ref"), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class Script extends StringObject {
  constructor(e2) {
    super(Lo, "script"), this.binding = e2.binding || "", this.contentType = e2.contentType || "", this.id = e2.id || "", this.name = e2.name || "", this.runAt = getStringOption(e2.runAt, ["client", "both", "server"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class SetProperty extends XFAObject {
  constructor(e2) {
    super(Lo, "setProperty"), this.connection = e2.connection || "", this.ref = e2.ref || "", this.target = e2.target || "";
  }
}
class SignData extends XFAObject {
  constructor(e2) {
    super(Lo, "signData", true), this.id = e2.id || "", this.operation = getStringOption(e2.operation, ["sign", "clear", "verify"]), this.ref = e2.ref || "", this.target = e2.target || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.filter = null, this.manifest = null;
  }
}
class Signature extends XFAObject {
  constructor(e2) {
    super(Lo, "signature", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["PDF1.3", "PDF1.6"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.border = null, this.extras = null, this.filter = null, this.manifest = null, this.margin = null;
  }
}
class Signing extends XFAObject {
  constructor(e2) {
    super(Lo, "signing", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.certificate = new XFAObjectArray();
  }
}
class Solid extends XFAObject {
  constructor(e2) {
    super(Lo, "solid", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null;
  }
  [to](e2) {
    return e2 ? e2[to]() : "#FFFFFF";
  }
}
class Speak extends StringObject {
  constructor(e2) {
    super(Lo, "speak"), this.disable = getInteger({ data: e2.disable, defaultValue: 0, validate: (e3) => 1 === e3 }), this.id = e2.id || "", this.priority = getStringOption(e2.priority, ["custom", "caption", "name", "toolTip"]), this.rid = e2.rid || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class Stipple extends XFAObject {
  constructor(e2) {
    super(Lo, "stipple", true), this.id = e2.id || "", this.rate = getInteger({ data: e2.rate, defaultValue: 50, validate: (e3) => e3 >= 0 && e3 <= 100 }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.color = null, this.extras = null;
  }
  [to](e2) {
    const t2 = this.rate / 100;
    return ai.makeHexColor(Math.round(e2.value.r * (1 - t2) + this.value.r * t2), Math.round(e2.value.g * (1 - t2) + this.value.g * t2), Math.round(e2.value.b * (1 - t2) + this.value.b * t2));
  }
}
class Subform extends XFAObject {
  constructor(e2) {
    super(Lo, "subform", true), this.access = getStringOption(e2.access, ["open", "nonInteractive", "protected", "readOnly"]), this.allowMacro = getInteger({ data: e2.allowMacro, defaultValue: 0, validate: (e3) => 1 === e3 }), this.anchorType = getStringOption(e2.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 }), this.columnWidths = (e2.columnWidths || "").trim().split(/\s+/).map((e3) => "-1" === e3 ? -1 : getMeasurement(e3)), this.h = e2.h ? getMeasurement(e2.h) : "", this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e2.id || "", this.layout = getStringOption(e2.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.locale = e2.locale || "", this.maxH = getMeasurement(e2.maxH, "0pt"), this.maxW = getMeasurement(e2.maxW, "0pt"), this.mergeMode = getStringOption(e2.mergeMode, ["consumeData", "matchTemplate"]), this.minH = getMeasurement(e2.minH, "0pt"), this.minW = getMeasurement(e2.minW, "0pt"), this.name = e2.name || "", this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = getRelevant(e2.relevant), this.restoreState = getStringOption(e2.restoreState, ["manual", "auto"]), this.scope = getStringOption(e2.scope, ["name", "none"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.w = e2.w ? getMeasurement(e2.w) : "", this.x = getMeasurement(e2.x, "0pt"), this.y = getMeasurement(e2.y, "0pt"), this.assist = null, this.bind = null, this.bookend = null, this.border = null, this.break = null, this.calculate = null, this.desc = null, this.extras = null, this.keep = null, this.margin = null, this.occur = null, this.overflow = null, this.pageSet = null, this.para = null, this.traversal = null, this.validate = null, this.variables = null, this.area = new XFAObjectArray(), this.breakAfter = new XFAObjectArray(), this.breakBefore = new XFAObjectArray(), this.connect = new XFAObjectArray(), this.draw = new XFAObjectArray(), this.event = new XFAObjectArray(), this.exObject = new XFAObjectArray(), this.exclGroup = new XFAObjectArray(), this.field = new XFAObjectArray(), this.proto = new XFAObjectArray(), this.setProperty = new XFAObjectArray(), this.subform = new XFAObjectArray(), this.subformSet = new XFAObjectArray();
  }
  [pr]() {
    const e2 = this[mr]();
    return e2 instanceof SubformSet ? e2[pr]() : e2;
  }
  [Cr]() {
    return true;
  }
  [Er]() {
    return this.layout.endsWith("-tb") && 0 === this[er].attempt && this[er].numberInLine > 0 || this[mr]()[Er]();
  }
  *[gr]() {
    yield* getContainedChildren(this);
  }
  [ir]() {
    return flushHTML(this);
  }
  [Xs](e2, t2) {
    addHTML(this, e2, t2);
  }
  [sr]() {
    return getAvailableSpace(this);
  }
  [Ir]() {
    const e2 = this[pr]();
    return !!e2[Ir]() && (void 0 !== this[er]._isSplittable ? this[er]._isSplittable : "position" === this.layout || this.layout.includes("row") || this.keep && "none" !== this.keep.intact ? (this[er]._isSplittable = false, false) : (!e2.layout?.endsWith("-tb") || 0 === e2[er].numberInLine) && (this[er]._isSplittable = true, true));
  }
  [Qr](e2) {
    if (setTabIndex(this), this.break) {
      if ("auto" !== this.break.after || "" !== this.break.afterTarget) {
        const e3 = new BreakAfter({ targetType: this.break.after, target: this.break.afterTarget, startNew: this.break.startNew.toString() });
        e3[yr] = this[yr], this[qs](e3), this.breakAfter.push(e3);
      }
      if ("auto" !== this.break.before || "" !== this.break.beforeTarget) {
        const e3 = new BreakBefore({ targetType: this.break.before, target: this.break.beforeTarget, startNew: this.break.startNew.toString() });
        e3[yr] = this[yr], this[qs](e3), this.breakBefore.push(e3);
      }
      if ("" !== this.break.overflowTarget) {
        const e3 = new Overflow({ target: this.break.overflowTarget, leader: this.break.overflowLeader, trailer: this.break.overflowTrailer });
        e3[yr] = this[yr], this[qs](e3), this.overflow.push(e3);
      }
      this[Xr](this.break), this.break = null;
    }
    if ("hidden" === this.presence || "inactive" === this.presence) return HTMLResult.EMPTY;
    if ((this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && warn$1("XFA - Several breakBefore or breakAfter in subforms: please file a bug."), this.breakBefore.children.length >= 1) {
      const e3 = this.breakBefore.children[0];
      if (handleBreak(e3)) return HTMLResult.breakNode(e3);
    }
    if (this[er]?.afterBreakAfter) return HTMLResult.EMPTY;
    fixDimensions(this);
    const t2 = [], i2 = { id: this[io], class: [] };
    setAccess(this, i2.class), this[er] ||= /* @__PURE__ */ Object.create(null), Object.assign(this[er], { children: t2, line: null, attributes: i2, attempt: 0, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, e2.width), height: Math.min(this.h || 1 / 0, e2.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
    const n2 = this[br](), a2 = n2[er].noLayoutFailure, s2 = this[Ir]();
    if (s2 || setFirstUnsplittable(this), !checkDimensions(this, e2)) return HTMLResult.FAILURE;
    const r2 = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
    if (this.layout.includes("row")) {
      const e3 = this[pr]().columnWidths;
      Array.isArray(e3) && e3.length > 0 && (this[er].columnWidths = e3, this[er].currentColumn = 0);
    }
    const o2 = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), l2 = ["xfaSubform"], c2 = layoutClass(this);
    if (c2 && l2.push(c2), i2.style = o2, i2.class = l2, this.name && (i2.xfaName = this.name), this.overflow) {
      const t3 = this.overflow[hr]();
      t3.addLeader && (t3.addLeader = false, handleOverflow(this, t3.leader, e2));
    }
    this[Hr]();
    const h2 = "lr-tb" === this.layout || "rl-tb" === this.layout, d2 = h2 ? 2 : 1;
    for (; this[er].attempt < d2; this[er].attempt++) {
      h2 && 1 === this[er].attempt && (this[er].numberInLine = 0);
      const e3 = this[zs]({ filter: r2, include: true });
      if (e3.success) break;
      if (e3.isBreak()) return this[$r](), e3;
      if (h2 && 0 === this[er].attempt && 0 === this[er].numberInLine && !n2[er].noLayoutFailure) {
        this[er].attempt = d2;
        break;
      }
    }
    if (this[$r](), s2 || unsetFirstUnsplittable(this), n2[er].noLayoutFailure = a2, this[er].attempt === d2) return this.overflow && (this[br]()[er].overflowNode = this.overflow), s2 || delete this[er], HTMLResult.FAILURE;
    if (this.overflow) {
      const t3 = this.overflow[hr]();
      t3.addTrailer && (t3.addTrailer = false, handleOverflow(this, t3.trailer, e2));
    }
    let u2 = 0, g2 = 0;
    this.margin && (u2 = this.margin.leftInset + this.margin.rightInset, g2 = this.margin.topInset + this.margin.bottomInset);
    const f2 = Math.max(this[er].width + u2, this.w || 0), p2 = Math.max(this[er].height + g2, this.h || 0), m2 = [this.x, this.y, f2, p2];
    if ("" === this.w && (o2.width = measureToString(f2)), "" === this.h && (o2.height = measureToString(p2)), ("0px" === o2.width || "0px" === o2.height) && 0 === t2.length) return HTMLResult.EMPTY;
    const b2 = { name: "div", attributes: i2, children: t2 };
    applyAssist(this, i2);
    const y2 = HTMLResult.success(createWrapper(this, b2), m2);
    if (this.breakAfter.children.length >= 1) {
      const e3 = this.breakAfter.children[0];
      if (handleBreak(e3)) return this[er].afterBreakAfter = y2, HTMLResult.breakNode(e3);
    }
    return delete this[er], y2;
  }
}
class SubformSet extends XFAObject {
  constructor(e2) {
    super(Lo, "subformSet", true), this.id = e2.id || "", this.name = e2.name || "", this.relation = getStringOption(e2.relation, ["ordered", "choice", "unordered"]), this.relevant = getRelevant(e2.relevant), this.use = e2.use || "", this.usehref = e2.usehref || "", this.bookend = null, this.break = null, this.desc = null, this.extras = null, this.occur = null, this.overflow = null, this.breakAfter = new XFAObjectArray(), this.breakBefore = new XFAObjectArray(), this.subform = new XFAObjectArray(), this.subformSet = new XFAObjectArray();
  }
  *[gr]() {
    yield* getContainedChildren(this);
  }
  [pr]() {
    let e2 = this[mr]();
    for (; !(e2 instanceof Subform); ) e2 = e2[mr]();
    return e2;
  }
  [Cr]() {
    return true;
  }
}
class SubjectDN extends ContentObject {
  constructor(e2) {
    super(Lo, "subjectDN"), this.delimiter = e2.delimiter || ",", this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
  [tr]() {
    this[Js] = new Map(this[Js].split(this.delimiter).map((e2) => ((e2 = e2.split("=", 2))[0] = e2[0].trim(), e2)));
  }
}
class SubjectDNs extends XFAObject {
  constructor(e2) {
    super(Lo, "subjectDNs", true), this.id = e2.id || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.subjectDN = new XFAObjectArray();
  }
}
class Submit extends XFAObject {
  constructor(e2) {
    super(Lo, "submit", true), this.embedPDF = getInteger({ data: e2.embedPDF, defaultValue: 0, validate: (e3) => 1 === e3 }), this.format = getStringOption(e2.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]), this.id = e2.id || "", this.target = e2.target || "", this.textEncoding = getKeyword({ data: e2.textEncoding ? e2.textEncoding.toLowerCase() : "", defaultValue: "", validate: (e3) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e3) || e3.match(/iso-8859-\d{2}/) }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.xdpContent = e2.xdpContent || "", this.encrypt = null, this.encryptData = new XFAObjectArray(), this.signData = new XFAObjectArray();
  }
}
class Template extends XFAObject {
  constructor(e2) {
    super(Lo, "template", true), this.baseProfile = getStringOption(e2.baseProfile, ["full", "interactiveForms"]), this.extras = null, this.subform = new XFAObjectArray();
  }
  [tr]() {
    0 === this.subform.children.length && warn$1("XFA - No subforms in template node."), this.subform.children.length >= 2 && warn$1("XFA - Several subforms in template node: please file a bug."), this[Yr] = 5e3;
  }
  [Ir]() {
    return true;
  }
  [Wr](e2, t2) {
    return e2.startsWith("#") ? [this[Ar].get(e2.slice(1))] : searchNode(this, t2, e2, true, true);
  }
  *[Zr]() {
    if (!this.subform.children.length) return HTMLResult.success({ name: "div", children: [] });
    this[er] = { overflowNode: null, firstUnsplittable: null, currentContentArea: null, currentPageArea: null, noLayoutFailure: false, pageNumber: 1, pagePosition: "first", oddOrEven: "odd", blankOrNotBlank: "nonBlank", paraStack: [] };
    const e2 = this.subform.children[0];
    e2.pageSet[Gs]();
    const t2 = e2.pageSet.pageArea.children, i2 = { name: "div", children: [] };
    let n2 = null, a2 = null, s2 = null;
    if (e2.breakBefore.children.length >= 1 ? (a2 = e2.breakBefore.children[0], s2 = a2.target) : e2.subform.children.length >= 1 && e2.subform.children[0].breakBefore.children.length >= 1 ? (a2 = e2.subform.children[0].breakBefore.children[0], s2 = a2.target) : e2.break?.beforeTarget ? (a2 = e2.break, s2 = a2.beforeTarget) : e2.subform.children.length >= 1 && e2.subform.children[0].break?.beforeTarget && (a2 = e2.subform.children[0].break, s2 = a2.beforeTarget), a2) {
      const e3 = this[Wr](s2, a2[mr]());
      e3 instanceof PageArea && (n2 = e3, a2[er] = {});
    }
    n2 ||= t2[0], n2[er] = { numberOfUse: 1 };
    const r2 = n2[mr]();
    let o2;
    r2[er] = { numberOfUse: 1, pageIndex: r2.pageArea.children.indexOf(n2), pageSetIndex: 0 };
    let l2 = null, c2 = null, h2 = true, d2 = 0, u2 = 0;
    for (; ; ) {
      if (h2) d2 = 0;
      else if (i2.children.pop(), 3 === ++d2) return warn$1("XFA - Something goes wrong: please file a bug."), i2;
      o2 = null, this[er].currentPageArea = n2;
      const t3 = n2[Qr]().html;
      i2.children.push(t3), l2 && (this[er].noLayoutFailure = true, t3.children.push(l2[Qr](n2[er].space).html), l2 = null), c2 && (this[er].noLayoutFailure = true, t3.children.push(c2[Qr](n2[er].space).html), c2 = null);
      const a3 = n2.contentArea.children, s3 = t3.children.filter((e3) => e3.attributes.class.includes("xfaContentarea"));
      h2 = false, this[er].firstUnsplittable = null, this[er].noLayoutFailure = false;
      const flush = (t4) => {
        const i3 = e2[ir]();
        i3 && (h2 ||= i3.children?.length > 0, s3[t4].children.push(i3));
      };
      for (let t4 = u2, n3 = a3.length; t4 < n3; t4++) {
        const n4 = this[er].currentContentArea = a3[t4], r3 = { width: n4.w, height: n4.h };
        u2 = 0, l2 && (s3[t4].children.push(l2[Qr](r3).html), l2 = null), c2 && (s3[t4].children.push(c2[Qr](r3).html), c2 = null);
        const d3 = e2[Qr](r3);
        if (d3.success) return d3.html ? (h2 ||= d3.html.children?.length > 0, s3[t4].children.push(d3.html)) : !h2 && i2.children.length > 1 && i2.children.pop(), i2;
        if (d3.isBreak()) {
          const e3 = d3.breakNode;
          if (flush(t4), "auto" === e3.targetType) continue;
          e3.leader && (l2 = this[Wr](e3.leader, e3[mr]()), l2 = l2 ? l2[0] : null), e3.trailer && (c2 = this[Wr](e3.trailer, e3[mr]()), c2 = c2 ? c2[0] : null), "pageArea" === e3.targetType ? (o2 = e3[er].target, t4 = 1 / 0) : e3[er].target ? (o2 = e3[er].target, u2 = e3[er].index + 1, t4 = 1 / 0) : t4 = e3[er].index;
          continue;
        }
        if (this[er].overflowNode) {
          const e3 = this[er].overflowNode;
          this[er].overflowNode = null;
          const i3 = e3[hr](), n5 = i3.target;
          i3.addLeader = null !== i3.leader, i3.addTrailer = null !== i3.trailer, flush(t4);
          const s4 = t4;
          if (t4 = 1 / 0, n5 instanceof PageArea) o2 = n5;
          else if (n5 instanceof ContentArea) {
            const e4 = a3.indexOf(n5);
            -1 !== e4 ? e4 > s4 ? t4 = e4 - 1 : u2 = e4 : (o2 = n5[mr](), u2 = o2.contentArea.children.indexOf(n5));
          }
          continue;
        }
        flush(t4);
      }
      this[er].pageNumber += 1, o2 && (o2[Dr]() ? o2[er].numberOfUse += 1 : o2 = null), n2 = o2 || n2[fr](), yield null;
    }
  }
}
class Text extends ContentObject {
  constructor(e2) {
    super(Lo, "text"), this.id = e2.id || "", this.maxChars = getInteger({ data: e2.maxChars, defaultValue: 0, validate: (e3) => e3 >= 0 }), this.name = e2.name || "", this.rid = e2.rid || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
  [Hs]() {
    return true;
  }
  [Nr](e2) {
    return e2[_r] === ao.xhtml.id ? (this[Js] = e2, true) : (warn$1(`XFA - Invalid content in Text: ${e2[Pr]}.`), false);
  }
  [Ur](e2) {
    this[Js] instanceof XFAObject || super[Ur](e2);
  }
  [tr]() {
    "string" == typeof this[Js] && (this[Js] = this[Js].replaceAll("\r\n", "\n"));
  }
  [hr]() {
    return "string" == typeof this[Js] ? this[Js].split(/[\u2029\u2028\n]/).filter((e2) => !!e2).join("\n") : this[Js][Jr]();
  }
  [Qr](e2) {
    if ("string" == typeof this[Js]) {
      const e3 = valueToHtml(this[Js]).html;
      return this[Js].includes("\u2029") ? (e3.name = "div", e3.children = [], this[Js].split("\u2029").map((e4) => e4.split(/[\u2028\n]/).flatMap((e5) => [{ name: "span", value: e5 }, { name: "br" }])).forEach((t2) => {
        e3.children.push({ name: "p", children: t2 });
      })) : /[\u2028\n]/.test(this[Js]) && (e3.name = "div", e3.children = [], this[Js].split(/[\u2028\n]/).forEach((t2) => {
        e3.children.push({ name: "span", value: t2 }, { name: "br" });
      })), HTMLResult.success(e3);
    }
    return this[Js][Qr](e2);
  }
}
class TextEdit extends XFAObject {
  constructor(e2) {
    super(Lo, "textEdit", true), this.allowRichText = getInteger({ data: e2.allowRichText, defaultValue: 0, validate: (e3) => 1 === e3 }), this.hScrollPolicy = getStringOption(e2.hScrollPolicy, ["auto", "off", "on"]), this.id = e2.id || "", this.multiLine = getInteger({ data: e2.multiLine, defaultValue: "", validate: (e3) => 0 === e3 || 1 === e3 }), this.use = e2.use || "", this.usehref = e2.usehref || "", this.vScrollPolicy = getStringOption(e2.vScrollPolicy, ["auto", "off", "on"]), this.border = null, this.comb = null, this.extras = null, this.margin = null;
  }
  [Qr](e2) {
    const t2 = toStyle(this, "border", "font", "margin");
    let i2;
    const n2 = this[mr]()[mr]();
    return "" === this.multiLine && (this.multiLine = n2 instanceof Draw ? 1 : 0), i2 = 1 === this.multiLine ? { name: "textarea", attributes: { dataId: n2[Zs]?.[io] || n2[io], fieldId: n2[io], class: ["xfaTextfield"], style: t2, "aria-label": ariaLabel(n2), "aria-required": false } } : { name: "input", attributes: { type: "text", dataId: n2[Zs]?.[io] || n2[io], fieldId: n2[io], class: ["xfaTextfield"], style: t2, "aria-label": ariaLabel(n2), "aria-required": false } }, isRequired(n2) && (i2.attributes["aria-required"] = true, i2.attributes.required = true), HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [i2] });
  }
}
class Time extends StringObject {
  constructor(e2) {
    super(Lo, "time"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
  [tr]() {
    const e2 = this[Js].trim();
    this[Js] = e2 ? new Date(e2) : null;
  }
  [Qr](e2) {
    return valueToHtml(this[Js] ? this[Js].toString() : "");
  }
}
class TimeStamp extends XFAObject {
  constructor(e2) {
    super(Lo, "timeStamp"), this.id = e2.id || "", this.server = e2.server || "", this.type = getStringOption(e2.type, ["optional", "required"]), this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class ToolTip extends StringObject {
  constructor(e2) {
    super(Lo, "toolTip"), this.id = e2.id || "", this.rid = e2.rid || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class Traversal extends XFAObject {
  constructor(e2) {
    super(Lo, "traversal", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.traverse = new XFAObjectArray();
  }
}
class Traverse extends XFAObject {
  constructor(e2) {
    super(Lo, "traverse", true), this.id = e2.id || "", this.operation = getStringOption(e2.operation, ["next", "back", "down", "first", "left", "right", "up"]), this.ref = e2.ref || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.script = null;
  }
  get name() {
    return this.operation;
  }
  [Mr]() {
    return false;
  }
}
class Ui extends XFAObject {
  constructor(e2) {
    super(Lo, "ui", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.picture = null, this.barcode = null, this.button = null, this.checkButton = null, this.choiceList = null, this.dateTimeEdit = null, this.defaultUi = null, this.imageEdit = null, this.numericEdit = null, this.passwordEdit = null, this.signature = null, this.textEdit = null;
  }
  [hr]() {
    if (void 0 === this[er]) {
      for (const e2 of Object.getOwnPropertyNames(this)) {
        if ("extras" === e2 || "picture" === e2) continue;
        const t2 = this[e2];
        if (t2 instanceof XFAObject) return this[er] = t2, t2;
      }
      this[er] = null;
    }
    return this[er];
  }
  [Qr](e2) {
    const t2 = this[hr]();
    return t2 ? t2[Qr](e2) : HTMLResult.EMPTY;
  }
}
class Validate extends XFAObject {
  constructor(e2) {
    super(Lo, "validate", true), this.formatTest = getStringOption(e2.formatTest, ["warning", "disabled", "error"]), this.id = e2.id || "", this.nullTest = getStringOption(e2.nullTest, ["disabled", "error", "warning"]), this.scriptTest = getStringOption(e2.scriptTest, ["error", "disabled", "warning"]), this.use = e2.use || "", this.usehref = e2.usehref || "", this.extras = null, this.message = null, this.picture = null, this.script = null;
  }
}
class Value extends XFAObject {
  constructor(e2) {
    super(Lo, "value", true), this.id = e2.id || "", this.override = getInteger({ data: e2.override, defaultValue: 0, validate: (e3) => 1 === e3 }), this.relevant = getRelevant(e2.relevant), this.use = e2.use || "", this.usehref = e2.usehref || "", this.arc = null, this.boolean = null, this.date = null, this.dateTime = null, this.decimal = null, this.exData = null, this.float = null, this.image = null, this.integer = null, this.line = null, this.rectangle = null, this.text = null, this.time = null;
  }
  [Kr](e2) {
    const t2 = this[mr]();
    if (t2 instanceof Field && t2.ui?.imageEdit) return this.image || (this.image = new qo({}), this[qs](this.image)), void (this.image[Js] = e2[Js]);
    const i2 = e2[Pr];
    if (null === this[i2]) {
      for (const e3 of Object.getOwnPropertyNames(this)) {
        const t3 = this[e3];
        t3 instanceof XFAObject && (this[e3] = null, this[Xr](t3));
      }
      this[e2[Pr]] = e2, this[qs](e2);
    } else this[i2][Js] = e2[Js];
  }
  [Jr]() {
    if (this.exData) return "string" == typeof this.exData[Js] ? this.exData[Js].trim() : this.exData[Js][Jr]().trim();
    for (const e2 of Object.getOwnPropertyNames(this)) {
      if ("image" === e2) continue;
      const t2 = this[e2];
      if (t2 instanceof XFAObject) return (t2[Js] || "").toString().trim();
    }
    return null;
  }
  [Qr](e2) {
    for (const t2 of Object.getOwnPropertyNames(this)) {
      const i2 = this[t2];
      if (i2 instanceof XFAObject) return i2[Qr](e2);
    }
    return HTMLResult.EMPTY;
  }
}
class Variables extends XFAObject {
  constructor(e2) {
    super(Lo, "variables", true), this.id = e2.id || "", this.use = e2.use || "", this.usehref = e2.usehref || "", this.boolean = new XFAObjectArray(), this.date = new XFAObjectArray(), this.dateTime = new XFAObjectArray(), this.decimal = new XFAObjectArray(), this.exData = new XFAObjectArray(), this.float = new XFAObjectArray(), this.image = new XFAObjectArray(), this.integer = new XFAObjectArray(), this.manifest = new XFAObjectArray(), this.script = new XFAObjectArray(), this.text = new XFAObjectArray(), this.time = new XFAObjectArray();
  }
  [Mr]() {
    return true;
  }
}
class TemplateNamespace {
  static [no](e2, t2) {
    if (TemplateNamespace.hasOwnProperty(e2)) {
      const i2 = TemplateNamespace[e2](t2);
      return i2[Vr](t2), i2;
    }
  }
  static appearanceFilter(e2) {
    return new AppearanceFilter(e2);
  }
  static arc(e2) {
    return new Arc(e2);
  }
  static area(e2) {
    return new Area(e2);
  }
  static assist(e2) {
    return new Assist(e2);
  }
  static barcode(e2) {
    return new Barcode(e2);
  }
  static bind(e2) {
    return new Bind(e2);
  }
  static bindItems(e2) {
    return new BindItems(e2);
  }
  static bookend(e2) {
    return new Bookend(e2);
  }
  static boolean(e2) {
    return new BooleanElement(e2);
  }
  static border(e2) {
    return new Border(e2);
  }
  static break(e2) {
    return new Break(e2);
  }
  static breakAfter(e2) {
    return new BreakAfter(e2);
  }
  static breakBefore(e2) {
    return new BreakBefore(e2);
  }
  static button(e2) {
    return new Button(e2);
  }
  static calculate(e2) {
    return new Calculate(e2);
  }
  static caption(e2) {
    return new Caption(e2);
  }
  static certificate(e2) {
    return new Certificate(e2);
  }
  static certificates(e2) {
    return new Certificates(e2);
  }
  static checkButton(e2) {
    return new CheckButton(e2);
  }
  static choiceList(e2) {
    return new ChoiceList(e2);
  }
  static color(e2) {
    return new Color(e2);
  }
  static comb(e2) {
    return new Comb(e2);
  }
  static connect(e2) {
    return new Connect(e2);
  }
  static contentArea(e2) {
    return new ContentArea(e2);
  }
  static corner(e2) {
    return new Corner(e2);
  }
  static date(e2) {
    return new DateElement(e2);
  }
  static dateTime(e2) {
    return new DateTime(e2);
  }
  static dateTimeEdit(e2) {
    return new DateTimeEdit(e2);
  }
  static decimal(e2) {
    return new Decimal(e2);
  }
  static defaultUi(e2) {
    return new DefaultUi(e2);
  }
  static desc(e2) {
    return new Desc(e2);
  }
  static digestMethod(e2) {
    return new DigestMethod(e2);
  }
  static digestMethods(e2) {
    return new DigestMethods(e2);
  }
  static draw(e2) {
    return new Draw(e2);
  }
  static edge(e2) {
    return new Edge(e2);
  }
  static encoding(e2) {
    return new Encoding(e2);
  }
  static encodings(e2) {
    return new Encodings(e2);
  }
  static encrypt(e2) {
    return new Encrypt(e2);
  }
  static encryptData(e2) {
    return new EncryptData(e2);
  }
  static encryption(e2) {
    return new Encryption(e2);
  }
  static encryptionMethod(e2) {
    return new EncryptionMethod(e2);
  }
  static encryptionMethods(e2) {
    return new EncryptionMethods(e2);
  }
  static event(e2) {
    return new Xo(e2);
  }
  static exData(e2) {
    return new ExData(e2);
  }
  static exObject(e2) {
    return new ExObject(e2);
  }
  static exclGroup(e2) {
    return new ExclGroup(e2);
  }
  static execute(e2) {
    return new Execute(e2);
  }
  static extras(e2) {
    return new Extras(e2);
  }
  static field(e2) {
    return new Field(e2);
  }
  static fill(e2) {
    return new Fill(e2);
  }
  static filter(e2) {
    return new Filter(e2);
  }
  static float(e2) {
    return new Float(e2);
  }
  static font(e2) {
    return new template_Font(e2);
  }
  static format(e2) {
    return new Format(e2);
  }
  static handler(e2) {
    return new Handler(e2);
  }
  static hyphenation(e2) {
    return new Hyphenation(e2);
  }
  static image(e2) {
    return new qo(e2);
  }
  static imageEdit(e2) {
    return new ImageEdit(e2);
  }
  static integer(e2) {
    return new Integer(e2);
  }
  static issuers(e2) {
    return new Issuers(e2);
  }
  static items(e2) {
    return new Items(e2);
  }
  static keep(e2) {
    return new Keep(e2);
  }
  static keyUsage(e2) {
    return new KeyUsage(e2);
  }
  static line(e2) {
    return new Line(e2);
  }
  static linear(e2) {
    return new Linear(e2);
  }
  static lockDocument(e2) {
    return new LockDocument(e2);
  }
  static manifest(e2) {
    return new Manifest(e2);
  }
  static margin(e2) {
    return new Margin(e2);
  }
  static mdp(e2) {
    return new Mdp(e2);
  }
  static medium(e2) {
    return new Medium(e2);
  }
  static message(e2) {
    return new Message(e2);
  }
  static numericEdit(e2) {
    return new NumericEdit(e2);
  }
  static occur(e2) {
    return new Occur(e2);
  }
  static oid(e2) {
    return new Oid(e2);
  }
  static oids(e2) {
    return new Oids(e2);
  }
  static overflow(e2) {
    return new Overflow(e2);
  }
  static pageArea(e2) {
    return new PageArea(e2);
  }
  static pageSet(e2) {
    return new PageSet(e2);
  }
  static para(e2) {
    return new Para(e2);
  }
  static passwordEdit(e2) {
    return new PasswordEdit(e2);
  }
  static pattern(e2) {
    return new template_Pattern(e2);
  }
  static picture(e2) {
    return new Picture(e2);
  }
  static proto(e2) {
    return new Proto(e2);
  }
  static radial(e2) {
    return new Radial(e2);
  }
  static reason(e2) {
    return new Reason(e2);
  }
  static reasons(e2) {
    return new Reasons(e2);
  }
  static rectangle(e2) {
    return new Rectangle(e2);
  }
  static ref(e2) {
    return new RefElement(e2);
  }
  static script(e2) {
    return new Script(e2);
  }
  static setProperty(e2) {
    return new SetProperty(e2);
  }
  static signData(e2) {
    return new SignData(e2);
  }
  static signature(e2) {
    return new Signature(e2);
  }
  static signing(e2) {
    return new Signing(e2);
  }
  static solid(e2) {
    return new Solid(e2);
  }
  static speak(e2) {
    return new Speak(e2);
  }
  static stipple(e2) {
    return new Stipple(e2);
  }
  static subform(e2) {
    return new Subform(e2);
  }
  static subformSet(e2) {
    return new SubformSet(e2);
  }
  static subjectDN(e2) {
    return new SubjectDN(e2);
  }
  static subjectDNs(e2) {
    return new SubjectDNs(e2);
  }
  static submit(e2) {
    return new Submit(e2);
  }
  static template(e2) {
    return new Template(e2);
  }
  static text(e2) {
    return new Text(e2);
  }
  static textEdit(e2) {
    return new TextEdit(e2);
  }
  static time(e2) {
    return new Time(e2);
  }
  static timeStamp(e2) {
    return new TimeStamp(e2);
  }
  static toolTip(e2) {
    return new ToolTip(e2);
  }
  static traversal(e2) {
    return new Traversal(e2);
  }
  static traverse(e2) {
    return new Traverse(e2);
  }
  static ui(e2) {
    return new Ui(e2);
  }
  static validate(e2) {
    return new Validate(e2);
  }
  static value(e2) {
    return new Value(e2);
  }
  static variables(e2) {
    return new Variables(e2);
  }
}
const zo = ao.datasets.id;
function createText(e2) {
  const t2 = new Text({});
  return t2[Js] = e2, t2;
}
class Binder {
  constructor(e2) {
    this.root = e2, this.datasets = e2.datasets, this.data = e2.datasets?.data || new XmlObject(ao.datasets.id, "data"), this.emptyMerge = 0 === this.data[ur]().length, this.root.form = this.form = e2.template[Ks]();
  }
  _isConsumeData() {
    return !this.emptyMerge && this._mergeMode;
  }
  _isMatchTemplate() {
    return !this._isConsumeData();
  }
  bind() {
    return this._bindElement(this.form, this.data), this.form;
  }
  getData() {
    return this.data;
  }
  _bindValue(e2, t2, i2) {
    if (e2[Zs] = t2, e2[wr]()) if (t2[kr]()) {
      const i3 = t2[cr]();
      e2[Kr](createText(i3));
    } else if (e2 instanceof Field && "multiSelect" === e2.ui?.choiceList?.open) {
      const i3 = t2[ur]().map((e3) => e3[Js].trim()).join("\n");
      e2[Kr](createText(i3));
    } else this._isConsumeData() && warn$1("XFA - Nodes haven't the same type.");
    else !t2[kr]() || this._isMatchTemplate() ? this._bindElement(e2, t2) : warn$1("XFA - Nodes haven't the same type.");
  }
  _findDataByNameToConsume(e2, t2, i2, n2) {
    if (!e2) return null;
    let a2, s2;
    for (let n3 = 0; n3 < 3; n3++) {
      for (a2 = i2[dr](e2, false, true); s2 = a2.next().value, s2; ) if (t2 === s2[kr]()) return s2;
      if (i2[_r] === ao.datasets.id && "data" === i2[Pr]) break;
      i2 = i2[mr]();
    }
    return n2 ? (a2 = this.data[dr](e2, true, false), s2 = a2.next().value, s2 || (a2 = this.data[nr](e2, true), s2 = a2.next().value, s2?.[kr]() ? s2 : null)) : null;
  }
  _setProperties(e2, t2) {
    if (e2.hasOwnProperty("setProperty")) for (const { ref: i2, target: n2, connection: a2 } of e2.setProperty.children) {
      if (a2) continue;
      if (!i2) continue;
      const s2 = searchNode(this.root, t2, i2, false, false);
      if (!s2) {
        warn$1(`XFA - Invalid reference: ${i2}.`);
        continue;
      }
      const [r2] = s2;
      if (!r2[Tr](this.data)) {
        warn$1("XFA - Invalid node: must be a data node.");
        continue;
      }
      const o2 = searchNode(this.root, e2, n2, false, false);
      if (!o2) {
        warn$1(`XFA - Invalid target: ${n2}.`);
        continue;
      }
      const [l2] = o2;
      if (!l2[Tr](e2)) {
        warn$1("XFA - Invalid target: must be a property or subproperty.");
        continue;
      }
      const c2 = l2[mr]();
      if (l2 instanceof SetProperty || c2 instanceof SetProperty) {
        warn$1("XFA - Invalid target: cannot be a setProperty or one of its properties.");
        continue;
      }
      if (l2 instanceof BindItems || c2 instanceof BindItems) {
        warn$1("XFA - Invalid target: cannot be a bindItems or one of its properties.");
        continue;
      }
      const h2 = r2[Jr](), d2 = l2[Pr];
      if (l2 instanceof XFAAttribute) {
        const e3 = /* @__PURE__ */ Object.create(null);
        e3[d2] = h2;
        const t3 = Reflect.construct(Object.getPrototypeOf(c2).constructor, [e3]);
        c2[d2] = t3[d2];
        continue;
      }
      l2.hasOwnProperty(Js) ? (l2[Zs] = r2, l2[Js] = h2, l2[tr]()) : warn$1("XFA - Invalid node to use in setProperty");
    }
  }
  _bindItems(e2, t2) {
    if (!e2.hasOwnProperty("items") || !e2.hasOwnProperty("bindItems") || e2.bindItems.isEmpty()) return;
    for (const t3 of e2.items.children) e2[Xr](t3);
    e2.items.clear();
    const i2 = new Items({}), n2 = new Items({});
    e2[qs](i2), e2.items.push(i2), e2[qs](n2), e2.items.push(n2);
    for (const { ref: a2, labelRef: s2, valueRef: r2, connection: o2 } of e2.bindItems.children) {
      if (o2) continue;
      if (!a2) continue;
      const e3 = searchNode(this.root, t2, a2, false, false);
      if (e3) for (const t3 of e3) {
        if (!t3[Tr](this.datasets)) {
          warn$1(`XFA - Invalid ref (${a2}): must be a datasets child.`);
          continue;
        }
        const e4 = searchNode(this.root, t3, s2, true, false);
        if (!e4) {
          warn$1(`XFA - Invalid label: ${s2}.`);
          continue;
        }
        const [o3] = e4;
        if (!o3[Tr](this.datasets)) {
          warn$1("XFA - Invalid label: must be a datasets child.");
          continue;
        }
        const l2 = searchNode(this.root, t3, r2, true, false);
        if (!l2) {
          warn$1(`XFA - Invalid value: ${r2}.`);
          continue;
        }
        const [c2] = l2;
        if (!c2[Tr](this.datasets)) {
          warn$1("XFA - Invalid value: must be a datasets child.");
          continue;
        }
        const h2 = createText(o3[Jr]()), d2 = createText(c2[Jr]());
        i2[qs](h2), i2.text.push(h2), n2[qs](d2), n2.text.push(d2);
      }
      else warn$1(`XFA - Invalid reference: ${a2}.`);
    }
  }
  _bindOccurrences(e2, t2, i2) {
    let n2;
    if (t2.length > 1 && (n2 = e2[Ks](), n2[Xr](n2.occur), n2.occur = null), this._bindValue(e2, t2[0], i2), this._setProperties(e2, t2[0]), this._bindItems(e2, t2[0]), 1 === t2.length) return;
    const a2 = e2[mr](), s2 = e2[Pr], r2 = a2[xr](e2);
    for (let e3 = 1, o2 = t2.length; e3 < o2; e3++) {
      const o3 = t2[e3], l2 = n2[Ks]();
      a2[s2].push(l2), a2[Sr](r2 + e3, l2), this._bindValue(l2, o3, i2), this._setProperties(l2, o3), this._bindItems(l2, o3);
    }
  }
  _createOccurrences(e2) {
    if (!this.emptyMerge) return;
    const { occur: t2 } = e2;
    if (!t2 || t2.initial <= 1) return;
    const i2 = e2[mr](), n2 = e2[Pr];
    if (!(i2[n2] instanceof XFAObjectArray)) return;
    let a2;
    a2 = e2.name ? i2[n2].children.filter((t3) => t3.name === e2.name).length : i2[n2].children.length;
    const s2 = i2[xr](e2) + 1, r2 = t2.initial - a2;
    if (r2) {
      const t3 = e2[Ks]();
      t3[Xr](t3.occur), t3.occur = null, i2[n2].push(t3), i2[Sr](s2, t3);
      for (let e3 = 1; e3 < r2; e3++) {
        const a3 = t3[Ks]();
        i2[n2].push(a3), i2[Sr](s2 + e3, a3);
      }
    }
  }
  _getOccurInfo(e2) {
    const { name: t2, occur: i2 } = e2;
    if (!i2 || !t2) return [1, 1];
    const n2 = -1 === i2.max ? 1 / 0 : i2.max;
    return [i2.min, n2];
  }
  _setAndBind(e2, t2) {
    this._setProperties(e2, t2), this._bindItems(e2, t2), this._bindElement(e2, t2);
  }
  _bindElement(e2, t2) {
    const i2 = [];
    this._createOccurrences(e2);
    for (const n2 of e2[ur]()) {
      if (n2[Zs]) continue;
      if (void 0 === this._mergeMode && "subform" === n2[Pr]) {
        this._mergeMode = "consumeData" === n2.mergeMode;
        const e4 = t2[ur]();
        if (e4.length > 0) this._bindOccurrences(n2, [e4[0]], null);
        else if (this.emptyMerge) {
          const e5 = t2[_r] === zo ? -1 : t2[_r], i3 = n2[Zs] = new XmlObject(e5, n2.name || "root");
          t2[qs](i3), this._bindElement(n2, i3);
        }
        continue;
      }
      if (!n2[Cr]()) continue;
      let e3 = false, a2 = null, s2 = null, r2 = null;
      if (n2.bind) {
        switch (n2.bind.match) {
          case "none":
            this._setAndBind(n2, t2);
            continue;
          case "global":
            e3 = true;
            break;
          case "dataRef":
            if (!n2.bind.ref) {
              warn$1(`XFA - ref is empty in node ${n2[Pr]}.`), this._setAndBind(n2, t2);
              continue;
            }
            s2 = n2.bind.ref;
        }
        n2.bind.picture && (a2 = n2.bind.picture[Js]);
      }
      const [o2, l2] = this._getOccurInfo(n2);
      if (s2) {
        if (r2 = searchNode(this.root, t2, s2, true, false), null === r2) {
          if (r2 = createDataNode(this.data, t2, s2), !r2) continue;
          this._isConsumeData() && (r2[Ys] = true), this._setAndBind(n2, r2);
          continue;
        }
        this._isConsumeData() && (r2 = r2.filter((e4) => !e4[Ys])), r2.length > l2 ? r2 = r2.slice(0, l2) : 0 === r2.length && (r2 = null), r2 && this._isConsumeData() && r2.forEach((e4) => {
          e4[Ys] = true;
        });
      } else {
        if (!n2.name) {
          this._setAndBind(n2, t2);
          continue;
        }
        if (this._isConsumeData()) {
          const i3 = [];
          for (; i3.length < l2; ) {
            const a3 = this._findDataByNameToConsume(n2.name, n2[wr](), t2, e3);
            if (!a3) break;
            a3[Ys] = true, i3.push(a3);
          }
          r2 = i3.length > 0 ? i3 : null;
        } else {
          if (r2 = t2[dr](n2.name, false, this.emptyMerge).next().value, !r2) {
            if (0 === o2) {
              i2.push(n2);
              continue;
            }
            const e4 = t2[_r] === zo ? -1 : t2[_r];
            r2 = n2[Zs] = new XmlObject(e4, n2.name), this.emptyMerge && (r2[Ys] = true), t2[qs](r2), this._setAndBind(n2, r2);
            continue;
          }
          this.emptyMerge && (r2[Ys] = true), r2 = [r2];
        }
      }
      r2 ? this._bindOccurrences(n2, r2, a2) : o2 > 0 ? this._setAndBind(n2, t2) : i2.push(n2);
    }
    i2.forEach((e3) => e3[mr]()[Xr](e3));
  }
}
class DataHandler {
  constructor(e2, t2) {
    this.data = t2, this.dataset = e2.datasets || null;
  }
  serialize(e2) {
    const t2 = [[-1, this.data[ur]()]];
    for (; t2.length > 0; ) {
      const i3 = t2.at(-1), [n2, a2] = i3;
      if (n2 + 1 === a2.length) {
        t2.pop();
        continue;
      }
      const s2 = a2[++i3[0]], r2 = e2.get(s2[io]);
      if (r2) s2[Kr](r2);
      else {
        const t3 = s2[ar]();
        for (const i4 of t3.values()) {
          const t4 = e2.get(i4[io]);
          if (t4) {
            i4[Kr](t4);
            break;
          }
        }
      }
      const o2 = s2[ur]();
      o2.length > 0 && t2.push([-1, o2]);
    }
    const i2 = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
    if (this.dataset) for (const e3 of this.dataset[ur]()) "data" !== e3[Pr] && e3[eo](i2);
    return this.data[eo](i2), i2.push("</xfa:datasets>"), i2.join("");
  }
}
const Wo = ao.config.id;
class Acrobat extends XFAObject {
  constructor(e2) {
    super(Wo, "acrobat", true), this.acrobat7 = null, this.autoSave = null, this.common = null, this.validate = null, this.validateApprovalSignatures = null, this.submitUrl = new XFAObjectArray();
  }
}
class Acrobat7 extends XFAObject {
  constructor(e2) {
    super(Wo, "acrobat7", true), this.dynamicRender = null;
  }
}
class ADBE_JSConsole extends OptionObject {
  constructor(e2) {
    super(Wo, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
  }
}
class ADBE_JSDebugger extends OptionObject {
  constructor(e2) {
    super(Wo, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
  }
}
class AddSilentPrint extends Option01 {
  constructor(e2) {
    super(Wo, "addSilentPrint");
  }
}
class AddViewerPreferences extends Option01 {
  constructor(e2) {
    super(Wo, "addViewerPreferences");
  }
}
class AdjustData extends Option10 {
  constructor(e2) {
    super(Wo, "adjustData");
  }
}
class AdobeExtensionLevel extends IntegerObject {
  constructor(e2) {
    super(Wo, "adobeExtensionLevel", 0, (e3) => e3 >= 1 && e3 <= 8);
  }
}
class Agent extends XFAObject {
  constructor(e2) {
    super(Wo, "agent", true), this.name = e2.name ? e2.name.trim() : "", this.common = new XFAObjectArray();
  }
}
class AlwaysEmbed extends ContentObject {
  constructor(e2) {
    super(Wo, "alwaysEmbed");
  }
}
class Amd extends StringObject {
  constructor(e2) {
    super(Wo, "amd");
  }
}
class config_Area extends XFAObject {
  constructor(e2) {
    super(Wo, "area"), this.level = getInteger({ data: e2.level, defaultValue: 0, validate: (e3) => e3 >= 1 && e3 <= 3 }), this.name = getStringOption(e2.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
  }
}
class Attributes extends OptionObject {
  constructor(e2) {
    super(Wo, "attributes", ["preserve", "delegate", "ignore"]);
  }
}
class AutoSave extends OptionObject {
  constructor(e2) {
    super(Wo, "autoSave", ["disabled", "enabled"]);
  }
}
class Base extends StringObject {
  constructor(e2) {
    super(Wo, "base");
  }
}
class BatchOutput extends XFAObject {
  constructor(e2) {
    super(Wo, "batchOutput"), this.format = getStringOption(e2.format, ["none", "concat", "zip", "zipCompress"]);
  }
}
class BehaviorOverride extends ContentObject {
  constructor(e2) {
    super(Wo, "behaviorOverride");
  }
  [tr]() {
    this[Js] = new Map(this[Js].trim().split(/\s+/).filter((e2) => e2.includes(":")).map((e2) => e2.split(":", 2)));
  }
}
class Cache extends XFAObject {
  constructor(e2) {
    super(Wo, "cache", true), this.templateCache = null;
  }
}
class Change extends Option01 {
  constructor(e2) {
    super(Wo, "change");
  }
}
class Common extends XFAObject {
  constructor(e2) {
    super(Wo, "common", true), this.data = null, this.locale = null, this.localeSet = null, this.messaging = null, this.suppressBanner = null, this.template = null, this.validationMessaging = null, this.versionControl = null, this.log = new XFAObjectArray();
  }
}
class Compress extends XFAObject {
  constructor(e2) {
    super(Wo, "compress"), this.scope = getStringOption(e2.scope, ["imageOnly", "document"]);
  }
}
class CompressLogicalStructure extends Option01 {
  constructor(e2) {
    super(Wo, "compressLogicalStructure");
  }
}
class CompressObjectStream extends Option10 {
  constructor(e2) {
    super(Wo, "compressObjectStream");
  }
}
class Compression extends XFAObject {
  constructor(e2) {
    super(Wo, "compression", true), this.compressLogicalStructure = null, this.compressObjectStream = null, this.level = null, this.type = null;
  }
}
class Config extends XFAObject {
  constructor(e2) {
    super(Wo, "config", true), this.acrobat = null, this.present = null, this.trace = null, this.agent = new XFAObjectArray();
  }
}
class Conformance extends OptionObject {
  constructor(e2) {
    super(Wo, "conformance", ["A", "B"]);
  }
}
class ContentCopy extends Option01 {
  constructor(e2) {
    super(Wo, "contentCopy");
  }
}
class Copies extends IntegerObject {
  constructor(e2) {
    super(Wo, "copies", 1, (e3) => e3 >= 1);
  }
}
class Creator extends StringObject {
  constructor(e2) {
    super(Wo, "creator");
  }
}
class CurrentPage extends IntegerObject {
  constructor(e2) {
    super(Wo, "currentPage", 0, (e3) => e3 >= 0);
  }
}
class Data extends XFAObject {
  constructor(e2) {
    super(Wo, "data", true), this.adjustData = null, this.attributes = null, this.incrementalLoad = null, this.outputXSL = null, this.range = null, this.record = null, this.startNode = null, this.uri = null, this.window = null, this.xsl = null, this.excludeNS = new XFAObjectArray(), this.transform = new XFAObjectArray();
  }
}
class Debug extends XFAObject {
  constructor(e2) {
    super(Wo, "debug", true), this.uri = null;
  }
}
class DefaultTypeface extends ContentObject {
  constructor(e2) {
    super(Wo, "defaultTypeface"), this.writingScript = getStringOption(e2.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
  }
}
class Destination extends OptionObject {
  constructor(e2) {
    super(Wo, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
  }
}
class DocumentAssembly extends Option01 {
  constructor(e2) {
    super(Wo, "documentAssembly");
  }
}
class Driver extends XFAObject {
  constructor(e2) {
    super(Wo, "driver", true), this.name = e2.name ? e2.name.trim() : "", this.fontInfo = null, this.xdc = null;
  }
}
class DuplexOption extends OptionObject {
  constructor(e2) {
    super(Wo, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
  }
}
class DynamicRender extends OptionObject {
  constructor(e2) {
    super(Wo, "dynamicRender", ["forbidden", "required"]);
  }
}
class Embed extends Option01 {
  constructor(e2) {
    super(Wo, "embed");
  }
}
class config_Encrypt extends Option01 {
  constructor(e2) {
    super(Wo, "encrypt");
  }
}
class config_Encryption extends XFAObject {
  constructor(e2) {
    super(Wo, "encryption", true), this.encrypt = null, this.encryptionLevel = null, this.permissions = null;
  }
}
class EncryptionLevel extends OptionObject {
  constructor(e2) {
    super(Wo, "encryptionLevel", ["40bit", "128bit"]);
  }
}
class Enforce extends StringObject {
  constructor(e2) {
    super(Wo, "enforce");
  }
}
class Equate extends XFAObject {
  constructor(e2) {
    super(Wo, "equate"), this.force = getInteger({ data: e2.force, defaultValue: 1, validate: (e3) => 0 === e3 }), this.from = e2.from || "", this.to = e2.to || "";
  }
}
class EquateRange extends XFAObject {
  constructor(e2) {
    super(Wo, "equateRange"), this.from = e2.from || "", this.to = e2.to || "", this._unicodeRange = e2.unicodeRange || "";
  }
  get unicodeRange() {
    const e2 = [], t2 = /U\+([0-9a-fA-F]+)/, i2 = this._unicodeRange;
    for (let n2 of i2.split(",").map((e3) => e3.trim()).filter((e3) => !!e3)) n2 = n2.split("-", 2).map((e3) => {
      const i3 = e3.match(t2);
      return i3 ? parseInt(i3[1], 16) : 0;
    }), 1 === n2.length && n2.push(n2[0]), e2.push(n2);
    return shadow$1(this, "unicodeRange", e2);
  }
}
class Exclude extends ContentObject {
  constructor(e2) {
    super(Wo, "exclude");
  }
  [tr]() {
    this[Js] = this[Js].trim().split(/\s+/).filter((e2) => e2 && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(e2));
  }
}
class ExcludeNS extends StringObject {
  constructor(e2) {
    super(Wo, "excludeNS");
  }
}
class FlipLabel extends OptionObject {
  constructor(e2) {
    super(Wo, "flipLabel", ["usePrinterSetting", "on", "off"]);
  }
}
class config_FontInfo extends XFAObject {
  constructor(e2) {
    super(Wo, "fontInfo", true), this.embed = null, this.map = null, this.subsetBelow = null, this.alwaysEmbed = new XFAObjectArray(), this.defaultTypeface = new XFAObjectArray(), this.neverEmbed = new XFAObjectArray();
  }
}
class FormFieldFilling extends Option01 {
  constructor(e2) {
    super(Wo, "formFieldFilling");
  }
}
class GroupParent extends StringObject {
  constructor(e2) {
    super(Wo, "groupParent");
  }
}
class IfEmpty extends OptionObject {
  constructor(e2) {
    super(Wo, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
  }
}
class IncludeXDPContent extends StringObject {
  constructor(e2) {
    super(Wo, "includeXDPContent");
  }
}
class IncrementalLoad extends OptionObject {
  constructor(e2) {
    super(Wo, "incrementalLoad", ["none", "forwardOnly"]);
  }
}
class IncrementalMerge extends Option01 {
  constructor(e2) {
    super(Wo, "incrementalMerge");
  }
}
class Interactive extends Option01 {
  constructor(e2) {
    super(Wo, "interactive");
  }
}
class Jog extends OptionObject {
  constructor(e2) {
    super(Wo, "jog", ["usePrinterSetting", "none", "pageSet"]);
  }
}
class LabelPrinter extends XFAObject {
  constructor(e2) {
    super(Wo, "labelPrinter", true), this.name = getStringOption(e2.name, ["zpl", "dpl", "ipl", "tcpl"]), this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
  }
}
class Layout extends OptionObject {
  constructor(e2) {
    super(Wo, "layout", ["paginate", "panel"]);
  }
}
class Level extends IntegerObject {
  constructor(e2) {
    super(Wo, "level", 0, (e3) => e3 > 0);
  }
}
class Linearized extends Option01 {
  constructor(e2) {
    super(Wo, "linearized");
  }
}
class Locale extends StringObject {
  constructor(e2) {
    super(Wo, "locale");
  }
}
class LocaleSet extends StringObject {
  constructor(e2) {
    super(Wo, "localeSet");
  }
}
class Log extends XFAObject {
  constructor(e2) {
    super(Wo, "log", true), this.mode = null, this.threshold = null, this.to = null, this.uri = null;
  }
}
class MapElement extends XFAObject {
  constructor(e2) {
    super(Wo, "map", true), this.equate = new XFAObjectArray(), this.equateRange = new XFAObjectArray();
  }
}
class MediumInfo extends XFAObject {
  constructor(e2) {
    super(Wo, "mediumInfo", true), this.map = null;
  }
}
class config_Message extends XFAObject {
  constructor(e2) {
    super(Wo, "message", true), this.msgId = null, this.severity = null;
  }
}
class Messaging extends XFAObject {
  constructor(e2) {
    super(Wo, "messaging", true), this.message = new XFAObjectArray();
  }
}
class Mode extends OptionObject {
  constructor(e2) {
    super(Wo, "mode", ["append", "overwrite"]);
  }
}
class ModifyAnnots extends Option01 {
  constructor(e2) {
    super(Wo, "modifyAnnots");
  }
}
class MsgId extends IntegerObject {
  constructor(e2) {
    super(Wo, "msgId", 1, (e3) => e3 >= 1);
  }
}
class NameAttr extends StringObject {
  constructor(e2) {
    super(Wo, "nameAttr");
  }
}
class NeverEmbed extends ContentObject {
  constructor(e2) {
    super(Wo, "neverEmbed");
  }
}
class NumberOfCopies extends IntegerObject {
  constructor(e2) {
    super(Wo, "numberOfCopies", null, (e3) => e3 >= 2 && e3 <= 5);
  }
}
class OpenAction extends XFAObject {
  constructor(e2) {
    super(Wo, "openAction", true), this.destination = null;
  }
}
class Output extends XFAObject {
  constructor(e2) {
    super(Wo, "output", true), this.to = null, this.type = null, this.uri = null;
  }
}
class OutputBin extends StringObject {
  constructor(e2) {
    super(Wo, "outputBin");
  }
}
class OutputXSL extends XFAObject {
  constructor(e2) {
    super(Wo, "outputXSL", true), this.uri = null;
  }
}
class Overprint extends OptionObject {
  constructor(e2) {
    super(Wo, "overprint", ["none", "both", "draw", "field"]);
  }
}
class Packets extends StringObject {
  constructor(e2) {
    super(Wo, "packets");
  }
  [tr]() {
    "*" !== this[Js] && (this[Js] = this[Js].trim().split(/\s+/).filter((e2) => ["config", "datasets", "template", "xfdf", "xslt"].includes(e2)));
  }
}
class PageOffset extends XFAObject {
  constructor(e2) {
    super(Wo, "pageOffset"), this.x = getInteger({ data: e2.x, defaultValue: "useXDCSetting", validate: (e3) => true }), this.y = getInteger({ data: e2.y, defaultValue: "useXDCSetting", validate: (e3) => true });
  }
}
class PageRange extends StringObject {
  constructor(e2) {
    super(Wo, "pageRange");
  }
  [tr]() {
    const e2 = this[Js].trim().split(/\s+/).map((e3) => parseInt(e3, 10)), t2 = [];
    for (let i2 = 0, n2 = e2.length; i2 < n2; i2 += 2) t2.push(e2.slice(i2, i2 + 2));
    this[Js] = t2;
  }
}
class Pagination extends OptionObject {
  constructor(e2) {
    super(Wo, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
  }
}
class PaginationOverride extends OptionObject {
  constructor(e2) {
    super(Wo, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
  }
}
class Part extends IntegerObject {
  constructor(e2) {
    super(Wo, "part", 1, (e3) => false);
  }
}
class Pcl extends XFAObject {
  constructor(e2) {
    super(Wo, "pcl", true), this.name = e2.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.pageOffset = null, this.staple = null, this.xdc = null;
  }
}
class Pdf extends XFAObject {
  constructor(e2) {
    super(Wo, "pdf", true), this.name = e2.name || "", this.adobeExtensionLevel = null, this.batchOutput = null, this.compression = null, this.creator = null, this.encryption = null, this.fontInfo = null, this.interactive = null, this.linearized = null, this.openAction = null, this.pdfa = null, this.producer = null, this.renderPolicy = null, this.scriptModel = null, this.silentPrint = null, this.submitFormat = null, this.tagged = null, this.version = null, this.viewerPreferences = null, this.xdc = null;
  }
}
class Pdfa extends XFAObject {
  constructor(e2) {
    super(Wo, "pdfa", true), this.amd = null, this.conformance = null, this.includeXDPContent = null, this.part = null;
  }
}
class Permissions extends XFAObject {
  constructor(e2) {
    super(Wo, "permissions", true), this.accessibleContent = null, this.change = null, this.contentCopy = null, this.documentAssembly = null, this.formFieldFilling = null, this.modifyAnnots = null, this.plaintextMetadata = null, this.print = null, this.printHighQuality = null;
  }
}
class PickTrayByPDFSize extends Option01 {
  constructor(e2) {
    super(Wo, "pickTrayByPDFSize");
  }
}
class config_Picture extends StringObject {
  constructor(e2) {
    super(Wo, "picture");
  }
}
class PlaintextMetadata extends Option01 {
  constructor(e2) {
    super(Wo, "plaintextMetadata");
  }
}
class Presence extends OptionObject {
  constructor(e2) {
    super(Wo, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
  }
}
class Present extends XFAObject {
  constructor(e2) {
    super(Wo, "present", true), this.behaviorOverride = null, this.cache = null, this.common = null, this.copies = null, this.destination = null, this.incrementalMerge = null, this.layout = null, this.output = null, this.overprint = null, this.pagination = null, this.paginationOverride = null, this.script = null, this.validate = null, this.xdp = null, this.driver = new XFAObjectArray(), this.labelPrinter = new XFAObjectArray(), this.pcl = new XFAObjectArray(), this.pdf = new XFAObjectArray(), this.ps = new XFAObjectArray(), this.submitUrl = new XFAObjectArray(), this.webClient = new XFAObjectArray(), this.zpl = new XFAObjectArray();
  }
}
class Print extends Option01 {
  constructor(e2) {
    super(Wo, "print");
  }
}
class PrintHighQuality extends Option01 {
  constructor(e2) {
    super(Wo, "printHighQuality");
  }
}
class PrintScaling extends OptionObject {
  constructor(e2) {
    super(Wo, "printScaling", ["appdefault", "noScaling"]);
  }
}
class PrinterName extends StringObject {
  constructor(e2) {
    super(Wo, "printerName");
  }
}
class Producer extends StringObject {
  constructor(e2) {
    super(Wo, "producer");
  }
}
class Ps extends XFAObject {
  constructor(e2) {
    super(Wo, "ps", true), this.name = e2.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.staple = null, this.xdc = null;
  }
}
let Go = class extends ContentObject {
  constructor(e2) {
    super(Wo, "range");
  }
  [tr]() {
    this[Js] = this[Js].split(",", 2).map((e2) => e2.split("-").map((e3) => parseInt(e3.trim(), 10))).filter((e2) => e2.every((e3) => !isNaN(e3))).map((e2) => (1 === e2.length && e2.push(e2[0]), e2));
  }
};
class Record extends ContentObject {
  constructor(e2) {
    super(Wo, "record");
  }
  [tr]() {
    this[Js] = this[Js].trim();
    const e2 = parseInt(this[Js], 10);
    !isNaN(e2) && e2 >= 0 && (this[Js] = e2);
  }
}
class Relevant extends ContentObject {
  constructor(e2) {
    super(Wo, "relevant");
  }
  [tr]() {
    this[Js] = this[Js].trim().split(/\s+/);
  }
}
class Rename extends ContentObject {
  constructor(e2) {
    super(Wo, "rename");
  }
  [tr]() {
    this[Js] = this[Js].trim(), (this[Js].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[Js])) && warn$1("XFA - Rename: invalid XFA name");
  }
}
class RenderPolicy extends OptionObject {
  constructor(e2) {
    super(Wo, "renderPolicy", ["server", "client"]);
  }
}
class RunScripts extends OptionObject {
  constructor(e2) {
    super(Wo, "runScripts", ["both", "client", "none", "server"]);
  }
}
class config_Script extends XFAObject {
  constructor(e2) {
    super(Wo, "script", true), this.currentPage = null, this.exclude = null, this.runScripts = null;
  }
}
class ScriptModel extends OptionObject {
  constructor(e2) {
    super(Wo, "scriptModel", ["XFA", "none"]);
  }
}
class Severity extends OptionObject {
  constructor(e2) {
    super(Wo, "severity", ["ignore", "error", "information", "trace", "warning"]);
  }
}
class SilentPrint extends XFAObject {
  constructor(e2) {
    super(Wo, "silentPrint", true), this.addSilentPrint = null, this.printerName = null;
  }
}
class Staple extends XFAObject {
  constructor(e2) {
    super(Wo, "staple"), this.mode = getStringOption(e2.mode, ["usePrinterSetting", "on", "off"]);
  }
}
class StartNode extends StringObject {
  constructor(e2) {
    super(Wo, "startNode");
  }
}
class StartPage extends IntegerObject {
  constructor(e2) {
    super(Wo, "startPage", 0, (e3) => true);
  }
}
class SubmitFormat extends OptionObject {
  constructor(e2) {
    super(Wo, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
  }
}
class SubmitUrl extends StringObject {
  constructor(e2) {
    super(Wo, "submitUrl");
  }
}
class SubsetBelow extends IntegerObject {
  constructor(e2) {
    super(Wo, "subsetBelow", 100, (e3) => e3 >= 0 && e3 <= 100);
  }
}
class SuppressBanner extends Option01 {
  constructor(e2) {
    super(Wo, "suppressBanner");
  }
}
class Tagged extends Option01 {
  constructor(e2) {
    super(Wo, "tagged");
  }
}
class config_Template extends XFAObject {
  constructor(e2) {
    super(Wo, "template", true), this.base = null, this.relevant = null, this.startPage = null, this.uri = null, this.xsl = null;
  }
}
class Threshold extends OptionObject {
  constructor(e2) {
    super(Wo, "threshold", ["trace", "error", "information", "warning"]);
  }
}
class To extends OptionObject {
  constructor(e2) {
    super(Wo, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
  }
}
class TemplateCache extends XFAObject {
  constructor(e2) {
    super(Wo, "templateCache"), this.maxEntries = getInteger({ data: e2.maxEntries, defaultValue: 5, validate: (e3) => e3 >= 0 });
  }
}
class Trace extends XFAObject {
  constructor(e2) {
    super(Wo, "trace", true), this.area = new XFAObjectArray();
  }
}
class Transform extends XFAObject {
  constructor(e2) {
    super(Wo, "transform", true), this.groupParent = null, this.ifEmpty = null, this.nameAttr = null, this.picture = null, this.presence = null, this.rename = null, this.whitespace = null;
  }
}
class Type extends OptionObject {
  constructor(e2) {
    super(Wo, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
  }
}
class Uri extends StringObject {
  constructor(e2) {
    super(Wo, "uri");
  }
}
class config_Validate extends OptionObject {
  constructor(e2) {
    super(Wo, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
  }
}
class ValidateApprovalSignatures extends ContentObject {
  constructor(e2) {
    super(Wo, "validateApprovalSignatures");
  }
  [tr]() {
    this[Js] = this[Js].trim().split(/\s+/).filter((e2) => ["docReady", "postSign"].includes(e2));
  }
}
class ValidationMessaging extends OptionObject {
  constructor(e2) {
    super(Wo, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
  }
}
class Version extends OptionObject {
  constructor(e2) {
    super(Wo, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
  }
}
class VersionControl extends XFAObject {
  constructor(e2) {
    super(Wo, "VersionControl"), this.outputBelow = getStringOption(e2.outputBelow, ["warn", "error", "update"]), this.sourceAbove = getStringOption(e2.sourceAbove, ["warn", "error"]), this.sourceBelow = getStringOption(e2.sourceBelow, ["update", "maintain"]);
  }
}
class ViewerPreferences extends XFAObject {
  constructor(e2) {
    super(Wo, "viewerPreferences", true), this.ADBE_JSConsole = null, this.ADBE_JSDebugger = null, this.addViewerPreferences = null, this.duplexOption = null, this.enforce = null, this.numberOfCopies = null, this.pageRange = null, this.pickTrayByPDFSize = null, this.printScaling = null;
  }
}
class WebClient extends XFAObject {
  constructor(e2) {
    super(Wo, "webClient", true), this.name = e2.name ? e2.name.trim() : "", this.fontInfo = null, this.xdc = null;
  }
}
class Whitespace extends OptionObject {
  constructor(e2) {
    super(Wo, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
  }
}
class Window extends ContentObject {
  constructor(e2) {
    super(Wo, "window");
  }
  [tr]() {
    const e2 = this[Js].split(",", 2).map((e3) => parseInt(e3.trim(), 10));
    e2.some((e3) => isNaN(e3)) ? this[Js] = [0, 0] : (1 === e2.length && e2.push(e2[0]), this[Js] = e2);
  }
}
class Xdc extends XFAObject {
  constructor(e2) {
    super(Wo, "xdc", true), this.uri = new XFAObjectArray(), this.xsl = new XFAObjectArray();
  }
}
class Xdp extends XFAObject {
  constructor(e2) {
    super(Wo, "xdp", true), this.packets = null;
  }
}
class Xsl extends XFAObject {
  constructor(e2) {
    super(Wo, "xsl", true), this.debug = null, this.uri = null;
  }
}
class Zpl extends XFAObject {
  constructor(e2) {
    super(Wo, "zpl", true), this.name = e2.name ? e2.name.trim() : "", this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
  }
}
class ConfigNamespace {
  static [no](e2, t2) {
    if (ConfigNamespace.hasOwnProperty(e2)) return ConfigNamespace[e2](t2);
  }
  static acrobat(e2) {
    return new Acrobat(e2);
  }
  static acrobat7(e2) {
    return new Acrobat7(e2);
  }
  static ADBE_JSConsole(e2) {
    return new ADBE_JSConsole(e2);
  }
  static ADBE_JSDebugger(e2) {
    return new ADBE_JSDebugger(e2);
  }
  static addSilentPrint(e2) {
    return new AddSilentPrint(e2);
  }
  static addViewerPreferences(e2) {
    return new AddViewerPreferences(e2);
  }
  static adjustData(e2) {
    return new AdjustData(e2);
  }
  static adobeExtensionLevel(e2) {
    return new AdobeExtensionLevel(e2);
  }
  static agent(e2) {
    return new Agent(e2);
  }
  static alwaysEmbed(e2) {
    return new AlwaysEmbed(e2);
  }
  static amd(e2) {
    return new Amd(e2);
  }
  static area(e2) {
    return new config_Area(e2);
  }
  static attributes(e2) {
    return new Attributes(e2);
  }
  static autoSave(e2) {
    return new AutoSave(e2);
  }
  static base(e2) {
    return new Base(e2);
  }
  static batchOutput(e2) {
    return new BatchOutput(e2);
  }
  static behaviorOverride(e2) {
    return new BehaviorOverride(e2);
  }
  static cache(e2) {
    return new Cache(e2);
  }
  static change(e2) {
    return new Change(e2);
  }
  static common(e2) {
    return new Common(e2);
  }
  static compress(e2) {
    return new Compress(e2);
  }
  static compressLogicalStructure(e2) {
    return new CompressLogicalStructure(e2);
  }
  static compressObjectStream(e2) {
    return new CompressObjectStream(e2);
  }
  static compression(e2) {
    return new Compression(e2);
  }
  static config(e2) {
    return new Config(e2);
  }
  static conformance(e2) {
    return new Conformance(e2);
  }
  static contentCopy(e2) {
    return new ContentCopy(e2);
  }
  static copies(e2) {
    return new Copies(e2);
  }
  static creator(e2) {
    return new Creator(e2);
  }
  static currentPage(e2) {
    return new CurrentPage(e2);
  }
  static data(e2) {
    return new Data(e2);
  }
  static debug(e2) {
    return new Debug(e2);
  }
  static defaultTypeface(e2) {
    return new DefaultTypeface(e2);
  }
  static destination(e2) {
    return new Destination(e2);
  }
  static documentAssembly(e2) {
    return new DocumentAssembly(e2);
  }
  static driver(e2) {
    return new Driver(e2);
  }
  static duplexOption(e2) {
    return new DuplexOption(e2);
  }
  static dynamicRender(e2) {
    return new DynamicRender(e2);
  }
  static embed(e2) {
    return new Embed(e2);
  }
  static encrypt(e2) {
    return new config_Encrypt(e2);
  }
  static encryption(e2) {
    return new config_Encryption(e2);
  }
  static encryptionLevel(e2) {
    return new EncryptionLevel(e2);
  }
  static enforce(e2) {
    return new Enforce(e2);
  }
  static equate(e2) {
    return new Equate(e2);
  }
  static equateRange(e2) {
    return new EquateRange(e2);
  }
  static exclude(e2) {
    return new Exclude(e2);
  }
  static excludeNS(e2) {
    return new ExcludeNS(e2);
  }
  static flipLabel(e2) {
    return new FlipLabel(e2);
  }
  static fontInfo(e2) {
    return new config_FontInfo(e2);
  }
  static formFieldFilling(e2) {
    return new FormFieldFilling(e2);
  }
  static groupParent(e2) {
    return new GroupParent(e2);
  }
  static ifEmpty(e2) {
    return new IfEmpty(e2);
  }
  static includeXDPContent(e2) {
    return new IncludeXDPContent(e2);
  }
  static incrementalLoad(e2) {
    return new IncrementalLoad(e2);
  }
  static incrementalMerge(e2) {
    return new IncrementalMerge(e2);
  }
  static interactive(e2) {
    return new Interactive(e2);
  }
  static jog(e2) {
    return new Jog(e2);
  }
  static labelPrinter(e2) {
    return new LabelPrinter(e2);
  }
  static layout(e2) {
    return new Layout(e2);
  }
  static level(e2) {
    return new Level(e2);
  }
  static linearized(e2) {
    return new Linearized(e2);
  }
  static locale(e2) {
    return new Locale(e2);
  }
  static localeSet(e2) {
    return new LocaleSet(e2);
  }
  static log(e2) {
    return new Log(e2);
  }
  static map(e2) {
    return new MapElement(e2);
  }
  static mediumInfo(e2) {
    return new MediumInfo(e2);
  }
  static message(e2) {
    return new config_Message(e2);
  }
  static messaging(e2) {
    return new Messaging(e2);
  }
  static mode(e2) {
    return new Mode(e2);
  }
  static modifyAnnots(e2) {
    return new ModifyAnnots(e2);
  }
  static msgId(e2) {
    return new MsgId(e2);
  }
  static nameAttr(e2) {
    return new NameAttr(e2);
  }
  static neverEmbed(e2) {
    return new NeverEmbed(e2);
  }
  static numberOfCopies(e2) {
    return new NumberOfCopies(e2);
  }
  static openAction(e2) {
    return new OpenAction(e2);
  }
  static output(e2) {
    return new Output(e2);
  }
  static outputBin(e2) {
    return new OutputBin(e2);
  }
  static outputXSL(e2) {
    return new OutputXSL(e2);
  }
  static overprint(e2) {
    return new Overprint(e2);
  }
  static packets(e2) {
    return new Packets(e2);
  }
  static pageOffset(e2) {
    return new PageOffset(e2);
  }
  static pageRange(e2) {
    return new PageRange(e2);
  }
  static pagination(e2) {
    return new Pagination(e2);
  }
  static paginationOverride(e2) {
    return new PaginationOverride(e2);
  }
  static part(e2) {
    return new Part(e2);
  }
  static pcl(e2) {
    return new Pcl(e2);
  }
  static pdf(e2) {
    return new Pdf(e2);
  }
  static pdfa(e2) {
    return new Pdfa(e2);
  }
  static permissions(e2) {
    return new Permissions(e2);
  }
  static pickTrayByPDFSize(e2) {
    return new PickTrayByPDFSize(e2);
  }
  static picture(e2) {
    return new config_Picture(e2);
  }
  static plaintextMetadata(e2) {
    return new PlaintextMetadata(e2);
  }
  static presence(e2) {
    return new Presence(e2);
  }
  static present(e2) {
    return new Present(e2);
  }
  static print(e2) {
    return new Print(e2);
  }
  static printHighQuality(e2) {
    return new PrintHighQuality(e2);
  }
  static printScaling(e2) {
    return new PrintScaling(e2);
  }
  static printerName(e2) {
    return new PrinterName(e2);
  }
  static producer(e2) {
    return new Producer(e2);
  }
  static ps(e2) {
    return new Ps(e2);
  }
  static range(e2) {
    return new Go(e2);
  }
  static record(e2) {
    return new Record(e2);
  }
  static relevant(e2) {
    return new Relevant(e2);
  }
  static rename(e2) {
    return new Rename(e2);
  }
  static renderPolicy(e2) {
    return new RenderPolicy(e2);
  }
  static runScripts(e2) {
    return new RunScripts(e2);
  }
  static script(e2) {
    return new config_Script(e2);
  }
  static scriptModel(e2) {
    return new ScriptModel(e2);
  }
  static severity(e2) {
    return new Severity(e2);
  }
  static silentPrint(e2) {
    return new SilentPrint(e2);
  }
  static staple(e2) {
    return new Staple(e2);
  }
  static startNode(e2) {
    return new StartNode(e2);
  }
  static startPage(e2) {
    return new StartPage(e2);
  }
  static submitFormat(e2) {
    return new SubmitFormat(e2);
  }
  static submitUrl(e2) {
    return new SubmitUrl(e2);
  }
  static subsetBelow(e2) {
    return new SubsetBelow(e2);
  }
  static suppressBanner(e2) {
    return new SuppressBanner(e2);
  }
  static tagged(e2) {
    return new Tagged(e2);
  }
  static template(e2) {
    return new config_Template(e2);
  }
  static templateCache(e2) {
    return new TemplateCache(e2);
  }
  static threshold(e2) {
    return new Threshold(e2);
  }
  static to(e2) {
    return new To(e2);
  }
  static trace(e2) {
    return new Trace(e2);
  }
  static transform(e2) {
    return new Transform(e2);
  }
  static type(e2) {
    return new Type(e2);
  }
  static uri(e2) {
    return new Uri(e2);
  }
  static validate(e2) {
    return new config_Validate(e2);
  }
  static validateApprovalSignatures(e2) {
    return new ValidateApprovalSignatures(e2);
  }
  static validationMessaging(e2) {
    return new ValidationMessaging(e2);
  }
  static version(e2) {
    return new Version(e2);
  }
  static versionControl(e2) {
    return new VersionControl(e2);
  }
  static viewerPreferences(e2) {
    return new ViewerPreferences(e2);
  }
  static webClient(e2) {
    return new WebClient(e2);
  }
  static whitespace(e2) {
    return new Whitespace(e2);
  }
  static window(e2) {
    return new Window(e2);
  }
  static xdc(e2) {
    return new Xdc(e2);
  }
  static xdp(e2) {
    return new Xdp(e2);
  }
  static xsl(e2) {
    return new Xsl(e2);
  }
  static zpl(e2) {
    return new Zpl(e2);
  }
}
const Vo = ao.connectionSet.id;
class ConnectionSet extends XFAObject {
  constructor(e2) {
    super(Vo, "connectionSet", true), this.wsdlConnection = new XFAObjectArray(), this.xmlConnection = new XFAObjectArray(), this.xsdConnection = new XFAObjectArray();
  }
}
class EffectiveInputPolicy extends XFAObject {
  constructor(e2) {
    super(Vo, "effectiveInputPolicy"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class EffectiveOutputPolicy extends XFAObject {
  constructor(e2) {
    super(Vo, "effectiveOutputPolicy"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class Operation extends StringObject {
  constructor(e2) {
    super(Vo, "operation"), this.id = e2.id || "", this.input = e2.input || "", this.name = e2.name || "", this.output = e2.output || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class RootElement extends StringObject {
  constructor(e2) {
    super(Vo, "rootElement"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class SoapAction extends StringObject {
  constructor(e2) {
    super(Vo, "soapAction"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class SoapAddress extends StringObject {
  constructor(e2) {
    super(Vo, "soapAddress"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class connection_set_Uri extends StringObject {
  constructor(e2) {
    super(Vo, "uri"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class WsdlAddress extends StringObject {
  constructor(e2) {
    super(Vo, "wsdlAddress"), this.id = e2.id || "", this.name = e2.name || "", this.use = e2.use || "", this.usehref = e2.usehref || "";
  }
}
class WsdlConnection extends XFAObject {
  constructor(e2) {
    super(Vo, "wsdlConnection", true), this.dataDescription = e2.dataDescription || "", this.name = e2.name || "", this.effectiveInputPolicy = null, this.effectiveOutputPolicy = null, this.operation = null, this.soapAction = null, this.soapAddress = null, this.wsdlAddress = null;
  }
}
class XmlConnection extends XFAObject {
  constructor(e2) {
    super(Vo, "xmlConnection", true), this.dataDescription = e2.dataDescription || "", this.name = e2.name || "", this.uri = null;
  }
}
class XsdConnection extends XFAObject {
  constructor(e2) {
    super(Vo, "xsdConnection", true), this.dataDescription = e2.dataDescription || "", this.name = e2.name || "", this.rootElement = null, this.uri = null;
  }
}
class ConnectionSetNamespace {
  static [no](e2, t2) {
    if (ConnectionSetNamespace.hasOwnProperty(e2)) return ConnectionSetNamespace[e2](t2);
  }
  static connectionSet(e2) {
    return new ConnectionSet(e2);
  }
  static effectiveInputPolicy(e2) {
    return new EffectiveInputPolicy(e2);
  }
  static effectiveOutputPolicy(e2) {
    return new EffectiveOutputPolicy(e2);
  }
  static operation(e2) {
    return new Operation(e2);
  }
  static rootElement(e2) {
    return new RootElement(e2);
  }
  static soapAction(e2) {
    return new SoapAction(e2);
  }
  static soapAddress(e2) {
    return new SoapAddress(e2);
  }
  static uri(e2) {
    return new connection_set_Uri(e2);
  }
  static wsdlAddress(e2) {
    return new WsdlAddress(e2);
  }
  static wsdlConnection(e2) {
    return new WsdlConnection(e2);
  }
  static xmlConnection(e2) {
    return new XmlConnection(e2);
  }
  static xsdConnection(e2) {
    return new XsdConnection(e2);
  }
}
const Ko = ao.datasets.id;
class datasets_Data extends XmlObject {
  constructor(e2) {
    super(Ko, "data", e2);
  }
  [Fr]() {
    return true;
  }
}
class Datasets extends XFAObject {
  constructor(e2) {
    super(Ko, "datasets", true), this.data = null, this.Signature = null;
  }
  [Nr](e2) {
    const t2 = e2[Pr];
    ("data" === t2 && e2[_r] === Ko || "Signature" === t2 && e2[_r] === ao.signature.id) && (this[t2] = e2), this[qs](e2);
  }
}
class DatasetsNamespace {
  static [no](e2, t2) {
    if (DatasetsNamespace.hasOwnProperty(e2)) return DatasetsNamespace[e2](t2);
  }
  static datasets(e2) {
    return new Datasets(e2);
  }
  static data(e2) {
    return new datasets_Data(e2);
  }
}
const Yo = ao.localeSet.id;
class CalendarSymbols extends XFAObject {
  constructor(e2) {
    super(Yo, "calendarSymbols", true), this.name = "gregorian", this.dayNames = new XFAObjectArray(2), this.eraNames = null, this.meridiemNames = null, this.monthNames = new XFAObjectArray(2);
  }
}
class CurrencySymbol extends StringObject {
  constructor(e2) {
    super(Yo, "currencySymbol"), this.name = getStringOption(e2.name, ["symbol", "isoname", "decimal"]);
  }
}
class CurrencySymbols extends XFAObject {
  constructor(e2) {
    super(Yo, "currencySymbols", true), this.currencySymbol = new XFAObjectArray(3);
  }
}
class DatePattern extends StringObject {
  constructor(e2) {
    super(Yo, "datePattern"), this.name = getStringOption(e2.name, ["full", "long", "med", "short"]);
  }
}
class DatePatterns extends XFAObject {
  constructor(e2) {
    super(Yo, "datePatterns", true), this.datePattern = new XFAObjectArray(4);
  }
}
class DateTimeSymbols extends ContentObject {
  constructor(e2) {
    super(Yo, "dateTimeSymbols");
  }
}
class Day extends StringObject {
  constructor(e2) {
    super(Yo, "day");
  }
}
class DayNames extends XFAObject {
  constructor(e2) {
    super(Yo, "dayNames", true), this.abbr = getInteger({ data: e2.abbr, defaultValue: 0, validate: (e3) => 1 === e3 }), this.day = new XFAObjectArray(7);
  }
}
class Era extends StringObject {
  constructor(e2) {
    super(Yo, "era");
  }
}
class EraNames extends XFAObject {
  constructor(e2) {
    super(Yo, "eraNames", true), this.era = new XFAObjectArray(2);
  }
}
class locale_set_Locale extends XFAObject {
  constructor(e2) {
    super(Yo, "locale", true), this.desc = e2.desc || "", this.name = "isoname", this.calendarSymbols = null, this.currencySymbols = null, this.datePatterns = null, this.dateTimeSymbols = null, this.numberPatterns = null, this.numberSymbols = null, this.timePatterns = null, this.typeFaces = null;
  }
}
class locale_set_LocaleSet extends XFAObject {
  constructor(e2) {
    super(Yo, "localeSet", true), this.locale = new XFAObjectArray();
  }
}
class Meridiem extends StringObject {
  constructor(e2) {
    super(Yo, "meridiem");
  }
}
class MeridiemNames extends XFAObject {
  constructor(e2) {
    super(Yo, "meridiemNames", true), this.meridiem = new XFAObjectArray(2);
  }
}
class Month extends StringObject {
  constructor(e2) {
    super(Yo, "month");
  }
}
class MonthNames extends XFAObject {
  constructor(e2) {
    super(Yo, "monthNames", true), this.abbr = getInteger({ data: e2.abbr, defaultValue: 0, validate: (e3) => 1 === e3 }), this.month = new XFAObjectArray(12);
  }
}
class NumberPattern extends StringObject {
  constructor(e2) {
    super(Yo, "numberPattern"), this.name = getStringOption(e2.name, ["full", "long", "med", "short"]);
  }
}
class NumberPatterns extends XFAObject {
  constructor(e2) {
    super(Yo, "numberPatterns", true), this.numberPattern = new XFAObjectArray(4);
  }
}
class NumberSymbol extends StringObject {
  constructor(e2) {
    super(Yo, "numberSymbol"), this.name = getStringOption(e2.name, ["decimal", "grouping", "percent", "minus", "zero"]);
  }
}
class NumberSymbols extends XFAObject {
  constructor(e2) {
    super(Yo, "numberSymbols", true), this.numberSymbol = new XFAObjectArray(5);
  }
}
class TimePattern extends StringObject {
  constructor(e2) {
    super(Yo, "timePattern"), this.name = getStringOption(e2.name, ["full", "long", "med", "short"]);
  }
}
class TimePatterns extends XFAObject {
  constructor(e2) {
    super(Yo, "timePatterns", true), this.timePattern = new XFAObjectArray(4);
  }
}
class TypeFace extends XFAObject {
  constructor(e2) {
    super(Yo, "typeFace", true), this.name = "" | e2.name;
  }
}
class TypeFaces extends XFAObject {
  constructor(e2) {
    super(Yo, "typeFaces", true), this.typeFace = new XFAObjectArray();
  }
}
class LocaleSetNamespace {
  static [no](e2, t2) {
    if (LocaleSetNamespace.hasOwnProperty(e2)) return LocaleSetNamespace[e2](t2);
  }
  static calendarSymbols(e2) {
    return new CalendarSymbols(e2);
  }
  static currencySymbol(e2) {
    return new CurrencySymbol(e2);
  }
  static currencySymbols(e2) {
    return new CurrencySymbols(e2);
  }
  static datePattern(e2) {
    return new DatePattern(e2);
  }
  static datePatterns(e2) {
    return new DatePatterns(e2);
  }
  static dateTimeSymbols(e2) {
    return new DateTimeSymbols(e2);
  }
  static day(e2) {
    return new Day(e2);
  }
  static dayNames(e2) {
    return new DayNames(e2);
  }
  static era(e2) {
    return new Era(e2);
  }
  static eraNames(e2) {
    return new EraNames(e2);
  }
  static locale(e2) {
    return new locale_set_Locale(e2);
  }
  static localeSet(e2) {
    return new locale_set_LocaleSet(e2);
  }
  static meridiem(e2) {
    return new Meridiem(e2);
  }
  static meridiemNames(e2) {
    return new MeridiemNames(e2);
  }
  static month(e2) {
    return new Month(e2);
  }
  static monthNames(e2) {
    return new MonthNames(e2);
  }
  static numberPattern(e2) {
    return new NumberPattern(e2);
  }
  static numberPatterns(e2) {
    return new NumberPatterns(e2);
  }
  static numberSymbol(e2) {
    return new NumberSymbol(e2);
  }
  static numberSymbols(e2) {
    return new NumberSymbols(e2);
  }
  static timePattern(e2) {
    return new TimePattern(e2);
  }
  static timePatterns(e2) {
    return new TimePatterns(e2);
  }
  static typeFace(e2) {
    return new TypeFace(e2);
  }
  static typeFaces(e2) {
    return new TypeFaces(e2);
  }
}
const Jo = ao.signature.id;
class signature_Signature extends XFAObject {
  constructor(e2) {
    super(Jo, "signature", true);
  }
}
class SignatureNamespace {
  static [no](e2, t2) {
    if (SignatureNamespace.hasOwnProperty(e2)) return SignatureNamespace[e2](t2);
  }
  static signature(e2) {
    return new signature_Signature(e2);
  }
}
const Zo = ao.stylesheet.id;
class Stylesheet extends XFAObject {
  constructor(e2) {
    super(Zo, "stylesheet", true);
  }
}
class StylesheetNamespace {
  static [no](e2, t2) {
    if (StylesheetNamespace.hasOwnProperty(e2)) return StylesheetNamespace[e2](t2);
  }
  static stylesheet(e2) {
    return new Stylesheet(e2);
  }
}
const Qo = ao.xdp.id;
class xdp_Xdp extends XFAObject {
  constructor(e2) {
    super(Qo, "xdp", true), this.uuid = e2.uuid || "", this.timeStamp = e2.timeStamp || "", this.config = null, this.connectionSet = null, this.datasets = null, this.localeSet = null, this.stylesheet = new XFAObjectArray(), this.template = null;
  }
  [Lr](e2) {
    const t2 = ao[e2[Pr]];
    return t2 && e2[_r] === t2.id;
  }
}
class XdpNamespace {
  static [no](e2, t2) {
    if (XdpNamespace.hasOwnProperty(e2)) return XdpNamespace[e2](t2);
  }
  static xdp(e2) {
    return new xdp_Xdp(e2);
  }
}
const el = ao.xhtml.id, tl = Symbol(), il = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]), nl = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (e2) => "none" === e2 ? "none" : "normal"], ["xfa-font-horizontal-scale", (e2) => `scaleX(${Math.max(0, parseInt(e2) / 100).toFixed(2)})`], ["xfa-font-vertical-scale", (e2) => `scaleY(${Math.max(0, parseInt(e2) / 100).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (e2, t2) => measureToString(0.99 * (e2 = t2.fontSize = Math.abs(getMeasurement(e2))))], ["letter-spacing", (e2) => measureToString(getMeasurement(e2))], ["line-height", (e2) => measureToString(getMeasurement(e2))], ["margin", (e2) => measureToString(getMeasurement(e2))], ["margin-bottom", (e2) => measureToString(getMeasurement(e2))], ["margin-left", (e2) => measureToString(getMeasurement(e2))], ["margin-right", (e2) => measureToString(getMeasurement(e2))], ["margin-top", (e2) => measureToString(getMeasurement(e2))], ["text-indent", (e2) => measureToString(getMeasurement(e2))], ["font-family", (e2) => e2], ["vertical-align", (e2) => measureToString(getMeasurement(e2))]]), al = /\s+/g, sl = /[\r\n]+/g, rl = /\r\n?/g;
function mapStyle(e2, t2, i2) {
  const n2 = /* @__PURE__ */ Object.create(null);
  if (!e2) return n2;
  const a2 = /* @__PURE__ */ Object.create(null);
  for (const [t3, i3] of e2.split(";").map((e3) => e3.split(":", 2))) {
    const e3 = nl.get(t3);
    if ("" === e3) continue;
    let s2 = i3;
    e3 && (s2 = "string" == typeof e3 ? e3 : e3(i3, a2)), t3.endsWith("scale") ? n2.transform = n2.transform ? `${n2[t3]} ${s2}` : s2 : n2[t3.replaceAll(/-([a-zA-Z])/g, (e4, t4) => t4.toUpperCase())] = s2;
  }
  if (n2.fontFamily && setFontFamily({ typeface: n2.fontFamily, weight: n2.fontWeight || "normal", posture: n2.fontStyle || "normal", size: a2.fontSize || 0 }, t2, t2[yr].fontFinder, n2), i2 && n2.verticalAlign && "0px" !== n2.verticalAlign && n2.fontSize) {
    const e3 = 0.583, t3 = 0.333, i3 = getMeasurement(n2.fontSize);
    n2.fontSize = measureToString(i3 * e3), n2.verticalAlign = measureToString(Math.sign(getMeasurement(n2.verticalAlign)) * i3 * t3);
  }
  return i2 && n2.fontSize && (n2.fontSize = `calc(${n2.fontSize} * var(--total-scale-factor))`), fixTextIndent(n2), n2;
}
const ol = /* @__PURE__ */ new Set(["body", "html"]);
class XhtmlObject extends XmlObject {
  constructor(e2, t2) {
    super(el, t2), this[tl] = false, this.style = e2.style || "";
  }
  [Ws](e2) {
    var t2;
    super[Ws](e2), this.style = (t2 = this).style ? t2.style.split(";").filter((e3) => !!e3.trim()).map((e3) => e3.split(":", 2).map((e4) => e4.trim())).filter(([e3, i2]) => ("font-family" === e3 && t2[yr].usedTypefaces.add(i2), il.has(e3))).map((e3) => e3.join(":")).join(";") : "";
  }
  [Hs]() {
    return !ol.has(this[Pr]);
  }
  [Ur](e2, t2 = false) {
    t2 ? this[tl] = true : (e2 = e2.replaceAll(sl, ""), this.style.includes("xfa-spacerun:yes") || (e2 = e2.replaceAll(al, " "))), e2 && (this[Js] += e2);
  }
  [jr](e2, t2 = true) {
    const i2 = /* @__PURE__ */ Object.create(null), n2 = { top: NaN, bottom: NaN, left: NaN, right: NaN };
    let a2 = null;
    for (const [e3, t3] of this.style.split(";").map((e4) => e4.split(":", 2))) switch (e3) {
      case "font-family":
        i2.typeface = stripQuotes(t3);
        break;
      case "font-size":
        i2.size = getMeasurement(t3);
        break;
      case "font-weight":
        i2.weight = t3;
        break;
      case "font-style":
        i2.posture = t3;
        break;
      case "letter-spacing":
        i2.letterSpacing = getMeasurement(t3);
        break;
      case "margin":
        const e4 = t3.split(/ \t/).map((e5) => getMeasurement(e5));
        switch (e4.length) {
          case 1:
            n2.top = n2.bottom = n2.left = n2.right = e4[0];
            break;
          case 2:
            n2.top = n2.bottom = e4[0], n2.left = n2.right = e4[1];
            break;
          case 3:
            n2.top = e4[0], n2.bottom = e4[2], n2.left = n2.right = e4[1];
            break;
          case 4:
            n2.top = e4[0], n2.left = e4[1], n2.bottom = e4[2], n2.right = e4[3];
        }
        break;
      case "margin-top":
        n2.top = getMeasurement(t3);
        break;
      case "margin-bottom":
        n2.bottom = getMeasurement(t3);
        break;
      case "margin-left":
        n2.left = getMeasurement(t3);
        break;
      case "margin-right":
        n2.right = getMeasurement(t3);
        break;
      case "line-height":
        a2 = getMeasurement(t3);
    }
    if (e2.pushData(i2, n2, a2), this[Js]) e2.addString(this[Js]);
    else for (const t3 of this[ur]()) "#text" !== t3[Pr] ? t3[jr](e2) : e2.addString(t3[Js]);
    t2 && e2.popFont();
  }
  [Qr](e2) {
    const t2 = [];
    if (this[er] = { children: t2 }, this[zs]({}), 0 === t2.length && !this[Js]) return HTMLResult.EMPTY;
    let i2;
    return i2 = this[tl] ? this[Js] ? this[Js].replaceAll(rl, "\n") : void 0 : this[Js] || void 0, HTMLResult.success({ name: this[Pr], attributes: { href: this.href, style: mapStyle(this.style, this, this[tl]) }, children: t2, value: i2 });
  }
}
class A extends XhtmlObject {
  constructor(e2) {
    super(e2, "a"), this.href = fixURL(e2.href) || "";
  }
}
class B extends XhtmlObject {
  constructor(e2) {
    super(e2, "b");
  }
  [jr](e2) {
    e2.pushFont({ weight: "bold" }), super[jr](e2), e2.popFont();
  }
}
class Body extends XhtmlObject {
  constructor(e2) {
    super(e2, "body");
  }
  [Qr](e2) {
    const t2 = super[Qr](e2), { html: i2 } = t2;
    return i2 ? (i2.name = "div", i2.attributes.class = ["xfaRich"], t2) : HTMLResult.EMPTY;
  }
}
class Br extends XhtmlObject {
  constructor(e2) {
    super(e2, "br");
  }
  [Jr]() {
    return "\n";
  }
  [jr](e2) {
    e2.addString("\n");
  }
  [Qr](e2) {
    return HTMLResult.success({ name: "br" });
  }
}
class Html extends XhtmlObject {
  constructor(e2) {
    super(e2, "html");
  }
  [Qr](e2) {
    const t2 = [];
    if (this[er] = { children: t2 }, this[zs]({}), 0 === t2.length) return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, value: this[Js] || "" });
    if (1 === t2.length) {
      const e3 = t2[0];
      if (e3.attributes?.class.includes("xfaRich")) return HTMLResult.success(e3);
    }
    return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, children: t2 });
  }
}
class I extends XhtmlObject {
  constructor(e2) {
    super(e2, "i");
  }
  [jr](e2) {
    e2.pushFont({ posture: "italic" }), super[jr](e2), e2.popFont();
  }
}
class Li extends XhtmlObject {
  constructor(e2) {
    super(e2, "li");
  }
}
class Ol extends XhtmlObject {
  constructor(e2) {
    super(e2, "ol");
  }
}
class P extends XhtmlObject {
  constructor(e2) {
    super(e2, "p");
  }
  [jr](e2) {
    super[jr](e2, false), e2.addString("\n"), e2.addPara(), e2.popFont();
  }
  [Jr]() {
    return this[mr]()[ur]().at(-1) === this ? super[Jr]() : super[Jr]() + "\n";
  }
}
class Span extends XhtmlObject {
  constructor(e2) {
    super(e2, "span");
  }
}
class Sub extends XhtmlObject {
  constructor(e2) {
    super(e2, "sub");
  }
}
class Sup extends XhtmlObject {
  constructor(e2) {
    super(e2, "sup");
  }
}
class Ul extends XhtmlObject {
  constructor(e2) {
    super(e2, "ul");
  }
}
class XhtmlNamespace {
  static [no](e2, t2) {
    if (XhtmlNamespace.hasOwnProperty(e2)) return XhtmlNamespace[e2](t2);
  }
  static a(e2) {
    return new A(e2);
  }
  static b(e2) {
    return new B(e2);
  }
  static body(e2) {
    return new Body(e2);
  }
  static br(e2) {
    return new Br(e2);
  }
  static html(e2) {
    return new Html(e2);
  }
  static i(e2) {
    return new I(e2);
  }
  static li(e2) {
    return new Li(e2);
  }
  static ol(e2) {
    return new Ol(e2);
  }
  static p(e2) {
    return new P(e2);
  }
  static span(e2) {
    return new Span(e2);
  }
  static sub(e2) {
    return new Sub(e2);
  }
  static sup(e2) {
    return new Sup(e2);
  }
  static ul(e2) {
    return new Ul(e2);
  }
}
const ll = { config: ConfigNamespace, connection: ConnectionSetNamespace, datasets: DatasetsNamespace, localeSet: LocaleSetNamespace, signature: SignatureNamespace, stylesheet: StylesheetNamespace, template: TemplateNamespace, xdp: XdpNamespace, xhtml: XhtmlNamespace };
class UnknownNamespace {
  constructor(e2) {
    this.namespaceId = e2;
  }
  [no](e2, t2) {
    return new XmlObject(this.namespaceId, e2, t2);
  }
}
class Root extends XFAObject {
  constructor(e2) {
    super(-1, "root", /* @__PURE__ */ Object.create(null)), this.element = null, this[Ar] = e2;
  }
  [Nr](e2) {
    return this.element = e2, true;
  }
  [tr]() {
    super[tr](), this.element.template instanceof Template && (this[Ar].set(qr, this.element), this.element.template[zr](this[Ar]), this.element.template[Ar] = this[Ar]);
  }
}
class Empty extends XFAObject {
  constructor() {
    super(-1, "", /* @__PURE__ */ Object.create(null));
  }
  [Nr](e2) {
    return false;
  }
}
class Builder {
  constructor(e2 = null) {
    this._namespaceStack = [], this._nsAgnosticLevel = 0, this._namespacePrefixes = /* @__PURE__ */ new Map(), this._namespaces = /* @__PURE__ */ new Map(), this._nextNsId = Math.max(...Object.values(ao).map(({ id: e3 }) => e3)), this._currentNamespace = e2 || new UnknownNamespace(++this._nextNsId);
  }
  buildRoot(e2) {
    return new Root(e2);
  }
  build({ nsPrefix: e2, name: t2, attributes: i2, namespace: n2, prefixes: a2 }) {
    const s2 = null !== n2;
    if (s2 && (this._namespaceStack.push(this._currentNamespace), this._currentNamespace = this._searchNamespace(n2)), a2 && this._addNamespacePrefix(a2), i2.hasOwnProperty(Rr)) {
      const e3 = ll.datasets, t3 = i2[Rr];
      let n3 = null;
      for (const [i3, a3] of Object.entries(t3)) {
        if (this._getNamespaceToUse(i3) === e3) {
          n3 = { xfa: a3 };
          break;
        }
      }
      n3 ? i2[Rr] = n3 : delete i2[Rr];
    }
    const r2 = this._getNamespaceToUse(e2), o2 = r2?.[no](t2, i2) || new Empty();
    return o2[Fr]() && this._nsAgnosticLevel++, (s2 || a2 || o2[Fr]()) && (o2[Vs] = { hasNamespace: s2, prefixes: a2, nsAgnostic: o2[Fr]() }), o2;
  }
  isNsAgnostic() {
    return this._nsAgnosticLevel > 0;
  }
  _searchNamespace(e2) {
    let t2 = this._namespaces.get(e2);
    if (t2) return t2;
    for (const [i2, { check: n2 }] of Object.entries(ao)) if (n2(e2)) {
      if (t2 = ll[i2], t2) return this._namespaces.set(e2, t2), t2;
      break;
    }
    return t2 = new UnknownNamespace(++this._nextNsId), this._namespaces.set(e2, t2), t2;
  }
  _addNamespacePrefix(e2) {
    for (const { prefix: t2, value: i2 } of e2) {
      const e3 = this._searchNamespace(i2);
      let n2 = this._namespacePrefixes.get(t2);
      n2 || (n2 = [], this._namespacePrefixes.set(t2, n2)), n2.push(e3);
    }
  }
  _getNamespaceToUse(e2) {
    if (!e2) return this._currentNamespace;
    const t2 = this._namespacePrefixes.get(e2);
    return t2?.length > 0 ? t2.at(-1) : (warn$1(`Unknown namespace prefix: ${e2}.`), null);
  }
  clean(e2) {
    const { hasNamespace: t2, prefixes: i2, nsAgnostic: n2 } = e2;
    t2 && (this._currentNamespace = this._namespaceStack.pop()), i2 && i2.forEach(({ prefix: e3 }) => {
      this._namespacePrefixes.get(e3).pop();
    }), n2 && this._nsAgnosticLevel--;
  }
}
class XFAParser extends XMLParserBase {
  constructor(e2 = null, t2 = false) {
    super(), this._builder = new Builder(e2), this._stack = [], this._globalData = { usedTypefaces: /* @__PURE__ */ new Set() }, this._ids = /* @__PURE__ */ new Map(), this._current = this._builder.buildRoot(this._ids), this._errorCode = Is, this._whiteRegex = /^\s+$/, this._nbsps = /\xa0+/g, this._richText = t2;
  }
  parse(e2) {
    if (this.parseXml(e2), this._errorCode === Is) return this._current[tr](), this._current.element;
  }
  onText(e2) {
    e2 = e2.replace(this._nbsps, (e3) => e3.slice(1) + " "), this._richText || this._current[Hs]() ? this._current[Ur](e2, this._richText) : this._whiteRegex.test(e2) || this._current[Ur](e2.trim());
  }
  onCdata(e2) {
    this._current[Ur](e2);
  }
  _mkAttributes(e2, t2) {
    let i2 = null, n2 = null;
    const a2 = /* @__PURE__ */ Object.create({});
    for (const { name: s2, value: r2 } of e2) if ("xmlns" === s2) i2 ? warn$1(`XFA - multiple namespace definition in <${t2}>`) : i2 = r2;
    else if (s2.startsWith("xmlns:")) {
      const e3 = s2.substring(6);
      n2 ??= [], n2.push({ prefix: e3, value: r2 });
    } else {
      const e3 = s2.indexOf(":");
      if (-1 === e3) a2[s2] = r2;
      else {
        const t3 = a2[Rr] ??= /* @__PURE__ */ Object.create(null), [i3, n3] = [s2.slice(0, e3), s2.slice(e3 + 1)];
        (t3[i3] ||= /* @__PURE__ */ Object.create(null))[n3] = r2;
      }
    }
    return [i2, n2, a2];
  }
  _getNameAndPrefix(e2, t2) {
    const i2 = e2.indexOf(":");
    return -1 === i2 ? [e2, null] : [e2.substring(i2 + 1), t2 ? "" : e2.substring(0, i2)];
  }
  onBeginElement(e2, t2, i2) {
    const [n2, a2, s2] = this._mkAttributes(t2, e2), [r2, o2] = this._getNameAndPrefix(e2, this._builder.isNsAgnostic()), l2 = this._builder.build({ nsPrefix: o2, name: r2, attributes: s2, namespace: n2, prefixes: a2 });
    if (l2[yr] = this._globalData, i2) return l2[tr](), this._current[Nr](l2) && l2[Gr](this._ids), void l2[Ws](this._builder);
    this._stack.push(this._current), this._current = l2;
  }
  onEndElement(e2) {
    const t2 = this._current;
    if (t2[vr]() && "string" == typeof t2[Js]) {
      const e3 = new XFAParser();
      e3._globalData = this._globalData;
      const i2 = e3.parse(t2[Js]);
      t2[Js] = null, t2[Nr](i2);
    }
    t2[tr](), this._current = this._stack.pop(), this._current[Nr](t2) && t2[Gr](this._ids), t2[Ws](this._builder);
  }
  onError(e2) {
    this._errorCode = e2;
  }
}
class XFAFactory {
  constructor(e2) {
    try {
      this.root = new XFAParser().parse(XFAFactory._createDocument(e2));
      const t2 = new Binder(this.root);
      this.form = t2.bind(), this.dataHandler = new DataHandler(this.root, t2.getData()), this.form[yr].template = this.form;
    } catch (e3) {
      warn$1(`XFA - an error occurred during parsing and binding: ${e3}`);
    }
  }
  isValid() {
    return !(!this.root || !this.form);
  }
  _createPagesHelper() {
    const e2 = this.form[Zr]();
    return new Promise((t2, i2) => {
      const nextIteration = () => {
        try {
          const i3 = e2.next();
          i3.done ? t2(i3.value) : setTimeout(nextIteration, 0);
        } catch (e3) {
          i2(e3);
        }
      };
      setTimeout(nextIteration, 0);
    });
  }
  async _createPages() {
    try {
      this.pages = await this._createPagesHelper(), this.dims = this.pages.children.map((e2) => {
        const { width: t2, height: i2 } = e2.attributes.style;
        return [0, 0, parseInt(t2), parseInt(i2)];
      });
    } catch (e2) {
      warn$1(`XFA - an error occurred during layout: ${e2}`);
    }
  }
  getBoundingBox(e2) {
    return this.dims[e2];
  }
  async getNumPages() {
    return this.pages || await this._createPages(), this.dims.length;
  }
  setImages(e2) {
    this.form[yr].images = e2;
  }
  setFonts(e2) {
    this.form[yr].fontFinder = new FontFinder(e2);
    const t2 = [];
    for (let e3 of this.form[yr].usedTypefaces) {
      e3 = stripQuotes(e3);
      this.form[yr].fontFinder.find(e3) || t2.push(e3);
    }
    return t2.length > 0 ? t2 : null;
  }
  appendFonts(e2, t2) {
    this.form[yr].fontFinder.add(e2, t2);
  }
  async getPages() {
    this.pages || await this._createPages();
    const e2 = this.pages;
    return this.pages = null, e2;
  }
  serializeData(e2) {
    return this.dataHandler.serialize(e2);
  }
  static _createDocument(e2) {
    return e2["/xdp:xdp"] ? Object.values(e2).join("") : e2["xdp:xdp"];
  }
  static getRichTextAsHtml(e2) {
    if (!e2 || "string" != typeof e2) return null;
    try {
      let t2 = new XFAParser(XhtmlNamespace, true).parse(e2);
      if (!["body", "xhtml"].includes(t2[Pr])) {
        const e3 = XhtmlNamespace.body({});
        e3[qs](t2), t2 = e3;
      }
      const i2 = t2[Qr]();
      if (!i2.success) return null;
      const { html: n2 } = i2, { attributes: a2 } = n2;
      return a2 && (a2.class && (a2.class = a2.class.filter((e3) => !e3.startsWith("xfa"))), a2.dir = "auto"), { html: n2, str: t2[Jr]() };
    } catch (e3) {
      warn$1(`XFA - an error occurred during parsing of rich text: ${e3}`);
    }
    return null;
  }
}
class AnnotationFactory {
  static createGlobals(e2) {
    return Promise.all([e2.ensureCatalog("acroForm"), e2.ensureDoc("xfaDatasets"), e2.ensureCatalog("structTreeRoot"), e2.ensureCatalog("baseUrl"), e2.ensureCatalog("attachments"), e2.ensureCatalog("globalColorSpaceCache")]).then(([t2, i2, n2, a2, s2, r2]) => ({ pdfManager: e2, acroForm: t2 instanceof Dict ? t2 : Dict.empty, xfaDatasets: i2, structTreeRoot: n2, baseUrl: a2, attachments: s2, globalColorSpaceCache: r2 }), (e3) => (warn$1(`createGlobals: "${e3}".`), null));
  }
  static async create(e2, t2, i2, n2, a2, s2, r2, o2) {
    const l2 = a2 ? await this._getPageIndex(e2, t2, i2.pdfManager) : null;
    return i2.pdfManager.ensure(this, "_create", [e2, t2, i2, n2, a2, s2, r2, l2, o2]);
  }
  static _create(e2, t2, i2, n2, a2 = false, s2 = null, r2 = null, o2 = null, l2 = null) {
    const c2 = e2.fetchIfRef(t2);
    if (!(c2 instanceof Dict)) return;
    let h2 = c2.get("Subtype");
    if (h2 = h2 instanceof Name ? h2.name : null, r2 && !r2.has(T[h2.toUpperCase()])) return null;
    const { acroForm: d2, pdfManager: u2 } = i2, g2 = t2 instanceof Ref ? t2.toString() : `annot_${n2.createObjId()}`, f2 = { xref: e2, ref: t2, dict: c2, subtype: h2, id: g2, annotationGlobals: i2, collectFields: a2, orphanFields: s2, needAppearances: !a2 && true === d2.get("NeedAppearances"), pageIndex: o2, evaluatorOptions: u2.evaluatorOptions, pageRef: l2 };
    switch (h2) {
      case "Link":
        return new LinkAnnotation(f2);
      case "Text":
        return new TextAnnotation(f2);
      case "Widget":
        let e3 = getInheritableProperty({ dict: c2, key: "FT" });
        switch (e3 = e3 instanceof Name ? e3.name : null, e3) {
          case "Tx":
            return new TextWidgetAnnotation(f2);
          case "Btn":
            return new ButtonWidgetAnnotation(f2);
          case "Ch":
            return new ChoiceWidgetAnnotation(f2);
          case "Sig":
            return new SignatureWidgetAnnotation(f2);
        }
        return warn$1(`Unimplemented widget field type "${e3}", falling back to base field type.`), new WidgetAnnotation(f2);
      case "Popup":
        return new PopupAnnotation(f2);
      case "FreeText":
        return new FreeTextAnnotation(f2);
      case "Line":
        return new LineAnnotation(f2);
      case "Square":
        return new SquareAnnotation(f2);
      case "Circle":
        return new CircleAnnotation(f2);
      case "PolyLine":
        return new PolylineAnnotation(f2);
      case "Polygon":
        return new PolygonAnnotation(f2);
      case "Caret":
        return new CaretAnnotation(f2);
      case "Ink":
        return new InkAnnotation(f2);
      case "Highlight":
        return new HighlightAnnotation(f2);
      case "Underline":
        return new UnderlineAnnotation(f2);
      case "Squiggly":
        return new SquigglyAnnotation(f2);
      case "StrikeOut":
        return new StrikeOutAnnotation(f2);
      case "Stamp":
        return new StampAnnotation(f2);
      case "FileAttachment":
        return new FileAttachmentAnnotation(f2);
      default:
        return a2 || warn$1(h2 ? `Unimplemented annotation type "${h2}", falling back to base annotation.` : "Annotation is missing the required /Subtype."), new Annotation(f2);
    }
  }
  static async _getPageIndex(e2, t2, i2) {
    try {
      const n2 = await e2.fetchIfRefAsync(t2);
      if (!(n2 instanceof Dict)) return -1;
      const a2 = n2.getRaw("P");
      if (a2 instanceof Ref) try {
        return await i2.ensureCatalog("getPageIndex", [a2]);
      } catch (e3) {
        info$1(`_getPageIndex -- not a valid page reference: "${e3}".`);
      }
      if (n2.has("Kids")) return -1;
      const s2 = await i2.ensureDoc("numPages");
      for (let e3 = 0; e3 < s2; e3++) {
        const n3 = await i2.getPage(e3), a3 = await i2.ensure(n3, "annotations");
        for (const i3 of a3) if (i3 instanceof Ref && isRefsEqual(i3, t2)) return e3;
      }
    } catch (e3) {
      warn$1(`_getPageIndex: "${e3}".`);
    }
    return -1;
  }
  static generateImages(e2, t2, i2) {
    if (!i2) return warn$1("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."), null;
    let n2;
    for (const { bitmapId: i3, bitmap: a2 } of e2) a2 && (n2 ||= /* @__PURE__ */ new Map(), n2.set(i3, StampAnnotation.createImage(a2, t2)));
    return n2;
  }
  static async saveNewAnnotations(e2, t2, i2, n2, a2) {
    const s2 = e2.xref;
    let r2;
    const o2 = [], { isOffscreenCanvasSupported: l2 } = e2.options;
    for (const c2 of i2) if (!c2.deleted) switch (c2.annotationType) {
      case f:
        if (!r2) {
          const e3 = new Dict(s2);
          e3.setIfName("BaseFont", "Helvetica"), e3.setIfName("Type", "Font"), e3.setIfName("Subtype", "Type1"), e3.setIfName("Encoding", "WinAnsiEncoding"), r2 = s2.getNewTemporaryRef(), a2.put(r2, { data: e3 });
        }
        o2.push(FreeTextAnnotation.createNewAnnotation(s2, c2, a2, { evaluator: e2, task: t2, baseFontRef: r2 }));
        break;
      case p:
        c2.quadPoints ? o2.push(HighlightAnnotation.createNewAnnotation(s2, c2, a2)) : o2.push(InkAnnotation.createNewAnnotation(s2, c2, a2));
        break;
      case b:
        o2.push(InkAnnotation.createNewAnnotation(s2, c2, a2));
        break;
      case m:
        const i3 = l2 ? await n2?.get(c2.bitmapId) : null;
        if (i3?.imageStream) {
          const { imageStream: e3, smaskStream: t3 } = i3;
          if (t3) {
            const i4 = s2.getNewTemporaryRef();
            a2.put(i4, { data: t3 }), e3.dict.set("SMask", i4);
          }
          const n3 = i3.imageRef = s2.getNewTemporaryRef();
          a2.put(n3, { data: e3 }), i3.imageStream = i3.smaskStream = null;
        }
        o2.push(StampAnnotation.createNewAnnotation(s2, c2, a2, { image: i3 }));
        break;
      case y:
        o2.push(StampAnnotation.createNewAnnotation(s2, c2, a2, {}));
    }
    return { annotations: (await Promise.all(o2)).flat() };
  }
  static async printNewAnnotations(e2, t2, i2, n2, a2) {
    if (!n2) return null;
    const { options: s2, xref: r2 } = t2, o2 = [];
    for (const l2 of n2) if (!l2.deleted) switch (l2.annotationType) {
      case f:
        o2.push(FreeTextAnnotation.createNewPrintAnnotation(e2, r2, l2, { evaluator: t2, task: i2, evaluatorOptions: s2 }));
        break;
      case p:
        l2.quadPoints ? o2.push(HighlightAnnotation.createNewPrintAnnotation(e2, r2, l2, { evaluatorOptions: s2 })) : o2.push(InkAnnotation.createNewPrintAnnotation(e2, r2, l2, { evaluatorOptions: s2 }));
        break;
      case b:
        o2.push(InkAnnotation.createNewPrintAnnotation(e2, r2, l2, { evaluatorOptions: s2 }));
        break;
      case m:
        const n3 = s2.isOffscreenCanvasSupported ? await a2?.get(l2.bitmapId) : null;
        if (n3?.imageStream) {
          const { imageStream: e3, smaskStream: t3 } = n3;
          t3 && e3.dict.set("SMask", t3), n3.imageRef = new JpegStream(e3, e3.length), n3.imageStream = n3.smaskStream = null;
        }
        o2.push(StampAnnotation.createNewPrintAnnotation(e2, r2, l2, { image: n3, evaluatorOptions: s2 }));
        break;
      case y:
        o2.push(StampAnnotation.createNewPrintAnnotation(e2, r2, l2, { evaluatorOptions: s2 }));
    }
    return Promise.all(o2);
  }
}
function getRgbColor(e2, t2 = new Uint8ClampedArray(3)) {
  if (!Array.isArray(e2)) return t2;
  const i2 = t2 || new Uint8ClampedArray(3);
  switch (e2.length) {
    case 0:
      return null;
    case 1:
      return ColorSpaceUtils.gray.getRgbItem(e2, 0, i2, 0), i2;
    case 3:
      return ColorSpaceUtils.rgb.getRgbItem(e2, 0, i2, 0), i2;
    case 4:
      return ColorSpaceUtils.cmyk.getRgbItem(e2, 0, i2, 0), i2;
    default:
      return t2;
  }
}
function getPdfColorArray(e2, t2 = null) {
  return e2 && Array.from(e2, (e3) => e3 / 255) || t2;
}
function getQuadPoints(e2, t2) {
  const i2 = e2.getArray("QuadPoints");
  if (!isNumberArray(i2, null) || 0 === i2.length || i2.length % 8 > 0) return null;
  const n2 = new Float32Array(i2.length);
  for (let e3 = 0, a2 = i2.length; e3 < a2; e3 += 8) {
    const [a3, s2, r2, o2, l2, c2, h2, d2] = i2.slice(e3, e3 + 8), u2 = Math.min(a3, r2, l2, h2), g2 = Math.max(a3, r2, l2, h2), f2 = Math.min(s2, o2, c2, d2), p2 = Math.max(s2, o2, c2, d2);
    if (null !== t2 && (u2 < t2[0] || g2 > t2[2] || f2 < t2[1] || p2 > t2[3])) return null;
    n2.set([u2, p2, g2, p2, u2, f2, g2, f2], e3);
  }
  return n2;
}
function getTransformMatrix(e2, t2, i2) {
  const n2 = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
  ai.axialAlignedBoundingBox(t2, i2, n2);
  const [a2, s2, r2, o2] = n2;
  if (a2 === r2 || s2 === o2) return [1, 0, 0, 1, e2[0], e2[1]];
  const l2 = (e2[2] - e2[0]) / (r2 - a2), c2 = (e2[3] - e2[1]) / (o2 - s2);
  return [l2, 0, 0, c2, e2[0] - a2 * l2, e2[1] - s2 * c2];
}
class Annotation {
  constructor(e2) {
    const { dict: t2, xref: i2, annotationGlobals: n2, ref: a2, orphanFields: s2 } = e2, r2 = s2?.get(a2);
    r2 && t2.set("Parent", r2), this.setTitle(t2.get("T")), this.setContents(t2.get("Contents")), this.setModificationDate(t2.get("M")), this.setFlags(t2.get("F")), this.setRectangle(t2.getArray("Rect")), this.setColor(t2.getArray("C")), this.setBorderStyle(t2), this.setAppearance(t2), this.setOptionalContent(t2);
    const o2 = t2.get("MK");
    this.setBorderAndBackgroundColors(o2), this.setRotation(o2, t2), this.ref = e2.ref instanceof Ref ? e2.ref : null, this._streams = [], this.appearance && this._streams.push(this.appearance);
    const l2 = !!(this.flags & N), c2 = !!(this.flags & L);
    if (this.data = { annotationFlags: this.flags, borderStyle: this.borderStyle, color: this.color, backgroundColor: this.backgroundColor, borderColor: this.borderColor, rotation: this.rotation, contentsObj: this._contents, hasAppearance: !!this.appearance, id: e2.id, modificationDate: this.modificationDate, rect: this.rectangle, subtype: e2.subtype, hasOwnCanvas: false, noRotate: !!(this.flags & _), noHTML: l2 && c2, isEditable: false, structParent: -1 }, n2.structTreeRoot) {
      let i3 = t2.get("StructParent");
      this.data.structParent = i3 = Number.isInteger(i3) && i3 >= 0 ? i3 : -1, n2.structTreeRoot.addAnnotationIdToPage(e2.pageRef, i3);
    }
    if (e2.collectFields) {
      const n3 = t2.get("Kids");
      if (Array.isArray(n3)) {
        const e3 = [];
        for (const t3 of n3) t3 instanceof Ref && e3.push(t3.toString());
        0 !== e3.length && (this.data.kidIds = e3);
      }
      this.data.actions = collectActions(i2, t2, te), this.data.fieldName = this._constructFieldName(t2), this.data.pageIndex = e2.pageIndex;
    }
    const h2 = t2.get("IT");
    h2 instanceof Name && (this.data.it = h2.name), this._isOffscreenCanvasSupported = e2.evaluatorOptions.isOffscreenCanvasSupported, this._fallbackFontDict = null, this._needAppearances = false;
  }
  _hasFlag(e2, t2) {
    return !!(e2 & t2);
  }
  _buildFlags(e2, t2) {
    let { flags: i2 } = this;
    if (void 0 === e2) {
      if (void 0 === t2) return;
      return t2 ? -5 & i2 : -3 & i2 | O;
    }
    return e2 ? (i2 |= O, t2 ? -33 & i2 | D : -3 & i2 | R) : (i2 &= -35, t2 ? -5 & i2 : i2 | O);
  }
  _isViewable(e2) {
    return !this._hasFlag(e2, M) && !this._hasFlag(e2, R);
  }
  _isPrintable(e2) {
    return this._hasFlag(e2, O) && !this._hasFlag(e2, D) && !this._hasFlag(e2, M);
  }
  mustBeViewed(e2, t2) {
    const i2 = e2?.get(this.data.id)?.noView;
    return void 0 !== i2 ? !i2 : this.viewable && !this._hasFlag(this.flags, D);
  }
  mustBePrinted(e2) {
    const t2 = e2?.get(this.data.id)?.noPrint;
    return void 0 !== t2 ? !t2 : this.printable;
  }
  mustBeViewedWhenEditing(e2, t2 = null) {
    return e2 ? !this.data.isEditable : !t2?.has(this.data.id);
  }
  get viewable() {
    return null !== this.data.quadPoints && (0 === this.flags || this._isViewable(this.flags));
  }
  get printable() {
    return null !== this.data.quadPoints && (0 !== this.flags && this._isPrintable(this.flags));
  }
  _parseStringHelper(e2) {
    const t2 = "string" == typeof e2 ? stringToPDFString(e2) : "";
    return { str: t2, dir: t2 && "rtl" === bidi(t2).dir ? "rtl" : "ltr" };
  }
  setDefaultAppearance(e2) {
    const { dict: t2, annotationGlobals: i2 } = e2, n2 = getInheritableProperty({ dict: t2, key: "DA" }) || i2.acroForm.get("DA");
    this._defaultAppearance = "string" == typeof n2 ? n2 : "", this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance);
  }
  setTitle(e2) {
    this._title = this._parseStringHelper(e2);
  }
  setContents(e2) {
    this._contents = this._parseStringHelper(e2);
  }
  setModificationDate(e2) {
    this.modificationDate = "string" == typeof e2 ? e2 : null;
  }
  setFlags(e2) {
    this.flags = Number.isInteger(e2) && e2 > 0 ? e2 : 0, this.flags & M && "Annotation" !== this.constructor.name && (this.flags ^= M);
  }
  hasFlag(e2) {
    return this._hasFlag(this.flags, e2);
  }
  setRectangle(e2) {
    this.rectangle = lookupNormalRect(e2, [0, 0, 0, 0]);
  }
  setColor(e2) {
    this.color = getRgbColor(e2);
  }
  setLineEndings(e2) {
    if (this.lineEndings = ["None", "None"], Array.isArray(e2) && 2 === e2.length) for (let t2 = 0; t2 < 2; t2++) {
      const i2 = e2[t2];
      if (i2 instanceof Name) switch (i2.name) {
        case "None":
          continue;
        case "Square":
        case "Circle":
        case "Diamond":
        case "OpenArrow":
        case "ClosedArrow":
        case "Butt":
        case "ROpenArrow":
        case "RClosedArrow":
        case "Slash":
          this.lineEndings[t2] = i2.name;
          continue;
      }
      warn$1(`Ignoring invalid lineEnding: ${i2}`);
    }
  }
  setRotation(e2, t2) {
    this.rotation = 0;
    let i2 = e2 instanceof Dict ? e2.get("R") || 0 : t2.get("Rotate") || 0;
    Number.isInteger(i2) && 0 !== i2 && (i2 %= 360, i2 < 0 && (i2 += 360), i2 % 90 == 0 && (this.rotation = i2));
  }
  setBorderAndBackgroundColors(e2) {
    e2 instanceof Dict ? (this.borderColor = getRgbColor(e2.getArray("BC"), null), this.backgroundColor = getRgbColor(e2.getArray("BG"), null)) : this.borderColor = this.backgroundColor = null;
  }
  setBorderStyle(e2) {
    if (this.borderStyle = new AnnotationBorderStyle(), e2 instanceof Dict) if (e2.has("BS")) {
      const t2 = e2.get("BS");
      if (t2 instanceof Dict) {
        const e3 = t2.get("Type");
        e3 && !isName(e3, "Border") || (this.borderStyle.setWidth(t2.get("W"), this.rectangle), this.borderStyle.setStyle(t2.get("S")), this.borderStyle.setDashArray(t2.getArray("D")));
      }
    } else if (e2.has("Border")) {
      const t2 = e2.getArray("Border");
      Array.isArray(t2) && t2.length >= 3 && (this.borderStyle.setHorizontalCornerRadius(t2[0]), this.borderStyle.setVerticalCornerRadius(t2[1]), this.borderStyle.setWidth(t2[2], this.rectangle), 4 === t2.length && this.borderStyle.setDashArray(t2[3], true));
    } else this.borderStyle.setWidth(0);
  }
  setAppearance(e2) {
    this.appearance = null;
    const t2 = e2.get("AP");
    if (!(t2 instanceof Dict)) return;
    const i2 = t2.get("N");
    if (i2 instanceof BaseStream) return void (this.appearance = i2);
    if (!(i2 instanceof Dict)) return;
    const n2 = e2.get("AS");
    if (!(n2 instanceof Name && i2.has(n2.name))) return;
    const a2 = i2.get(n2.name);
    a2 instanceof BaseStream && (this.appearance = a2);
  }
  setOptionalContent(e2) {
    this.oc = null;
    const t2 = e2.get("OC");
    t2 instanceof Name ? warn$1("setOptionalContent: Support for /Name-entry is not implemented.") : t2 instanceof Dict && (this.oc = t2);
  }
  async loadResources(e2, t2) {
    const i2 = await t2.dict.getAsync("Resources");
    return i2 && await ObjectLoader.load(i2, e2, i2.xref), i2;
  }
  async getOperatorList(e2, t2, i2, n2) {
    const { hasOwnCanvas: a2, id: s2, rect: o2 } = this.data;
    let l2 = this.appearance;
    const c2 = !!(a2 && i2 & r);
    if (c2 && (0 === this.width || 0 === this.height)) return this.data.hasOwnCanvas = false, { opList: new OperatorList(), separateForm: false, separateCanvas: false };
    if (!l2) {
      if (!c2) return { opList: new OperatorList(), separateForm: false, separateCanvas: false };
      l2 = new StringStream(""), l2.dict = new Dict();
    }
    const h2 = l2.dict, d2 = await this.loadResources(mi, l2), u2 = lookupRect(h2.getArray("BBox"), [0, 0, 1, 1]), g2 = lookupMatrix(h2.getArray("Matrix"), pi), f2 = getTransformMatrix(o2, u2, g2), p2 = new OperatorList();
    let m2;
    return this.oc && (m2 = await e2.parseMarkedContentProps(this.oc, null)), void 0 !== m2 && p2.addOp(xt, ["OC", m2]), p2.addOp(Et, [s2, o2, f2, g2, c2]), await e2.getOperatorList({ stream: l2, task: t2, resources: d2, operatorList: p2, fallbackFontDict: this._fallbackFontDict }), p2.addOp(Mt, []), void 0 !== m2 && p2.addOp(St, []), this.reset(), { opList: p2, separateForm: false, separateCanvas: c2 };
  }
  async save(e2, t2, i2, n2) {
    return null;
  }
  get overlaysTextContent() {
    return false;
  }
  get hasTextContent() {
    return false;
  }
  async extractTextContent(e2, t2, i2) {
    if (!this.appearance) return;
    const n2 = await this.loadResources(bi, this.appearance), a2 = [], s2 = [];
    let r2 = null;
    const o2 = { desiredSize: Math.Infinity, ready: true, enqueue(e3, t3) {
      for (const t4 of e3.items) void 0 !== t4.str && (r2 ||= t4.transform.slice(-2), s2.push(t4.str), t4.hasEOL && (a2.push(s2.join("").trimEnd()), s2.length = 0));
    } };
    if (await e2.getTextContent({ stream: this.appearance, task: t2, resources: n2, includeMarkedContent: true, keepWhiteSpace: true, sink: o2, viewBox: i2 }), this.reset(), s2.length && a2.push(s2.join("").trimEnd()), a2.length > 1 || a2[0]) {
      const e3 = this.appearance.dict, t3 = lookupRect(e3.getArray("BBox"), null), i3 = lookupMatrix(e3.getArray("Matrix"), null);
      this.data.textPosition = this._transformPoint(r2, t3, i3), this.data.textContent = a2;
    }
  }
  _transformPoint(e2, t2, i2) {
    const { rect: n2 } = this.data;
    t2 ||= [0, 0, 1, 1], i2 ||= [1, 0, 0, 1, 0, 0];
    const a2 = getTransformMatrix(n2, t2, i2);
    a2[4] -= n2[0], a2[5] -= n2[1];
    const s2 = e2.slice();
    return ai.applyTransform(s2, a2), ai.applyTransform(s2, i2), s2;
  }
  getFieldObject() {
    return this.data.kidIds ? { id: this.data.id, actions: this.data.actions, name: this.data.fieldName, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, type: "", kidIds: this.data.kidIds, page: this.data.pageIndex, rotation: this.rotation } : null;
  }
  reset() {
    for (const e2 of this._streams) e2.reset();
  }
  _constructFieldName(e2) {
    if (!e2.has("T") && !e2.has("Parent")) return warn$1("Unknown field name, falling back to empty field name."), "";
    if (!e2.has("Parent")) return stringToPDFString(e2.get("T"));
    const t2 = [];
    e2.has("T") && t2.unshift(stringToPDFString(e2.get("T")));
    let i2 = e2;
    const n2 = new RefSet();
    for (e2.objId && n2.put(e2.objId); i2.has("Parent") && (i2 = i2.get("Parent"), i2 instanceof Dict && (!i2.objId || !n2.has(i2.objId))); ) i2.objId && n2.put(i2.objId), i2.has("T") && t2.unshift(stringToPDFString(i2.get("T")));
    return t2.join(".");
  }
  get width() {
    return this.data.rect[2] - this.data.rect[0];
  }
  get height() {
    return this.data.rect[3] - this.data.rect[1];
  }
}
class AnnotationBorderStyle {
  constructor() {
    this.width = 1, this.rawWidth = 1, this.style = Y, this.dashArray = [3], this.horizontalCornerRadius = 0, this.verticalCornerRadius = 0;
  }
  setWidth(e2, t2 = [0, 0, 0, 0]) {
    if (e2 instanceof Name) this.width = 0;
    else if ("number" == typeof e2) {
      if (e2 > 0) {
        this.rawWidth = e2;
        const i2 = (t2[2] - t2[0]) / 2, n2 = (t2[3] - t2[1]) / 2;
        i2 > 0 && n2 > 0 && (e2 > i2 || e2 > n2) && (warn$1(`AnnotationBorderStyle.setWidth - ignoring width: ${e2}`), e2 = 1);
      }
      this.width = e2;
    }
  }
  setStyle(e2) {
    if (e2 instanceof Name) switch (e2.name) {
      case "S":
        this.style = Y;
        break;
      case "D":
        this.style = J;
        break;
      case "B":
        this.style = Z;
        break;
      case "I":
        this.style = Q;
        break;
      case "U":
        this.style = ee;
    }
  }
  setDashArray(e2, t2 = false) {
    if (Array.isArray(e2)) {
      let i2 = true, n2 = true;
      for (const t3 of e2) {
        if (!(+t3 >= 0)) {
          i2 = false;
          break;
        }
        t3 > 0 && (n2 = false);
      }
      0 === e2.length || i2 && !n2 ? (this.dashArray = e2, t2 && this.setStyle(Name.get("D"))) : this.width = 0;
    } else e2 && (this.width = 0);
  }
  setHorizontalCornerRadius(e2) {
    Number.isInteger(e2) && (this.horizontalCornerRadius = e2);
  }
  setVerticalCornerRadius(e2) {
    Number.isInteger(e2) && (this.verticalCornerRadius = e2);
  }
}
class MarkupAnnotation extends Annotation {
  constructor(e2) {
    super(e2);
    const { dict: t2 } = e2;
    if (t2.has("IRT")) {
      const e3 = t2.getRaw("IRT");
      this.data.inReplyTo = e3 instanceof Ref ? e3.toString() : null;
      const i3 = t2.get("RT");
      this.data.replyType = i3 instanceof Name ? i3.name : E;
    }
    let i2 = null;
    if (this.data.replyType === F) {
      const e3 = t2.get("IRT");
      this.setTitle(e3.get("T")), this.data.titleObj = this._title, this.setContents(e3.get("Contents")), this.data.contentsObj = this._contents, e3.has("CreationDate") ? (this.setCreationDate(e3.get("CreationDate")), this.data.creationDate = this.creationDate) : this.data.creationDate = null, e3.has("M") ? (this.setModificationDate(e3.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, i2 = e3.getRaw("Popup"), e3.has("C") ? (this.setColor(e3.getArray("C")), this.data.color = this.color) : this.data.color = null;
    } else this.data.titleObj = this._title, this.setCreationDate(t2.get("CreationDate")), this.data.creationDate = this.creationDate, i2 = t2.getRaw("Popup"), t2.has("C") || (this.data.color = null);
    this.data.popupRef = i2 instanceof Ref ? i2.toString() : null, t2.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(t2.get("RC")));
  }
  setCreationDate(e2) {
    this.creationDate = "string" == typeof e2 ? e2 : null;
  }
  _setDefaultAppearance({ xref: e2, extra: t2, strokeColor: i2, fillColor: n2, blendMode: a2, strokeAlpha: s2, fillAlpha: r2, pointsCallback: o2 }) {
    const l2 = this.data.rect = [1 / 0, 1 / 0, -1 / 0, -1 / 0], c2 = ["q"];
    t2 && c2.push(t2), i2 && c2.push(`${i2[0]} ${i2[1]} ${i2[2]} RG`), n2 && c2.push(`${n2[0]} ${n2[1]} ${n2[2]} rg`);
    const h2 = this.data.quadPoints || Float32Array.from([this.rectangle[0], this.rectangle[3], this.rectangle[2], this.rectangle[3], this.rectangle[0], this.rectangle[1], this.rectangle[2], this.rectangle[1]]);
    for (let e3 = 0, t3 = h2.length; e3 < t3; e3 += 8) {
      const t4 = o2(c2, h2.subarray(e3, e3 + 8));
      ai.rectBoundingBox(...t4, l2);
    }
    c2.push("Q");
    const d2 = new Dict(e2), u2 = new Dict(e2);
    u2.setIfName("Subtype", "Form");
    const g2 = new StringStream(c2.join(" "));
    g2.dict = u2, d2.set("Fm0", g2);
    const f2 = new Dict(e2);
    a2 && f2.setIfName("BM", a2), f2.setIfNumber("CA", s2), f2.setIfNumber("ca", r2);
    const p2 = new Dict(e2);
    p2.set("GS0", f2);
    const m2 = new Dict(e2);
    m2.set("ExtGState", p2), m2.set("XObject", d2);
    const b2 = new Dict(e2);
    b2.set("Resources", m2), b2.set("BBox", l2), this.appearance = new StringStream("/GS0 gs /Fm0 Do"), this.appearance.dict = b2, this._streams.push(this.appearance, g2);
  }
  static async createNewAnnotation(e2, t2, i2, n2) {
    const a2 = t2.ref ||= e2.getNewTemporaryRef(), s2 = await this.createNewAppearanceStream(t2, e2, n2);
    let r2;
    if (s2) {
      const n3 = e2.getNewTemporaryRef();
      r2 = this.createNewDict(t2, e2, { apRef: n3 }), i2.put(n3, { data: s2 });
    } else r2 = this.createNewDict(t2, e2, {});
    Number.isInteger(t2.parentTreeId) && r2.set("StructParent", t2.parentTreeId), i2.put(a2, { data: r2 });
    const o2 = { ref: a2 }, { popup: l2 } = t2;
    if (l2) {
      if (l2.deleted) return r2.delete("Popup"), r2.delete("Contents"), r2.delete("RC"), o2;
      const t3 = l2.ref ||= e2.getNewTemporaryRef();
      l2.parent = a2;
      const n3 = PopupAnnotation.createNewDict(l2, e2);
      return i2.put(t3, { data: n3 }), r2.setIfDefined("Contents", stringToAsciiOrUTF16BE(l2.contents)), r2.set("Popup", t3), [o2, { ref: t3 }];
    }
    return o2;
  }
  static async createNewPrintAnnotation(e2, t2, i2, n2) {
    const a2 = await this.createNewAppearanceStream(i2, t2, n2), s2 = this.createNewDict(i2, t2, a2 ? { ap: a2 } : {}), r2 = new this.prototype.constructor({ dict: s2, xref: t2, annotationGlobals: e2, evaluatorOptions: n2.evaluatorOptions });
    return i2.ref && (r2.ref = r2.refToReplace = i2.ref), r2;
  }
}
class WidgetAnnotation extends Annotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2, annotationGlobals: n2 } = e2, a2 = this.data;
    this._needAppearances = e2.needAppearances, a2.annotationType = T.WIDGET, void 0 === a2.fieldName && (a2.fieldName = this._constructFieldName(t2)), void 0 === a2.actions && (a2.actions = collectActions(i2, t2, te));
    let s2 = getInheritableProperty({ dict: t2, key: "V", getArray: true });
    a2.fieldValue = this._decodeFormValue(s2);
    const r2 = getInheritableProperty({ dict: t2, key: "DV", getArray: true });
    if (a2.defaultFieldValue = this._decodeFormValue(r2), void 0 === s2 && n2.xfaDatasets) {
      const e3 = this._title.str;
      e3 && (this._hasValueFromXFA = true, a2.fieldValue = s2 = n2.xfaDatasets.getValue(e3));
    }
    void 0 === s2 && null !== a2.defaultFieldValue && (a2.fieldValue = a2.defaultFieldValue), a2.alternativeText = stringToPDFString(t2.get("TU") || ""), this.setDefaultAppearance(e2), a2.hasAppearance ||= this._needAppearances && void 0 !== a2.fieldValue && null !== a2.fieldValue;
    const o2 = getInheritableProperty({ dict: t2, key: "FT" });
    a2.fieldType = o2 instanceof Name ? o2.name : null;
    const l2 = getInheritableProperty({ dict: t2, key: "DR" }), c2 = n2.acroForm.get("DR"), h2 = this.appearance?.dict.get("Resources");
    this._fieldResources = { localResources: l2, acroFormResources: c2, appearanceResources: h2, mergedResources: Dict.merge({ xref: i2, dictArray: [l2, h2, c2], mergeSubDicts: true }) }, a2.fieldFlags = getInheritableProperty({ dict: t2, key: "Ff" }), (!Number.isInteger(a2.fieldFlags) || a2.fieldFlags < 0) && (a2.fieldFlags = 0), a2.password = this.hasFieldFlag(H), a2.readOnly = this.hasFieldFlag(U), a2.required = this.hasFieldFlag(j), a2.hidden = this._hasFlag(a2.annotationFlags, D) || this._hasFlag(a2.annotationFlags, R);
  }
  _decodeFormValue(e2) {
    return Array.isArray(e2) ? e2.filter((e3) => "string" == typeof e3).map((e3) => stringToPDFString(e3)) : e2 instanceof Name ? stringToPDFString(e2.name) : "string" == typeof e2 ? stringToPDFString(e2) : null;
  }
  hasFieldFlag(e2) {
    return !!(this.data.fieldFlags & e2);
  }
  _isViewable(e2) {
    return true;
  }
  mustBeViewed(e2, t2) {
    return t2 ? this.viewable : super.mustBeViewed(e2, t2) && !this._hasFlag(this.flags, R);
  }
  getRotationMatrix(e2) {
    let t2 = e2?.get(this.data.id)?.rotation;
    return void 0 === t2 && (t2 = this.rotation), 0 === t2 ? pi : getRotationMatrix(t2, this.width, this.height);
  }
  getBorderAndBackgroundAppearances(e2) {
    let t2 = e2?.get(this.data.id)?.rotation;
    if (void 0 === t2 && (t2 = this.rotation), !this.backgroundColor && !this.borderColor) return "";
    const i2 = 0 === t2 || 180 === t2 ? `0 0 ${this.width} ${this.height} re` : `0 0 ${this.height} ${this.width} re`;
    let n2 = "";
    if (this.backgroundColor && (n2 = `${getPdfColor(this.backgroundColor, true)} ${i2} f `), this.borderColor) {
      n2 += `${this.borderStyle.width || 1} w ${getPdfColor(this.borderColor, false)} ${i2} S `;
    }
    return n2;
  }
  async getOperatorList(e2, t2, i2, n2) {
    if (i2 & c && !(this instanceof SignatureWidgetAnnotation) && !this.data.noHTML && !this.data.hasOwnCanvas) return { opList: new OperatorList(), separateForm: true, separateCanvas: false };
    if (!this._hasText) return super.getOperatorList(e2, t2, i2, n2);
    const a2 = await this._getAppearance(e2, t2, i2, n2);
    if (this.appearance && null === a2) return super.getOperatorList(e2, t2, i2, n2);
    const s2 = new OperatorList();
    if (!this._defaultAppearance || null === a2) return { opList: s2, separateForm: false, separateCanvas: false };
    const o2 = !!(this.data.hasOwnCanvas && i2 & r), l2 = [0, 0, this.width, this.height], h2 = getTransformMatrix(this.data.rect, l2, [1, 0, 0, 1, 0, 0]);
    let d2;
    this.oc && (d2 = await e2.parseMarkedContentProps(this.oc, null)), void 0 !== d2 && s2.addOp(xt, ["OC", d2]), s2.addOp(Et, [this.data.id, this.data.rect, h2, this.getRotationMatrix(n2), o2]);
    const u2 = new StringStream(a2);
    return await e2.getOperatorList({ stream: u2, task: t2, resources: this._fieldResources.mergedResources, operatorList: s2 }), s2.addOp(Mt, []), void 0 !== d2 && s2.addOp(St, []), { opList: s2, separateForm: false, separateCanvas: o2 };
  }
  _getMKDict(e2) {
    const t2 = new Dict(null);
    return e2 && t2.set("R", e2), t2.setIfArray("BC", getPdfColorArray(this.borderColor)), t2.setIfArray("BG", getPdfColorArray(this.backgroundColor)), t2.size > 0 ? t2 : null;
  }
  amendSavedDict(e2, t2) {
  }
  setValue(e2, t2, i2, n2) {
    const { dict: a2, ref: s2 } = (function(e3, t3, i3) {
      const n3 = new RefSet(), a3 = e3, s3 = { dict: null, ref: null };
      for (; e3 instanceof Dict && !n3.has(t3) && (n3.put(t3), !e3.has("T")); ) {
        if (!((t3 = e3.getRaw("Parent")) instanceof Ref)) return s3;
        e3 = i3.fetch(t3);
      }
      return e3 instanceof Dict && e3 !== a3 && (s3.dict = e3, s3.ref = t3), s3;
    })(e2, this.ref, i2);
    if (a2) {
      if (!n2.has(s2)) {
        const e3 = a2.clone();
        return e3.set("V", t2), n2.put(s2, { data: e3 }), e3;
      }
    } else e2.set("V", t2);
    return null;
  }
  async save(e2, t2, i2, n2) {
    const a2 = i2?.get(this.data.id), s2 = this._buildFlags(a2?.noView, a2?.noPrint);
    let r2 = a2?.value, o2 = a2?.rotation;
    if (r2 === this.data.fieldValue || void 0 === r2) {
      if (!this._hasValueFromXFA && void 0 === o2 && void 0 === s2) return;
      r2 ||= this.data.fieldValue;
    }
    if (void 0 === o2 && !this._hasValueFromXFA && Array.isArray(r2) && Array.isArray(this.data.fieldValue) && isArrayEqual(r2, this.data.fieldValue) && void 0 === s2) return;
    void 0 === o2 && (o2 = this.rotation);
    let c2 = null;
    if (!this._needAppearances && (c2 = await this._getAppearance(e2, t2, l, i2), null === c2 && void 0 === s2)) return;
    let h2 = false;
    c2?.needAppearances && (h2 = true, c2 = null);
    const { xref: d2 } = e2, u2 = d2.fetchIfRef(this.ref);
    if (!(u2 instanceof Dict)) return;
    const g2 = new Dict(d2);
    for (const e3 of u2.getKeys()) "AP" !== e3 && g2.set(e3, u2.getRaw(e3));
    if (void 0 !== s2 && (g2.set("F", s2), null === c2 && !h2)) {
      const e3 = u2.getRaw("AP");
      e3 && g2.set("AP", e3);
    }
    const f2 = { path: this.data.fieldName, value: r2 }, p2 = this.setValue(g2, Array.isArray(r2) ? r2.map(stringToAsciiOrUTF16BE) : stringToAsciiOrUTF16BE(r2), d2, n2);
    this.amendSavedDict(i2, p2 || g2);
    const m2 = this._getMKDict(o2);
    if (m2 && g2.set("MK", m2), n2.put(this.ref, { data: g2, xfa: f2, needAppearances: h2 }), null !== c2) {
      const e3 = d2.getNewTemporaryRef(), t3 = new Dict(d2);
      g2.set("AP", t3), t3.set("N", e3);
      const a3 = this._getSaveFieldResources(d2), s3 = new StringStream(c2), r3 = s3.dict = new Dict(d2);
      r3.setIfName("Subtype", "Form"), r3.set("Resources", a3);
      const l2 = o2 % 180 == 0 ? [0, 0, this.width, this.height] : [0, 0, this.height, this.width];
      r3.set("BBox", l2);
      const h3 = this.getRotationMatrix(i2);
      h3 !== pi && r3.set("Matrix", h3), n2.put(e3, { data: s3, xfa: null, needAppearances: false });
    }
    g2.set("M", `D:${getModificationDate()}`);
  }
  async _getAppearance(e2, t2, i2, n2) {
    if (this.data.password) return null;
    const s2 = n2?.get(this.data.id);
    let r2, o2;
    if (s2 && (r2 = s2.formattedValue || s2.value, o2 = s2.rotation), void 0 === o2 && void 0 === r2 && !this._needAppearances && (!this._hasValueFromXFA || this.appearance)) return null;
    const c2 = this.getBorderAndBackgroundAppearances(n2);
    if (void 0 === r2 && (r2 = this.data.fieldValue, !r2)) return `/Tx BMC q ${c2}Q EMC`;
    if (Array.isArray(r2) && 1 === r2.length && (r2 = r2[0]), assert$1("string" == typeof r2, "Expected `value` to be a string."), r2 = r2.trimEnd(), this.data.combo) {
      const e3 = this.data.options.find(({ exportValue: e4 }) => r2 === e4);
      r2 = e3?.displayValue || r2;
    }
    if ("" === r2) return `/Tx BMC q ${c2}Q EMC`;
    void 0 === o2 && (o2 = this.rotation);
    let h2, d2 = -1;
    this.data.multiLine ? (h2 = r2.split(/\r\n?|\n/).map((e3) => e3.normalize("NFC")), d2 = h2.length) : h2 = [r2.replace(/\r\n?|\n/, "").normalize("NFC")];
    let { width: u2, height: g2 } = this;
    90 !== o2 && 270 !== o2 || ([u2, g2] = [g2, u2]), this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
    let f2, p2, m2, b2 = await WidgetAnnotation._getFontData(e2, t2, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
    const y2 = [];
    let w2 = false;
    for (const e3 of h2) {
      const t3 = b2.encodeString(e3);
      t3.length > 1 && (w2 = true), y2.push(t3.join(""));
    }
    if (w2 && i2 & l) return { needAppearances: true };
    if (w2 && this._isOffscreenCanvasSupported) {
      const i3 = this.data.comb ? "monospace" : "sans-serif", n3 = new FakeUnicodeFont(e2.xref, i3), a2 = n3.createFontResources(h2.join("")), s3 = a2.getRaw("Font");
      if (this._fieldResources.mergedResources.has("Font")) {
        const e3 = this._fieldResources.mergedResources.get("Font");
        for (const t3 of s3.getKeys()) e3.set(t3, s3.getRaw(t3));
      } else this._fieldResources.mergedResources.set("Font", s3);
      const o3 = n3.fontName.name;
      b2 = await WidgetAnnotation._getFontData(e2, t2, { fontName: o3, fontSize: 0 }, a2);
      for (let e3 = 0, t3 = y2.length; e3 < t3; e3++) y2[e3] = stringToUTF16String(h2[e3]);
      const l2 = Object.assign(/* @__PURE__ */ Object.create(null), this.data.defaultAppearanceData);
      this.data.defaultAppearanceData.fontSize = 0, this.data.defaultAppearanceData.fontName = o3, [f2, p2, m2] = this._computeFontSize(g2 - 2, u2 - 4, r2, b2, d2), this.data.defaultAppearanceData = l2;
    } else this._isOffscreenCanvasSupported || warn$1("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."), [f2, p2, m2] = this._computeFontSize(g2 - 2, u2 - 4, r2, b2, d2);
    let x2 = b2.descent;
    x2 = isNaN(x2) ? a * m2 : Math.max(a * m2, Math.abs(x2) * p2);
    const S2 = Math.min(Math.floor((g2 - p2) / 2), 1), v2 = this.data.textAlignment;
    if (this.data.multiLine) return this._getMultilineAppearance(f2, y2, b2, p2, u2, g2, v2, 2, S2, x2, m2, n2);
    if (this.data.comb) return this._getCombAppearance(f2, b2, y2[0], p2, u2, g2, 2, S2, x2, m2, n2);
    const C2 = S2 + x2;
    if (0 === v2 || v2 > 2) return `/Tx BMC q ${c2}BT ` + f2 + ` 1 0 0 1 ${numberToString(2)} ${numberToString(C2)} Tm (${escapeString(y2[0])}) Tj ET Q EMC`;
    return `/Tx BMC q ${c2}BT ` + f2 + ` 1 0 0 1 0 0 Tm ${this._renderText(y2[0], b2, p2, u2, v2, { shift: 0 }, 2, C2)} ET Q EMC`;
  }
  static async _getFontData(e2, t2, i2, n2) {
    const a2 = new OperatorList(), s2 = { font: null, clone() {
      return this;
    } }, { fontName: r2, fontSize: o2 } = i2;
    return await e2.handleSetFont(n2, [r2 && Name.get(r2), o2], null, a2, t2, s2, null), s2.font;
  }
  _getTextWidth(e2, t2) {
    return Math.sumPrecise(t2.charsToGlyphs(e2).map((e3) => e3.width)) / 1e3;
  }
  _computeFontSize(e2, t2, n2, a2, s2) {
    let { fontSize: r2 } = this.data.defaultAppearanceData, o2 = (r2 || 12) * i, l2 = Math.round(e2 / o2);
    if (!r2) {
      const roundWithTwoDigits = (e3) => Math.floor(100 * e3) / 100;
      if (-1 === s2) {
        const s3 = this._getTextWidth(n2, a2);
        r2 = roundWithTwoDigits(Math.min(e2 / i, t2 / s3)), l2 = 1;
      } else {
        const c3 = n2.split(/\r\n?|\n/), h3 = [];
        for (const e3 of c3) {
          const t3 = a2.encodeString(e3).join(""), i2 = a2.charsToGlyphs(t3), n3 = a2.getCharPositions(t3);
          h3.push({ line: t3, glyphs: i2, positions: n3 });
        }
        const isTooBig = (i2) => {
          let n3 = 0;
          for (const s3 of h3) {
            if (n3 += this._splitLine(null, a2, i2, t2, s3).length * i2, n3 > e2) return true;
          }
          return false;
        };
        for (l2 = Math.max(l2, s2); o2 = e2 / l2, r2 = roundWithTwoDigits(o2 / i), isTooBig(r2); ) l2++;
      }
      const { fontName: c2, fontColor: h2 } = this.data.defaultAppearanceData;
      this._defaultAppearance = (function({ fontSize: e3, fontName: t3, fontColor: i2 }) {
        return `/${escapePDFName(t3)} ${e3} Tf ${getPdfColor(i2, true)}`;
      })({ fontSize: r2, fontName: c2, fontColor: h2 });
    }
    return [this._defaultAppearance, r2, e2 / l2];
  }
  _renderText(e2, t2, i2, n2, a2, s2, r2, o2) {
    let l2;
    if (1 === a2) {
      l2 = (n2 - this._getTextWidth(e2, t2) * i2) / 2;
    } else if (2 === a2) {
      l2 = n2 - this._getTextWidth(e2, t2) * i2 - r2;
    } else l2 = r2;
    const c2 = numberToString(l2 - s2.shift);
    return s2.shift = l2, `${c2} ${o2 = numberToString(o2)} Td (${escapeString(e2)}) Tj`;
  }
  _getSaveFieldResources(e2) {
    const { localResources: t2, appearanceResources: i2, acroFormResources: n2 } = this._fieldResources, a2 = this.data.defaultAppearanceData?.fontName;
    if (!a2) return t2 || Dict.empty;
    for (const e3 of [t2, i2]) if (e3 instanceof Dict) {
      const t3 = e3.get("Font");
      if (t3 instanceof Dict && t3.has(a2)) return e3;
    }
    if (n2 instanceof Dict) {
      const i3 = n2.get("Font");
      if (i3 instanceof Dict && i3.has(a2)) {
        const n3 = new Dict(e2);
        n3.set(a2, i3.getRaw(a2));
        const s2 = new Dict(e2);
        return s2.set("Font", n3), Dict.merge({ xref: e2, dictArray: [s2, t2], mergeSubDicts: true });
      }
    }
    return t2 || Dict.empty;
  }
  getFieldObject() {
    return null;
  }
}
class TextWidgetAnnotation extends WidgetAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2 } = e2;
    t2.has("PMD") && (this.flags |= D, this.data.hidden = true, warn$1("Barcodes are not supported")), this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML, this._hasText = true, "string" != typeof this.data.fieldValue && (this.data.fieldValue = "");
    let i2 = getInheritableProperty({ dict: t2, key: "Q" });
    (!Number.isInteger(i2) || i2 < 0 || i2 > 2) && (i2 = null), this.data.textAlignment = i2;
    let n2 = getInheritableProperty({ dict: t2, key: "MaxLen" });
    (!Number.isInteger(n2) || n2 < 0) && (n2 = 0), this.data.maxLen = n2, this.data.multiLine = this.hasFieldFlag($), this.data.comb = this.hasFieldFlag(K) && !this.data.multiLine && !this.data.password && !this.hasFieldFlag(W) && 0 !== this.data.maxLen, this.data.doNotScroll = this.hasFieldFlag(V);
    const { data: { actions: a2 } } = this;
    if (!a2) return;
    const s2 = /^AF(Date|Time)_(?:Keystroke|Format)(?:Ex)?\(['"]?([^'"]+)['"]?\);$/;
    let r2 = false;
    (1 === a2.Format?.length && 1 === a2.Keystroke?.length && s2.test(a2.Format[0]) && s2.test(a2.Keystroke[0]) || 0 === a2.Format?.length && 1 === a2.Keystroke?.length && s2.test(a2.Keystroke[0]) || 0 === a2.Keystroke?.length && 1 === a2.Format?.length && s2.test(a2.Format[0])) && (r2 = true);
    const o2 = [];
    a2.Format && o2.push(...a2.Format), a2.Keystroke && o2.push(...a2.Keystroke), r2 && (delete a2.Keystroke, a2.Format = o2);
    for (const e3 of o2) {
      const t3 = e3.match(s2);
      if (!t3) continue;
      const i3 = "Date" === t3[1];
      let n3 = t3[2];
      const a3 = parseInt(n3, 10);
      if (isNaN(a3) || Math.floor(Math.log10(a3)) + 1 !== t3[2].length || (n3 = (i3 ? Ts : Fs)[a3] ?? n3), this.data.datetimeFormat = n3, !r2) break;
      if (i3) {
        /HH|MM|ss|h/.test(n3) ? (this.data.datetimeType = "datetime-local", this.data.timeStep = /ss/.test(n3) ? 1 : 60) : this.data.datetimeType = "date";
        break;
      }
      this.data.datetimeType = "time", this.data.timeStep = /ss/.test(n3) ? 1 : 60;
      break;
    }
  }
  get hasTextContent() {
    return !!this.appearance && !this._needAppearances;
  }
  _getCombAppearance(e2, t2, i2, n2, a2, s2, r2, o2, l2, c2, h2) {
    const d2 = a2 / this.data.maxLen, u2 = this.getBorderAndBackgroundAppearances(h2), g2 = [], f2 = t2.getCharPositions(i2);
    for (const [e3, t3] of f2) g2.push(`(${escapeString(i2.substring(e3, t3))}) Tj`);
    const p2 = g2.join(` ${numberToString(d2)} 0 Td `);
    return `/Tx BMC q ${u2}BT ` + e2 + ` 1 0 0 1 ${numberToString(r2)} ${numberToString(o2 + l2)} Tm ${p2} ET Q EMC`;
  }
  _getMultilineAppearance(e2, t2, i2, n2, a2, s2, r2, o2, l2, c2, h2, d2) {
    const u2 = [], g2 = a2 - 2 * o2, f2 = { shift: 0 };
    for (let e3 = 0, s3 = t2.length; e3 < s3; e3++) {
      const s4 = t2[e3], d3 = this._splitLine(s4, i2, n2, g2);
      for (let t3 = 0, s5 = d3.length; t3 < s5; t3++) {
        const s6 = d3[t3], g3 = 0 === e3 && 0 === t3 ? -l2 - (h2 - c2) : -h2;
        u2.push(this._renderText(s6, i2, n2, a2, r2, f2, o2, g3));
      }
    }
    const p2 = this.getBorderAndBackgroundAppearances(d2), m2 = u2.join("\n");
    return `/Tx BMC q ${p2}BT ` + e2 + ` 1 0 0 1 0 ${numberToString(s2)} Tm ${m2} ET Q EMC`;
  }
  _splitLine(e2, t2, i2, n2, a2 = {}) {
    e2 = a2.line || e2;
    const s2 = a2.glyphs || t2.charsToGlyphs(e2);
    if (s2.length <= 1) return [e2];
    const r2 = a2.positions || t2.getCharPositions(e2), o2 = i2 / 1e3, l2 = [];
    let c2 = -1, h2 = -1, d2 = -1, u2 = 0, g2 = 0;
    for (let t3 = 0, i3 = s2.length; t3 < i3; t3++) {
      const [i4, a3] = r2[t3], f2 = s2[t3], p2 = f2.width * o2;
      " " === f2.unicode ? g2 + p2 > n2 ? (l2.push(e2.substring(u2, i4)), u2 = i4, g2 = p2, c2 = -1, d2 = -1) : (g2 += p2, c2 = i4, h2 = a3, d2 = t3) : g2 + p2 > n2 ? -1 !== c2 ? (l2.push(e2.substring(u2, h2)), u2 = h2, t3 = d2 + 1, c2 = -1, g2 = 0) : (l2.push(e2.substring(u2, i4)), u2 = i4, g2 = p2) : g2 += p2;
    }
    return u2 < e2.length && l2.push(e2.substring(u2, e2.length)), l2;
  }
  async extractTextContent(e2, t2, i2) {
    await super.extractTextContent(e2, t2, i2);
    const n2 = this.data.textContent;
    if (!n2) return;
    const a2 = n2.join("\n");
    if (a2 === this.data.fieldValue) return;
    const s2 = a2.replaceAll(/([.*+?^${}()|[\]\\])|(\s+)/g, (e3, t3) => t3 ? `\\${t3}` : "\\s+");
    new RegExp(`^\\s*${s2}\\s*$`).test(this.data.fieldValue) && (this.data.textContent = this.data.fieldValue.split("\n"));
  }
  getFieldObject() {
    return { id: this.data.id, value: this.data.fieldValue, defaultValue: this.data.defaultFieldValue || "", multiline: this.data.multiLine, password: this.data.password, charLimit: this.data.maxLen, comb: this.data.comb, editable: !this.data.readOnly, hidden: this.data.hidden, name: this.data.fieldName, rect: this.data.rect, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, datetimeFormat: this.data.datetimeFormat, hasDatetimeHTML: !!this.data.datetimeType, type: "text" };
  }
}
class ButtonWidgetAnnotation extends WidgetAnnotation {
  constructor(e2) {
    super(e2), this.checkedAppearance = null, this.uncheckedAppearance = null;
    const t2 = this.hasFieldFlag(X), i2 = this.hasFieldFlag(q);
    this.data.checkBox = !t2 && !i2, this.data.radioButton = t2 && !i2, this.data.pushButton = i2, this.data.isTooltipOnly = false, this.data.checkBox ? this._processCheckBox(e2) : this.data.radioButton ? this._processRadioButton(e2) : this.data.pushButton ? (this.data.hasOwnCanvas = true, this.data.noHTML = false, this._processPushButton(e2)) : warn$1("Invalid field flags for button widget annotation");
  }
  async getOperatorList(e2, t2, i2, n2) {
    if (this.data.pushButton) return super.getOperatorList(e2, t2, i2, false, n2);
    let a2 = null, s2 = null;
    if (n2) {
      const e3 = n2.get(this.data.id);
      a2 = e3 ? e3.value : null, s2 = e3 ? e3.rotation : null;
    }
    if (null === a2 && this.appearance) return super.getOperatorList(e2, t2, i2, n2);
    null == a2 && (a2 = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
    const r2 = a2 ? this.checkedAppearance : this.uncheckedAppearance;
    if (r2) {
      const a3 = this.appearance, o2 = lookupMatrix(r2.dict.getArray("Matrix"), pi);
      s2 && r2.dict.set("Matrix", this.getRotationMatrix(n2)), this.appearance = r2;
      const l2 = super.getOperatorList(e2, t2, i2, n2);
      return this.appearance = a3, r2.dict.set("Matrix", o2), l2;
    }
    return { opList: new OperatorList(), separateForm: false, separateCanvas: false };
  }
  async save(e2, t2, i2, n2) {
    this.data.checkBox ? this._saveCheckbox(e2, t2, i2, n2) : this.data.radioButton && this._saveRadioButton(e2, t2, i2, n2);
  }
  async _saveCheckbox(e2, t2, i2, n2) {
    if (!i2) return;
    const a2 = i2.get(this.data.id), s2 = this._buildFlags(a2?.noView, a2?.noPrint);
    let r2 = a2?.rotation, o2 = a2?.value;
    if (void 0 === r2 && void 0 === s2) {
      if (void 0 === o2) return;
      if (this.data.fieldValue === this.data.exportValue === o2) return;
    }
    let l2 = e2.xref.fetchIfRef(this.ref);
    if (!(l2 instanceof Dict)) return;
    l2 = l2.clone(), void 0 === r2 && (r2 = this.rotation), void 0 === o2 && (o2 = this.data.fieldValue === this.data.exportValue);
    const c2 = { path: this.data.fieldName, value: o2 ? this.data.exportValue : "" }, h2 = Name.get(o2 ? this.data.exportValue : "Off");
    this.setValue(l2, h2, e2.xref, n2), l2.set("AS", h2), l2.set("M", `D:${getModificationDate()}`), void 0 !== s2 && l2.set("F", s2);
    const d2 = this._getMKDict(r2);
    d2 && l2.set("MK", d2), n2.put(this.ref, { data: l2, xfa: c2, needAppearances: false });
  }
  async _saveRadioButton(e2, t2, i2, n2) {
    if (!i2) return;
    const a2 = i2.get(this.data.id), s2 = this._buildFlags(a2?.noView, a2?.noPrint);
    let r2 = a2?.rotation, o2 = a2?.value;
    if (void 0 === r2 && void 0 === s2) {
      if (void 0 === o2) return;
      if (this.data.fieldValue === this.data.buttonValue === o2) return;
    }
    let l2 = e2.xref.fetchIfRef(this.ref);
    if (!(l2 instanceof Dict)) return;
    l2 = l2.clone(), void 0 === o2 && (o2 = this.data.fieldValue === this.data.buttonValue), void 0 === r2 && (r2 = this.rotation);
    const c2 = { path: this.data.fieldName, value: o2 ? this.data.buttonValue : "" }, h2 = Name.get(o2 ? this.data.buttonValue : "Off");
    o2 && this.setValue(l2, h2, e2.xref, n2), l2.set("AS", h2), l2.set("M", `D:${getModificationDate()}`), void 0 !== s2 && l2.set("F", s2);
    const d2 = this._getMKDict(r2);
    d2 && l2.set("MK", d2), n2.put(this.ref, { data: l2, xfa: c2, needAppearances: false });
  }
  _getDefaultCheckedAppearance(e2, t2) {
    const { width: i2, height: n2 } = this, a2 = [0, 0, i2, n2], s2 = 0.8 * Math.min(i2, n2);
    let r2, o2;
    "check" === t2 ? (r2 = { width: 0.755 * s2, height: 0.705 * s2 }, o2 = "3") : "disc" === t2 ? (r2 = { width: 0.791 * s2, height: 0.705 * s2 }, o2 = "l") : unreachable$1(`_getDefaultCheckedAppearance - unsupported type: ${t2}`);
    const l2 = `q BT /PdfJsZaDb ${s2} Tf 0 g ${numberToString((i2 - r2.width) / 2)} ${numberToString((n2 - r2.height) / 2)} Td (${o2}) Tj ET Q`, c2 = new Dict(e2.xref);
    c2.set("FormType", 1), c2.setIfName("Subtype", "Form"), c2.setIfName("Type", "XObject"), c2.set("BBox", a2), c2.set("Matrix", [1, 0, 0, 1, 0, 0]), c2.set("Length", l2.length);
    const h2 = new Dict(e2.xref), d2 = new Dict(e2.xref);
    d2.set("PdfJsZaDb", this.fallbackFontDict), h2.set("Font", d2), c2.set("Resources", h2), this.checkedAppearance = new StringStream(l2), this.checkedAppearance.dict = c2, this._streams.push(this.checkedAppearance);
  }
  _processCheckBox(e2) {
    const t2 = e2.dict.get("AP");
    if (!(t2 instanceof Dict)) return;
    const i2 = t2.get("N");
    if (!(i2 instanceof Dict)) return;
    const n2 = this._decodeFormValue(e2.dict.get("AS"));
    "string" == typeof n2 && (this.data.fieldValue = n2);
    const a2 = null !== this.data.fieldValue && "Off" !== this.data.fieldValue ? this.data.fieldValue : "Yes", s2 = this._decodeFormValue(i2.getKeys());
    if (0 === s2.length) s2.push("Off", a2);
    else if (1 === s2.length) "Off" === s2[0] ? s2.push(a2) : s2.unshift("Off");
    else if (s2.includes(a2)) s2.length = 0, s2.push("Off", a2);
    else {
      const e3 = s2.find((e4) => "Off" !== e4);
      s2.length = 0, s2.push("Off", e3);
    }
    s2.includes(this.data.fieldValue) || (this.data.fieldValue = "Off"), this.data.exportValue = s2[1];
    const r2 = i2.get(this.data.exportValue);
    this.checkedAppearance = r2 instanceof BaseStream ? r2 : null;
    const o2 = i2.get("Off");
    this.uncheckedAppearance = o2 instanceof BaseStream ? o2 : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e2, "check"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
  }
  _processRadioButton(e2) {
    this.data.buttonValue = null;
    const t2 = e2.dict.get("Parent");
    if (t2 instanceof Dict) {
      this.parent = e2.dict.getRaw("Parent");
      const i3 = t2.get("V");
      i3 instanceof Name && (this.data.fieldValue = this._decodeFormValue(i3));
    }
    const i2 = e2.dict.get("AP");
    if (!(i2 instanceof Dict)) return;
    const n2 = i2.get("N");
    if (!(n2 instanceof Dict)) return;
    for (const e3 of n2.getKeys()) if ("Off" !== e3) {
      this.data.buttonValue = this._decodeFormValue(e3);
      break;
    }
    const a2 = n2.get(this.data.buttonValue);
    this.checkedAppearance = a2 instanceof BaseStream ? a2 : null;
    const s2 = n2.get("Off");
    this.uncheckedAppearance = s2 instanceof BaseStream ? s2 : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e2, "disc"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
  }
  _processPushButton(e2) {
    const { dict: t2, annotationGlobals: i2 } = e2;
    t2.has("A") || t2.has("AA") || this.data.alternativeText ? (this.data.isTooltipOnly = !t2.has("A") && !t2.has("AA"), Catalog.parseDestDictionary({ destDict: t2, resultObj: this.data, docBaseUrl: i2.baseUrl, docAttachments: i2.attachments })) : warn$1("Push buttons without action dictionaries are not supported");
  }
  getFieldObject() {
    let e2, t2 = "button";
    return this.data.checkBox ? (t2 = "checkbox", e2 = this.data.exportValue) : this.data.radioButton && (t2 = "radiobutton", e2 = this.data.buttonValue), { id: this.data.id, value: this.data.fieldValue || "Off", defaultValue: this.data.defaultFieldValue, exportValues: e2, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, hidden: this.data.hidden, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: t2 };
  }
  get fallbackFontDict() {
    const e2 = new Dict();
    return e2.setIfName("BaseFont", "ZapfDingbats"), e2.setIfName("Type", "FallbackType"), e2.setIfName("Subtype", "FallbackType"), e2.setIfName("Encoding", "ZapfDingbatsEncoding"), shadow$1(this, "fallbackFontDict", e2);
  }
}
class ChoiceWidgetAnnotation extends WidgetAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    this.indices = t2.getArray("I"), this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0, this.data.options = [];
    const n2 = getInheritableProperty({ dict: t2, key: "Opt" });
    if (Array.isArray(n2)) for (let e3 = 0, t3 = n2.length; e3 < t3; e3++) {
      const t4 = i2.fetchIfRef(n2[e3]), a2 = Array.isArray(t4);
      this.data.options[e3] = { exportValue: this._decodeFormValue(a2 ? i2.fetchIfRef(t4[0]) : t4), displayValue: this._decodeFormValue(a2 ? i2.fetchIfRef(t4[1]) : t4) };
    }
    if (this.hasIndices) {
      this.data.fieldValue = [];
      const e3 = this.data.options.length;
      for (const t3 of this.indices) Number.isInteger(t3) && t3 >= 0 && t3 < e3 && this.data.fieldValue.push(this.data.options[t3].exportValue);
    } else "string" == typeof this.data.fieldValue ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue ||= [];
    0 === this.data.options.length && this.data.fieldValue.length > 0 && (this.data.options = this.data.fieldValue.map((e3) => ({ exportValue: e3, displayValue: e3 }))), this.data.combo = this.hasFieldFlag(z), this.data.multiSelect = this.hasFieldFlag(G), this._hasText = true;
  }
  getFieldObject() {
    const e2 = this.data.combo ? "combobox" : "listbox", t2 = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
    return { id: this.data.id, value: t2, defaultValue: this.data.defaultFieldValue, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, numItems: this.data.fieldValue.length, multipleSelection: this.data.multiSelect, hidden: this.data.hidden, actions: this.data.actions, items: this.data.options, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: e2 };
  }
  amendSavedDict(e2, t2) {
    if (!this.hasIndices) return;
    let i2 = e2?.get(this.data.id)?.value;
    Array.isArray(i2) || (i2 = [i2]);
    const n2 = [], { options: a2 } = this.data;
    for (let e3 = 0, t3 = 0, s2 = a2.length; e3 < s2; e3++) a2[e3].exportValue === i2[t3] && (n2.push(e3), t3 += 1);
    t2.set("I", n2);
  }
  async _getAppearance(e2, t2, n2, a2) {
    if (this.data.combo) return super._getAppearance(e2, t2, n2, a2);
    let s2, r2;
    const o2 = a2?.get(this.data.id);
    if (o2 && (r2 = o2.rotation, s2 = o2.value), void 0 === r2 && void 0 === s2 && !this._needAppearances) return null;
    void 0 === s2 ? s2 = this.data.fieldValue : Array.isArray(s2) || (s2 = [s2]);
    let { width: l2, height: c2 } = this;
    90 !== r2 && 270 !== r2 || ([l2, c2] = [c2, l2]);
    const h2 = this.data.options.length, d2 = [];
    for (let e3 = 0; e3 < h2; e3++) {
      const { exportValue: t3 } = this.data.options[e3];
      s2.includes(t3) && d2.push(e3);
    }
    this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
    const u2 = await WidgetAnnotation._getFontData(e2, t2, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
    let g2, { fontSize: f2 } = this.data.defaultAppearanceData;
    if (f2) g2 = this._defaultAppearance;
    else {
      const e3 = (c2 - 1) / h2;
      let t3, i2 = -1;
      for (const { displayValue: e4 } of this.data.options) {
        const n3 = this._getTextWidth(e4, u2);
        n3 > i2 && (i2 = n3, t3 = e4);
      }
      [g2, f2] = this._computeFontSize(e3, l2 - 4, t3, u2, -1);
    }
    const p2 = f2 * i, m2 = (p2 - f2) / 2, b2 = Math.floor(c2 / p2);
    let y2 = 0;
    if (d2.length > 0) {
      const e3 = Math.min(...d2), t3 = Math.max(...d2);
      y2 = Math.max(0, t3 - b2 + 1), y2 > e3 && (y2 = e3);
    }
    const w2 = Math.min(y2 + b2 + 1, h2), x2 = ["/Tx BMC q", `1 1 ${l2} ${c2} re W n`];
    if (d2.length) {
      x2.push("0.600006 0.756866 0.854904 rg");
      for (const e3 of d2) y2 <= e3 && e3 < w2 && x2.push(`1 ${c2 - (e3 - y2 + 1) * p2} ${l2} ${p2} re f`);
    }
    x2.push("BT", g2, `1 0 0 1 0 ${c2} Tm`);
    const S2 = { shift: 0 };
    for (let e3 = y2; e3 < w2; e3++) {
      const { displayValue: t3 } = this.data.options[e3], i2 = e3 === y2 ? m2 : 0;
      x2.push(this._renderText(t3, u2, f2, l2, 0, S2, 2, -p2 + i2));
    }
    return x2.push("ET Q EMC"), x2.join("\n");
  }
}
class SignatureWidgetAnnotation extends WidgetAnnotation {
  constructor(e2) {
    super(e2), this.data.fieldValue = null, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !this.data.hasOwnCanvas;
  }
  getFieldObject() {
    return { id: this.data.id, value: null, page: this.data.pageIndex, type: "signature" };
  }
}
class TextAnnotation extends MarkupAnnotation {
  constructor(e2) {
    super(e2), this.data.noRotate = true, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false;
    const { dict: t2 } = e2;
    this.data.annotationType = T.TEXT, this.data.hasAppearance ? this.data.name = "NoIcon" : (this.data.rect[1] = this.data.rect[3] - 22, this.data.rect[2] = this.data.rect[0] + 22, this.data.name = t2.has("Name") ? t2.get("Name").name : "Note"), t2.has("State") ? (this.data.state = t2.get("State") || null, this.data.stateModel = t2.get("StateModel") || null) : (this.data.state = null, this.data.stateModel = null);
  }
}
class LinkAnnotation extends Annotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, annotationGlobals: i2 } = e2;
    this.data.annotationType = T.LINK, this.data.noHTML = false;
    const n2 = getQuadPoints(t2, this.rectangle);
    n2 && (this.data.quadPoints = n2), this.data.borderColor ||= this.data.color, Catalog.parseDestDictionary({ destDict: t2, resultObj: this.data, docBaseUrl: i2.baseUrl, docAttachments: i2.attachments });
  }
  get overlaysTextContent() {
    return true;
  }
}
class PopupAnnotation extends Annotation {
  constructor(e2) {
    super(e2);
    const { dict: t2 } = e2;
    this.data.annotationType = T.POPUP, this.data.noHTML = false, 0 !== this.width && 0 !== this.height || (this.data.rect = null);
    let i2 = t2.get("Parent");
    if (!i2) return void warn$1("Popup annotation has a missing or invalid parent annotation.");
    this.data.parentRect = lookupNormalRect(i2.getArray("Rect"), null), this.data.creationDate = i2.get("CreationDate") || "";
    if (isName(i2.get("RT"), F) && (i2 = i2.get("IRT")), i2.has("M") ? (this.setModificationDate(i2.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, i2.has("C") ? (this.setColor(i2.getArray("C")), this.data.color = this.color) : this.data.color = null, !this.viewable) {
      const e3 = i2.get("F");
      this._isViewable(e3) && this.setFlags(e3);
    }
    this.setTitle(i2.get("T")), this.data.titleObj = this._title, this.setContents(i2.get("Contents")), this.data.contentsObj = this._contents, i2.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(i2.get("RC"))), this.data.open = !!t2.get("Open");
  }
  static createNewDict(e2, t2, i2) {
    const { oldAnnotation: n2, rect: a2, parent: s2 } = e2, r2 = n2 || new Dict(t2);
    return r2.setIfNotExists("Type", Name.get("Annot")), r2.setIfNotExists("Subtype", Name.get("Popup")), r2.setIfNotExists("Open", false), r2.setIfArray("Rect", a2), r2.set("Parent", s2), r2;
  }
  static async createNewAppearanceStream(e2, t2, i2) {
    return null;
  }
}
class FreeTextAnnotation extends MarkupAnnotation {
  constructor(e2) {
    super(e2), this.data.hasOwnCanvas = this.data.noRotate, this.data.isEditable = !this.data.noHTML, this.data.noHTML = false;
    const { annotationGlobals: t2, evaluatorOptions: i2, xref: n2 } = e2;
    if (this.data.annotationType = T.FREETEXT, this.setDefaultAppearance(e2), this._hasAppearance = !!this.appearance, this._hasAppearance) {
      const { fontColor: e3, fontSize: a2 } = (function(e4, t3, i3, n3) {
        return new AppearanceStreamEvaluator(e4, t3, i3, n3).parse();
      })(this.appearance, i2, n2, t2.globalColorSpaceCache);
      this.data.defaultAppearanceData.fontColor = e3, this.data.defaultAppearanceData.fontSize = a2 || 10;
    } else {
      this.data.defaultAppearanceData.fontSize ||= 10;
      const { fontColor: t3, fontSize: i3 } = this.data.defaultAppearanceData;
      if (this._contents.str) {
        this.data.textContent = this._contents.str.split(/\r\n?|\n/).map((e4) => e4.trimEnd());
        const { coords: e3, bbox: t4, matrix: n3 } = FakeUnicodeFont.getFirstPositionInfo(this.rectangle, this.rotation, i3);
        this.data.textPosition = this._transformPoint(e3, t4, n3);
      }
      if (this._isOffscreenCanvasSupported) {
        const a2 = e2.dict.get("CA"), s2 = new FakeUnicodeFont(n2, "sans-serif");
        this.appearance = s2.createAppearance(this._contents.str, this.rectangle, this.rotation, i3, t3, a2), this._streams.push(this.appearance);
      } else warn$1("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
    }
  }
  get hasTextContent() {
    return this._hasAppearance;
  }
  static createNewDict(e2, t2, { apRef: i2, ap: n2 }) {
    const { color: a2, date: s2, fontSize: r2, oldAnnotation: o2, rect: l2, rotation: c2, user: h2, value: d2 } = e2, u2 = o2 || new Dict(t2);
    u2.setIfNotExists("Type", Name.get("Annot")), u2.setIfNotExists("Subtype", Name.get("FreeText")), u2.set(o2 ? "M" : "CreationDate", `D:${getModificationDate(s2)}`), o2 && u2.delete("RC"), u2.setIfArray("Rect", l2);
    const g2 = `/Helv ${r2} Tf ${getPdfColor(a2, true)}`;
    if (u2.set("DA", g2), u2.setIfDefined("Contents", stringToAsciiOrUTF16BE(d2)), u2.setIfNotExists("F", 4), u2.setIfNotExists("Border", [0, 0, 0]), u2.setIfNumber("Rotate", c2), u2.setIfDefined("T", stringToAsciiOrUTF16BE(h2)), i2 || n2) {
      const e3 = new Dict(t2);
      u2.set("AP", e3), e3.set("N", i2 || n2);
    }
    return u2;
  }
  static async createNewAppearanceStream(e2, t2, n2) {
    const { baseFontRef: a2, evaluator: s2, task: r2 } = n2, { color: o2, fontSize: l2, rect: c2, rotation: h2, value: d2 } = e2;
    if (!o2) return null;
    const u2 = new Dict(t2), g2 = new Dict(t2);
    if (a2) g2.set("Helv", a2);
    else {
      const e3 = new Dict(t2);
      e3.setIfName("BaseFont", "Helvetica"), e3.setIfName("Type", "Font"), e3.setIfName("Subtype", "Type1"), e3.setIfName("Encoding", "WinAnsiEncoding"), g2.set("Helv", e3);
    }
    u2.set("Font", g2);
    const f2 = await WidgetAnnotation._getFontData(s2, r2, { fontName: "Helv", fontSize: l2 }, u2), [p2, m2, b2, y2] = c2;
    let w2 = b2 - p2, x2 = y2 - m2;
    h2 % 180 != 0 && ([w2, x2] = [x2, w2]);
    const S2 = d2.split("\n"), v2 = l2 / 1e3;
    let C2 = -1 / 0;
    const k2 = [];
    for (let e3 of S2) {
      const t3 = f2.encodeString(e3);
      if (t3.length > 1) return null;
      e3 = t3.join(""), k2.push(e3);
      let i2 = 0;
      const n3 = f2.charsToGlyphs(e3);
      for (const e4 of n3) i2 += e4.width * v2;
      C2 = Math.max(C2, i2);
    }
    let T2 = 1;
    C2 > w2 && (T2 = w2 / C2);
    let F2 = 1;
    const E2 = i * l2, M2 = 1 * l2, D2 = E2 * S2.length;
    D2 > x2 && (F2 = x2 / D2);
    const O2 = l2 * Math.min(T2, F2);
    let _2, R2, N2;
    switch (h2) {
      case 0:
        N2 = [1, 0, 0, 1], R2 = [c2[0], c2[1], w2, x2], _2 = [c2[0], c2[3] - M2];
        break;
      case 90:
        N2 = [0, 1, -1, 0], R2 = [c2[1], -c2[2], w2, x2], _2 = [c2[1], -c2[0] - M2];
        break;
      case 180:
        N2 = [-1, 0, 0, -1], R2 = [-c2[2], -c2[3], w2, x2], _2 = [-c2[2], -c2[1] - M2];
        break;
      case 270:
        N2 = [0, -1, 1, 0], R2 = [-c2[3], c2[0], w2, x2], _2 = [-c2[3], c2[2] - M2];
    }
    const L2 = ["q", `${N2.join(" ")} 0 0 cm`, `${R2.join(" ")} re W n`, "BT", `${getPdfColor(o2, true)}`, `0 Tc /Helv ${numberToString(O2)} Tf`];
    L2.push(`${_2.join(" ")} Td (${escapeString(k2[0])}) Tj`);
    const U2 = numberToString(E2);
    for (let e3 = 1, t3 = k2.length; e3 < t3; e3++) {
      const t4 = k2[e3];
      L2.push(`0 -${U2} Td (${escapeString(t4)}) Tj`);
    }
    L2.push("ET", "Q");
    const j2 = L2.join("\n"), $2 = new Dict(t2);
    $2.set("FormType", 1), $2.setIfName("Subtype", "Form"), $2.setIfName("Type", "XObject"), $2.set("BBox", c2), $2.set("Resources", u2), $2.set("Matrix", [1, 0, 0, 1, -c2[0], -c2[1]]);
    const H2 = new StringStream(j2);
    return H2.dict = $2, H2;
  }
}
class LineAnnotation extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    this.data.annotationType = T.LINE, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false;
    const n2 = lookupRect(t2.getArray("L"), [0, 0, 0, 0]);
    if (this.data.lineCoordinates = ai.normalizeRect(n2), this.setLineEndings(t2.getArray("LE")), this.data.lineEndings = this.lineEndings, !this.appearance) {
      const e3 = getPdfColorArray(this.color, [0, 0, 0]), a2 = t2.get("CA"), s2 = getPdfColorArray(getRgbColor(t2.getArray("IC"), null)), r2 = s2 ? a2 : null, o2 = this.borderStyle.width || 1, l2 = 2 * o2, c2 = [this.data.lineCoordinates[0] - l2, this.data.lineCoordinates[1] - l2, this.data.lineCoordinates[2] + l2, this.data.lineCoordinates[3] + l2];
      ai.intersect(this.rectangle, c2) || (this.rectangle = c2), this._setDefaultAppearance({ xref: i2, extra: `${o2} w`, strokeColor: e3, fillColor: s2, strokeAlpha: a2, fillAlpha: r2, pointsCallback: (e4, t3) => (e4.push(`${n2[0]} ${n2[1]} m`, `${n2[2]} ${n2[3]} l`, "S"), [t3[0] - o2, t3[7] - o2, t3[2] + o2, t3[3] + o2]) });
    }
  }
}
class SquareAnnotation extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    if (this.data.annotationType = T.SQUARE, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false, !this.appearance) {
      const e3 = getPdfColorArray(this.color, [0, 0, 0]), n2 = t2.get("CA"), a2 = getPdfColorArray(getRgbColor(t2.getArray("IC"), null)), s2 = a2 ? n2 : null;
      if (0 === this.borderStyle.width && !a2) return;
      this._setDefaultAppearance({ xref: i2, extra: `${this.borderStyle.width} w`, strokeColor: e3, fillColor: a2, strokeAlpha: n2, fillAlpha: s2, pointsCallback: (e4, t3) => {
        const i3 = t3[4] + this.borderStyle.width / 2, n3 = t3[5] + this.borderStyle.width / 2, s3 = t3[6] - t3[4] - this.borderStyle.width, r2 = t3[3] - t3[7] - this.borderStyle.width;
        return e4.push(`${i3} ${n3} ${s3} ${r2} re`), a2 ? e4.push("B") : e4.push("S"), [t3[0], t3[7], t3[2], t3[3]];
      } });
    }
  }
}
class CircleAnnotation extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    if (this.data.annotationType = T.CIRCLE, !this.appearance) {
      const e3 = getPdfColorArray(this.color, [0, 0, 0]), n2 = t2.get("CA"), a2 = getPdfColorArray(getRgbColor(t2.getArray("IC"), null)), s2 = a2 ? n2 : null;
      if (0 === this.borderStyle.width && !a2) return;
      const r2 = 4 / 3 * Math.tan(Math.PI / 8);
      this._setDefaultAppearance({ xref: i2, extra: `${this.borderStyle.width} w`, strokeColor: e3, fillColor: a2, strokeAlpha: n2, fillAlpha: s2, pointsCallback: (e4, t3) => {
        const i3 = t3[0] + this.borderStyle.width / 2, n3 = t3[1] - this.borderStyle.width / 2, s3 = t3[6] - this.borderStyle.width / 2, o2 = t3[7] + this.borderStyle.width / 2, l2 = i3 + (s3 - i3) / 2, c2 = n3 + (o2 - n3) / 2, h2 = (s3 - i3) / 2 * r2, d2 = (o2 - n3) / 2 * r2;
        return e4.push(`${l2} ${o2} m`, `${l2 + h2} ${o2} ${s3} ${c2 + d2} ${s3} ${c2} c`, `${s3} ${c2 - d2} ${l2 + h2} ${n3} ${l2} ${n3} c`, `${l2 - h2} ${n3} ${i3} ${c2 - d2} ${i3} ${c2} c`, `${i3} ${c2 + d2} ${l2 - h2} ${o2} ${l2} ${o2} c`, "h"), a2 ? e4.push("B") : e4.push("S"), [t3[0], t3[7], t3[2], t3[3]];
      } });
    }
  }
}
class PolylineAnnotation extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    this.data.annotationType = T.POLYLINE, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false, this.data.vertices = null, this instanceof PolygonAnnotation || (this.setLineEndings(t2.getArray("LE")), this.data.lineEndings = this.lineEndings);
    const n2 = t2.getArray("Vertices");
    if (!isNumberArray(n2, null)) return;
    const a2 = this.data.vertices = Float32Array.from(n2);
    if (!this.appearance) {
      const e3 = getPdfColorArray(this.color, [0, 0, 0]), n3 = t2.get("CA");
      let s2, r2 = getRgbColor(t2.getArray("IC"), null);
      r2 && (r2 = getPdfColorArray(r2)), s2 = r2 ? this.color ? r2.every((t3, i3) => t3 === e3[i3]) ? "f" : "B" : "f" : "S";
      const o2 = this.borderStyle.width || 1, l2 = 2 * o2, c2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      for (let e4 = 0, t3 = a2.length; e4 < t3; e4 += 2) ai.rectBoundingBox(a2[e4] - l2, a2[e4 + 1] - l2, a2[e4] + l2, a2[e4 + 1] + l2, c2);
      ai.intersect(this.rectangle, c2) || (this.rectangle = c2), this._setDefaultAppearance({ xref: i2, extra: `${o2} w`, strokeColor: e3, strokeAlpha: n3, fillColor: r2, fillAlpha: r2 ? n3 : null, pointsCallback: (e4, t3) => {
        for (let t4 = 0, i3 = a2.length; t4 < i3; t4 += 2) e4.push(`${a2[t4]} ${a2[t4 + 1]} ${0 === t4 ? "m" : "l"}`);
        return e4.push(s2), [t3[0], t3[7], t3[2], t3[3]];
      } });
    }
  }
}
class PolygonAnnotation extends PolylineAnnotation {
  constructor(e2) {
    super(e2), this.data.annotationType = T.POLYGON;
  }
}
class CaretAnnotation extends MarkupAnnotation {
  constructor(e2) {
    super(e2), this.data.annotationType = T.CARET;
  }
}
class InkAnnotation extends MarkupAnnotation {
  constructor(e2) {
    super(e2), this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false;
    const { dict: t2, xref: i2 } = e2;
    this.data.annotationType = T.INK, this.data.inkLists = [], this.data.isEditable = !this.data.noHTML, this.data.noHTML = false, this.data.opacity = t2.get("CA") || 1;
    const n2 = t2.getArray("InkList");
    if (Array.isArray(n2)) {
      for (let e3 = 0, t3 = n2.length; e3 < t3; ++e3) {
        if (!Array.isArray(n2[e3])) continue;
        const t4 = new Float32Array(n2[e3].length);
        this.data.inkLists.push(t4);
        for (let a2 = 0, s2 = n2[e3].length; a2 < s2; a2 += 2) {
          const s3 = i2.fetchIfRef(n2[e3][a2]), r2 = i2.fetchIfRef(n2[e3][a2 + 1]);
          "number" == typeof s3 && "number" == typeof r2 && (t4[a2] = s3, t4[a2 + 1] = r2);
        }
      }
      if (!this.appearance) {
        const e3 = getPdfColorArray(this.color, [0, 0, 0]), n3 = t2.get("CA"), a2 = this.borderStyle.width || 1, s2 = 2 * a2, r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const e4 of this.data.inkLists) for (let t3 = 0, i3 = e4.length; t3 < i3; t3 += 2) ai.rectBoundingBox(e4[t3] - s2, e4[t3 + 1] - s2, e4[t3] + s2, e4[t3 + 1] + s2, r2);
        ai.intersect(this.rectangle, r2) || (this.rectangle = r2), this._setDefaultAppearance({ xref: i2, extra: `${a2} w`, strokeColor: e3, strokeAlpha: n3, pointsCallback: (e4, t3) => {
          for (const t4 of this.data.inkLists) {
            for (let i3 = 0, n4 = t4.length; i3 < n4; i3 += 2) e4.push(`${t4[i3]} ${t4[i3 + 1]} ${0 === i3 ? "m" : "l"}`);
            e4.push("S");
          }
          return [t3[0], t3[7], t3[2], t3[3]];
        } });
      }
    }
  }
  static createNewDict(e2, t2, { apRef: i2, ap: n2 }) {
    const { oldAnnotation: a2, color: s2, date: r2, opacity: o2, paths: l2, outlines: c2, rect: h2, rotation: d2, thickness: u2, user: g2 } = e2, f2 = a2 || new Dict(t2);
    if (f2.setIfNotExists("Type", Name.get("Annot")), f2.setIfNotExists("Subtype", Name.get("Ink")), f2.set(a2 ? "M" : "CreationDate", `D:${getModificationDate(r2)}`), f2.setIfArray("Rect", h2), f2.setIfArray("InkList", c2?.points || l2?.points), f2.setIfNotExists("F", 4), f2.setIfNumber("Rotate", d2), f2.setIfDefined("T", stringToAsciiOrUTF16BE(g2)), c2 && f2.setIfName("IT", "InkHighlight"), u2 > 0) {
      const e3 = new Dict(t2);
      f2.set("BS", e3), e3.set("W", u2);
    }
    if (f2.setIfArray("C", getPdfColorArray(s2)), f2.setIfNumber("CA", o2), n2 || i2) {
      const e3 = new Dict(t2);
      f2.set("AP", e3), e3.set("N", i2 || n2);
    }
    return f2;
  }
  static async createNewAppearanceStream(e2, t2, i2) {
    if (e2.outlines) return this.createNewAppearanceStreamForHighlight(e2, t2, i2);
    const { color: n2, rect: a2, paths: s2, thickness: r2, opacity: o2 } = e2;
    if (!n2) return null;
    const l2 = [`${r2} w 1 J 1 j`, `${getPdfColor(n2, false)}`];
    1 !== o2 && l2.push("/R0 gs");
    for (const e3 of s2.lines) {
      l2.push(`${numberToString(e3[4])} ${numberToString(e3[5])} m`);
      for (let t3 = 6, i3 = e3.length; t3 < i3; t3 += 6) if (isNaN(e3[t3])) l2.push(`${numberToString(e3[t3 + 4])} ${numberToString(e3[t3 + 5])} l`);
      else {
        const [i4, n3, a3, s3, r3, o3] = e3.slice(t3, t3 + 6);
        l2.push([i4, n3, a3, s3, r3, o3].map(numberToString).join(" ") + " c");
      }
      6 === e3.length && l2.push(`${numberToString(e3[4])} ${numberToString(e3[5])} l`);
    }
    l2.push("S");
    const c2 = l2.join("\n"), h2 = new Dict(t2);
    if (h2.set("FormType", 1), h2.setIfName("Subtype", "Form"), h2.setIfName("Type", "XObject"), h2.set("BBox", a2), h2.set("Length", c2.length), 1 !== o2) {
      const e3 = new Dict(t2), i3 = new Dict(t2), n3 = new Dict(t2);
      n3.set("CA", o2), n3.setIfName("Type", "ExtGState"), i3.set("R0", n3), e3.set("ExtGState", i3), h2.set("Resources", e3);
    }
    const d2 = new StringStream(c2);
    return d2.dict = h2, d2;
  }
  static async createNewAppearanceStreamForHighlight(e2, t2, i2) {
    const { color: n2, rect: a2, outlines: { outline: s2 }, opacity: r2 } = e2;
    if (!n2) return null;
    const o2 = [`${getPdfColor(n2, true)}`, "/R0 gs"];
    o2.push(`${numberToString(s2[4])} ${numberToString(s2[5])} m`);
    for (let e3 = 6, t3 = s2.length; e3 < t3; e3 += 6) if (isNaN(s2[e3])) o2.push(`${numberToString(s2[e3 + 4])} ${numberToString(s2[e3 + 5])} l`);
    else {
      const [t4, i3, n3, a3, r3, l3] = s2.slice(e3, e3 + 6);
      o2.push([t4, i3, n3, a3, r3, l3].map(numberToString).join(" ") + " c");
    }
    o2.push("h f");
    const l2 = o2.join("\n"), c2 = new Dict(t2);
    c2.set("FormType", 1), c2.setIfName("Subtype", "Form"), c2.setIfName("Type", "XObject"), c2.set("BBox", a2), c2.set("Length", l2.length);
    const h2 = new Dict(t2), d2 = new Dict(t2);
    h2.set("ExtGState", d2), c2.set("Resources", h2);
    const u2 = new Dict(t2);
    d2.set("R0", u2), u2.setIfName("BM", "Multiply"), 1 !== r2 && (u2.set("ca", r2), u2.setIfName("Type", "ExtGState"));
    const g2 = new StringStream(l2);
    return g2.dict = c2, g2;
  }
}
class HighlightAnnotation extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    this.data.annotationType = T.HIGHLIGHT, this.data.isEditable = !this.data.noHTML, this.data.noHTML = false, this.data.opacity = t2.get("CA") || 1;
    if (this.data.quadPoints = getQuadPoints(t2, null)) {
      const e3 = this.appearance?.dict.get("Resources");
      if (!this.appearance || !e3?.has("ExtGState")) {
        this.appearance && warn$1("HighlightAnnotation - ignoring built-in appearance stream.");
        const e4 = getPdfColorArray(this.color, [1, 1, 0]), n2 = t2.get("CA");
        this._setDefaultAppearance({ xref: i2, fillColor: e4, blendMode: "Multiply", fillAlpha: n2, pointsCallback: (e5, t3) => (e5.push(`${t3[0]} ${t3[1]} m`, `${t3[2]} ${t3[3]} l`, `${t3[6]} ${t3[7]} l`, `${t3[4]} ${t3[5]} l`, "f"), [t3[0], t3[7], t3[2], t3[3]]) });
      }
    } else this.data.popupRef = null;
  }
  get overlaysTextContent() {
    return true;
  }
  static createNewDict(e2, t2, { apRef: i2, ap: n2 }) {
    const { color: a2, date: s2, oldAnnotation: r2, opacity: o2, rect: l2, rotation: c2, user: h2, quadPoints: d2 } = e2, u2 = r2 || new Dict(t2);
    if (u2.setIfNotExists("Type", Name.get("Annot")), u2.setIfNotExists("Subtype", Name.get("Highlight")), u2.set(r2 ? "M" : "CreationDate", `D:${getModificationDate(s2)}`), u2.setIfArray("Rect", l2), u2.setIfNotExists("F", 4), u2.setIfNotExists("Border", [0, 0, 0]), u2.setIfNumber("Rotate", c2), u2.setIfArray("QuadPoints", d2), u2.setIfArray("C", getPdfColorArray(a2)), u2.setIfNumber("CA", o2), u2.setIfDefined("T", stringToAsciiOrUTF16BE(h2)), i2 || n2) {
      const e3 = new Dict(t2);
      u2.set("AP", e3), e3.set("N", i2 || n2);
    }
    return u2;
  }
  static async createNewAppearanceStream(e2, t2, i2) {
    const { color: n2, rect: a2, outlines: s2, opacity: r2 } = e2;
    if (!n2) return null;
    const o2 = [`${getPdfColor(n2, true)}`, "/R0 gs"], l2 = [];
    for (const e3 of s2) {
      l2.length = 0, l2.push(`${numberToString(e3[0])} ${numberToString(e3[1])} m`);
      for (let t3 = 2, i3 = e3.length; t3 < i3; t3 += 2) l2.push(`${numberToString(e3[t3])} ${numberToString(e3[t3 + 1])} l`);
      l2.push("h"), o2.push(l2.join("\n"));
    }
    o2.push("f*");
    const c2 = o2.join("\n"), h2 = new Dict(t2);
    h2.set("FormType", 1), h2.setIfName("Subtype", "Form"), h2.setIfName("Type", "XObject"), h2.set("BBox", a2), h2.set("Length", c2.length);
    const d2 = new Dict(t2), u2 = new Dict(t2);
    d2.set("ExtGState", u2), h2.set("Resources", d2);
    const g2 = new Dict(t2);
    u2.set("R0", g2), g2.setIfName("BM", "Multiply"), 1 !== r2 && (g2.set("ca", r2), g2.setIfName("Type", "ExtGState"));
    const f2 = new StringStream(c2);
    return f2.dict = h2, f2;
  }
}
class UnderlineAnnotation extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    this.data.annotationType = T.UNDERLINE;
    if (this.data.quadPoints = getQuadPoints(t2, null)) {
      if (!this.appearance) {
        const e3 = getPdfColorArray(this.color, [0, 0, 0]), n2 = t2.get("CA");
        this._setDefaultAppearance({ xref: i2, extra: "[] 0 d 0.571 w", strokeColor: e3, strokeAlpha: n2, pointsCallback: (e4, t3) => (e4.push(`${t3[4]} ${t3[5] + 1.3} m`, `${t3[6]} ${t3[7] + 1.3} l`, "S"), [t3[0], t3[7], t3[2], t3[3]]) });
      }
    } else this.data.popupRef = null;
  }
  get overlaysTextContent() {
    return true;
  }
}
class SquigglyAnnotation extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    this.data.annotationType = T.SQUIGGLY;
    if (this.data.quadPoints = getQuadPoints(t2, null)) {
      if (!this.appearance) {
        const e3 = getPdfColorArray(this.color, [0, 0, 0]), n2 = t2.get("CA");
        this._setDefaultAppearance({ xref: i2, extra: "[] 0 d 1 w", strokeColor: e3, strokeAlpha: n2, pointsCallback: (e4, t3) => {
          const i3 = (t3[1] - t3[5]) / 6;
          let n3 = i3, a2 = t3[4];
          const s2 = t3[5], r2 = t3[6];
          e4.push(`${a2} ${s2 + n3} m`);
          do {
            a2 += 2, n3 = 0 === n3 ? i3 : 0, e4.push(`${a2} ${s2 + n3} l`);
          } while (a2 < r2);
          return e4.push("S"), [t3[4], s2 - 2 * i3, r2, s2 + 2 * i3];
        } });
      }
    } else this.data.popupRef = null;
  }
  get overlaysTextContent() {
    return true;
  }
}
class StrikeOutAnnotation extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2;
    this.data.annotationType = T.STRIKEOUT;
    if (this.data.quadPoints = getQuadPoints(t2, null)) {
      if (!this.appearance) {
        const e3 = getPdfColorArray(this.color, [0, 0, 0]), n2 = t2.get("CA");
        this._setDefaultAppearance({ xref: i2, extra: "[] 0 d 1 w", strokeColor: e3, strokeAlpha: n2, pointsCallback: (e4, t3) => (e4.push((t3[0] + t3[4]) / 2 + " " + (t3[1] + t3[5]) / 2 + " m", (t3[2] + t3[6]) / 2 + " " + (t3[3] + t3[7]) / 2 + " l", "S"), [t3[0], t3[7], t3[2], t3[3]]) });
      }
    } else this.data.popupRef = null;
  }
  get overlaysTextContent() {
    return true;
  }
}
class StampAnnotation extends MarkupAnnotation {
  #ke = null;
  constructor(e2) {
    super(e2), this.data.annotationType = T.STAMP, this.data.hasOwnCanvas = this.data.noRotate, this.data.isEditable = !this.data.noHTML, this.data.noHTML = false;
  }
  mustBeViewedWhenEditing(e2, t2 = null) {
    return e2 ? !this.data.isEditable || (this.#ke ??= this.data.hasOwnCanvas, this.data.hasOwnCanvas = true, true) : (null !== this.#ke && (this.data.hasOwnCanvas = this.#ke, this.#ke = null), !t2?.has(this.data.id));
  }
  static async createImage(e2, t2) {
    const { width: i2, height: n2 } = e2, a2 = new OffscreenCanvas(i2, n2), s2 = a2.getContext("2d", { alpha: true });
    s2.drawImage(e2, 0, 0);
    const r2 = s2.getImageData(0, 0, i2, n2).data, o2 = new Uint32Array(r2.buffer), l2 = o2.some(FeatureTest.isLittleEndian ? (e3) => e3 >>> 24 != 255 : (e3) => !!(255 & ~e3));
    l2 && (s2.fillStyle = "white", s2.fillRect(0, 0, i2, n2), s2.drawImage(e2, 0, 0));
    const c2 = a2.convertToBlob({ type: "image/jpeg", quality: 1 }).then((e3) => e3.arrayBuffer()), h2 = Name.get("XObject"), d2 = Name.get("Image"), u2 = new Dict(t2);
    u2.set("Type", h2), u2.set("Subtype", d2), u2.set("BitsPerComponent", 8), u2.setIfName("ColorSpace", "DeviceRGB"), u2.setIfName("Filter", "DCTDecode"), u2.set("BBox", [0, 0, i2, n2]), u2.set("Width", i2), u2.set("Height", n2);
    let g2 = null;
    if (l2) {
      const e3 = new Uint8Array(o2.length);
      if (FeatureTest.isLittleEndian) for (let t3 = 0, i3 = o2.length; t3 < i3; t3++) e3[t3] = o2[t3] >>> 24;
      else for (let t3 = 0, i3 = o2.length; t3 < i3; t3++) e3[t3] = 255 & o2[t3];
      const a3 = new Dict(t2);
      a3.set("Type", h2), a3.set("Subtype", d2), a3.set("BitsPerComponent", 8), a3.setIfName("ColorSpace", "DeviceGray"), a3.set("Width", i2), a3.set("Height", n2), g2 = new Stream(e3, 0, 0, a3);
    }
    return { imageStream: new Stream(await c2, 0, 0, u2), smaskStream: g2, width: i2, height: n2 };
  }
  static createNewDict(e2, t2, { apRef: i2, ap: n2 }) {
    const { date: a2, oldAnnotation: s2, rect: r2, rotation: o2, user: l2 } = e2, c2 = s2 || new Dict(t2);
    if (c2.setIfNotExists("Type", Name.get("Annot")), c2.setIfNotExists("Subtype", Name.get("Stamp")), c2.set(s2 ? "M" : "CreationDate", `D:${getModificationDate(a2)}`), c2.setIfArray("Rect", r2), c2.setIfNotExists("F", 4), c2.setIfNotExists("Border", [0, 0, 0]), c2.setIfNumber("Rotate", o2), c2.setIfDefined("T", stringToAsciiOrUTF16BE(l2)), i2 || n2) {
      const e3 = new Dict(t2);
      c2.set("AP", e3), e3.set("N", i2 || n2);
    }
    return c2;
  }
  static async #Te(e2, t2) {
    const { areContours: i2, color: n2, rect: a2, lines: s2, thickness: r2 } = e2;
    if (!n2) return null;
    const o2 = [`${r2} w 1 J 1 j`, `${getPdfColor(n2, i2)}`];
    for (const e3 of s2) {
      o2.push(`${numberToString(e3[4])} ${numberToString(e3[5])} m`);
      for (let t3 = 6, i3 = e3.length; t3 < i3; t3 += 6) if (isNaN(e3[t3])) o2.push(`${numberToString(e3[t3 + 4])} ${numberToString(e3[t3 + 5])} l`);
      else {
        const [i4, n3, a3, s3, r3, l3] = e3.slice(t3, t3 + 6);
        o2.push([i4, n3, a3, s3, r3, l3].map(numberToString).join(" ") + " c");
      }
      6 === e3.length && o2.push(`${numberToString(e3[4])} ${numberToString(e3[5])} l`);
    }
    o2.push(i2 ? "F" : "S");
    const l2 = o2.join("\n"), c2 = new Dict(t2);
    c2.set("FormType", 1), c2.setIfName("Subtype", "Form"), c2.setIfName("Type", "XObject"), c2.set("BBox", a2), c2.set("Length", l2.length);
    const h2 = new StringStream(l2);
    return h2.dict = c2, h2;
  }
  static async createNewAppearanceStream(e2, t2, i2) {
    if (e2.oldAnnotation) return null;
    if (e2.isSignature) return this.#Te(e2, t2);
    const { rotation: n2 } = e2, { imageRef: a2, width: s2, height: r2 } = i2.image, o2 = new Dict(t2), l2 = new Dict(t2);
    o2.set("XObject", l2), l2.set("Im0", a2);
    const c2 = `q ${s2} 0 0 ${r2} 0 0 cm /Im0 Do Q`, h2 = new Dict(t2);
    if (h2.set("FormType", 1), h2.setIfName("Subtype", "Form"), h2.setIfName("Type", "XObject"), h2.set("BBox", [0, 0, s2, r2]), h2.set("Resources", o2), n2) {
      const e3 = getRotationMatrix(n2, s2, r2);
      h2.set("Matrix", e3);
    }
    const d2 = new StringStream(c2);
    return d2.dict = h2, d2;
  }
}
class FileAttachmentAnnotation extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: i2 } = e2, n2 = new FileSpec(t2.get("FS"), i2);
    this.data.annotationType = T.FILEATTACHMENT, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = false, this.data.file = n2.serializable;
    const a2 = t2.get("Name");
    this.data.name = a2 instanceof Name ? stringToPDFString(a2.name) : "PushPin";
    const s2 = t2.get("ca");
    this.data.fillAlpha = "number" == typeof s2 && s2 >= 0 && s2 <= 1 ? s2 : null;
  }
}
const cl = { get r() {
  return shadow$1(this, "r", new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]));
}, get k() {
  return shadow$1(this, "k", new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]));
} };
function calculateMD5(e2, t2, i2) {
  let n2 = 1732584193, a2 = -271733879, s2 = -1732584194, r2 = 271733878;
  const o2 = i2 + 72 & -64, l2 = new Uint8Array(o2);
  let c2, h2;
  for (c2 = 0; c2 < i2; ++c2) l2[c2] = e2[t2++];
  l2[c2++] = 128;
  const d2 = o2 - 8;
  c2 < d2 && (c2 = d2), l2[c2++] = i2 << 3 & 255, l2[c2++] = i2 >> 5 & 255, l2[c2++] = i2 >> 13 & 255, l2[c2++] = i2 >> 21 & 255, l2[c2++] = i2 >>> 29 & 255, c2 += 3;
  const u2 = new Int32Array(16), { k: g2, r: f2 } = cl;
  for (c2 = 0; c2 < o2; ) {
    for (h2 = 0; h2 < 16; ++h2, c2 += 4) u2[h2] = l2[c2] | l2[c2 + 1] << 8 | l2[c2 + 2] << 16 | l2[c2 + 3] << 24;
    let e3, t3, i3 = n2, o3 = a2, d3 = s2, p2 = r2;
    for (h2 = 0; h2 < 64; ++h2) {
      h2 < 16 ? (e3 = o3 & d3 | ~o3 & p2, t3 = h2) : h2 < 32 ? (e3 = p2 & o3 | ~p2 & d3, t3 = 5 * h2 + 1 & 15) : h2 < 48 ? (e3 = o3 ^ d3 ^ p2, t3 = 3 * h2 + 5 & 15) : (e3 = d3 ^ (o3 | ~p2), t3 = 7 * h2 & 15);
      const n3 = p2, a3 = i3 + e3 + g2[h2] + u2[t3] | 0, s3 = f2[h2];
      p2 = d3, d3 = o3, o3 = o3 + (a3 << s3 | a3 >>> 32 - s3) | 0, i3 = n3;
    }
    n2 = n2 + i3 | 0, a2 = a2 + o3 | 0, s2 = s2 + d3 | 0, r2 = r2 + p2 | 0;
  }
  return new Uint8Array([255 & n2, n2 >> 8 & 255, n2 >> 16 & 255, n2 >>> 24 & 255, 255 & a2, a2 >> 8 & 255, a2 >> 16 & 255, a2 >>> 24 & 255, 255 & s2, s2 >> 8 & 255, s2 >> 16 & 255, s2 >>> 24 & 255, 255 & r2, r2 >> 8 & 255, r2 >> 16 & 255, r2 >>> 24 & 255]);
}
function decodeString(e2) {
  try {
    return stringToUTF8String$1(e2);
  } catch (t2) {
    return warn$1(`UTF-8 decoding failed: "${t2}".`), e2;
  }
}
class DatasetXMLParser extends SimpleXMLParser {
  constructor(e2) {
    super(e2), this.node = null;
  }
  onEndElement(e2) {
    const t2 = super.onEndElement(e2);
    if (t2 && "xfa:datasets" === e2) throw this.node = t2, new Error("Aborting DatasetXMLParser.");
  }
}
class DatasetReader {
  constructor(e2) {
    if (e2.datasets) this.node = new SimpleXMLParser({ hasAttributes: true }).parseFromString(e2.datasets).documentElement;
    else {
      const t2 = new DatasetXMLParser({ hasAttributes: true });
      try {
        t2.parseFromString(e2["xdp:xdp"]);
      } catch {
      }
      this.node = t2.node;
    }
  }
  getValue(e2) {
    if (!this.node || !e2) return "";
    const t2 = this.node.searchNode(parseXFAPath(e2), 0);
    if (!t2) return "";
    const i2 = t2.firstChild;
    return "value" === i2?.nodeName ? t2.children.map((e3) => decodeString(e3.textContent)) : decodeString(t2.textContent);
  }
}
class SingleIntersector {
  #Fe;
  #Ie = 1 / 0;
  #Ee = 1 / 0;
  #Me = -1 / 0;
  #De = -1 / 0;
  #Oe = null;
  #_e = [];
  #Pe = [];
  #Re = -1;
  #Be = false;
  constructor(e2) {
    this.#Fe = e2;
    const t2 = e2.data.quadPoints;
    if (t2) {
      for (let e3 = 0, i2 = t2.length; e3 < i2; e3 += 8) this.#Ie = Math.min(this.#Ie, t2[e3]), this.#Me = Math.max(this.#Me, t2[e3 + 2]), this.#Ee = Math.min(this.#Ee, t2[e3 + 5]), this.#De = Math.max(this.#De, t2[e3 + 1]);
      t2.length > 8 && (this.#Oe = t2);
    } else [this.#Ie, this.#Ee, this.#Me, this.#De] = e2.data.rect;
  }
  overlaps(e2) {
    return !(this.#Ie >= e2.#Me || this.#Me <= e2.#Ie || this.#Ee >= e2.#De || this.#De <= e2.#Ee);
  }
  #Ne(e2, t2) {
    if (this.#Ie >= e2 || this.#Me <= e2 || this.#Ee >= t2 || this.#De <= t2) return false;
    const i2 = this.#Oe;
    if (!i2) return true;
    if (this.#Re >= 0) {
      const n2 = this.#Re;
      if (!(i2[n2] >= e2 || i2[n2 + 2] <= e2 || i2[n2 + 5] >= t2 || i2[n2 + 1] <= t2)) return true;
      this.#Re = -1;
    }
    for (let n2 = 0, a2 = i2.length; n2 < a2; n2 += 8) if (!(i2[n2] >= e2 || i2[n2 + 2] <= e2 || i2[n2 + 5] >= t2 || i2[n2 + 1] <= t2)) return this.#Re = n2, true;
    return false;
  }
  addGlyph(e2, t2, i2) {
    return this.#Ne(e2, t2) ? (this.#Pe.length > 0 && (this.#_e.push(this.#Pe.join("")), this.#Pe.length = 0), this.#_e.push(i2), this.#Be = true, true) : (this.disableExtraChars(), false);
  }
  addExtraChar(e2) {
    this.#Be && this.#Pe.push(e2);
  }
  disableExtraChars() {
    this.#Be && (this.#Be = false, this.#Pe.length = 0);
  }
  setText() {
    this.#Fe.data.overlaidText = this.#_e.join("");
  }
}
class Intersector {
  #Le = /* @__PURE__ */ new Map();
  constructor(e2) {
    for (const t2 of e2) {
      if (!t2.data.quadPoints && !t2.data.rect) continue;
      const e3 = new SingleIntersector(t2);
      for (const [t3, i2] of this.#Le) t3.overlaps(e3) && (i2 ? i2.add(e3) : this.#Le.set(t3, /* @__PURE__ */ new Set([e3])));
      this.#Le.set(e3, null);
    }
  }
  addGlyph(e2, t2, i2, n2) {
    const a2 = e2[4] + t2 / 2, s2 = e2[5] + i2 / 2;
    let r2;
    for (const [e3, t3] of this.#Le) r2 ? r2.has(e3) ? e3.addGlyph(a2, s2, n2) : e3.disableExtraChars() : e3.addGlyph(a2, s2, n2) && (r2 = t3);
  }
  addExtraChar(e2) {
    for (const t2 of this.#Le.keys()) t2.addExtraChar(e2);
  }
  setText() {
    for (const e2 of this.#Le.keys()) e2.setText();
  }
}
class Word64 {
  constructor(e2, t2) {
    this.high = 0 | e2, this.low = 0 | t2;
  }
  and(e2) {
    this.high &= e2.high, this.low &= e2.low;
  }
  xor(e2) {
    this.high ^= e2.high, this.low ^= e2.low;
  }
  shiftRight(e2) {
    e2 >= 32 ? (this.low = this.high >>> e2 - 32 | 0, this.high = 0) : (this.low = this.low >>> e2 | this.high << 32 - e2, this.high = this.high >>> e2 | 0);
  }
  rotateRight(e2) {
    let t2, i2;
    32 & e2 ? (i2 = this.low, t2 = this.high) : (t2 = this.low, i2 = this.high), e2 &= 31, this.low = t2 >>> e2 | i2 << 32 - e2, this.high = i2 >>> e2 | t2 << 32 - e2;
  }
  not() {
    this.high = ~this.high, this.low = ~this.low;
  }
  add(e2) {
    const t2 = (this.low >>> 0) + (e2.low >>> 0);
    let i2 = (this.high >>> 0) + (e2.high >>> 0);
    t2 > 4294967295 && (i2 += 1), this.low = 0 | t2, this.high = 0 | i2;
  }
  copyTo(e2, t2) {
    e2[t2] = this.high >>> 24 & 255, e2[t2 + 1] = this.high >> 16 & 255, e2[t2 + 2] = this.high >> 8 & 255, e2[t2 + 3] = 255 & this.high, e2[t2 + 4] = this.low >>> 24 & 255, e2[t2 + 5] = this.low >> 16 & 255, e2[t2 + 6] = this.low >> 8 & 255, e2[t2 + 7] = 255 & this.low;
  }
  assign(e2) {
    this.high = e2.high, this.low = e2.low;
  }
}
const hl = { get k() {
  return shadow$1(this, "k", [new Word64(1116352408, 3609767458), new Word64(1899447441, 602891725), new Word64(3049323471, 3964484399), new Word64(3921009573, 2173295548), new Word64(961987163, 4081628472), new Word64(1508970993, 3053834265), new Word64(2453635748, 2937671579), new Word64(2870763221, 3664609560), new Word64(3624381080, 2734883394), new Word64(310598401, 1164996542), new Word64(607225278, 1323610764), new Word64(1426881987, 3590304994), new Word64(1925078388, 4068182383), new Word64(2162078206, 991336113), new Word64(2614888103, 633803317), new Word64(3248222580, 3479774868), new Word64(3835390401, 2666613458), new Word64(4022224774, 944711139), new Word64(264347078, 2341262773), new Word64(604807628, 2007800933), new Word64(770255983, 1495990901), new Word64(1249150122, 1856431235), new Word64(1555081692, 3175218132), new Word64(1996064986, 2198950837), new Word64(2554220882, 3999719339), new Word64(2821834349, 766784016), new Word64(2952996808, 2566594879), new Word64(3210313671, 3203337956), new Word64(3336571891, 1034457026), new Word64(3584528711, 2466948901), new Word64(113926993, 3758326383), new Word64(338241895, 168717936), new Word64(666307205, 1188179964), new Word64(773529912, 1546045734), new Word64(1294757372, 1522805485), new Word64(1396182291, 2643833823), new Word64(1695183700, 2343527390), new Word64(1986661051, 1014477480), new Word64(2177026350, 1206759142), new Word64(2456956037, 344077627), new Word64(2730485921, 1290863460), new Word64(2820302411, 3158454273), new Word64(3259730800, 3505952657), new Word64(3345764771, 106217008), new Word64(3516065817, 3606008344), new Word64(3600352804, 1432725776), new Word64(4094571909, 1467031594), new Word64(275423344, 851169720), new Word64(430227734, 3100823752), new Word64(506948616, 1363258195), new Word64(659060556, 3750685593), new Word64(883997877, 3785050280), new Word64(958139571, 3318307427), new Word64(1322822218, 3812723403), new Word64(1537002063, 2003034995), new Word64(1747873779, 3602036899), new Word64(1955562222, 1575990012), new Word64(2024104815, 1125592928), new Word64(2227730452, 2716904306), new Word64(2361852424, 442776044), new Word64(2428436474, 593698344), new Word64(2756734187, 3733110249), new Word64(3204031479, 2999351573), new Word64(3329325298, 3815920427), new Word64(3391569614, 3928383900), new Word64(3515267271, 566280711), new Word64(3940187606, 3454069534), new Word64(4118630271, 4000239992), new Word64(116418474, 1914138554), new Word64(174292421, 2731055270), new Word64(289380356, 3203993006), new Word64(460393269, 320620315), new Word64(685471733, 587496836), new Word64(852142971, 1086792851), new Word64(1017036298, 365543100), new Word64(1126000580, 2618297676), new Word64(1288033470, 3409855158), new Word64(1501505948, 4234509866), new Word64(1607167915, 987167468), new Word64(1816402316, 1246189591)]);
} };
function ch(e2, t2, i2, n2, a2) {
  e2.assign(t2), e2.and(i2), a2.assign(t2), a2.not(), a2.and(n2), e2.xor(a2);
}
function maj(e2, t2, i2, n2, a2) {
  e2.assign(t2), e2.and(i2), a2.assign(t2), a2.and(n2), e2.xor(a2), a2.assign(i2), a2.and(n2), e2.xor(a2);
}
function sigma(e2, t2, i2) {
  e2.assign(t2), e2.rotateRight(28), i2.assign(t2), i2.rotateRight(34), e2.xor(i2), i2.assign(t2), i2.rotateRight(39), e2.xor(i2);
}
function sigmaPrime(e2, t2, i2) {
  e2.assign(t2), e2.rotateRight(14), i2.assign(t2), i2.rotateRight(18), e2.xor(i2), i2.assign(t2), i2.rotateRight(41), e2.xor(i2);
}
function littleSigma(e2, t2, i2) {
  e2.assign(t2), e2.rotateRight(1), i2.assign(t2), i2.rotateRight(8), e2.xor(i2), i2.assign(t2), i2.shiftRight(7), e2.xor(i2);
}
function littleSigmaPrime(e2, t2, i2) {
  e2.assign(t2), e2.rotateRight(19), i2.assign(t2), i2.rotateRight(61), e2.xor(i2), i2.assign(t2), i2.shiftRight(6), e2.xor(i2);
}
function calculateSHA512(e2, t2, i2, n2 = false) {
  let a2, s2, r2, o2, l2, c2, h2, d2;
  n2 ? (a2 = new Word64(3418070365, 3238371032), s2 = new Word64(1654270250, 914150663), r2 = new Word64(2438529370, 812702999), o2 = new Word64(355462360, 4144912697), l2 = new Word64(1731405415, 4290775857), c2 = new Word64(2394180231, 1750603025), h2 = new Word64(3675008525, 1694076839), d2 = new Word64(1203062813, 3204075428)) : (a2 = new Word64(1779033703, 4089235720), s2 = new Word64(3144134277, 2227873595), r2 = new Word64(1013904242, 4271175723), o2 = new Word64(2773480762, 1595750129), l2 = new Word64(1359893119, 2917565137), c2 = new Word64(2600822924, 725511199), h2 = new Word64(528734635, 4215389547), d2 = new Word64(1541459225, 327033209));
  const u2 = 128 * Math.ceil((i2 + 17) / 128), g2 = new Uint8Array(u2);
  let f2, p2;
  for (f2 = 0; f2 < i2; ++f2) g2[f2] = e2[t2++];
  g2[f2++] = 128;
  const m2 = u2 - 16;
  f2 < m2 && (f2 = m2), f2 += 11, g2[f2++] = i2 >>> 29 & 255, g2[f2++] = i2 >> 21 & 255, g2[f2++] = i2 >> 13 & 255, g2[f2++] = i2 >> 5 & 255, g2[f2++] = i2 << 3 & 255;
  const b2 = new Array(80);
  for (f2 = 0; f2 < 80; f2++) b2[f2] = new Word64(0, 0);
  const { k: y2 } = hl;
  let w2 = new Word64(0, 0), x2 = new Word64(0, 0), S2 = new Word64(0, 0), v2 = new Word64(0, 0), C2 = new Word64(0, 0), k2 = new Word64(0, 0), T2 = new Word64(0, 0), F2 = new Word64(0, 0);
  const E2 = new Word64(0, 0), M2 = new Word64(0, 0), D2 = new Word64(0, 0), O2 = new Word64(0, 0);
  let _2, R2;
  for (f2 = 0; f2 < u2; ) {
    for (p2 = 0; p2 < 16; ++p2) b2[p2].high = g2[f2] << 24 | g2[f2 + 1] << 16 | g2[f2 + 2] << 8 | g2[f2 + 3], b2[p2].low = g2[f2 + 4] << 24 | g2[f2 + 5] << 16 | g2[f2 + 6] << 8 | g2[f2 + 7], f2 += 8;
    for (p2 = 16; p2 < 80; ++p2) _2 = b2[p2], littleSigmaPrime(_2, b2[p2 - 2], O2), _2.add(b2[p2 - 7]), littleSigma(D2, b2[p2 - 15], O2), _2.add(D2), _2.add(b2[p2 - 16]);
    for (w2.assign(a2), x2.assign(s2), S2.assign(r2), v2.assign(o2), C2.assign(l2), k2.assign(c2), T2.assign(h2), F2.assign(d2), p2 = 0; p2 < 80; ++p2) E2.assign(F2), sigmaPrime(D2, C2, O2), E2.add(D2), ch(D2, C2, k2, T2, O2), E2.add(D2), E2.add(y2[p2]), E2.add(b2[p2]), sigma(M2, w2, O2), maj(D2, w2, x2, S2, O2), M2.add(D2), _2 = F2, F2 = T2, T2 = k2, k2 = C2, v2.add(E2), C2 = v2, v2 = S2, S2 = x2, x2 = w2, _2.assign(E2), _2.add(M2), w2 = _2;
    a2.add(w2), s2.add(x2), r2.add(S2), o2.add(v2), l2.add(C2), c2.add(k2), h2.add(T2), d2.add(F2);
  }
  return n2 ? (R2 = new Uint8Array(48), a2.copyTo(R2, 0), s2.copyTo(R2, 8), r2.copyTo(R2, 16), o2.copyTo(R2, 24), l2.copyTo(R2, 32), c2.copyTo(R2, 40)) : (R2 = new Uint8Array(64), a2.copyTo(R2, 0), s2.copyTo(R2, 8), r2.copyTo(R2, 16), o2.copyTo(R2, 24), l2.copyTo(R2, 32), c2.copyTo(R2, 40), h2.copyTo(R2, 48), d2.copyTo(R2, 56)), R2;
}
function calculateSHA384(e2, t2, i2) {
  return calculateSHA512(e2, t2, i2, true);
}
const dl = { get k() {
  return shadow$1(this, "k", [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
} };
function rotr(e2, t2) {
  return e2 >>> t2 | e2 << 32 - t2;
}
function calculate_sha256_ch(e2, t2, i2) {
  return e2 & t2 ^ ~e2 & i2;
}
function calculate_sha256_maj(e2, t2, i2) {
  return e2 & t2 ^ e2 & i2 ^ t2 & i2;
}
function calculate_sha256_sigma(e2) {
  return rotr(e2, 2) ^ rotr(e2, 13) ^ rotr(e2, 22);
}
function calculate_sha256_sigmaPrime(e2) {
  return rotr(e2, 6) ^ rotr(e2, 11) ^ rotr(e2, 25);
}
function calculate_sha256_littleSigma(e2) {
  return rotr(e2, 7) ^ rotr(e2, 18) ^ e2 >>> 3;
}
function calculate_sha256_littleSigmaPrime(e2) {
  return rotr(e2, 17) ^ rotr(e2, 19) ^ e2 >>> 10;
}
function calculateSHA256(e2, t2, i2) {
  let n2 = 1779033703, a2 = 3144134277, s2 = 1013904242, r2 = 2773480762, o2 = 1359893119, l2 = 2600822924, c2 = 528734635, h2 = 1541459225;
  const d2 = 64 * Math.ceil((i2 + 9) / 64), u2 = new Uint8Array(d2);
  let g2, f2;
  for (g2 = 0; g2 < i2; ++g2) u2[g2] = e2[t2++];
  u2[g2++] = 128;
  const p2 = d2 - 8;
  g2 < p2 && (g2 = p2), g2 += 3, u2[g2++] = i2 >>> 29 & 255, u2[g2++] = i2 >> 21 & 255, u2[g2++] = i2 >> 13 & 255, u2[g2++] = i2 >> 5 & 255, u2[g2++] = i2 << 3 & 255;
  const m2 = new Uint32Array(64), { k: b2 } = dl;
  for (g2 = 0; g2 < d2; ) {
    for (f2 = 0; f2 < 16; ++f2) m2[f2] = u2[g2] << 24 | u2[g2 + 1] << 16 | u2[g2 + 2] << 8 | u2[g2 + 3], g2 += 4;
    for (f2 = 16; f2 < 64; ++f2) m2[f2] = calculate_sha256_littleSigmaPrime(m2[f2 - 2]) + m2[f2 - 7] + calculate_sha256_littleSigma(m2[f2 - 15]) + m2[f2 - 16] | 0;
    let e3, t3, i3 = n2, d3 = a2, p3 = s2, y2 = r2, w2 = o2, x2 = l2, S2 = c2, v2 = h2;
    for (f2 = 0; f2 < 64; ++f2) e3 = v2 + calculate_sha256_sigmaPrime(w2) + calculate_sha256_ch(w2, x2, S2) + b2[f2] + m2[f2], t3 = calculate_sha256_sigma(i3) + calculate_sha256_maj(i3, d3, p3), v2 = S2, S2 = x2, x2 = w2, w2 = y2 + e3 | 0, y2 = p3, p3 = d3, d3 = i3, i3 = e3 + t3 | 0;
    n2 = n2 + i3 | 0, a2 = a2 + d3 | 0, s2 = s2 + p3 | 0, r2 = r2 + y2 | 0, o2 = o2 + w2 | 0, l2 = l2 + x2 | 0, c2 = c2 + S2 | 0, h2 = h2 + v2 | 0;
  }
  return new Uint8Array([n2 >> 24 & 255, n2 >> 16 & 255, n2 >> 8 & 255, 255 & n2, a2 >> 24 & 255, a2 >> 16 & 255, a2 >> 8 & 255, 255 & a2, s2 >> 24 & 255, s2 >> 16 & 255, s2 >> 8 & 255, 255 & s2, r2 >> 24 & 255, r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2, o2 >> 24 & 255, o2 >> 16 & 255, o2 >> 8 & 255, 255 & o2, l2 >> 24 & 255, l2 >> 16 & 255, l2 >> 8 & 255, 255 & l2, c2 >> 24 & 255, c2 >> 16 & 255, c2 >> 8 & 255, 255 & c2, h2 >> 24 & 255, h2 >> 16 & 255, h2 >> 8 & 255, 255 & h2]);
}
class DecryptStream extends DecodeStream {
  constructor(e2, t2, i2) {
    super(t2), this.str = e2, this.dict = e2.dict, this.decrypt = i2, this.nextChunk = null, this.initialized = false;
  }
  readBlock() {
    let e2;
    if (this.initialized ? e2 = this.nextChunk : (e2 = this.str.getBytes(512), this.initialized = true), !e2?.length) return void (this.eof = true);
    this.nextChunk = this.str.getBytes(512);
    const t2 = this.nextChunk?.length > 0;
    e2 = (0, this.decrypt)(e2, !t2);
    const i2 = this.bufferLength, n2 = i2 + e2.length;
    this.ensureBuffer(n2).set(e2, i2), this.bufferLength = n2;
  }
}
class ARCFourCipher {
  constructor(e2) {
    this.a = 0, this.b = 0;
    const t2 = new Uint8Array(256), i2 = e2.length;
    for (let e3 = 0; e3 < 256; ++e3) t2[e3] = e3;
    for (let n2 = 0, a2 = 0; n2 < 256; ++n2) {
      const s2 = t2[n2];
      a2 = a2 + s2 + e2[n2 % i2] & 255, t2[n2] = t2[a2], t2[a2] = s2;
    }
    this.s = t2;
  }
  encryptBlock(e2) {
    let t2 = this.a, i2 = this.b;
    const n2 = this.s, a2 = e2.length, s2 = new Uint8Array(a2);
    for (let r2 = 0; r2 < a2; ++r2) {
      t2 = t2 + 1 & 255;
      const a3 = n2[t2];
      i2 = i2 + a3 & 255;
      const o2 = n2[i2];
      n2[t2] = o2, n2[i2] = a3, s2[r2] = e2[r2] ^ n2[a3 + o2 & 255];
    }
    return this.a = t2, this.b = i2, s2;
  }
  decryptBlock(e2) {
    return this.encryptBlock(e2);
  }
  encrypt(e2) {
    return this.encryptBlock(e2);
  }
}
class NullCipher {
  decryptBlock(e2) {
    return e2;
  }
  encrypt(e2) {
    return e2;
  }
}
class AESBaseCipher {
  _s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);
  _inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
  _mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]);
  _mixCol = new Uint8Array(256).map((e2, t2) => t2 < 128 ? t2 << 1 : t2 << 1 ^ 27);
  constructor() {
    this.buffer = new Uint8Array(16), this.bufferPosition = 0;
  }
  _expandKey(e2) {
    unreachable$1("Cannot call `_expandKey` on the base class");
  }
  _decrypt(e2, t2) {
    let i2, n2, a2;
    const s2 = new Uint8Array(16);
    s2.set(e2);
    for (let e3 = 0, i3 = this._keySize; e3 < 16; ++e3, ++i3) s2[e3] ^= t2[i3];
    for (let e3 = this._cyclesOfRepetition - 1; e3 >= 1; --e3) {
      i2 = s2[13], s2[13] = s2[9], s2[9] = s2[5], s2[5] = s2[1], s2[1] = i2, i2 = s2[14], n2 = s2[10], s2[14] = s2[6], s2[10] = s2[2], s2[6] = i2, s2[2] = n2, i2 = s2[15], n2 = s2[11], a2 = s2[7], s2[15] = s2[3], s2[11] = i2, s2[7] = n2, s2[3] = a2;
      for (let e4 = 0; e4 < 16; ++e4) s2[e4] = this._inv_s[s2[e4]];
      for (let i3 = 0, n3 = 16 * e3; i3 < 16; ++i3, ++n3) s2[i3] ^= t2[n3];
      for (let e4 = 0; e4 < 16; e4 += 4) {
        const t3 = this._mix[s2[e4]], n3 = this._mix[s2[e4 + 1]], a3 = this._mix[s2[e4 + 2]], r2 = this._mix[s2[e4 + 3]];
        i2 = t3 ^ n3 >>> 8 ^ n3 << 24 ^ a3 >>> 16 ^ a3 << 16 ^ r2 >>> 24 ^ r2 << 8, s2[e4] = i2 >>> 24 & 255, s2[e4 + 1] = i2 >> 16 & 255, s2[e4 + 2] = i2 >> 8 & 255, s2[e4 + 3] = 255 & i2;
      }
    }
    i2 = s2[13], s2[13] = s2[9], s2[9] = s2[5], s2[5] = s2[1], s2[1] = i2, i2 = s2[14], n2 = s2[10], s2[14] = s2[6], s2[10] = s2[2], s2[6] = i2, s2[2] = n2, i2 = s2[15], n2 = s2[11], a2 = s2[7], s2[15] = s2[3], s2[11] = i2, s2[7] = n2, s2[3] = a2;
    for (let e3 = 0; e3 < 16; ++e3) s2[e3] = this._inv_s[s2[e3]], s2[e3] ^= t2[e3];
    return s2;
  }
  _encrypt(e2, t2) {
    const i2 = this._s;
    let n2, a2, s2;
    const r2 = new Uint8Array(16);
    r2.set(e2);
    for (let e3 = 0; e3 < 16; ++e3) r2[e3] ^= t2[e3];
    for (let e3 = 1; e3 < this._cyclesOfRepetition; e3++) {
      for (let e4 = 0; e4 < 16; ++e4) r2[e4] = i2[r2[e4]];
      s2 = r2[1], r2[1] = r2[5], r2[5] = r2[9], r2[9] = r2[13], r2[13] = s2, s2 = r2[2], a2 = r2[6], r2[2] = r2[10], r2[6] = r2[14], r2[10] = s2, r2[14] = a2, s2 = r2[3], a2 = r2[7], n2 = r2[11], r2[3] = r2[15], r2[7] = s2, r2[11] = a2, r2[15] = n2;
      for (let e4 = 0; e4 < 16; e4 += 4) {
        const t3 = r2[e4], i3 = r2[e4 + 1], a3 = r2[e4 + 2], s3 = r2[e4 + 3];
        n2 = t3 ^ i3 ^ a3 ^ s3, r2[e4] ^= n2 ^ this._mixCol[t3 ^ i3], r2[e4 + 1] ^= n2 ^ this._mixCol[i3 ^ a3], r2[e4 + 2] ^= n2 ^ this._mixCol[a3 ^ s3], r2[e4 + 3] ^= n2 ^ this._mixCol[s3 ^ t3];
      }
      for (let i3 = 0, n3 = 16 * e3; i3 < 16; ++i3, ++n3) r2[i3] ^= t2[n3];
    }
    for (let e3 = 0; e3 < 16; ++e3) r2[e3] = i2[r2[e3]];
    s2 = r2[1], r2[1] = r2[5], r2[5] = r2[9], r2[9] = r2[13], r2[13] = s2, s2 = r2[2], a2 = r2[6], r2[2] = r2[10], r2[6] = r2[14], r2[10] = s2, r2[14] = a2, s2 = r2[3], a2 = r2[7], n2 = r2[11], r2[3] = r2[15], r2[7] = s2, r2[11] = a2, r2[15] = n2;
    for (let e3 = 0, i3 = this._keySize; e3 < 16; ++e3, ++i3) r2[e3] ^= t2[i3];
    return r2;
  }
  _decryptBlock2(e2, t2) {
    const i2 = e2.length;
    let n2 = this.buffer, a2 = this.bufferPosition;
    const s2 = [];
    let r2 = this.iv;
    for (let t3 = 0; t3 < i2; ++t3) {
      if (n2[a2] = e2[t3], ++a2, a2 < 16) continue;
      const i3 = this._decrypt(n2, this._key);
      for (let e3 = 0; e3 < 16; ++e3) i3[e3] ^= r2[e3];
      r2 = n2, s2.push(i3), n2 = new Uint8Array(16), a2 = 0;
    }
    if (this.buffer = n2, this.bufferLength = a2, this.iv = r2, 0 === s2.length) return new Uint8Array(0);
    let o2 = 16 * s2.length;
    if (t2) {
      const e3 = s2.at(-1);
      let t3 = e3[15];
      if (t3 <= 16) {
        for (let i3 = 15, n3 = 16 - t3; i3 >= n3; --i3) if (e3[i3] !== t3) {
          t3 = 0;
          break;
        }
        o2 -= t3, s2[s2.length - 1] = e3.subarray(0, 16 - t3);
      }
    }
    const l2 = new Uint8Array(o2);
    for (let e3 = 0, t3 = 0, i3 = s2.length; e3 < i3; ++e3, t3 += 16) l2.set(s2[e3], t3);
    return l2;
  }
  decryptBlock(e2, t2, i2 = null) {
    const n2 = e2.length, a2 = this.buffer;
    let s2 = this.bufferPosition;
    if (i2) this.iv = i2;
    else {
      for (let t3 = 0; s2 < 16 && t3 < n2; ++t3, ++s2) a2[s2] = e2[t3];
      if (s2 < 16) return this.bufferLength = s2, new Uint8Array(0);
      this.iv = a2, e2 = e2.subarray(16);
    }
    return this.buffer = new Uint8Array(16), this.bufferLength = 0, this.decryptBlock = this._decryptBlock2, this.decryptBlock(e2, t2);
  }
  encrypt(e2, t2) {
    const i2 = e2.length;
    let n2 = this.buffer, a2 = this.bufferPosition;
    const s2 = [];
    t2 ||= new Uint8Array(16);
    for (let r3 = 0; r3 < i2; ++r3) {
      if (n2[a2] = e2[r3], ++a2, a2 < 16) continue;
      for (let e3 = 0; e3 < 16; ++e3) n2[e3] ^= t2[e3];
      const i3 = this._encrypt(n2, this._key);
      t2 = i3, s2.push(i3), n2 = new Uint8Array(16), a2 = 0;
    }
    if (this.buffer = n2, this.bufferLength = a2, this.iv = t2, 0 === s2.length) return new Uint8Array(0);
    const r2 = 16 * s2.length, o2 = new Uint8Array(r2);
    for (let e3 = 0, t3 = 0, i3 = s2.length; e3 < i3; ++e3, t3 += 16) o2.set(s2[e3], t3);
    return o2;
  }
}
class AES128Cipher extends AESBaseCipher {
  _rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]);
  constructor(e2) {
    super(), this._cyclesOfRepetition = 10, this._keySize = 160, this._key = this._expandKey(e2);
  }
  _expandKey(e2) {
    const t2 = this._s, i2 = this._rcon, n2 = new Uint8Array(176);
    n2.set(e2);
    for (let e3 = 16, a2 = 1; e3 < 176; ++a2) {
      let s2 = n2[e3 - 3], r2 = n2[e3 - 2], o2 = n2[e3 - 1], l2 = n2[e3 - 4];
      s2 = t2[s2], r2 = t2[r2], o2 = t2[o2], l2 = t2[l2], s2 ^= i2[a2];
      for (let t3 = 0; t3 < 4; ++t3) n2[e3] = s2 ^= n2[e3 - 16], e3++, n2[e3] = r2 ^= n2[e3 - 16], e3++, n2[e3] = o2 ^= n2[e3 - 16], e3++, n2[e3] = l2 ^= n2[e3 - 16], e3++;
    }
    return n2;
  }
}
class AES256Cipher extends AESBaseCipher {
  constructor(e2) {
    super(), this._cyclesOfRepetition = 14, this._keySize = 224, this._key = this._expandKey(e2);
  }
  _expandKey(e2) {
    const t2 = this._s, i2 = new Uint8Array(240);
    i2.set(e2);
    let n2, a2, s2, r2, o2 = 1;
    for (let e3 = 32, l2 = 1; e3 < 240; ++l2) {
      e3 % 32 == 16 ? (n2 = t2[n2], a2 = t2[a2], s2 = t2[s2], r2 = t2[r2]) : e3 % 32 == 0 && (n2 = i2[e3 - 3], a2 = i2[e3 - 2], s2 = i2[e3 - 1], r2 = i2[e3 - 4], n2 = t2[n2], a2 = t2[a2], s2 = t2[s2], r2 = t2[r2], n2 ^= o2, (o2 <<= 1) >= 256 && (o2 = 255 & (27 ^ o2)));
      for (let t3 = 0; t3 < 4; ++t3) i2[e3] = n2 ^= i2[e3 - 32], e3++, i2[e3] = a2 ^= i2[e3 - 32], e3++, i2[e3] = s2 ^= i2[e3 - 32], e3++, i2[e3] = r2 ^= i2[e3 - 32], e3++;
    }
    return i2;
  }
}
class PDFBase {
  _hash(e2, t2, i2) {
    unreachable$1("Abstract method `_hash` called");
  }
  checkOwnerPassword(e2, t2, i2, n2) {
    const a2 = new Uint8Array(e2.length + 56);
    a2.set(e2, 0), a2.set(t2, e2.length), a2.set(i2, e2.length + t2.length);
    return isArrayEqual(this._hash(e2, a2, i2), n2);
  }
  checkUserPassword(e2, t2, i2) {
    const n2 = new Uint8Array(e2.length + 8);
    n2.set(e2, 0), n2.set(t2, e2.length);
    return isArrayEqual(this._hash(e2, n2, []), i2);
  }
  getOwnerKey(e2, t2, i2, n2) {
    const a2 = new Uint8Array(e2.length + 56);
    a2.set(e2, 0), a2.set(t2, e2.length), a2.set(i2, e2.length + t2.length);
    const s2 = this._hash(e2, a2, i2);
    return new AES256Cipher(s2).decryptBlock(n2, false, new Uint8Array(16));
  }
  getUserKey(e2, t2, i2) {
    const n2 = new Uint8Array(e2.length + 8);
    n2.set(e2, 0), n2.set(t2, e2.length);
    const a2 = this._hash(e2, n2, []);
    return new AES256Cipher(a2).decryptBlock(i2, false, new Uint8Array(16));
  }
}
class PDF17 extends PDFBase {
  _hash(e2, t2, i2) {
    return calculateSHA256(t2, 0, t2.length);
  }
}
class PDF20 extends PDFBase {
  _hash(e2, t2, i2) {
    let n2 = calculateSHA256(t2, 0, t2.length).subarray(0, 32), a2 = [0], s2 = 0;
    for (; s2 < 64 || a2.at(-1) > s2 - 32; ) {
      const t3 = e2.length + n2.length + i2.length, r2 = new Uint8Array(t3);
      let o2 = 0;
      r2.set(e2, o2), o2 += e2.length, r2.set(n2, o2), o2 += n2.length, r2.set(i2, o2);
      const l2 = new Uint8Array(64 * t3);
      for (let e3 = 0, i3 = 0; e3 < 64; e3++, i3 += t3) l2.set(r2, i3);
      a2 = new AES128Cipher(n2.subarray(0, 16)).encrypt(l2, n2.subarray(16, 32));
      const c2 = Math.sumPrecise(a2.slice(0, 16)) % 3;
      0 === c2 ? n2 = calculateSHA256(a2, 0, a2.length) : 1 === c2 ? n2 = calculateSHA384(a2, 0, a2.length) : 2 === c2 && (n2 = calculateSHA512(a2, 0, a2.length)), s2++;
    }
    return n2.subarray(0, 32);
  }
}
class CipherTransform {
  constructor(e2, t2) {
    this.StringCipherConstructor = e2, this.StreamCipherConstructor = t2;
  }
  createStream(e2, t2) {
    const i2 = new this.StreamCipherConstructor();
    return new DecryptStream(e2, t2, function(e3, t3) {
      return i2.decryptBlock(e3, t3);
    });
  }
  decryptString(e2) {
    const t2 = new this.StringCipherConstructor();
    let i2 = stringToBytes$1(e2);
    return i2 = t2.decryptBlock(i2, true), bytesToString$1(i2);
  }
  encryptString(e2) {
    const t2 = new this.StringCipherConstructor();
    if (t2 instanceof AESBaseCipher) {
      const i3 = 16 - e2.length % 16;
      e2 += String.fromCharCode(i3).repeat(i3);
      const n2 = new Uint8Array(16);
      crypto.getRandomValues(n2);
      let a2 = stringToBytes$1(e2);
      a2 = t2.encrypt(a2, n2);
      const s2 = new Uint8Array(16 + a2.length);
      return s2.set(n2), s2.set(a2, 16), bytesToString$1(s2);
    }
    let i2 = stringToBytes$1(e2);
    return i2 = t2.encrypt(i2), bytesToString$1(i2);
  }
}
class CipherTransformFactory {
  static get _defaultPasswordBytes() {
    return shadow$1(this, "_defaultPasswordBytes", new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]));
  }
  #Ue(e2, t2, i2, n2, a2, s2, r2, o2, l2, c2, h2, d2) {
    if (t2) {
      const e3 = Math.min(127, t2.length);
      t2 = t2.subarray(0, e3);
    } else t2 = [];
    const u2 = 6 === e2 ? new PDF20() : new PDF17();
    return u2.checkUserPassword(t2, o2, r2) ? u2.getUserKey(t2, l2, h2) : t2.length && u2.checkOwnerPassword(t2, n2, s2, i2) ? u2.getOwnerKey(t2, a2, s2, c2) : null;
  }
  #je(e2, t2, i2, n2, a2, s2, r2, o2) {
    const l2 = 40 + i2.length + e2.length, c2 = new Uint8Array(l2);
    let h2, d2, u2 = 0;
    if (t2) for (d2 = Math.min(32, t2.length); u2 < d2; ++u2) c2[u2] = t2[u2];
    for (h2 = 0; u2 < 32; ) c2[u2++] = CipherTransformFactory._defaultPasswordBytes[h2++];
    c2.set(i2, u2), u2 += i2.length, c2[u2++] = 255 & a2, c2[u2++] = a2 >> 8 & 255, c2[u2++] = a2 >> 16 & 255, c2[u2++] = a2 >>> 24 & 255, c2.set(e2, u2), u2 += e2.length, s2 >= 4 && !o2 && (c2.fill(255, u2, u2 + 4), u2 += 4);
    let g2 = calculateMD5(c2, 0, u2);
    const f2 = r2 >> 3;
    if (s2 >= 3) for (h2 = 0; h2 < 50; ++h2) g2 = calculateMD5(g2, 0, f2);
    const p2 = g2.subarray(0, f2);
    let m2, b2;
    if (s2 >= 3) {
      u2 = 0, c2.set(CipherTransformFactory._defaultPasswordBytes, u2), u2 += 32, c2.set(e2, u2), u2 += e2.length, m2 = new ARCFourCipher(p2), b2 = m2.encryptBlock(calculateMD5(c2, 0, u2)), d2 = p2.length;
      const t3 = new Uint8Array(d2);
      for (h2 = 1; h2 <= 19; ++h2) {
        for (let e3 = 0; e3 < d2; ++e3) t3[e3] = p2[e3] ^ h2;
        m2 = new ARCFourCipher(t3), b2 = m2.encryptBlock(b2);
      }
    } else m2 = new ARCFourCipher(p2), b2 = m2.encryptBlock(CipherTransformFactory._defaultPasswordBytes);
    return b2.every((e3, t3) => n2[t3] === e3) ? p2 : null;
  }
  #$e(e2, t2, i2, n2) {
    const a2 = new Uint8Array(32);
    let s2 = 0;
    const r2 = Math.min(32, e2.length);
    for (; s2 < r2; ++s2) a2[s2] = e2[s2];
    let o2 = 0;
    for (; s2 < 32; ) a2[s2++] = CipherTransformFactory._defaultPasswordBytes[o2++];
    let l2 = calculateMD5(a2, 0, s2);
    const c2 = n2 >> 3;
    if (i2 >= 3) for (o2 = 0; o2 < 50; ++o2) l2 = calculateMD5(l2, 0, l2.length);
    let h2, d2;
    if (i2 >= 3) {
      d2 = t2;
      const e3 = new Uint8Array(c2);
      for (o2 = 19; o2 >= 0; o2--) {
        for (let t3 = 0; t3 < c2; ++t3) e3[t3] = l2[t3] ^ o2;
        h2 = new ARCFourCipher(e3), d2 = h2.encryptBlock(d2);
      }
    } else h2 = new ARCFourCipher(l2.subarray(0, c2)), d2 = h2.encryptBlock(t2);
    return d2;
  }
  #He(e2, t2, i2, n2 = false) {
    const a2 = i2.length, s2 = new Uint8Array(a2 + 9);
    s2.set(i2);
    let r2 = a2;
    s2[r2++] = 255 & e2, s2[r2++] = e2 >> 8 & 255, s2[r2++] = e2 >> 16 & 255, s2[r2++] = 255 & t2, s2[r2++] = t2 >> 8 & 255, n2 && (s2[r2++] = 115, s2[r2++] = 65, s2[r2++] = 108, s2[r2++] = 84);
    return calculateMD5(s2, 0, r2).subarray(0, Math.min(a2 + 5, 16));
  }
  #Xe(e2, t2, i2, n2, a2) {
    if (!(t2 instanceof Name)) throw new ti("Invalid crypt filter name.");
    const s2 = this, r2 = e2.get(t2.name), o2 = r2?.get("CFM");
    if (!o2 || "None" === o2.name) return function() {
      return new NullCipher();
    };
    if ("V2" === o2.name) return function() {
      return new ARCFourCipher(s2.#He(i2, n2, a2, false));
    };
    if ("AESV2" === o2.name) return function() {
      return new AES128Cipher(s2.#He(i2, n2, a2, true));
    };
    if ("AESV3" === o2.name) return function() {
      return new AES256Cipher(a2);
    };
    throw new ti("Unknown crypto method");
  }
  constructor(e2, t2, i2) {
    const n2 = e2.get("Filter");
    if (!isName(n2, "Standard")) throw new ti("unknown encryption method");
    this.filterName = n2.name, this.dict = e2;
    const a2 = e2.get("V");
    if (!Number.isInteger(a2) || 1 !== a2 && 2 !== a2 && 4 !== a2 && 5 !== a2) throw new ti("unsupported encryption algorithm");
    this.algorithm = a2;
    let s2 = e2.get("Length");
    if (!s2) if (a2 <= 3) s2 = 40;
    else {
      const t3 = e2.get("CF"), i3 = e2.get("StmF");
      if (t3 instanceof Dict && i3 instanceof Name) {
        t3.suppressEncryption = true;
        const e3 = t3.get(i3.name);
        s2 = e3?.get("Length") || 128, s2 < 40 && (s2 <<= 3);
      }
    }
    if (!Number.isInteger(s2) || s2 < 40 || s2 % 8 != 0) throw new ti("invalid key length");
    const r2 = stringToBytes$1(e2.get("O")), o2 = stringToBytes$1(e2.get("U")), l2 = r2.subarray(0, 32), c2 = o2.subarray(0, 32), h2 = e2.get("P"), d2 = e2.get("R"), u2 = (4 === a2 || 5 === a2) && false !== e2.get("EncryptMetadata");
    this.encryptMetadata = u2;
    const g2 = stringToBytes$1(t2);
    let f2, p2;
    if (i2) {
      if (6 === d2) try {
        i2 = utf8StringToString(i2);
      } catch {
        warn$1("CipherTransformFactory: Unable to convert UTF8 encoded password.");
      }
      f2 = stringToBytes$1(i2);
    }
    if (5 !== a2) p2 = this.#je(g2, f2, l2, c2, h2, d2, s2, u2);
    else {
      const t3 = r2.subarray(32, 40), i3 = r2.subarray(40, 48), n3 = o2.subarray(0, 48), a3 = o2.subarray(32, 40), s3 = o2.subarray(40, 48), h3 = stringToBytes$1(e2.get("OE")), u3 = stringToBytes$1(e2.get("UE")), g3 = stringToBytes$1(e2.get("Perms"));
      p2 = this.#Ue(d2, f2, l2, t3, i3, n3, c2, a3, s3, h3, u3, g3);
    }
    if (!p2) {
      if (!i2) throw new Jt("No password given", Gt);
      const e3 = this.#$e(f2, l2, d2, s2);
      p2 = this.#je(g2, e3, l2, c2, h2, d2, s2, u2);
    }
    if (!p2) throw new Jt("Incorrect Password", Vt);
    if (4 === a2 && p2.length < 16 ? (this.encryptionKey = new Uint8Array(16), this.encryptionKey.set(p2)) : this.encryptionKey = p2, a2 >= 4) {
      const t3 = e2.get("CF");
      t3 instanceof Dict && (t3.suppressEncryption = true), this.cf = t3, this.stmf = e2.get("StmF") || Name.get("Identity"), this.strf = e2.get("StrF") || Name.get("Identity"), this.eff = e2.get("EFF") || this.stmf;
    }
  }
  createCipherTransform(e2, t2) {
    if (4 === this.algorithm || 5 === this.algorithm) return new CipherTransform(this.#Xe(this.cf, this.strf, e2, t2, this.encryptionKey), this.#Xe(this.cf, this.stmf, e2, t2, this.encryptionKey));
    const i2 = this.#He(e2, t2, this.encryptionKey, false), cipherConstructor = function() {
      return new ARCFourCipher(i2);
    };
    return new CipherTransform(cipherConstructor, cipherConstructor);
  }
}
class XRef {
  constructor(e2, t2) {
    this.stream = e2, this.pdfManager = t2, this.entries = [], this._xrefStms = /* @__PURE__ */ new Set(), this._cacheMap = /* @__PURE__ */ new Map(), this._pendingRefs = new RefSet(), this._newPersistentRefNum = null, this._newTemporaryRefNum = null, this._persistentRefsCache = null;
  }
  getNewPersistentRef(e2) {
    null === this._newPersistentRefNum && (this._newPersistentRefNum = this.entries.length || 1);
    const t2 = this._newPersistentRefNum++;
    return this._cacheMap.set(t2, e2), Ref.get(t2, 0);
  }
  getNewTemporaryRef() {
    if (null === this._newTemporaryRefNum && (this._newTemporaryRefNum = this.entries.length || 1, this._newPersistentRefNum)) {
      this._persistentRefsCache = /* @__PURE__ */ new Map();
      for (let e2 = this._newTemporaryRefNum; e2 < this._newPersistentRefNum; e2++) this._persistentRefsCache.set(e2, this._cacheMap.get(e2)), this._cacheMap.delete(e2);
    }
    return Ref.get(this._newTemporaryRefNum++, 0);
  }
  resetNewTemporaryRef() {
    if (this._newTemporaryRefNum = null, this._persistentRefsCache) for (const [e2, t2] of this._persistentRefsCache) this._cacheMap.set(e2, t2);
    this._persistentRefsCache = null;
  }
  setStartXRef(e2) {
    this.startXRefQueue = [e2];
  }
  parse(e2 = false) {
    let t2, i2, n2;
    e2 ? (warn$1("Indexing all PDF objects"), t2 = this.indexObjects()) : t2 = this.readXRef(), t2.assignXref(this), this.trailer = t2;
    try {
      i2 = t2.get("Encrypt");
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn$1(`XRef.parse - Invalid "Encrypt" reference: "${e3}".`);
    }
    if (i2 instanceof Dict) {
      const e3 = t2.get("ID"), n3 = e3?.length ? e3[0] : "";
      i2.suppressEncryption = true, this.encrypt = new CipherTransformFactory(i2, n3, this.pdfManager.password);
    }
    try {
      n2 = t2.get("Root");
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn$1(`XRef.parse - Invalid "Root" reference: "${e3}".`);
    }
    if (n2 instanceof Dict) try {
      if (n2.get("Pages") instanceof Dict) return void (this.root = n2);
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn$1(`XRef.parse - Invalid "Pages" reference: "${e3}".`);
    }
    if (!e2) throw new XRefParseException();
    throw new Qt("Invalid Root reference.");
  }
  processXRefTable(e2) {
    "tableState" in this || (this.tableState = { entryNum: 0, streamPos: e2.lexer.stream.pos, parserBuf1: e2.buf1, parserBuf2: e2.buf2 });
    if (!isCmd(this.readXRefTable(e2), "trailer")) throw new ti("Invalid XRef table: could not find trailer dictionary");
    let t2 = e2.getObj();
    if (t2 instanceof Dict || !t2.dict || (t2 = t2.dict), !(t2 instanceof Dict)) throw new ti("Invalid XRef table: could not parse trailer dictionary");
    return delete this.tableState, t2;
  }
  readXRefTable(e2) {
    const t2 = e2.lexer.stream, i2 = this.tableState;
    let n2;
    for (t2.pos = i2.streamPos, e2.buf1 = i2.parserBuf1, e2.buf2 = i2.parserBuf2; ; ) {
      if (!("firstEntryNum" in i2) || !("entryCount" in i2)) {
        if (isCmd(n2 = e2.getObj(), "trailer")) break;
        i2.firstEntryNum = n2, i2.entryCount = e2.getObj();
      }
      let a2 = i2.firstEntryNum;
      const s2 = i2.entryCount;
      if (!Number.isInteger(a2) || !Number.isInteger(s2)) throw new ti("Invalid XRef table: wrong types in subsection header");
      for (let n3 = i2.entryNum; n3 < s2; n3++) {
        i2.streamPos = t2.pos, i2.entryNum = n3, i2.parserBuf1 = e2.buf1, i2.parserBuf2 = e2.buf2;
        const r2 = {};
        r2.offset = e2.getObj(), r2.gen = e2.getObj();
        const o2 = e2.getObj();
        if (o2 instanceof Cmd) switch (o2.cmd) {
          case "f":
            r2.free = true;
            break;
          case "n":
            r2.uncompressed = true;
        }
        if (!Number.isInteger(r2.offset) || !Number.isInteger(r2.gen) || !r2.free && !r2.uncompressed) throw new ti(`Invalid entry in XRef subsection: ${a2}, ${s2}`);
        0 === n3 && r2.free && 1 === a2 && (a2 = 0), this.entries[n3 + a2] || (this.entries[n3 + a2] = r2);
      }
      i2.entryNum = 0, i2.streamPos = t2.pos, i2.parserBuf1 = e2.buf1, i2.parserBuf2 = e2.buf2, delete i2.firstEntryNum, delete i2.entryCount;
    }
    if (this.entries[0] && !this.entries[0].free) throw new ti("Invalid XRef table: unexpected first object");
    return n2;
  }
  processXRefStream(e2) {
    if (!("streamState" in this)) {
      const { dict: t2, pos: i2 } = e2, n2 = t2.get("W"), a2 = t2.get("Index") || [0, t2.get("Size")];
      this.streamState = { entryRanges: a2, byteWidths: n2, entryNum: 0, streamPos: i2 };
    }
    return this.readXRefStream(e2), delete this.streamState, e2.dict;
  }
  readXRefStream(e2) {
    const t2 = this.streamState;
    e2.pos = t2.streamPos;
    const [i2, n2, a2] = t2.byteWidths, s2 = t2.entryRanges;
    for (; s2.length > 0; ) {
      const [r2, o2] = s2;
      if (!Number.isInteger(r2) || !Number.isInteger(o2)) throw new ti(`Invalid XRef range fields: ${r2}, ${o2}`);
      if (!Number.isInteger(i2) || !Number.isInteger(n2) || !Number.isInteger(a2)) throw new ti(`Invalid XRef entry fields length: ${r2}, ${o2}`);
      for (let s3 = t2.entryNum; s3 < o2; ++s3) {
        t2.entryNum = s3, t2.streamPos = e2.pos;
        let o3 = 0, l2 = 0, c2 = 0;
        for (let t3 = 0; t3 < i2; ++t3) {
          const t4 = e2.getByte();
          if (-1 === t4) throw new ti("Invalid XRef byteWidths 'type'.");
          o3 = o3 << 8 | t4;
        }
        0 === i2 && (o3 = 1);
        for (let t3 = 0; t3 < n2; ++t3) {
          const t4 = e2.getByte();
          if (-1 === t4) throw new ti("Invalid XRef byteWidths 'offset'.");
          l2 = l2 << 8 | t4;
        }
        for (let t3 = 0; t3 < a2; ++t3) {
          const t4 = e2.getByte();
          if (-1 === t4) throw new ti("Invalid XRef byteWidths 'generation'.");
          c2 = c2 << 8 | t4;
        }
        const h2 = {};
        switch (h2.offset = l2, h2.gen = c2, o3) {
          case 0:
            h2.free = true;
            break;
          case 1:
            h2.uncompressed = true;
            break;
          case 2:
            break;
          default:
            throw new ti(`Invalid XRef entry type: ${o3}`);
        }
        this.entries[r2 + s3] || (this.entries[r2 + s3] = h2);
      }
      t2.entryNum = 0, t2.streamPos = e2.pos, s2.splice(0, 2);
    }
  }
  indexObjects() {
    function readToken(e3, t3) {
      let i3 = "", n3 = e3[t3];
      for (; 10 !== n3 && 13 !== n3 && 60 !== n3 && !(++t3 >= e3.length); ) i3 += String.fromCharCode(n3), n3 = e3[t3];
      return i3;
    }
    function skipUntil(e3, t3, i3) {
      const n3 = i3.length, a3 = e3.length;
      let s3 = 0;
      for (; t3 < a3; ) {
        let a4 = 0;
        for (; a4 < n3 && e3[t3 + a4] === i3[a4]; ) ++a4;
        if (a4 >= n3) break;
        t3++, s3++;
      }
      return s3;
    }
    const e2 = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, t2 = /\b(startxref|\d+\s+\d+\s+obj)\b/g, i2 = /^(\d+)\s+(\d+)\s+obj\b/, n2 = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), a2 = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), s2 = new Uint8Array([47, 88, 82, 101, 102]);
    this.entries.length = 0, this._cacheMap.clear();
    const r2 = this.stream;
    r2.pos = 0;
    const o2 = r2.getBytes(), l2 = bytesToString$1(o2), c2 = o2.length;
    let h2 = r2.start;
    const d2 = [], u2 = [];
    for (; h2 < c2; ) {
      let g3 = o2[h2];
      if (9 === g3 || 10 === g3 || 13 === g3 || 32 === g3) {
        ++h2;
        continue;
      }
      if (37 === g3) {
        do {
          if (++h2, h2 >= c2) break;
          g3 = o2[h2];
        } while (10 !== g3 && 13 !== g3);
        continue;
      }
      const f3 = readToken(o2, h2);
      let p3;
      if (f3.startsWith("xref") && (4 === f3.length || /\s/.test(f3[4]))) h2 += skipUntil(o2, h2, n2), d2.push(h2), h2 += skipUntil(o2, h2, a2);
      else if (p3 = i2.exec(f3)) {
        const t3 = 0 | p3[1], i3 = 0 | p3[2], n3 = h2 + f3.length;
        let a3, d3 = false;
        if (this.entries[t3]) {
          if (this.entries[t3].gen === i3) try {
            new Parser({ lexer: new Lexer(r2.makeSubStream(n3)) }).getObj(), d3 = true;
          } catch (e3) {
            e3 instanceof ParserEOFException ? warn$1(`indexObjects -- checking object (${f3}): "${e3}".`) : d3 = true;
          }
        } else d3 = true;
        d3 && (this.entries[t3] = { offset: h2 - r2.start, gen: i3, uncompressed: true }), e2.lastIndex = n3;
        const g4 = e2.exec(l2);
        if (g4) {
          a3 = e2.lastIndex + 1 - h2, "endobj" !== g4[1] && (warn$1(`indexObjects: Found "${g4[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`), a3 -= g4[1].length + 1);
        } else a3 = c2 - h2;
        const m3 = o2.subarray(h2, h2 + a3), b2 = skipUntil(m3, 0, s2);
        b2 < a3 && m3[b2 + 5] < 64 && (u2.push(h2 - r2.start), this._xrefStms.add(h2 - r2.start)), h2 += a3;
      } else if (f3.startsWith("trailer") && (7 === f3.length || /\s/.test(f3[7]))) {
        d2.push(h2);
        const e3 = h2 + f3.length;
        let i3;
        t2.lastIndex = e3;
        const n3 = t2.exec(l2);
        if (n3) {
          i3 = t2.lastIndex + 1 - h2, "startxref" !== n3[1] && (warn$1(`indexObjects: Found "${n3[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`), i3 -= n3[1].length + 1);
        } else i3 = c2 - h2;
        h2 += i3;
      } else h2 += f3.length + 1;
    }
    for (const e3 of u2) this.startXRefQueue.push(e3), this.readXRef(true);
    const g2 = [];
    let f2, p2, m2 = false;
    for (const e3 of d2) {
      r2.pos = e3;
      const t3 = new Parser({ lexer: new Lexer(r2), xref: this, allowStreams: true, recoveryMode: true });
      if (!isCmd(t3.getObj(), "trailer")) continue;
      const i3 = t3.getObj();
      i3 instanceof Dict && (g2.push(i3), i3.has("Encrypt") && (m2 = true));
    }
    for (const e3 of [...g2, "genFallback", ...g2]) {
      if ("genFallback" === e3) {
        if (!p2) break;
        this._generationFallback = true;
        continue;
      }
      let t3 = false;
      try {
        const i3 = e3.get("Root");
        if (!(i3 instanceof Dict)) continue;
        const n3 = i3.get("Pages");
        if (!(n3 instanceof Dict)) continue;
        const a3 = n3.get("Count");
        Number.isInteger(a3) && (t3 = true);
      } catch (e4) {
        p2 = e4;
        continue;
      }
      if (t3 && (!m2 || e3.has("Encrypt")) && e3.has("ID")) return e3;
      f2 = e3;
    }
    if (f2) return f2;
    if (this.topDict) return this.topDict;
    if (!g2.length) for (const e3 in this.entries) {
      if (!Object.hasOwn(this.entries, e3)) continue;
      const t3 = this.entries[e3], i3 = Ref.get(parseInt(e3), t3.gen);
      let n3;
      try {
        n3 = this.fetch(i3);
      } catch {
        continue;
      }
      if (n3 instanceof BaseStream && (n3 = n3.dict), n3 instanceof Dict && n3.has("Root")) return n3;
    }
    throw new Qt("Invalid PDF structure.");
  }
  readXRef(e2 = false) {
    const t2 = this.stream, i2 = /* @__PURE__ */ new Set();
    for (; this.startXRefQueue.length; ) {
      try {
        const e3 = this.startXRefQueue[0];
        if (i2.has(e3)) {
          warn$1("readXRef - skipping XRef table since it was already parsed."), this.startXRefQueue.shift();
          continue;
        }
        i2.add(e3), t2.pos = e3 + t2.start;
        const n2 = new Parser({ lexer: new Lexer(t2), xref: this, allowStreams: true });
        let a2, s2 = n2.getObj();
        if (isCmd(s2, "xref")) a2 = this.processXRefTable(n2), this.topDict || (this.topDict = a2), s2 = a2.get("XRefStm"), Number.isInteger(s2) && !this._xrefStms.has(s2) && (this._xrefStms.add(s2), this.startXRefQueue.push(s2));
        else {
          if (!Number.isInteger(s2)) throw new ti("Invalid XRef stream header");
          if (!(Number.isInteger(n2.getObj()) && isCmd(n2.getObj(), "obj") && (s2 = n2.getObj()) instanceof BaseStream)) throw new ti("Invalid XRef stream");
          if (a2 = this.processXRefStream(s2), this.topDict || (this.topDict = a2), !a2) throw new ti("Failed to read XRef stream");
        }
        s2 = a2.get("Prev"), Number.isInteger(s2) ? this.startXRefQueue.push(s2) : s2 instanceof Ref && this.startXRefQueue.push(s2.num);
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        info$1("(while reading XRef): " + e3);
      }
      this.startXRefQueue.shift();
    }
    if (this.topDict) return this.topDict;
    if (!e2) throw new XRefParseException();
  }
  getEntry(e2) {
    const t2 = this.entries[e2];
    return t2 && !t2.free && t2.offset ? t2 : null;
  }
  fetchIfRef(e2, t2 = false) {
    return e2 instanceof Ref ? this.fetch(e2, t2) : e2;
  }
  fetch(e2, t2 = false) {
    if (!(e2 instanceof Ref)) throw new Error("ref object is not a reference");
    const i2 = e2.num, n2 = this._cacheMap.get(i2);
    if (void 0 !== n2) return n2 instanceof Dict && !n2.objId && (n2.objId = e2.toString()), n2;
    let a2 = this.getEntry(i2);
    if (null === a2) return a2;
    if (this._pendingRefs.has(e2)) return this._pendingRefs.remove(e2), warn$1(`Ignoring circular reference: ${e2}.`), li;
    this._pendingRefs.put(e2);
    try {
      a2 = a2.uncompressed ? this.fetchUncompressed(e2, a2, t2) : this.fetchCompressed(e2, a2, t2), this._pendingRefs.remove(e2);
    } catch (t3) {
      throw this._pendingRefs.remove(e2), t3;
    }
    return a2 instanceof Dict ? a2.objId = e2.toString() : a2 instanceof BaseStream && (a2.dict.objId = e2.toString()), a2;
  }
  fetchUncompressed(e2, t2, i2 = false) {
    const n2 = e2.gen;
    let a2 = e2.num;
    if (t2.gen !== n2) {
      const s3 = `Inconsistent generation in XRef: ${e2}`;
      if (this._generationFallback && t2.gen < n2) return warn$1(s3), this.fetchUncompressed(Ref.get(a2, t2.gen), t2, i2);
      throw new XRefEntryException(s3);
    }
    const s2 = this.stream.makeSubStream(t2.offset + this.stream.start), r2 = new Parser({ lexer: new Lexer(s2), xref: this, allowStreams: true }), o2 = r2.getObj(), l2 = r2.getObj(), c2 = r2.getObj();
    if (o2 !== a2 || l2 !== n2 || !(c2 instanceof Cmd)) throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e2}`);
    if ("obj" !== c2.cmd) {
      if (c2.cmd.startsWith("obj") && (a2 = parseInt(c2.cmd.substring(3), 10), !Number.isNaN(a2))) return a2;
      throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e2}`);
    }
    return (t2 = this.encrypt && !i2 ? r2.getObj(this.encrypt.createCipherTransform(a2, n2)) : r2.getObj()) instanceof BaseStream || this._cacheMap.set(a2, t2), t2;
  }
  fetchCompressed(e2, t2, i2 = false) {
    const n2 = t2.offset, a2 = this.fetch(Ref.get(n2, 0));
    if (!(a2 instanceof BaseStream)) throw new ti("bad ObjStm stream");
    const s2 = a2.dict.get("First"), r2 = a2.dict.get("N");
    if (!Number.isInteger(s2) || !Number.isInteger(r2)) throw new ti("invalid first and n parameters for ObjStm stream");
    let o2 = new Parser({ lexer: new Lexer(a2), xref: this, allowStreams: true });
    const l2 = new Array(r2), c2 = new Array(r2);
    for (let e3 = 0; e3 < r2; ++e3) {
      const t3 = o2.getObj();
      if (!Number.isInteger(t3)) throw new ti(`invalid object number in the ObjStm stream: ${t3}`);
      const i3 = o2.getObj();
      if (!Number.isInteger(i3)) throw new ti(`invalid object offset in the ObjStm stream: ${i3}`);
      l2[e3] = t3;
      const a3 = this.getEntry(t3);
      a3?.offset === n2 && a3.gen !== e3 && (a3.gen = e3), c2[e3] = i3;
    }
    const h2 = (a2.start || 0) + s2, d2 = new Array(r2);
    for (let e3 = 0; e3 < r2; ++e3) {
      const t3 = e3 < r2 - 1 ? c2[e3 + 1] - c2[e3] : void 0;
      if (t3 < 0) throw new ti("Invalid offset in the ObjStm stream.");
      o2 = new Parser({ lexer: new Lexer(a2.makeSubStream(h2 + c2[e3], t3, a2.dict)), xref: this, allowStreams: true });
      const i3 = o2.getObj();
      if (d2[e3] = i3, i3 instanceof BaseStream) continue;
      const s3 = l2[e3], u2 = this.entries[s3];
      u2 && u2.offset === n2 && u2.gen === e3 && this._cacheMap.set(s3, i3);
    }
    if (void 0 === (t2 = d2[t2.gen])) throw new XRefEntryException(`Bad (compressed) XRef entry: ${e2}`);
    return t2;
  }
  async fetchIfRefAsync(e2, t2) {
    return e2 instanceof Ref ? this.fetchAsync(e2, t2) : e2;
  }
  async fetchAsync(e2, t2) {
    try {
      return this.fetch(e2, t2);
    } catch (i2) {
      if (!(i2 instanceof MissingDataException)) throw i2;
      return await this.pdfManager.requestRange(i2.begin, i2.end), this.fetchAsync(e2, t2);
    }
  }
  getCatalogObj() {
    return this.root;
  }
}
const ul = [0, 0, 612, 792];
class Page {
  #qe = false;
  #ze = null;
  constructor({ pdfManager: e2, xref: t2, pageIndex: i2, pageDict: n2, ref: a2, globalIdFactory: s2, fontCache: r2, builtInCMapCache: o2, standardFontDataCache: l2, globalColorSpaceCache: c2, globalImageCache: h2, systemFontCache: d2, nonBlendModesSet: u2, xfaFactory: g2 }) {
    this.pdfManager = e2, this.pageIndex = i2, this.pageDict = n2, this.xref = t2, this.ref = a2, this.fontCache = r2, this.builtInCMapCache = o2, this.standardFontDataCache = l2, this.globalColorSpaceCache = c2, this.globalImageCache = h2, this.systemFontCache = d2, this.nonBlendModesSet = u2, this.evaluatorOptions = e2.evaluatorOptions, this.xfaFactory = g2;
    const f2 = { obj: 0 };
    this._localIdFactory = class extends s2 {
      static createObjId() {
        return `p${i2}_${++f2.obj}`;
      }
      static getPageObjId() {
        return `p${a2.toString()}`;
      }
    };
  }
  #We(e2) {
    return new PartialEvaluator({ xref: this.xref, handler: e2, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalColorSpaceCache: this.globalColorSpaceCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions });
  }
  #Ge(e2, t2 = false) {
    const i2 = getInheritableProperty({ dict: this.pageDict, key: e2, getArray: t2, stopWhenFound: false });
    return Array.isArray(i2) ? 1 !== i2.length && i2[0] instanceof Dict ? Dict.merge({ xref: this.xref, dictArray: i2 }) : i2[0] : i2;
  }
  get content() {
    return this.pageDict.getArray("Contents");
  }
  get resources() {
    const e2 = this.#Ge("Resources");
    return shadow$1(this, "resources", e2 instanceof Dict ? e2 : Dict.empty);
  }
  #Ve(e2) {
    if (this.xfaData) return this.xfaData.bbox;
    const t2 = lookupNormalRect(this.#Ge(e2, true), null);
    if (t2) {
      if (t2[2] - t2[0] > 0 && t2[3] - t2[1] > 0) return t2;
      warn$1(`Empty, or invalid, /${e2} entry.`);
    }
    return null;
  }
  get mediaBox() {
    return shadow$1(this, "mediaBox", this.#Ve("MediaBox") || ul);
  }
  get cropBox() {
    return shadow$1(this, "cropBox", this.#Ve("CropBox") || this.mediaBox);
  }
  get userUnit() {
    const e2 = this.pageDict.get("UserUnit");
    return shadow$1(this, "userUnit", "number" == typeof e2 && e2 > 0 ? e2 : 1);
  }
  get view() {
    const { cropBox: e2, mediaBox: t2 } = this;
    if (e2 !== t2 && !isArrayEqual(e2, t2)) {
      const i2 = ai.intersect(e2, t2);
      if (i2 && i2[2] - i2[0] > 0 && i2[3] - i2[1] > 0) return shadow$1(this, "view", i2);
      warn$1("Empty /CropBox and /MediaBox intersection.");
    }
    return shadow$1(this, "view", t2);
  }
  get rotate() {
    let e2 = this.#Ge("Rotate") || 0;
    return e2 % 90 != 0 ? e2 = 0 : e2 >= 360 ? e2 %= 360 : e2 < 0 && (e2 = (e2 % 360 + 360) % 360), shadow$1(this, "rotate", e2);
  }
  #Ke(e2, t2) {
    if (!this.evaluatorOptions.ignoreErrors) throw e2;
    warn$1(`getContentStream - ignoring sub-stream (${t2}): "${e2}".`);
  }
  async getContentStream() {
    const e2 = await this.pdfManager.ensure(this, "content");
    return e2 instanceof BaseStream ? e2 : Array.isArray(e2) ? new StreamsSequenceStream(e2, this.#Ke.bind(this)) : new NullStream();
  }
  get xfaData() {
    return shadow$1(this, "xfaData", this.xfaFactory ? { bbox: this.xfaFactory.getBoundingBox(this.pageIndex) } : null);
  }
  async #Ye(e2, t2, i2) {
    const n2 = [];
    for (const a2 of e2) if (a2.id) {
      const e3 = Ref.fromString(a2.id);
      if (!e3) {
        warn$1(`A non-linked annotation cannot be modified: ${a2.id}`);
        continue;
      }
      if (a2.deleted) {
        if (t2.put(e3, e3), a2.popupRef) {
          const e4 = Ref.fromString(a2.popupRef);
          e4 && t2.put(e4, e4);
        }
        continue;
      }
      if (a2.popup?.deleted) {
        const e4 = Ref.fromString(a2.popupRef);
        e4 && t2.put(e4, e4);
      }
      i2?.put(e3), a2.ref = e3, n2.push(this.xref.fetchAsync(e3).then((e4) => {
        e4 instanceof Dict && (a2.oldAnnotation = e4.clone());
      }, () => {
        warn$1(`Cannot fetch \`oldAnnotation\` for: ${e3}.`);
      })), delete a2.id;
    }
    await Promise.all(n2);
  }
  async saveNewAnnotations(e2, t2, i2, n2, a2) {
    if (this.xfaFactory) throw new Error("XFA: Cannot save new annotations.");
    const s2 = this.#We(e2), r2 = new RefSetCache(), o2 = new RefSet();
    await this.#Ye(i2, r2, o2);
    const l2 = this.pageDict, c2 = this.annotations.filter((e3) => !(e3 instanceof Ref && r2.has(e3))), h2 = await AnnotationFactory.saveNewAnnotations(s2, t2, i2, n2, a2);
    for (const { ref: e3 } of h2.annotations) e3 instanceof Ref && !o2.has(e3) && c2.push(e3);
    const d2 = l2.clone();
    d2.set("Annots", c2), a2.put(this.ref, { data: d2 });
    for (const e3 of r2) a2.put(e3, { data: null });
  }
  async save(e2, t2, i2, n2) {
    const a2 = this.#We(e2), s2 = await this._parsedAnnotations, r2 = [];
    for (const e3 of s2) r2.push(e3.save(a2, t2, i2, n2).catch(function(e4) {
      return warn$1(`save - ignoring annotation data during "${t2.name}" task: "${e4}".`), null;
    }));
    return Promise.all(r2);
  }
  async loadResources(e2) {
    await (this.#ze ??= this.pdfManager.ensure(this, "resources")), await ObjectLoader.load(this.resources, e2, this.xref);
  }
  async #Je(e2, t2) {
    const i2 = e2?.get("Resources");
    return i2 instanceof Dict && i2.size ? (await ObjectLoader.load(i2, t2, this.xref), Dict.merge({ xref: this.xref, dictArray: [i2, this.resources], mergeSubDicts: true })) : this.resources;
  }
  async getOperatorList({ handler: e2, sink: t2, task: i2, intent: n2, cacheKey: a2, annotationStorage: l2 = null, modifiedIds: u2 = null }) {
    const f2 = this.getContentStream(), p2 = this.loadResources(mi), m2 = this.#We(e2), b2 = this.xfaFactory ? null : getNewAnnotationsMap(l2), y2 = b2?.get(this.pageIndex);
    let w2 = Promise.resolve(null), x2 = null;
    if (y2) {
      const e3 = this.pdfManager.ensureDoc("annotationGlobals");
      let t3;
      const n3 = /* @__PURE__ */ new Set();
      for (const { bitmapId: e4, bitmap: t4 } of y2) !e4 || t4 || n3.has(e4) || n3.add(e4);
      const { isOffscreenCanvasSupported: a3 } = this.evaluatorOptions;
      if (n3.size > 0) {
        const e4 = y2.slice();
        for (const [t4, i3] of l2) t4.startsWith(g) && i3.bitmap && n3.has(i3.bitmapId) && e4.push(i3);
        t3 = AnnotationFactory.generateImages(e4, this.xref, a3);
      } else t3 = AnnotationFactory.generateImages(y2, this.xref, a3);
      x2 = new RefSet(), w2 = Promise.all([e3, this.#Ye(y2, x2, null)]).then(([e4]) => e4 ? AnnotationFactory.printNewAnnotations(e4, m2, i2, y2, t3) : null);
    }
    const S2 = Promise.all([f2, p2]).then(async ([s2]) => {
      const r2 = await this.#Je(s2.dict, mi), o2 = new OperatorList(n2, t2);
      return e2.send("StartRenderPage", { transparency: m2.hasBlendModes(r2, this.nonBlendModesSet), pageIndex: this.pageIndex, cacheKey: a2 }), await m2.getOperatorList({ stream: s2, task: i2, resources: r2, operatorList: o2 }), o2;
    });
    let [v2, C2, k2] = await Promise.all([S2, this._parsedAnnotations, w2]);
    if (k2) {
      C2 = C2.filter((e3) => !(e3.ref && x2.has(e3.ref)));
      for (let e3 = 0, t3 = k2.length; e3 < t3; e3++) {
        const i3 = k2[e3];
        if (i3.refToReplace) {
          const n3 = C2.findIndex((e4) => e4.ref && isRefsEqual(e4.ref, i3.refToReplace));
          n3 >= 0 && (C2.splice(n3, 1, i3), k2.splice(e3--, 1), t3--);
        }
      }
      C2 = C2.concat(k2);
    }
    if (0 === C2.length || n2 & h) return v2.flush(true), { length: v2.totalLength };
    const T2 = !!(n2 & c), F2 = !!(n2 & d), E2 = !!(n2 & s), M2 = !!(n2 & r), D2 = !!(n2 & o), O2 = [];
    for (const e3 of C2) (E2 || M2 && e3.mustBeViewed(l2, T2) && e3.mustBeViewedWhenEditing(F2, u2) || D2 && e3.mustBePrinted(l2)) && O2.push(e3.getOperatorList(m2, i2, n2, l2).catch(function(e4) {
      return warn$1(`getOperatorList - ignoring annotation data during "${i2.name}" task: "${e4}".`), { opList: null, separateForm: false, separateCanvas: false };
    }));
    const _2 = await Promise.all(O2);
    let R2 = false, N2 = false;
    for (const { opList: e3, separateForm: t3, separateCanvas: i3 } of _2) v2.addOpList(e3), R2 ||= t3, N2 ||= i3;
    return v2.flush(true, { form: R2, canvas: N2 }), { length: v2.totalLength };
  }
  async extractTextContent({ handler: e2, task: t2, includeMarkedContent: i2, disableNormalization: n2, sink: a2, intersector: s2 = null }) {
    const r2 = this.getContentStream(), o2 = this.loadResources(bi), l2 = this.pdfManager.ensureCatalog("lang"), [c2, , h2] = await Promise.all([r2, o2, l2]), d2 = await this.#Je(c2.dict, bi);
    return this.#We(e2).getTextContent({ stream: c2, task: t2, resources: d2, includeMarkedContent: i2, disableNormalization: n2, sink: a2, viewBox: this.view, lang: h2, intersector: s2 });
  }
  async getStructTree() {
    const e2 = await this.pdfManager.ensureCatalog("structTreeRoot");
    if (!e2) return null;
    await this._parsedAnnotations;
    try {
      const t2 = await this.pdfManager.ensure(this, "_parseStructTree", [e2]);
      return await this.pdfManager.ensure(t2, "serializable");
    } catch (e3) {
      return warn$1(`getStructTree: "${e3}".`), null;
    }
  }
  _parseStructTree(e2) {
    const t2 = new StructTreePage(e2, this.pageDict);
    return t2.parse(this.ref), t2;
  }
  async getAnnotationsData(e2, t2, i2) {
    const n2 = await this._parsedAnnotations;
    if (0 === n2.length) return n2;
    const a2 = [], l2 = [];
    let c2;
    const h2 = !!(i2 & s), d2 = !!(i2 & r), u2 = !!(i2 & o), g2 = [];
    for (const i3 of n2) {
      const n3 = h2 || d2 && i3.viewable;
      (n3 || u2 && i3.printable) && a2.push(i3.data), i3.hasTextContent && n3 ? (c2 ??= this.#We(e2), l2.push(i3.extractTextContent(c2, t2, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]).catch(function(e3) {
        warn$1(`getAnnotationsData - ignoring textContent during "${t2.name}" task: "${e3}".`);
      }))) : i3.overlaysTextContent && n3 && g2.push(i3);
    }
    if (g2.length > 0) {
      const i3 = new Intersector(g2);
      l2.push(this.extractTextContent({ handler: e2, task: t2, includeMarkedContent: false, disableNormalization: false, sink: null, viewBox: this.view, lang: null, intersector: i3 }).then(() => {
        i3.setText();
      }));
    }
    return await Promise.all(l2), a2;
  }
  get annotations() {
    const e2 = this.#Ge("Annots");
    return shadow$1(this, "annotations", Array.isArray(e2) ? e2 : []);
  }
  get _parsedAnnotations() {
    const e2 = this.pdfManager.ensure(this, "annotations").then(async (e3) => {
      if (0 === e3.length) return e3;
      const [t2, i2] = await Promise.all([this.pdfManager.ensureDoc("annotationGlobals"), this.pdfManager.ensureDoc("fieldObjects")]);
      if (!t2) return [];
      const n2 = i2?.orphanFields, a2 = [];
      for (const i3 of e3) a2.push(AnnotationFactory.create(this.xref, i3, t2, this._localIdFactory, false, n2, null, this.ref).catch(function(e4) {
        return warn$1(`_parsedAnnotations: "${e4}".`), null;
      }));
      const s2 = [];
      let r2, o2;
      for (const e4 of await Promise.all(a2)) e4 && (e4 instanceof WidgetAnnotation ? (o2 ||= []).push(e4) : e4 instanceof PopupAnnotation ? (r2 ||= []).push(e4) : s2.push(e4));
      return o2 && s2.push(...o2), r2 && s2.push(...r2), s2;
    });
    return this.#qe = true, shadow$1(this, "_parsedAnnotations", e2);
  }
  get jsActions() {
    return shadow$1(this, "jsActions", collectActions(this.xref, this.pageDict, ne));
  }
  async collectAnnotationsByType(e2, t2, i2, n2, a2) {
    const { pageIndex: s2 } = this;
    if (this.#qe) {
      const e3 = await this._parsedAnnotations;
      for (const { data: t3 } of e3) i2 && !i2.has(t3.annotationType) || (t3.pageIndex = s2, n2.push(Promise.resolve(t3)));
      return;
    }
    const r2 = await this.pdfManager.ensure(this, "annotations");
    for (const o2 of r2) n2.push(AnnotationFactory.create(this.xref, o2, a2, this._localIdFactory, false, null, i2, this.ref).then(async (i3) => {
      if (!i3) return null;
      if (i3.data.pageIndex = s2, i3.hasTextContent && i3.viewable) {
        const n3 = this.#We(e2);
        await i3.extractTextContent(n3, t2, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]);
      }
      return i3.data;
    }).catch(function(e3) {
      return warn$1(`collectAnnotationsByType: "${e3}".`), null;
    }));
  }
}
const gl = new Uint8Array([37, 80, 68, 70, 45]), fl = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), pl = new Uint8Array([101, 110, 100, 111, 98, 106]);
function find(e2, t2, i2 = 1024, n2 = false) {
  const a2 = t2.length, s2 = e2.peekBytes(i2), r2 = s2.length - a2;
  if (r2 <= 0) return false;
  if (n2) {
    const i3 = a2 - 1;
    let n3 = s2.length - 1;
    for (; n3 >= i3; ) {
      let r3 = 0;
      for (; r3 < a2 && s2[n3 - r3] === t2[i3 - r3]; ) r3++;
      if (r3 >= a2) return e2.pos += n3 - i3, true;
      n3--;
    }
  } else {
    let i3 = 0;
    for (; i3 <= r2; ) {
      let n3 = 0;
      for (; n3 < a2 && s2[i3 + n3] === t2[n3]; ) n3++;
      if (n3 >= a2) return e2.pos += i3, true;
      i3++;
    }
  }
  return false;
}
class PDFDocument {
  #Ze = /* @__PURE__ */ new Map();
  #Qe = null;
  constructor(e2, t2) {
    if (t2.length <= 0) throw new Qt("The PDF file is empty, i.e. its size is zero bytes.");
    this.pdfManager = e2, this.stream = t2, this.xref = new XRef(t2, e2);
    const i2 = { font: 0 };
    this._globalIdFactory = class {
      static getDocId() {
        return `g_${e2.docId}`;
      }
      static createFontId() {
        return "f" + ++i2.font;
      }
      static createObjId() {
        unreachable$1("Abstract method `createObjId` called.");
      }
      static getPageObjId() {
        unreachable$1("Abstract method `getPageObjId` called.");
      }
    };
  }
  parse(e2) {
    this.xref.parse(e2), this.catalog = new Catalog(this.pdfManager, this.xref);
  }
  get linearization() {
    let e2 = null;
    try {
      e2 = Linearization.create(this.stream);
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      info$1(e3);
    }
    return shadow$1(this, "linearization", e2);
  }
  get startXRef() {
    const e2 = this.stream;
    let t2 = 0;
    if (this.linearization) {
      if (e2.reset(), find(e2, pl)) {
        e2.skip(6);
        let i2 = e2.peekByte();
        for (; isWhiteSpace(i2); ) e2.pos++, i2 = e2.peekByte();
        t2 = e2.pos - e2.start;
      }
    } else {
      const i2 = 1024, n2 = fl.length;
      let a2 = false, s2 = e2.end;
      for (; !a2 && s2 > 0; ) s2 -= i2 - n2, s2 < 0 && (s2 = 0), e2.pos = s2, a2 = find(e2, fl, i2, true);
      if (a2) {
        let i3;
        e2.skip(9);
        do {
          i3 = e2.getByte();
        } while (isWhiteSpace(i3));
        let n3 = "";
        for (; i3 >= 32 && i3 <= 57; ) n3 += String.fromCharCode(i3), i3 = e2.getByte();
        t2 = parseInt(n3, 10), isNaN(t2) && (t2 = 0);
      }
    }
    return shadow$1(this, "startXRef", t2);
  }
  checkHeader() {
    const e2 = this.stream;
    if (e2.reset(), !find(e2, gl)) return;
    e2.moveStart(), e2.skip(gl.length);
    let t2, i2 = "";
    for (; (t2 = e2.getByte()) > 32 && i2.length < 7; ) i2 += String.fromCharCode(t2);
    gi.test(i2) ? this.#Qe = i2 : warn$1(`Invalid PDF header version: ${i2}`);
  }
  parseStartXRef() {
    this.xref.setStartXRef(this.startXRef);
  }
  get numPages() {
    let e2 = 0;
    return e2 = this.catalog.hasActualNumPages ? this.catalog.numPages : this.xfaFactory ? this.xfaFactory.getNumPages() : this.linearization ? this.linearization.numPages : this.catalog.numPages, shadow$1(this, "numPages", e2);
  }
  #et(e2, t2 = 0) {
    return !!Array.isArray(e2) && e2.every((e3) => {
      if (!((e3 = this.xref.fetchIfRef(e3)) instanceof Dict)) return false;
      if (e3.has("Kids")) return ++t2 > 10 ? (warn$1("#hasOnlyDocumentSignatures: maximum recursion depth reached"), false) : this.#et(e3.get("Kids"), t2);
      const i2 = isName(e3.get("FT"), "Sig"), n2 = e3.get("Rect"), a2 = Array.isArray(n2) && n2.every((e4) => 0 === e4);
      return i2 && a2;
    });
  }
  #tt(e2, t2, i2 = new RefSet()) {
    if (Array.isArray(e2)) for (let n2 of e2) {
      if (n2 instanceof Ref) {
        if (i2.has(n2)) continue;
        i2.put(n2);
      }
      if (n2 = this.xref.fetchIfRef(n2), !(n2 instanceof Dict)) continue;
      if (n2.has("Kids")) {
        this.#tt(n2.get("Kids"), t2, i2);
        continue;
      }
      if (!isName(n2.get("FT"), "Sig")) continue;
      const e3 = n2.get("V");
      if (!(e3 instanceof Dict)) continue;
      const a2 = e3.get("SubFilter");
      a2 instanceof Name && t2.add(a2.name);
    }
  }
  get _xfaStreams() {
    const { acroForm: e2 } = this.catalog;
    if (!e2) return null;
    const t2 = e2.get("XFA"), i2 = new Map(["xdp:xdp", "template", "datasets", "config", "connectionSet", "localeSet", "stylesheet", "/xdp:xdp"].map((e3) => [e3, null]));
    if (t2 instanceof BaseStream && !t2.isEmpty) return i2.set("xdp:xdp", t2), i2;
    if (!Array.isArray(t2) || 0 === t2.length) return null;
    for (let e3 = 0, n2 = t2.length; e3 < n2; e3 += 2) {
      let a2;
      if (a2 = 0 === e3 ? "xdp:xdp" : e3 === n2 - 2 ? "/xdp:xdp" : t2[e3], !i2.has(a2)) continue;
      const s2 = this.xref.fetchIfRef(t2[e3 + 1]);
      s2 instanceof BaseStream && !s2.isEmpty && i2.set(a2, s2);
    }
    return i2;
  }
  get xfaDatasets() {
    const e2 = this._xfaStreams;
    if (!e2) return shadow$1(this, "xfaDatasets", null);
    for (const t2 of ["datasets", "xdp:xdp"]) {
      const i2 = e2.get(t2);
      if (i2) try {
        const e3 = stringToUTF8String$1(i2.getString());
        return shadow$1(this, "xfaDatasets", new DatasetReader({ [t2]: e3 }));
      } catch {
        warn$1("XFA - Invalid utf-8 string.");
        break;
      }
    }
    return shadow$1(this, "xfaDatasets", null);
  }
  get xfaData() {
    const e2 = this._xfaStreams;
    if (!e2) return null;
    const t2 = /* @__PURE__ */ Object.create(null);
    for (const [i2, n2] of e2) if (n2) try {
      t2[i2] = stringToUTF8String$1(n2.getString());
    } catch {
      return warn$1("XFA - Invalid utf-8 string."), null;
    }
    return t2;
  }
  get xfaFactory() {
    let e2;
    return this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (e2 = this.xfaData), shadow$1(this, "xfaFactory", e2 ? new XFAFactory(e2) : null);
  }
  get isPureXfa() {
    return !!this.xfaFactory && this.xfaFactory.isValid();
  }
  get htmlForXfa() {
    return this.xfaFactory ? this.xfaFactory.getPages() : null;
  }
  async #it() {
    const e2 = await this.pdfManager.ensureCatalog("xfaImages");
    e2 && this.xfaFactory.setImages(e2);
  }
  async #nt(e2, t2) {
    const i2 = await this.pdfManager.ensureCatalog("acroForm");
    if (!i2) return;
    const n2 = await i2.getAsync("DR");
    if (!(n2 instanceof Dict)) return;
    await ObjectLoader.load(n2, ["Font"], this.xref);
    const a2 = n2.get("Font");
    if (!(a2 instanceof Dict)) return;
    const s2 = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions, { useSystemFonts: false }), { builtInCMapCache: r2, fontCache: o2, standardFontDataCache: l2 } = this.catalog, c2 = new PartialEvaluator({ xref: this.xref, handler: e2, pageIndex: -1, idFactory: this._globalIdFactory, fontCache: o2, builtInCMapCache: r2, standardFontDataCache: l2, options: s2 }), h2 = new OperatorList(), d2 = [], u2 = { get font() {
      return d2.at(-1);
    }, set font(e3) {
      d2.push(e3);
    }, clone() {
      return this;
    } }, parseFont = (e3, i3, a3) => c2.handleSetFont(n2, [Name.get(e3), 1], null, h2, t2, u2, i3, a3).catch((e4) => (warn$1(`loadXfaFonts: "${e4}".`), null)), g2 = [];
    for (const [e3, t3] of a2) {
      const i3 = t3.get("FontDescriptor");
      if (!(i3 instanceof Dict)) continue;
      let n3 = i3.get("FontFamily");
      n3 = n3.replaceAll(/[ ]+(\d)/g, "$1");
      const a3 = { fontFamily: n3, fontWeight: i3.get("FontWeight"), italicAngle: -i3.get("ItalicAngle") };
      validateCSSFont(a3) && g2.push(parseFont(e3, null, a3));
    }
    await Promise.all(g2);
    const f2 = this.xfaFactory.setFonts(d2);
    if (!f2) return;
    s2.ignoreErrors = true, g2.length = 0, d2.length = 0;
    const p2 = /* @__PURE__ */ new Set();
    for (const e3 of f2) getXfaFontName(`${e3}-Regular`) || p2.add(e3);
    p2.size && f2.push("PdfJS-Fallback");
    for (const e3 of f2) if (!p2.has(e3)) for (const t3 of [{ name: "Regular", fontWeight: 400, italicAngle: 0 }, { name: "Bold", fontWeight: 700, italicAngle: 0 }, { name: "Italic", fontWeight: 400, italicAngle: 12 }, { name: "BoldItalic", fontWeight: 700, italicAngle: 12 }]) {
      const i3 = `${e3}-${t3.name}`;
      g2.push(parseFont(i3, getXfaFontDict(i3), { fontFamily: e3, fontWeight: t3.fontWeight, italicAngle: t3.italicAngle }));
    }
    await Promise.all(g2), this.xfaFactory.appendFonts(d2, p2);
  }
  loadXfaResources(e2, t2) {
    return Promise.all([this.#nt(e2, t2).catch(() => {
    }), this.#it()]);
  }
  serializeXfaData(e2) {
    return this.xfaFactory ? this.xfaFactory.serializeData(e2) : null;
  }
  get version() {
    return this.catalog.version || this.#Qe;
  }
  get formInfo() {
    const e2 = { hasFields: false, hasAcroForm: false, hasXfa: false, hasSignatures: false }, { acroForm: t2 } = this.catalog;
    if (!t2) return shadow$1(this, "formInfo", e2);
    try {
      const i2 = t2.get("Fields"), n2 = Array.isArray(i2) && i2.length > 0;
      e2.hasFields = n2;
      const a2 = t2.get("XFA");
      e2.hasXfa = Array.isArray(a2) && a2.length > 0 || a2 instanceof BaseStream && !a2.isEmpty;
      const s2 = !!(1 & t2.get("SigFlags")), r2 = s2 && this.#et(i2);
      e2.hasAcroForm = n2 && !r2, e2.hasSignatures = s2;
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn$1(`Cannot fetch form information: "${e3}".`);
    }
    return shadow$1(this, "formInfo", e2);
  }
  get documentInfo() {
    const { catalog: e2, formInfo: t2, xref: i2 } = this, n2 = { PDFFormatVersion: this.version, Language: e2.lang, EncryptFilterName: i2.encrypt?.filterName ?? null, IsLinearized: !!this.linearization, IsAcroFormPresent: t2.hasAcroForm, IsXFAPresent: t2.hasXfa, IsCollectionPresent: !!e2.collection, IsSignaturesPresent: t2.hasSignatures };
    let a2;
    try {
      a2 = i2.trailer.get("Info");
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      info$1("The document information dictionary is invalid.");
    }
    if (!(a2 instanceof Dict)) return shadow$1(this, "documentInfo", n2);
    for (const [e3, t3] of a2) {
      switch (e3) {
        case "Title":
        case "Author":
        case "Subject":
        case "Keywords":
        case "Creator":
        case "Producer":
        case "CreationDate":
        case "ModDate":
          if ("string" == typeof t3) {
            n2[e3] = stringToPDFString(t3);
            continue;
          }
          break;
        case "Trapped":
          if (t3 instanceof Name) {
            n2[e3] = t3;
            continue;
          }
          break;
        default:
          let i3;
          switch (typeof t3) {
            case "string":
              i3 = stringToPDFString(t3);
              break;
            case "number":
            case "boolean":
              i3 = t3;
              break;
            default:
              t3 instanceof Name && (i3 = t3);
          }
          if (void 0 === i3) {
            warn$1(`Bad value, for custom key "${e3}", in Info: ${t3}.`);
            continue;
          }
          n2.Custom ??= /* @__PURE__ */ Object.create(null), n2.Custom[e3] = i3;
          continue;
      }
      warn$1(`Bad value, for key "${e3}", in Info: ${t3}.`);
    }
    return shadow$1(this, "documentInfo", n2);
  }
  get fingerprints() {
    const e2 = "\0".repeat(16);
    function validate(t3) {
      return "string" == typeof t3 && 16 === t3.length && t3 !== e2;
    }
    const t2 = this.xref.trailer.get("ID");
    let i2, n2;
    return Array.isArray(t2) && validate(t2[0]) ? (i2 = stringToBytes$1(t2[0]), t2[1] !== t2[0] && validate(t2[1]) && (n2 = stringToBytes$1(t2[1]))) : i2 = calculateMD5(this.stream.getByteRange(0, 1024), 0, 1024), shadow$1(this, "fingerprints", [toHexUtil(i2), n2 ? toHexUtil(n2) : null]);
  }
  async #at(e2) {
    const { catalog: t2, linearization: i2, xref: n2 } = this, a2 = Ref.get(i2.objectNumberFirst, 0);
    try {
      const e3 = await n2.fetchAsync(a2);
      if (e3 instanceof Dict) {
        let i3 = e3.getRaw("Type");
        if (i3 instanceof Ref && (i3 = await n2.fetchAsync(i3)), isName(i3, "Page") || !e3.has("Type") && !e3.has("Kids") && e3.has("Contents")) return t2.pageKidsCountCache.has(a2) || t2.pageKidsCountCache.put(a2, 1), t2.pageIndexCache.has(a2) || t2.pageIndexCache.put(a2, 0), [e3, a2];
      }
      throw new ti("The Linearization dictionary doesn't point to a valid Page dictionary.");
    } catch (i3) {
      return warn$1(`_getLinearizationPage: "${i3.message}".`), t2.getPageDict(e2);
    }
  }
  getPage(e2) {
    const t2 = this.#Ze.get(e2);
    if (t2) return t2;
    const { catalog: i2, linearization: n2, xfaFactory: a2 } = this;
    let s2;
    return s2 = a2 ? Promise.resolve([Dict.empty, null]) : n2?.pageFirst === e2 ? this.#at(e2) : i2.getPageDict(e2), s2 = s2.then(([t3, n3]) => new Page({ pdfManager: this.pdfManager, xref: this.xref, pageIndex: e2, pageDict: t3, ref: n3, globalIdFactory: this._globalIdFactory, fontCache: i2.fontCache, builtInCMapCache: i2.builtInCMapCache, standardFontDataCache: i2.standardFontDataCache, globalColorSpaceCache: i2.globalColorSpaceCache, globalImageCache: i2.globalImageCache, systemFontCache: i2.systemFontCache, nonBlendModesSet: i2.nonBlendModesSet, xfaFactory: a2 })), this.#Ze.set(e2, s2), s2;
  }
  async checkFirstPage(e2 = false) {
    if (!e2) try {
      await this.getPage(0);
    } catch (e3) {
      if (e3 instanceof XRefEntryException) throw this.#Ze.delete(0), await this.cleanup(), new XRefParseException();
    }
  }
  async checkLastPage(e2 = false) {
    const { catalog: t2, pdfManager: i2 } = this;
    let n2;
    t2.setActualNumPages();
    try {
      if (await Promise.all([i2.ensureDoc("xfaFactory"), i2.ensureDoc("linearization"), i2.ensureCatalog("numPages")]), this.xfaFactory) return;
      if (n2 = this.linearization ? this.linearization.numPages : t2.numPages, !Number.isInteger(n2)) throw new ti("Page count is not an integer.");
      if (n2 <= 1) return;
      await this.getPage(n2 - 1);
    } catch (a2) {
      if (this.#Ze.delete(n2 - 1), await this.cleanup(), a2 instanceof XRefEntryException && !e2) throw new XRefParseException();
      let s2;
      warn$1(`checkLastPage - invalid /Pages tree /Count: ${n2}.`);
      try {
        s2 = await t2.getAllPageDicts(e2);
      } catch (i3) {
        if (i3 instanceof XRefEntryException && !e2) throw new XRefParseException();
        return void t2.setActualNumPages(1);
      }
      for (const [e3, [n3, a3]] of s2) {
        let s3;
        n3 instanceof Error ? (s3 = Promise.reject(n3), s3.catch(() => {
        })) : s3 = Promise.resolve(new Page({ pdfManager: i2, xref: this.xref, pageIndex: e3, pageDict: n3, ref: a3, globalIdFactory: this._globalIdFactory, fontCache: t2.fontCache, builtInCMapCache: t2.builtInCMapCache, standardFontDataCache: t2.standardFontDataCache, globalColorSpaceCache: this.globalColorSpaceCache, globalImageCache: t2.globalImageCache, systemFontCache: t2.systemFontCache, nonBlendModesSet: t2.nonBlendModesSet, xfaFactory: null })), this.#Ze.set(e3, s3);
      }
      t2.setActualNumPages(s2.size);
    }
  }
  async fontFallback(e2, t2) {
    const { catalog: i2, pdfManager: n2 } = this;
    for (const a2 of await Promise.all(i2.fontCache)) if (a2.loadedName === e2) return void a2.fallback(t2, n2.evaluatorOptions);
  }
  async cleanup(e2 = false) {
    return this.catalog ? this.catalog.cleanup(e2) : clearGlobalCaches();
  }
  async #st(e2, t2, i2, n2, a2, s2, r2) {
    const { xref: o2 } = this;
    if (!(i2 instanceof Ref) || s2.has(i2)) return;
    s2.put(i2);
    const l2 = await o2.fetchAsync(i2);
    if (!(l2 instanceof Dict)) return;
    let c2 = await l2.getAsync("Subtype");
    if (c2 = c2 instanceof Name ? c2.name : null, "Link" === c2) return;
    if (l2.has("T")) {
      const t3 = stringToPDFString(await l2.getAsync("T"));
      e2 = "" === e2 ? t3 : `${e2}.${t3}`;
    } else {
      let i3 = l2;
      for (; ; ) {
        if (i3 = i3.getRaw("Parent") || t2, i3 instanceof Ref) {
          if (s2.has(i3)) break;
          i3 = await o2.fetchAsync(i3);
        }
        if (!(i3 instanceof Dict)) break;
        if (i3.has("T")) {
          const t3 = stringToPDFString(await i3.getAsync("T"));
          e2 = "" === e2 ? t3 : `${e2}.${t3}`;
          break;
        }
      }
    }
    if (t2 && !l2.has("Parent") && isName(l2.get("Subtype"), "Widget") && r2.put(i2, t2), n2.has(e2) || n2.set(e2, []), n2.get(e2).push(AnnotationFactory.create(o2, i2, a2, null, true, r2, null, null).then((e3) => e3?.getFieldObject()).catch(function(e3) {
      return warn$1(`#collectFieldObjects: "${e3}".`), null;
    })), !l2.has("Kids")) return;
    const h2 = await l2.getAsync("Kids");
    if (Array.isArray(h2)) for (const t3 of h2) await this.#st(e2, i2, t3, n2, a2, s2, r2);
  }
  get fieldObjects() {
    return shadow$1(this, "fieldObjects", this.pdfManager.ensureDoc("formInfo").then(async (e2) => {
      if (!e2.hasFields) return null;
      const t2 = await this.annotationGlobals;
      if (!t2) return null;
      const { acroForm: i2 } = t2, n2 = new RefSet(), a2 = /* @__PURE__ */ Object.create(null), s2 = /* @__PURE__ */ new Map(), r2 = new RefSetCache();
      for (const e3 of i2.get("Fields")) await this.#st("", null, e3, s2, t2, n2, r2);
      const o2 = [];
      for (const [e3, t3] of s2) o2.push(Promise.all(t3).then((t4) => {
        (t4 = t4.filter((e4) => !!e4)).length > 0 && (a2[e3] = t4);
      }));
      return await Promise.all(o2), { allFields: objectSize(a2) > 0 ? a2 : null, orphanFields: r2 };
    }));
  }
  get hasJSActions() {
    return shadow$1(this, "hasJSActions", this.pdfManager.ensureDoc("_parseHasJSActions"));
  }
  async _parseHasJSActions() {
    const [e2, t2] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
    return !!e2 || !!t2?.allFields && Object.values(t2.allFields).some((e3) => e3.some((e4) => null !== e4.actions));
  }
  get calculationOrderIds() {
    const e2 = this.catalog.acroForm?.get("CO");
    if (!Array.isArray(e2) || 0 === e2.length) return shadow$1(this, "calculationOrderIds", null);
    const t2 = [];
    for (const i2 of e2) i2 instanceof Ref && t2.push(i2.toString());
    return shadow$1(this, "calculationOrderIds", t2.length ? t2 : null);
  }
  get annotationGlobals() {
    return shadow$1(this, "annotationGlobals", AnnotationFactory.createGlobals(this.pdfManager));
  }
}
class BasePdfManager {
  constructor({ docBaseUrl: e2, docId: t2, enableXfa: i2, evaluatorOptions: n2, handler: a2, password: s2 }) {
    this._docBaseUrl = (function(e3) {
      if (e3) {
        const t3 = createValidAbsoluteUrl$1(e3);
        if (t3) return t3.href;
        warn$1(`Invalid absolute docBaseUrl: "${e3}".`);
      }
      return null;
    })(e2), this._docId = t2, this._password = s2, this.enableXfa = i2, n2.isOffscreenCanvasSupported &&= FeatureTest.isOffscreenCanvasSupported, n2.isImageDecoderSupported &&= FeatureTest.isImageDecoderSupported, this.evaluatorOptions = Object.freeze(n2), ImageResizer.setOptions(n2), JpegStream.setOptions(n2), OperatorList.setOptions(n2);
    const r2 = { ...n2, handler: a2 };
    JpxImage.setOptions(r2), IccColorSpace.setOptions(r2), CmykICCBasedCS.setOptions(r2);
  }
  get docId() {
    return this._docId;
  }
  get password() {
    return this._password;
  }
  get docBaseUrl() {
    return this._docBaseUrl;
  }
  ensureDoc(e2, t2) {
    return this.ensure(this.pdfDocument, e2, t2);
  }
  ensureXRef(e2, t2) {
    return this.ensure(this.pdfDocument.xref, e2, t2);
  }
  ensureCatalog(e2, t2) {
    return this.ensure(this.pdfDocument.catalog, e2, t2);
  }
  getPage(e2) {
    return this.pdfDocument.getPage(e2);
  }
  fontFallback(e2, t2) {
    return this.pdfDocument.fontFallback(e2, t2);
  }
  cleanup(e2 = false) {
    return this.pdfDocument.cleanup(e2);
  }
  async ensure(e2, t2, i2) {
    unreachable$1("Abstract method `ensure` called");
  }
  requestRange(e2, t2) {
    unreachable$1("Abstract method `requestRange` called");
  }
  requestLoadedStream(e2 = false) {
    unreachable$1("Abstract method `requestLoadedStream` called");
  }
  sendProgressiveData(e2) {
    unreachable$1("Abstract method `sendProgressiveData` called");
  }
  updatePassword(e2) {
    this._password = e2;
  }
  terminate(e2) {
    unreachable$1("Abstract method `terminate` called");
  }
}
class LocalPdfManager extends BasePdfManager {
  constructor(e2) {
    super(e2);
    const t2 = new Stream(e2.source);
    this.pdfDocument = new PDFDocument(this, t2), this._loadedStreamPromise = Promise.resolve(t2);
  }
  async ensure(e2, t2, i2) {
    const n2 = e2[t2];
    return "function" == typeof n2 ? n2.apply(e2, i2) : n2;
  }
  requestRange(e2, t2) {
    return Promise.resolve();
  }
  requestLoadedStream(e2 = false) {
    return this._loadedStreamPromise;
  }
  terminate(e2) {
  }
}
class NetworkPdfManager extends BasePdfManager {
  constructor(e2) {
    super(e2), this.streamManager = new ChunkedStreamManager(e2.source, { msgHandler: e2.handler, length: e2.length, disableAutoFetch: e2.disableAutoFetch, rangeChunkSize: e2.rangeChunkSize }), this.pdfDocument = new PDFDocument(this, this.streamManager.getStream());
  }
  async ensure(e2, t2, i2) {
    try {
      const n2 = e2[t2];
      return "function" == typeof n2 ? n2.apply(e2, i2) : n2;
    } catch (n2) {
      if (!(n2 instanceof MissingDataException)) throw n2;
      return await this.requestRange(n2.begin, n2.end), this.ensure(e2, t2, i2);
    }
  }
  requestRange(e2, t2) {
    return this.streamManager.requestRange(e2, t2);
  }
  requestLoadedStream(e2 = false) {
    return this.streamManager.requestAllChunks(e2);
  }
  sendProgressiveData(e2) {
    this.streamManager.onReceiveData({ chunk: e2 });
  }
  terminate(e2) {
    this.streamManager.abort(e2);
  }
}
const ml = 1, bl = 2, yl = 1, wl = 2, Al = 3, xl = 4, Sl = 5, vl = 6, Cl = 7, kl = 8;
function onFn$1() {
}
function wrapReason$1(e2) {
  if (e2 instanceof ii || e2 instanceof Qt || e2 instanceof Jt || e2 instanceof ei || e2 instanceof Zt) return e2;
  switch (e2 instanceof Error || "object" == typeof e2 && null !== e2 || unreachable$1('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), e2.name) {
    case "AbortException":
      return new ii(e2.message);
    case "InvalidPDFException":
      return new Qt(e2.message);
    case "PasswordException":
      return new Jt(e2.message, e2.code);
    case "ResponseException":
      return new ei(e2.message, e2.status, e2.missing);
    case "UnknownErrorException":
      return new Zt(e2.message, e2.details);
  }
  return new Zt(e2.message, e2.toString());
}
let Tl = class {
  #rt = new AbortController();
  constructor(e2, t2, i2) {
    this.sourceName = e2, this.targetName = t2, this.comObj = i2, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), i2.addEventListener("message", this.#ot.bind(this), { signal: this.#rt.signal });
  }
  #ot({ data: e2 }) {
    if (e2.targetName !== this.sourceName) return;
    if (e2.stream) return void this.#lt(e2);
    if (e2.callback) {
      const t3 = e2.callbackId, i2 = this.callbackCapabilities[t3];
      if (!i2) throw new Error(`Cannot resolve callback ${t3}`);
      if (delete this.callbackCapabilities[t3], e2.callback === ml) i2.resolve(e2.data);
      else {
        if (e2.callback !== bl) throw new Error("Unexpected callback case");
        i2.reject(wrapReason$1(e2.reason));
      }
      return;
    }
    const t2 = this.actionHandler[e2.action];
    if (!t2) throw new Error(`Unknown action from worker: ${e2.action}`);
    if (e2.callbackId) {
      const i2 = this.sourceName, n2 = e2.sourceName, a2 = this.comObj;
      return void Promise.try(t2, e2.data).then(function(t3) {
        a2.postMessage({ sourceName: i2, targetName: n2, callback: ml, callbackId: e2.callbackId, data: t3 });
      }, function(t3) {
        a2.postMessage({ sourceName: i2, targetName: n2, callback: bl, callbackId: e2.callbackId, reason: wrapReason$1(t3) });
      });
    }
    e2.streamId ? this.#ct(e2) : t2(e2.data);
  }
  on(e2, t2) {
    const i2 = this.actionHandler;
    if (i2[e2]) throw new Error(`There is already an actionName called "${e2}"`);
    i2[e2] = t2;
  }
  send(e2, t2, i2) {
    this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e2, data: t2 }, i2);
  }
  sendWithPromise(e2, t2, i2) {
    const n2 = this.callbackId++, a2 = Promise.withResolvers();
    this.callbackCapabilities[n2] = a2;
    try {
      this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e2, callbackId: n2, data: t2 }, i2);
    } catch (e3) {
      a2.reject(e3);
    }
    return a2.promise;
  }
  sendWithStream(e2, t2, i2, n2) {
    const a2 = this.streamId++, s2 = this.sourceName, r2 = this.targetName, o2 = this.comObj;
    return new ReadableStream({ start: (i3) => {
      const l2 = Promise.withResolvers();
      return this.streamControllers[a2] = { controller: i3, startCall: l2, pullCall: null, cancelCall: null, isClosed: false }, o2.postMessage({ sourceName: s2, targetName: r2, action: e2, streamId: a2, data: t2, desiredSize: i3.desiredSize }, n2), l2.promise;
    }, pull: (e3) => {
      const t3 = Promise.withResolvers();
      return this.streamControllers[a2].pullCall = t3, o2.postMessage({ sourceName: s2, targetName: r2, stream: vl, streamId: a2, desiredSize: e3.desiredSize }), t3.promise;
    }, cancel: (e3) => {
      assert$1(e3 instanceof Error, "cancel must have a valid reason");
      const t3 = Promise.withResolvers();
      return this.streamControllers[a2].cancelCall = t3, this.streamControllers[a2].isClosed = true, o2.postMessage({ sourceName: s2, targetName: r2, stream: yl, streamId: a2, reason: wrapReason$1(e3) }), t3.promise;
    } }, i2);
  }
  #ct(e2) {
    const t2 = e2.streamId, i2 = this.sourceName, n2 = e2.sourceName, a2 = this.comObj, s2 = this, r2 = this.actionHandler[e2.action], o2 = { enqueue(e3, s3 = 1, r3) {
      if (this.isCancelled) return;
      const o3 = this.desiredSize;
      this.desiredSize -= s3, o3 > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), a2.postMessage({ sourceName: i2, targetName: n2, stream: xl, streamId: t2, chunk: e3 }, r3);
    }, close() {
      this.isCancelled || (this.isCancelled = true, a2.postMessage({ sourceName: i2, targetName: n2, stream: Al, streamId: t2 }), delete s2.streamSinks[t2]);
    }, error(e3) {
      assert$1(e3 instanceof Error, "error must have a valid reason"), this.isCancelled || (this.isCancelled = true, a2.postMessage({ sourceName: i2, targetName: n2, stream: Sl, streamId: t2, reason: wrapReason$1(e3) }));
    }, sinkCapability: Promise.withResolvers(), onPull: null, onCancel: null, isCancelled: false, desiredSize: e2.desiredSize, ready: null };
    o2.sinkCapability.resolve(), o2.ready = o2.sinkCapability.promise, this.streamSinks[t2] = o2, Promise.try(r2, e2.data, o2).then(function() {
      a2.postMessage({ sourceName: i2, targetName: n2, stream: kl, streamId: t2, success: true });
    }, function(e3) {
      a2.postMessage({ sourceName: i2, targetName: n2, stream: kl, streamId: t2, reason: wrapReason$1(e3) });
    });
  }
  #lt(e2) {
    const t2 = e2.streamId, i2 = this.sourceName, n2 = e2.sourceName, a2 = this.comObj, s2 = this.streamControllers[t2], r2 = this.streamSinks[t2];
    switch (e2.stream) {
      case kl:
        e2.success ? s2.startCall.resolve() : s2.startCall.reject(wrapReason$1(e2.reason));
        break;
      case Cl:
        e2.success ? s2.pullCall.resolve() : s2.pullCall.reject(wrapReason$1(e2.reason));
        break;
      case vl:
        if (!r2) {
          a2.postMessage({ sourceName: i2, targetName: n2, stream: Cl, streamId: t2, success: true });
          break;
        }
        r2.desiredSize <= 0 && e2.desiredSize > 0 && r2.sinkCapability.resolve(), r2.desiredSize = e2.desiredSize, Promise.try(r2.onPull || onFn$1).then(function() {
          a2.postMessage({ sourceName: i2, targetName: n2, stream: Cl, streamId: t2, success: true });
        }, function(e3) {
          a2.postMessage({ sourceName: i2, targetName: n2, stream: Cl, streamId: t2, reason: wrapReason$1(e3) });
        });
        break;
      case xl:
        if (assert$1(s2, "enqueue should have stream controller"), s2.isClosed) break;
        s2.controller.enqueue(e2.chunk);
        break;
      case Al:
        if (assert$1(s2, "close should have stream controller"), s2.isClosed) break;
        s2.isClosed = true, s2.controller.close(), this.#ht(s2, t2);
        break;
      case Sl:
        assert$1(s2, "error should have stream controller"), s2.controller.error(wrapReason$1(e2.reason)), this.#ht(s2, t2);
        break;
      case wl:
        e2.success ? s2.cancelCall.resolve() : s2.cancelCall.reject(wrapReason$1(e2.reason)), this.#ht(s2, t2);
        break;
      case yl:
        if (!r2) break;
        const o2 = wrapReason$1(e2.reason);
        Promise.try(r2.onCancel || onFn$1, o2).then(function() {
          a2.postMessage({ sourceName: i2, targetName: n2, stream: wl, streamId: t2, success: true });
        }, function(e3) {
          a2.postMessage({ sourceName: i2, targetName: n2, stream: wl, streamId: t2, reason: wrapReason$1(e3) });
        }), r2.sinkCapability.reject(o2), r2.isCancelled = true, delete this.streamSinks[t2];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  }
  async #ht(e2, t2) {
    await Promise.allSettled([e2.startCall?.promise, e2.pullCall?.promise, e2.cancelCall?.promise]), delete this.streamControllers[t2];
  }
  destroy() {
    this.#rt?.abort(), this.#rt = null;
  }
};
async function writeObject(e2, t2, i2, { encrypt: n2 = null }) {
  const a2 = n2?.createCipherTransform(e2.num, e2.gen);
  i2.push(`${e2.num} ${e2.gen} obj
`), t2 instanceof Dict ? await writeDict(t2, i2, a2) : t2 instanceof BaseStream ? await writeStream(t2, i2, a2) : (Array.isArray(t2) || ArrayBuffer.isView(t2)) && await writeArray(t2, i2, a2), i2.push("\nendobj\n");
}
async function writeDict(e2, t2, i2) {
  t2.push("<<");
  for (const n2 of e2.getKeys()) t2.push(` /${escapePDFName(n2)} `), await writeValue(e2.getRaw(n2), t2, i2);
  t2.push(">>");
}
async function writeStream(e2, t2, i2) {
  let n2 = e2.getBytes();
  const { dict: a2 } = e2, [s2, r2] = await Promise.all([a2.getAsync("Filter"), a2.getAsync("DecodeParms")]), o2 = isName(Array.isArray(s2) ? await a2.xref.fetchIfRefAsync(s2[0]) : s2, "FlateDecode");
  if (n2.length >= 256 || o2) try {
    const e3 = new CompressionStream("deflate"), t3 = e3.writable.getWriter();
    await t3.ready, t3.write(n2).then(async () => {
      await t3.ready, await t3.close();
    }).catch(() => {
    });
    const i3 = await new Response(e3.readable).arrayBuffer();
    let l3, c2;
    n2 = new Uint8Array(i3), s2 ? o2 || (l3 = Array.isArray(s2) ? [Name.get("FlateDecode"), ...s2] : [Name.get("FlateDecode"), s2], r2 && (c2 = Array.isArray(r2) ? [null, ...r2] : [null, r2])) : l3 = Name.get("FlateDecode"), l3 && a2.set("Filter", l3), c2 && a2.set("DecodeParms", c2);
  } catch (e3) {
    info$1(`writeStream - cannot compress data: "${e3}".`);
  }
  let l2 = bytesToString$1(n2);
  i2 && (l2 = i2.encryptString(l2)), a2.set("Length", l2.length), await writeDict(a2, t2, i2), t2.push(" stream\n", l2, "\nendstream");
}
async function writeArray(e2, t2, i2) {
  t2.push("[");
  let n2 = true;
  for (const a2 of e2) n2 ? n2 = false : t2.push(" "), await writeValue(a2, t2, i2);
  t2.push("]");
}
async function writeValue(e2, t2, i2) {
  e2 instanceof Name ? t2.push(`/${escapePDFName(e2.name)}`) : e2 instanceof Ref ? t2.push(`${e2.num} ${e2.gen} R`) : Array.isArray(e2) || ArrayBuffer.isView(e2) ? await writeArray(e2, t2, i2) : "string" == typeof e2 ? (i2 && (e2 = i2.encryptString(e2)), t2.push(`(${escapeString(e2)})`)) : "number" == typeof e2 ? t2.push(numberToString(e2)) : "boolean" == typeof e2 ? t2.push(e2.toString()) : e2 instanceof Dict ? await writeDict(e2, t2, i2) : e2 instanceof BaseStream ? await writeStream(e2, t2, i2) : null === e2 ? t2.push("null") : warn$1(`Unhandled value in writer: ${typeof e2}, please file a bug.`);
}
function writeInt(e2, t2, i2, n2) {
  for (let a2 = t2 + i2 - 1; a2 > i2 - 1; a2--) n2[a2] = 255 & e2, e2 >>= 8;
  return i2 + t2;
}
function writeString(e2, t2, i2) {
  const n2 = e2.length;
  for (let a2 = 0; a2 < n2; a2++) i2[t2 + a2] = 255 & e2.charCodeAt(a2);
  return t2 + n2;
}
function updateXFA({ xfaData: e2, xfaDatasetsRef: t2, changes: i2, xref: n2 }) {
  if (null === e2) {
    e2 = (function(e3, t3) {
      const i3 = new SimpleXMLParser({ hasAttributes: true }).parseFromString(e3);
      for (const { xfa: e4 } of t3) {
        if (!e4) continue;
        const { path: t4, value: n4 } = e4;
        if (!t4) continue;
        const a3 = parseXFAPath(t4);
        let s2 = i3.documentElement.searchNode(a3, 0);
        !s2 && a3.length > 1 && (s2 = i3.documentElement.searchNode([a3.at(-1)], 0)), s2 ? s2.childNodes = Array.isArray(n4) ? n4.map((e5) => new SimpleDOMNode("value", e5)) : [new SimpleDOMNode("#text", n4)] : warn$1(`Node not found for path: ${t4}`);
      }
      const n3 = [];
      return i3.documentElement.dump(n3), n3.join("");
    })(n2.fetchIfRef(t2).getString(), i2);
  }
  const a2 = new StringStream(e2);
  a2.dict = new Dict(n2), a2.dict.setIfName("Type", "EmbeddedFile"), i2.put(t2, { data: a2 });
}
function getIndexes(e2) {
  const t2 = [];
  for (const { ref: i2 } of e2) i2.num === t2.at(-2) + t2.at(-1) ? t2[t2.length - 1] += 1 : t2.push(i2.num, 1);
  return t2;
}
function computeIDs(e2, t2, i2) {
  if (Array.isArray(t2.fileIds) && t2.fileIds.length > 0) {
    const n2 = (function(e3, t3) {
      const i3 = Math.floor(Date.now() / 1e3), n3 = t3.filename || "", a2 = [i3.toString(), n3, e3.toString(), ...t3.infoMap.values()], s2 = Math.sumPrecise(a2.map((e4) => e4.length)), r2 = new Uint8Array(s2);
      let o2 = 0;
      for (const e4 of a2) o2 = writeString(e4, o2, r2);
      return bytesToString$1(calculateMD5(r2, 0, r2.length));
    })(e2, t2);
    i2.set("ID", [t2.fileIds[0], n2]);
  }
}
async function incrementalUpdate({ originalData: e2, xrefInfo: t2, changes: i2, xref: n2 = null, hasXfa: a2 = false, xfaDatasetsRef: s2 = null, hasXfaDatasetsEntry: r2 = false, needAppearances: o2, acroFormRef: l2 = null, acroForm: c2 = null, xfaData: h2 = null, useXrefStream: d2 = false }) {
  await (async function({ xref: e3, acroForm: t3, acroFormRef: i3, hasXfa: n3, hasXfaDatasetsEntry: a3, xfaDatasetsRef: s3, needAppearances: r3, changes: o3 }) {
    if (!n3 || a3 || s3 || warn$1("XFA - Cannot save it"), !r3 && (!n3 || !s3 || a3)) return;
    const l3 = t3.clone();
    if (n3 && !a3) {
      const e4 = t3.get("XFA").slice();
      e4.splice(2, 0, "datasets"), e4.splice(3, 0, s3), l3.set("XFA", e4);
    }
    r3 && l3.set("NeedAppearances", true), o3.put(i3, { data: l3 });
  })({ xref: n2, acroForm: c2, acroFormRef: l2, hasXfa: a2, hasXfaDatasetsEntry: r2, xfaDatasetsRef: s2, needAppearances: o2, changes: i2 }), a2 && updateXFA({ xfaData: h2, xfaDatasetsRef: s2, changes: i2, xref: n2 });
  const u2 = (function(e3, t3, i3) {
    const n3 = new Dict(null);
    n3.set("Prev", e3.startXRef);
    const a3 = e3.newRef;
    return i3 ? (t3.put(a3, { data: "" }), n3.set("Size", a3.num + 1), n3.setIfName("Type", "XRef")) : n3.set("Size", a3.num), null !== e3.rootRef && n3.set("Root", e3.rootRef), null !== e3.infoRef && n3.set("Info", e3.infoRef), null !== e3.encryptRef && n3.set("Encrypt", e3.encryptRef), n3;
  })(t2, i2, d2), g2 = [], f2 = await (async function(e3, t3, i3 = []) {
    const n3 = [];
    for (const [a3, { data: s3 }] of e3.items()) null !== s3 && "string" != typeof s3 ? (await writeObject(a3, s3, i3, t3), n3.push({ ref: a3, data: i3.join("") }), i3.length = 0) : n3.push({ ref: a3, data: s3 });
    return n3.sort((e4, t4) => e4.ref.num - t4.ref.num);
  })(i2, n2, g2);
  let p2 = e2.length;
  const m2 = e2.at(-1);
  10 !== m2 && 13 !== m2 && (g2.push("\n"), p2 += 1);
  for (const { data: e3 } of f2) null !== e3 && g2.push(e3);
  await (d2 ? (async function(e3, t3, i3, n3, a3) {
    const s3 = [];
    let r3 = 0, o3 = 0;
    for (const { ref: e4, data: n4 } of i3) {
      let i4;
      r3 = Math.max(r3, t3), null !== n4 ? (i4 = Math.min(e4.gen, 65535), s3.push([1, t3, i4]), t3 += n4.length) : (i4 = Math.min(e4.gen + 1, 65535), s3.push([0, 0, i4])), o3 = Math.max(o3, i4);
    }
    n3.set("Index", getIndexes(i3));
    const l3 = [1, getSizeInBytes(r3), getSizeInBytes(o3)];
    n3.set("W", l3), computeIDs(t3, e3, n3);
    const c3 = Math.sumPrecise(l3), h3 = new Uint8Array(c3 * s3.length), d3 = new Stream(h3);
    d3.dict = n3;
    let u3 = 0;
    for (const [e4, t4, i4] of s3) u3 = writeInt(e4, l3[0], u3, h3), u3 = writeInt(t4, l3[1], u3, h3), u3 = writeInt(i4, l3[2], u3, h3);
    await writeObject(e3.newRef, d3, a3, {}), a3.push("startxref\n", t3.toString(), "\n%%EOF\n");
  })(t2, p2, f2, u2, g2) : (async function(e3, t3, i3, n3, a3) {
    a3.push("xref\n");
    const s3 = getIndexes(i3);
    let r3 = 0;
    for (const { ref: e4, data: n4 } of i3) e4.num === s3[r3] && (a3.push(`${s3[r3]} ${s3[r3 + 1]}
`), r3 += 2), null !== n4 ? (a3.push(`${t3.toString().padStart(10, "0")} ${Math.min(e4.gen, 65535).toString().padStart(5, "0")} n\r
`), t3 += n4.length) : a3.push(`0000000000 ${Math.min(e4.gen + 1, 65535).toString().padStart(5, "0")} f\r
`);
    computeIDs(t3, e3, n3), a3.push("trailer\n"), await writeDict(n3, a3), a3.push("\nstartxref\n", t3.toString(), "\n%%EOF\n");
  })(t2, p2, f2, u2, g2));
  const b2 = e2.length + Math.sumPrecise(g2.map((e3) => e3.length)), y2 = new Uint8Array(b2);
  y2.set(e2);
  let w2 = e2.length;
  for (const e3 of g2) w2 = writeString(e3, w2, y2);
  return y2;
}
class PDFWorkerStream {
  constructor(e2) {
    this._msgHandler = e2, this._contentLength = null, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  getFullReader() {
    return assert$1(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once."), this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler), this._fullRequestReader;
  }
  getRangeReader(e2, t2) {
    const i2 = new PDFWorkerStreamRangeReader(e2, t2, this._msgHandler);
    return this._rangeRequestReaders.push(i2), i2;
  }
  cancelAllRequests(e2) {
    this._fullRequestReader?.cancel(e2);
    for (const t2 of this._rangeRequestReaders.slice(0)) t2.cancel(e2);
  }
}
class PDFWorkerStreamReader {
  constructor(e2) {
    this._msgHandler = e2, this.onProgress = null, this._contentLength = null, this._isRangeSupported = false, this._isStreamingSupported = false;
    const t2 = this._msgHandler.sendWithStream("GetReader");
    this._reader = t2.getReader(), this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((e3) => {
      this._isStreamingSupported = e3.isStreamingSupported, this._isRangeSupported = e3.isRangeSupported, this._contentLength = e3.contentLength;
    });
  }
  get headersReady() {
    return this._headersReady;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  async read() {
    const { value: e2, done: t2 } = await this._reader.read();
    return t2 ? { value: void 0, done: true } : { value: e2.buffer, done: false };
  }
  cancel(e2) {
    this._reader.cancel(e2);
  }
}
class PDFWorkerStreamRangeReader {
  constructor(e2, t2, i2) {
    this._msgHandler = i2, this.onProgress = null;
    const n2 = this._msgHandler.sendWithStream("GetRangeReader", { begin: e2, end: t2 });
    this._reader = n2.getReader();
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    const { value: e2, done: t2 } = await this._reader.read();
    return t2 ? { value: void 0, done: true } : { value: e2.buffer, done: false };
  }
  cancel(e2) {
    this._reader.cancel(e2);
  }
}
class WorkerTask {
  constructor(e2) {
    this.name = e2, this.terminated = false, this._capability = Promise.withResolvers();
  }
  get finished() {
    return this._capability.promise;
  }
  finish() {
    this._capability.resolve();
  }
  terminate() {
    this.terminated = true;
  }
  ensureNotTerminated() {
    if (this.terminated) throw new Error("Worker task was terminated");
  }
}
const _WorkerMessageHandler = class _WorkerMessageHandler {
  static setup(e2, t2) {
    let i2 = false;
    e2.on("test", (t3) => {
      i2 || (i2 = true, e2.send("test", t3 instanceof Uint8Array));
    }), e2.on("configure", (e3) => {
      var t3;
      t3 = e3.verbosity, Number.isInteger(t3) && (Kt = t3);
    }), e2.on("GetDocRequest", (e3) => this.createDocumentHandler(e3, t2));
  }
  static createDocumentHandler(e2, t2) {
    let i2, n2 = false, a2 = null;
    const s2 = /* @__PURE__ */ new Set(), r2 = Kt, { docId: o2, apiVersion: l2 } = e2, c2 = "5.4.296";
    if (l2 !== c2) throw new Error(`The API version "${l2}" does not match the Worker version "${c2}".`);
    const buildMsg = (e3, t3) => `The \`${e3}.prototype\` contains unexpected enumerable property "${t3}", thus breaking e.g. \`for...in\` iteration of ${e3}s.`;
    for (const e3 in {}) throw new Error(buildMsg("Object", e3));
    for (const e3 in []) throw new Error(buildMsg("Array", e3));
    const h2 = o2 + "_worker";
    let d2 = new Tl(h2, o2, t2);
    function ensureNotTerminated() {
      if (n2) throw new Error("Worker was terminated");
    }
    function startWorkerTask(e3) {
      s2.add(e3);
    }
    function finishWorkerTask(e3) {
      e3.finish(), s2.delete(e3);
    }
    async function loadDocument(e3) {
      await i2.ensureDoc("checkHeader"), await i2.ensureDoc("parseStartXRef"), await i2.ensureDoc("parse", [e3]), await i2.ensureDoc("checkFirstPage", [e3]), await i2.ensureDoc("checkLastPage", [e3]);
      const t3 = await i2.ensureDoc("isPureXfa");
      if (t3) {
        const e4 = new WorkerTask("loadXfaResources");
        startWorkerTask(e4), await i2.ensureDoc("loadXfaResources", [d2, e4]), finishWorkerTask(e4);
      }
      const [n3, a3] = await Promise.all([i2.ensureDoc("numPages"), i2.ensureDoc("fingerprints")]);
      return { numPages: n3, fingerprints: a3, htmlForXfa: t3 ? await i2.ensureDoc("htmlForXfa") : null };
    }
    function setupDoc(e3) {
      function onSuccess(e4) {
        ensureNotTerminated(), d2.send("GetDoc", { pdfInfo: e4 });
      }
      function onFailure(e4) {
        if (ensureNotTerminated(), e4 instanceof Jt) {
          const t3 = new WorkerTask(`PasswordException: response ${e4.code}`);
          startWorkerTask(t3), d2.sendWithPromise("PasswordRequest", e4).then(function({ password: e5 }) {
            finishWorkerTask(t3), i2.updatePassword(e5), pdfManagerReady();
          }).catch(function() {
            finishWorkerTask(t3), d2.send("DocException", e4);
          });
        } else d2.send("DocException", wrapReason$1(e4));
      }
      function pdfManagerReady() {
        ensureNotTerminated(), loadDocument(false).then(onSuccess, function(e4) {
          ensureNotTerminated(), e4 instanceof XRefParseException ? i2.requestLoadedStream().then(function() {
            ensureNotTerminated(), loadDocument(true).then(onSuccess, onFailure);
          }) : onFailure(e4);
        });
      }
      ensureNotTerminated(), (async function({ data: e4, password: t3, disableAutoFetch: i3, rangeChunkSize: n3, length: s3, docBaseUrl: r3, enableXfa: l3, evaluatorOptions: c3 }) {
        const h3 = { source: null, disableAutoFetch: i3, docBaseUrl: r3, docId: o2, enableXfa: l3, evaluatorOptions: c3, handler: d2, length: s3, password: t3, rangeChunkSize: n3 };
        if (e4) return h3.source = e4, new LocalPdfManager(h3);
        const u2 = new PDFWorkerStream(d2), g2 = u2.getFullReader(), f2 = Promise.withResolvers();
        let p2, m2 = [], b2 = 0;
        return g2.headersReady.then(function() {
          if (g2.isRangeSupported) {
            h3.source = u2, h3.length = g2.contentLength, h3.disableAutoFetch ||= g2.isStreamingSupported, p2 = new NetworkPdfManager(h3);
            for (const e5 of m2) p2.sendProgressiveData(e5);
            m2 = [], f2.resolve(p2), a2 = null;
          }
        }).catch(function(e5) {
          f2.reject(e5), a2 = null;
        }), new Promise(function(e5, t4) {
          const readChunk = function({ value: e6, done: i4 }) {
            try {
              if (ensureNotTerminated(), i4) {
                if (!p2) {
                  const e7 = arrayBuffersToBytes(m2);
                  m2 = [], s3 && e7.length !== s3 && warn$1("reported HTTP length is different from actual"), h3.source = e7, p2 = new LocalPdfManager(h3), f2.resolve(p2);
                }
                return void (a2 = null);
              }
              b2 += e6.byteLength, g2.isStreamingSupported || d2.send("DocProgress", { loaded: b2, total: Math.max(b2, g2.contentLength || 0) }), p2 ? p2.sendProgressiveData(e6) : m2.push(e6), g2.read().then(readChunk, t4);
            } catch (e7) {
              t4(e7);
            }
          };
          g2.read().then(readChunk, t4);
        }).catch(function(e5) {
          f2.reject(e5), a2 = null;
        }), a2 = (e5) => {
          u2.cancelAllRequests(e5);
        }, f2.promise;
      })(e3).then(function(e4) {
        if (n2) throw e4.terminate(new ii("Worker was terminated.")), new Error("Worker was terminated");
        i2 = e4, i2.requestLoadedStream(true).then((e5) => {
          d2.send("DataLoaded", { length: e5.bytes.byteLength });
        });
      }).then(pdfManagerReady, onFailure);
    }
    return d2.on("GetPage", function(e3) {
      return i2.getPage(e3.pageIndex).then(function(e4) {
        return Promise.all([i2.ensure(e4, "rotate"), i2.ensure(e4, "ref"), i2.ensure(e4, "userUnit"), i2.ensure(e4, "view")]).then(function([e5, t3, i3, n3]) {
          return { rotate: e5, ref: t3, refStr: t3?.toString() ?? null, userUnit: i3, view: n3 };
        });
      });
    }), d2.on("GetPageIndex", function(e3) {
      const t3 = Ref.get(e3.num, e3.gen);
      return i2.ensureCatalog("getPageIndex", [t3]);
    }), d2.on("GetDestinations", function(e3) {
      return i2.ensureCatalog("destinations");
    }), d2.on("GetDestination", function(e3) {
      return i2.ensureCatalog("getDestination", [e3.id]);
    }), d2.on("GetPageLabels", function(e3) {
      return i2.ensureCatalog("pageLabels");
    }), d2.on("GetPageLayout", function(e3) {
      return i2.ensureCatalog("pageLayout");
    }), d2.on("GetPageMode", function(e3) {
      return i2.ensureCatalog("pageMode");
    }), d2.on("GetViewerPreferences", function(e3) {
      return i2.ensureCatalog("viewerPreferences");
    }), d2.on("GetOpenAction", function(e3) {
      return i2.ensureCatalog("openAction");
    }), d2.on("GetAttachments", function(e3) {
      return i2.ensureCatalog("attachments");
    }), d2.on("GetDocJSActions", function(e3) {
      return i2.ensureCatalog("jsActions");
    }), d2.on("GetPageJSActions", function({ pageIndex: e3 }) {
      return i2.getPage(e3).then((e4) => i2.ensure(e4, "jsActions"));
    }), d2.on("GetAnnotationsByType", async function({ types: e3, pageIndexesToSkip: t3 }) {
      const [n3, a3] = await Promise.all([i2.ensureDoc("numPages"), i2.ensureDoc("annotationGlobals")]);
      if (!a3) return null;
      const s3 = [], r3 = [];
      let o3 = null;
      try {
        for (let l3 = 0, c3 = n3; l3 < c3; l3++) t3?.has(l3) || (o3 || (o3 = new WorkerTask("GetAnnotationsByType"), startWorkerTask(o3)), s3.push(i2.getPage(l3).then(async (t4) => t4 && t4.collectAnnotationsByType(d2, o3, e3, r3, a3) || [])));
        await Promise.all(s3);
        return (await Promise.all(r3)).filter((e4) => !!e4);
      } finally {
        o3 && finishWorkerTask(o3);
      }
    }), d2.on("GetOutline", function(e3) {
      return i2.ensureCatalog("documentOutline");
    }), d2.on("GetOptionalContentConfig", function(e3) {
      return i2.ensureCatalog("optionalContentConfig");
    }), d2.on("GetPermissions", function(e3) {
      return i2.ensureCatalog("permissions");
    }), d2.on("GetMetadata", function(e3) {
      return Promise.all([i2.ensureDoc("documentInfo"), i2.ensureCatalog("metadata")]);
    }), d2.on("GetMarkInfo", function(e3) {
      return i2.ensureCatalog("markInfo");
    }), d2.on("GetData", function(e3) {
      return i2.requestLoadedStream().then((e4) => e4.bytes);
    }), d2.on("GetAnnotations", function({ pageIndex: e3, intent: t3 }) {
      return i2.getPage(e3).then(function(i3) {
        const n3 = new WorkerTask(`GetAnnotations: page ${e3}`);
        return startWorkerTask(n3), i3.getAnnotationsData(d2, n3, t3).then((e4) => (finishWorkerTask(n3), e4), (e4) => {
          throw finishWorkerTask(n3), e4;
        });
      });
    }), d2.on("GetFieldObjects", function(e3) {
      return i2.ensureDoc("fieldObjects").then((e4) => e4?.allFields || null);
    }), d2.on("HasJSActions", function(e3) {
      return i2.ensureDoc("hasJSActions");
    }), d2.on("GetCalculationOrderIds", function(e3) {
      return i2.ensureDoc("calculationOrderIds");
    }), d2.on("SaveDocument", async function({ isPureXfa: e3, numPages: t3, annotationStorage: n3, filename: a3 }) {
      const s3 = [i2.requestLoadedStream(), i2.ensureCatalog("acroForm"), i2.ensureCatalog("acroFormRef"), i2.ensureDoc("startXRef"), i2.ensureDoc("xref"), i2.ensureCatalog("structTreeRoot")], r3 = new RefSetCache(), o3 = [], l3 = e3 ? null : getNewAnnotationsMap(n3), [c3, h3, u2, g2, f2, p2] = await Promise.all(s3), m2 = f2.trailer.getRaw("Root") || null;
      let b2;
      if (l3) {
        p2 ? await p2.canUpdateStructTree({ pdfManager: i2, newAnnotationsByPage: l3 }) && (b2 = p2) : await StructTreeRoot.canCreateStructureTree({ catalogRef: m2, pdfManager: i2, newAnnotationsByPage: l3 }) && (b2 = null);
        const e4 = AnnotationFactory.generateImages(n3.values(), f2, i2.evaluatorOptions.isOffscreenCanvasSupported), t4 = void 0 === b2 ? o3 : [];
        for (const [n4, a4] of l3) t4.push(i2.getPage(n4).then((t5) => {
          const i3 = new WorkerTask(`Save (editor): page ${n4}`);
          return startWorkerTask(i3), t5.saveNewAnnotations(d2, i3, a4, e4, r3).finally(function() {
            finishWorkerTask(i3);
          });
        }));
        null === b2 ? o3.push(Promise.all(t4).then(async () => {
          await StructTreeRoot.createStructureTree({ newAnnotationsByPage: l3, xref: f2, catalogRef: m2, pdfManager: i2, changes: r3 });
        })) : b2 && o3.push(Promise.all(t4).then(async () => {
          await b2.updateStructureTree({ newAnnotationsByPage: l3, pdfManager: i2, changes: r3 });
        }));
      }
      if (e3) o3.push(i2.ensureDoc("serializeXfaData", [n3]));
      else for (let e4 = 0; e4 < t3; e4++) o3.push(i2.getPage(e4).then(function(t4) {
        const i3 = new WorkerTask(`Save: page ${e4}`);
        return startWorkerTask(i3), t4.save(d2, i3, n3, r3).finally(function() {
          finishWorkerTask(i3);
        });
      }));
      const y2 = await Promise.all(o3);
      let w2 = null;
      if (e3) {
        if (w2 = y2[0], !w2) return c3.bytes;
      } else if (0 === r3.size) return c3.bytes;
      const x2 = u2 && h3 instanceof Dict && r3.values().some((e4) => e4.needAppearances), S2 = h3 instanceof Dict && h3.get("XFA") || null;
      let v2 = null, C2 = false;
      if (Array.isArray(S2)) {
        for (let e4 = 0, t4 = S2.length; e4 < t4; e4 += 2) "datasets" === S2[e4] && (v2 = S2[e4 + 1], C2 = true);
        null === v2 && (v2 = f2.getNewTemporaryRef());
      } else S2 && warn$1("Unsupported XFA type.");
      let k2 = /* @__PURE__ */ Object.create(null);
      if (f2.trailer) {
        const e4 = /* @__PURE__ */ new Map(), t4 = f2.trailer.get("Info") || null;
        if (t4 instanceof Dict) for (const [i3, n4] of t4) "string" == typeof n4 && e4.set(i3, stringToPDFString(n4));
        k2 = { rootRef: m2, encryptRef: f2.trailer.getRaw("Encrypt") || null, newRef: f2.getNewTemporaryRef(), infoRef: f2.trailer.getRaw("Info") || null, infoMap: e4, fileIds: f2.trailer.get("ID") || null, startXRef: g2, filename: a3 };
      }
      return incrementalUpdate({ originalData: c3.bytes, xrefInfo: k2, changes: r3, xref: f2, hasXfa: !!S2, xfaDatasetsRef: v2, hasXfaDatasetsEntry: C2, needAppearances: x2, acroFormRef: u2, acroForm: h3, xfaData: w2, useXrefStream: isDict(f2.topDict, "XRef") }).finally(() => {
        f2.resetNewTemporaryRef();
      });
    }), d2.on("GetOperatorList", function(e3, t3) {
      const n3 = e3.pageIndex;
      i2.getPage(n3).then(function(i3) {
        const a3 = new WorkerTask(`GetOperatorList: page ${n3}`);
        startWorkerTask(a3);
        const s3 = r2 >= se ? Date.now() : 0;
        i3.getOperatorList({ handler: d2, sink: t3, task: a3, intent: e3.intent, cacheKey: e3.cacheKey, annotationStorage: e3.annotationStorage, modifiedIds: e3.modifiedIds }).then(function(e4) {
          finishWorkerTask(a3), s3 && info$1(`page=${n3 + 1} - getOperatorList: time=${Date.now() - s3}ms, len=${e4.length}`), t3.close();
        }, function(e4) {
          finishWorkerTask(a3), a3.terminated || t3.error(e4);
        });
      });
    }), d2.on("GetTextContent", function(e3, t3) {
      const { pageIndex: n3, includeMarkedContent: a3, disableNormalization: s3 } = e3;
      i2.getPage(n3).then(function(e4) {
        const i3 = new WorkerTask("GetTextContent: page " + n3);
        startWorkerTask(i3);
        const o3 = r2 >= se ? Date.now() : 0;
        e4.extractTextContent({ handler: d2, task: i3, sink: t3, includeMarkedContent: a3, disableNormalization: s3 }).then(function() {
          finishWorkerTask(i3), o3 && info$1(`page=${n3 + 1} - getTextContent: time=` + (Date.now() - o3) + "ms"), t3.close();
        }, function(e5) {
          finishWorkerTask(i3), i3.terminated || t3.error(e5);
        });
      });
    }), d2.on("GetStructTree", function(e3) {
      return i2.getPage(e3.pageIndex).then((e4) => i2.ensure(e4, "getStructTree"));
    }), d2.on("FontFallback", function(e3) {
      return i2.fontFallback(e3.id, d2);
    }), d2.on("Cleanup", function(e3) {
      return i2.cleanup(true);
    }), d2.on("Terminate", function(e3) {
      n2 = true;
      const t3 = [];
      if (i2) {
        i2.terminate(new ii("Worker was terminated."));
        const e4 = i2.cleanup();
        t3.push(e4), i2 = null;
      } else clearGlobalCaches();
      a2?.(new ii("Worker was terminated."));
      for (const e4 of s2) t3.push(e4.finished), e4.terminate();
      return Promise.all(t3).then(function() {
        d2.destroy(), d2 = null;
      });
    }), d2.on("Ready", function(t3) {
      setupDoc(e2), e2 = null;
    }), h2;
  }
  static initializeFromPort(e2) {
    const t2 = new Tl("worker", "main", e2);
    this.setup(t2, e2), t2.send("ready", null);
  }
};
"undefined" == typeof window && !e && "undefined" != typeof self && "function" == typeof self.postMessage && "onmessage" in self && _WorkerMessageHandler.initializeFromPort(self);
let WorkerMessageHandler = _WorkerMessageHandler;
globalThis.pdfjsWorker = { WorkerMessageHandler };
const Fl = !("object" != typeof process || process + "" != "[object process]" || process.versions.nw || process.versions.electron && process.type && "browser" !== process.type), Il = [1e-3, 0, 0, 1e-3, 0, 0], El = 1.35, Ml = 1, Dl = 2, _l = 4, Pl = 16, Rl = 32, Bl = 64, Nl = 128, Ll = 256, jl = { DISABLE: 0, ENABLE: 1, ENABLE_FORMS: 2, ENABLE_STORAGE: 3 }, $l = "pdfjs_internal_editor_", Hl = { DISABLE: -1, NONE: 0, FREETEXT: 3, HIGHLIGHT: 9, STAMP: 13, INK: 15, POPUP: 16, SIGNATURE: 101, COMMENT: 102 }, Xl = { RESIZE: 1, CREATE: 2, FREETEXT_SIZE: 11, FREETEXT_COLOR: 12, FREETEXT_OPACITY: 13, INK_COLOR: 21, INK_THICKNESS: 22, INK_OPACITY: 23, HIGHLIGHT_COLOR: 31, HIGHLIGHT_THICKNESS: 32, HIGHLIGHT_FREE: 33, HIGHLIGHT_SHOW_ALL: 34, DRAW_STEP: 41 }, ql = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 }, zl = 0, Wl = 1, Gl = 2, Vl = 3, Kl = 3, Yl = 4, Jl = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }, Zl = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 }, Ql = 1, ec = 2, tc = 3, ic = 4, nc = 5, ac = { ERRORS: 0, WARNINGS: 1, INFOS: 5 }, sc = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotation: 80, endAnnotation: 81, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91, setStrokeTransparent: 92, setFillTransparent: 93, rawFillPath: 94 }, rc = 0, oc = 1, lc = 2, cc = 3, hc = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 };
let dc = ac.WARNINGS;
function setVerbosityLevel(e2) {
  Number.isInteger(e2) && (dc = e2);
}
function getVerbosityLevel() {
  return dc;
}
function info(e2) {
  dc >= ac.INFOS && console.info(`Info: ${e2}`);
}
function warn(e2) {
  dc >= ac.WARNINGS && console.warn(`Warning: ${e2}`);
}
function unreachable(e2) {
  throw new Error(e2);
}
function assert(e2, t2) {
  e2 || unreachable(t2);
}
function createValidAbsoluteUrl(e2, t2 = null, i2 = null) {
  if (!e2) return null;
  if (i2 && "string" == typeof e2) {
    if (i2.addDefaultProtocol && e2.startsWith("www.")) {
      const t3 = e2.match(/\./g);
      t3?.length >= 2 && (e2 = `http://${e2}`);
    }
    if (i2.tryConvertEncoding) try {
      e2 = decodeURIComponent(escape(e2));
    } catch {
    }
  }
  const n2 = t2 ? URL.parse(e2, t2) : URL.parse(e2);
  return (function(e3) {
    switch (e3?.protocol) {
      case "http:":
      case "https:":
      case "ftp:":
      case "mailto:":
      case "tel:":
        return true;
      default:
        return false;
    }
  })(n2) ? n2 : null;
}
function updateUrlHash(e2, t2, i2 = false) {
  const n2 = URL.parse(e2);
  return n2 ? (n2.hash = t2, n2.href) : i2 && createValidAbsoluteUrl(e2, "http://example.com") ? e2.split("#", 1)[0] + (t2 ? `#${t2}` : "") : "";
}
function shadow(e2, t2, i2, n2 = false) {
  return Object.defineProperty(e2, t2, { value: i2, enumerable: !n2, configurable: true, writable: false }), i2;
}
const uc = (function() {
  function BaseException(e2, t2) {
    this.message = e2, this.name = t2;
  }
  return BaseException.prototype = new Error(), BaseException.constructor = BaseException, BaseException;
})();
class PasswordException extends uc {
  constructor(e2, t2) {
    super(e2, "PasswordException"), this.code = t2;
  }
}
class UnknownErrorException extends uc {
  constructor(e2, t2) {
    super(e2, "UnknownErrorException"), this.details = t2;
  }
}
class InvalidPDFException extends uc {
  constructor(e2) {
    super(e2, "InvalidPDFException");
  }
}
class ResponseException extends uc {
  constructor(e2, t2, i2) {
    super(e2, "ResponseException"), this.status = t2, this.missing = i2;
  }
}
class FormatError extends uc {
  constructor(e2) {
    super(e2, "FormatError");
  }
}
class AbortException extends uc {
  constructor(e2) {
    super(e2, "AbortException");
  }
}
function bytesToString(e2) {
  "object" == typeof e2 && void 0 !== e2?.length || unreachable("Invalid argument for bytesToString");
  const t2 = e2.length, i2 = 8192;
  if (t2 < i2) return String.fromCharCode.apply(null, e2);
  const n2 = [];
  for (let a2 = 0; a2 < t2; a2 += i2) {
    const s2 = Math.min(a2 + i2, t2), r2 = e2.subarray(a2, s2);
    n2.push(String.fromCharCode.apply(null, r2));
  }
  return n2.join("");
}
function stringToBytes(e2) {
  "string" != typeof e2 && unreachable("Invalid argument for stringToBytes");
  const t2 = e2.length, i2 = new Uint8Array(t2);
  for (let n2 = 0; n2 < t2; ++n2) i2[n2] = 255 & e2.charCodeAt(n2);
  return i2;
}
class util_FeatureTest {
  static get isLittleEndian() {
    return shadow(this, "isLittleEndian", (function() {
      const e2 = new Uint8Array(4);
      return e2[0] = 1, 1 === new Uint32Array(e2.buffer, 0, 1)[0];
    })());
  }
  static get isEvalSupported() {
    return shadow(this, "isEvalSupported", (function() {
      try {
        return new Function(""), true;
      } catch {
        return false;
      }
    })());
  }
  static get isOffscreenCanvasSupported() {
    return shadow(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
  }
  static get isImageDecoderSupported() {
    return shadow(this, "isImageDecoderSupported", "undefined" != typeof ImageDecoder);
  }
  static get platform() {
    const { platform: e2, userAgent: t2 } = navigator;
    return shadow(this, "platform", { isAndroid: t2.includes("Android"), isLinux: e2.includes("Linux"), isMac: e2.includes("Mac"), isWindows: e2.includes("Win"), isFirefox: t2.includes("Firefox") });
  }
  static get isCSSRoundSupported() {
    return shadow(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
  }
}
const gc = Array.from(Array(256).keys(), (e2) => e2.toString(16).padStart(2, "0"));
class Util {
  static makeHexColor(e2, t2, i2) {
    return `#${gc[e2]}${gc[t2]}${gc[i2]}`;
  }
  static domMatrixToTransform(e2) {
    return [e2.a, e2.b, e2.c, e2.d, e2.e, e2.f];
  }
  static scaleMinMax(e2, t2) {
    let i2;
    e2[0] ? (e2[0] < 0 && (i2 = t2[0], t2[0] = t2[2], t2[2] = i2), t2[0] *= e2[0], t2[2] *= e2[0], e2[3] < 0 && (i2 = t2[1], t2[1] = t2[3], t2[3] = i2), t2[1] *= e2[3], t2[3] *= e2[3]) : (i2 = t2[0], t2[0] = t2[1], t2[1] = i2, i2 = t2[2], t2[2] = t2[3], t2[3] = i2, e2[1] < 0 && (i2 = t2[1], t2[1] = t2[3], t2[3] = i2), t2[1] *= e2[1], t2[3] *= e2[1], e2[2] < 0 && (i2 = t2[0], t2[0] = t2[2], t2[2] = i2), t2[0] *= e2[2], t2[2] *= e2[2]), t2[0] += e2[4], t2[1] += e2[5], t2[2] += e2[4], t2[3] += e2[5];
  }
  static transform(e2, t2) {
    return [e2[0] * t2[0] + e2[2] * t2[1], e2[1] * t2[0] + e2[3] * t2[1], e2[0] * t2[2] + e2[2] * t2[3], e2[1] * t2[2] + e2[3] * t2[3], e2[0] * t2[4] + e2[2] * t2[5] + e2[4], e2[1] * t2[4] + e2[3] * t2[5] + e2[5]];
  }
  static multiplyByDOMMatrix(e2, t2) {
    return [e2[0] * t2.a + e2[2] * t2.b, e2[1] * t2.a + e2[3] * t2.b, e2[0] * t2.c + e2[2] * t2.d, e2[1] * t2.c + e2[3] * t2.d, e2[0] * t2.e + e2[2] * t2.f + e2[4], e2[1] * t2.e + e2[3] * t2.f + e2[5]];
  }
  static applyTransform(e2, t2, i2 = 0) {
    const n2 = e2[i2], a2 = e2[i2 + 1];
    e2[i2] = n2 * t2[0] + a2 * t2[2] + t2[4], e2[i2 + 1] = n2 * t2[1] + a2 * t2[3] + t2[5];
  }
  static applyTransformToBezier(e2, t2, i2 = 0) {
    const n2 = t2[0], a2 = t2[1], s2 = t2[2], r2 = t2[3], o2 = t2[4], l2 = t2[5];
    for (let t3 = 0; t3 < 6; t3 += 2) {
      const c2 = e2[i2 + t3], h2 = e2[i2 + t3 + 1];
      e2[i2 + t3] = c2 * n2 + h2 * s2 + o2, e2[i2 + t3 + 1] = c2 * a2 + h2 * r2 + l2;
    }
  }
  static applyInverseTransform(e2, t2) {
    const i2 = e2[0], n2 = e2[1], a2 = t2[0] * t2[3] - t2[1] * t2[2];
    e2[0] = (i2 * t2[3] - n2 * t2[2] + t2[2] * t2[5] - t2[4] * t2[3]) / a2, e2[1] = (-i2 * t2[1] + n2 * t2[0] + t2[4] * t2[1] - t2[5] * t2[0]) / a2;
  }
  static axialAlignedBoundingBox(e2, t2, i2) {
    const n2 = t2[0], a2 = t2[1], s2 = t2[2], r2 = t2[3], o2 = t2[4], l2 = t2[5], c2 = e2[0], h2 = e2[1], d2 = e2[2], u2 = e2[3];
    let g2 = n2 * c2 + o2, f2 = g2, p2 = n2 * d2 + o2, m2 = p2, b2 = r2 * h2 + l2, y2 = b2, w2 = r2 * u2 + l2, x2 = w2;
    if (0 !== a2 || 0 !== s2) {
      const e3 = a2 * c2, t3 = a2 * d2, i3 = s2 * h2, n3 = s2 * u2;
      g2 += i3, m2 += i3, p2 += n3, f2 += n3, b2 += e3, x2 += e3, w2 += t3, y2 += t3;
    }
    i2[0] = Math.min(i2[0], g2, p2, f2, m2), i2[1] = Math.min(i2[1], b2, w2, y2, x2), i2[2] = Math.max(i2[2], g2, p2, f2, m2), i2[3] = Math.max(i2[3], b2, w2, y2, x2);
  }
  static inverseTransform(e2) {
    const t2 = e2[0] * e2[3] - e2[1] * e2[2];
    return [e2[3] / t2, -e2[1] / t2, -e2[2] / t2, e2[0] / t2, (e2[2] * e2[5] - e2[4] * e2[3]) / t2, (e2[4] * e2[1] - e2[5] * e2[0]) / t2];
  }
  static singularValueDecompose2dScale(e2, t2) {
    const i2 = e2[0], n2 = e2[1], a2 = e2[2], s2 = e2[3], r2 = i2 ** 2 + n2 ** 2, o2 = i2 * a2 + n2 * s2, l2 = a2 ** 2 + s2 ** 2, c2 = (r2 + l2) / 2, h2 = Math.sqrt(c2 ** 2 - (r2 * l2 - o2 ** 2));
    t2[0] = Math.sqrt(c2 + h2 || 1), t2[1] = Math.sqrt(c2 - h2 || 1);
  }
  static normalizeRect(e2) {
    const t2 = e2.slice(0);
    return e2[0] > e2[2] && (t2[0] = e2[2], t2[2] = e2[0]), e2[1] > e2[3] && (t2[1] = e2[3], t2[3] = e2[1]), t2;
  }
  static intersect(e2, t2) {
    const i2 = Math.max(Math.min(e2[0], e2[2]), Math.min(t2[0], t2[2])), n2 = Math.min(Math.max(e2[0], e2[2]), Math.max(t2[0], t2[2]));
    if (i2 > n2) return null;
    const a2 = Math.max(Math.min(e2[1], e2[3]), Math.min(t2[1], t2[3])), s2 = Math.min(Math.max(e2[1], e2[3]), Math.max(t2[1], t2[3]));
    return a2 > s2 ? null : [i2, a2, n2, s2];
  }
  static pointBoundingBox(e2, t2, i2) {
    i2[0] = Math.min(i2[0], e2), i2[1] = Math.min(i2[1], t2), i2[2] = Math.max(i2[2], e2), i2[3] = Math.max(i2[3], t2);
  }
  static rectBoundingBox(e2, t2, i2, n2, a2) {
    a2[0] = Math.min(a2[0], e2, i2), a2[1] = Math.min(a2[1], t2, n2), a2[2] = Math.max(a2[2], e2, i2), a2[3] = Math.max(a2[3], t2, n2);
  }
  static #e(e2, t2, i2, n2, a2, s2, r2, o2, l2, c2) {
    if (l2 <= 0 || l2 >= 1) return;
    const h2 = 1 - l2, d2 = l2 * l2, u2 = d2 * l2, g2 = h2 * (h2 * (h2 * e2 + 3 * l2 * t2) + 3 * d2 * i2) + u2 * n2, f2 = h2 * (h2 * (h2 * a2 + 3 * l2 * s2) + 3 * d2 * r2) + u2 * o2;
    c2[0] = Math.min(c2[0], g2), c2[1] = Math.min(c2[1], f2), c2[2] = Math.max(c2[2], g2), c2[3] = Math.max(c2[3], f2);
  }
  static #t(e2, t2, i2, n2, a2, s2, r2, o2, l2, c2, h2, d2) {
    if (Math.abs(l2) < 1e-12) return void (Math.abs(c2) >= 1e-12 && this.#e(e2, t2, i2, n2, a2, s2, r2, o2, -h2 / c2, d2));
    const u2 = c2 ** 2 - 4 * h2 * l2;
    if (u2 < 0) return;
    const g2 = Math.sqrt(u2), f2 = 2 * l2;
    this.#e(e2, t2, i2, n2, a2, s2, r2, o2, (-c2 + g2) / f2, d2), this.#e(e2, t2, i2, n2, a2, s2, r2, o2, (-c2 - g2) / f2, d2);
  }
  static bezierBoundingBox(e2, t2, i2, n2, a2, s2, r2, o2, l2) {
    l2[0] = Math.min(l2[0], e2, r2), l2[1] = Math.min(l2[1], t2, o2), l2[2] = Math.max(l2[2], e2, r2), l2[3] = Math.max(l2[3], t2, o2), this.#t(e2, i2, a2, r2, t2, n2, s2, o2, 3 * (3 * (i2 - a2) - e2 + r2), 6 * (e2 - 2 * i2 + a2), 3 * (i2 - e2), l2), this.#t(e2, i2, a2, r2, t2, n2, s2, o2, 3 * (3 * (n2 - s2) - t2 + o2), 6 * (t2 - 2 * n2 + s2), 3 * (n2 - t2), l2);
  }
}
let fc = null, pc = null;
function normalizeUnicode(e2) {
  return fc || (fc = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, pc = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), e2.replaceAll(fc, (e3, t2, i2) => t2 ? t2.normalize("NFKC") : pc.get(i2));
}
function getUuid() {
  if ("function" == typeof crypto.randomUUID) return crypto.randomUUID();
  const e2 = new Uint8Array(32);
  return crypto.getRandomValues(e2), bytesToString(e2);
}
const mc = "pdfjs_internal_id_";
function MathClamp(e2, t2, i2) {
  return Math.min(Math.max(e2, t2), i2);
}
function toBase64Util(e2) {
  return Uint8Array.prototype.toBase64 ? e2.toBase64() : btoa(bytesToString(e2));
}
"function" != typeof Promise.try && (Promise.try = function(e2, ...t2) {
  return new Promise((i2) => {
    i2(e2(...t2));
  });
}), "function" != typeof Math.sumPrecise && (Math.sumPrecise = function(e2) {
  return e2.reduce((e3, t2) => e3 + t2, 0);
});
class XfaText {
  static textContent(e2) {
    const t2 = [], i2 = { items: t2, styles: /* @__PURE__ */ Object.create(null) };
    return (function walk(e3) {
      if (!e3) return;
      let i3 = null;
      const n2 = e3.name;
      if ("#text" === n2) i3 = e3.value;
      else {
        if (!XfaText.shouldBuildText(n2)) return;
        e3?.attributes?.textContent ? i3 = e3.attributes.textContent : e3.value && (i3 = e3.value);
      }
      if (null !== i3 && t2.push({ str: i3 }), e3.children) for (const t3 of e3.children) walk(t3);
    })(e2), i2;
  }
  static shouldBuildText(e2) {
    return !("textarea" === e2 || "input" === e2 || "option" === e2 || "select" === e2);
  }
}
class XfaLayer {
  static setupStorage(e2, t2, i2, n2, a2) {
    const s2 = n2.getValue(t2, { value: null });
    switch (i2.name) {
      case "textarea":
        if (null !== s2.value && (e2.textContent = s2.value), "print" === a2) break;
        e2.addEventListener("input", (e3) => {
          n2.setValue(t2, { value: e3.target.value });
        });
        break;
      case "input":
        if ("radio" === i2.attributes.type || "checkbox" === i2.attributes.type) {
          if (s2.value === i2.attributes.xfaOn ? e2.setAttribute("checked", true) : s2.value === i2.attributes.xfaOff && e2.removeAttribute("checked"), "print" === a2) break;
          e2.addEventListener("change", (e3) => {
            n2.setValue(t2, { value: e3.target.checked ? e3.target.getAttribute("xfaOn") : e3.target.getAttribute("xfaOff") });
          });
        } else {
          if (null !== s2.value && e2.setAttribute("value", s2.value), "print" === a2) break;
          e2.addEventListener("input", (e3) => {
            n2.setValue(t2, { value: e3.target.value });
          });
        }
        break;
      case "select":
        if (null !== s2.value) {
          e2.setAttribute("value", s2.value);
          for (const e3 of i2.children) e3.attributes.value === s2.value ? e3.attributes.selected = true : e3.attributes.hasOwnProperty("selected") && delete e3.attributes.selected;
        }
        e2.addEventListener("input", (e3) => {
          const i3 = e3.target.options, a3 = -1 === i3.selectedIndex ? "" : i3[i3.selectedIndex].value;
          n2.setValue(t2, { value: a3 });
        });
    }
  }
  static setAttributes({ html: e2, element: t2, storage: i2 = null, intent: n2, linkService: a2 }) {
    const { attributes: s2 } = t2, r2 = e2 instanceof HTMLAnchorElement;
    "radio" === s2.type && (s2.name = `${s2.name}-${n2}`);
    for (const [t3, i3] of Object.entries(s2)) if (null != i3) switch (t3) {
      case "class":
        i3.length && e2.setAttribute(t3, i3.join(" "));
        break;
      case "dataId":
        break;
      case "id":
        e2.setAttribute("data-element-id", i3);
        break;
      case "style":
        Object.assign(e2.style, i3);
        break;
      case "textContent":
        e2.textContent = i3;
        break;
      default:
        (!r2 || "href" !== t3 && "newWindow" !== t3) && e2.setAttribute(t3, i3);
    }
    r2 && a2.addLinkAttributes(e2, s2.href, s2.newWindow), i2 && s2.dataId && this.setupStorage(e2, s2.dataId, t2, i2);
  }
  static render(e2) {
    const t2 = e2.annotationStorage, i2 = e2.linkService, n2 = e2.xfaHtml, a2 = e2.intent || "display", s2 = document.createElement(n2.name);
    n2.attributes && this.setAttributes({ html: s2, element: n2, intent: a2, linkService: i2 });
    const r2 = "richText" !== a2, o2 = e2.div;
    if (o2.append(s2), e2.viewport) {
      const t3 = `matrix(${e2.viewport.transform.join(",")})`;
      o2.style.transform = t3;
    }
    r2 && o2.setAttribute("class", "xfaLayer xfaFont");
    const l2 = [];
    if (0 === n2.children.length) {
      if (n2.value) {
        const e3 = document.createTextNode(n2.value);
        s2.append(e3), r2 && XfaText.shouldBuildText(n2.name) && l2.push(e3);
      }
      return { textDivs: l2 };
    }
    const c2 = [[n2, -1, s2]];
    for (; c2.length > 0; ) {
      const [e3, n3, s3] = c2.at(-1);
      if (n3 + 1 === e3.children.length) {
        c2.pop();
        continue;
      }
      const o3 = e3.children[++c2.at(-1)[1]];
      if (null === o3) continue;
      const { name: h2 } = o3;
      if ("#text" === h2) {
        const e4 = document.createTextNode(o3.value);
        l2.push(e4), s3.append(e4);
        continue;
      }
      const d2 = o3?.attributes?.xmlns ? document.createElementNS(o3.attributes.xmlns, h2) : document.createElement(h2);
      if (s3.append(d2), o3.attributes && this.setAttributes({ html: d2, element: o3, storage: t2, intent: a2, linkService: i2 }), o3.children?.length > 0) c2.push([o3, -1, d2]);
      else if (o3.value) {
        const e4 = document.createTextNode(o3.value);
        r2 && XfaText.shouldBuildText(h2) && l2.push(e4), d2.append(e4);
      }
    }
    for (const e3 of o2.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) e3.setAttribute("readOnly", true);
    return { textDivs: l2 };
  }
  static update(e2) {
    const t2 = `matrix(${e2.viewport.transform.join(",")})`;
    e2.div.style.transform = t2, e2.div.hidden = false;
  }
}
const bc = "http://www.w3.org/2000/svg";
class PixelsPerInch {
  static CSS = 96;
  static PDF = 72;
  static PDF_TO_CSS_UNITS = this.CSS / this.PDF;
}
async function fetchData(e2, t2 = "text") {
  if (isValidFetchUrl(e2, document.baseURI)) {
    const i2 = await fetch(e2);
    if (!i2.ok) throw new Error(i2.statusText);
    switch (t2) {
      case "arraybuffer":
        return i2.arrayBuffer();
      case "blob":
        return i2.blob();
      case "json":
        return i2.json();
    }
    return i2.text();
  }
  return new Promise((i2, n2) => {
    const a2 = new XMLHttpRequest();
    a2.open("GET", e2, true), a2.responseType = t2, a2.onreadystatechange = () => {
      if (a2.readyState === XMLHttpRequest.DONE) if (200 !== a2.status && 0 !== a2.status) n2(new Error(a2.statusText));
      else {
        switch (t2) {
          case "arraybuffer":
          case "blob":
          case "json":
            return void i2(a2.response);
        }
        i2(a2.responseText);
      }
    }, a2.send(null);
  });
}
class PageViewport {
  constructor({ viewBox: e2, userUnit: t2, scale: i2, rotation: n2, offsetX: a2 = 0, offsetY: s2 = 0, dontFlip: r2 = false }) {
    this.viewBox = e2, this.userUnit = t2, this.scale = i2, this.rotation = n2, this.offsetX = a2, this.offsetY = s2, i2 *= t2;
    const o2 = (e2[2] + e2[0]) / 2, l2 = (e2[3] + e2[1]) / 2;
    let c2, h2, d2, u2, g2, f2, p2, m2;
    switch ((n2 %= 360) < 0 && (n2 += 360), n2) {
      case 180:
        c2 = -1, h2 = 0, d2 = 0, u2 = 1;
        break;
      case 90:
        c2 = 0, h2 = 1, d2 = 1, u2 = 0;
        break;
      case 270:
        c2 = 0, h2 = -1, d2 = -1, u2 = 0;
        break;
      case 0:
        c2 = 1, h2 = 0, d2 = 0, u2 = -1;
        break;
      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }
    r2 && (d2 = -d2, u2 = -u2), 0 === c2 ? (g2 = Math.abs(l2 - e2[1]) * i2 + a2, f2 = Math.abs(o2 - e2[0]) * i2 + s2, p2 = (e2[3] - e2[1]) * i2, m2 = (e2[2] - e2[0]) * i2) : (g2 = Math.abs(o2 - e2[0]) * i2 + a2, f2 = Math.abs(l2 - e2[1]) * i2 + s2, p2 = (e2[2] - e2[0]) * i2, m2 = (e2[3] - e2[1]) * i2), this.transform = [c2 * i2, h2 * i2, d2 * i2, u2 * i2, g2 - c2 * i2 * o2 - d2 * i2 * l2, f2 - h2 * i2 * o2 - u2 * i2 * l2], this.width = p2, this.height = m2;
  }
  get rawDims() {
    const e2 = this.viewBox;
    return shadow(this, "rawDims", { pageWidth: e2[2] - e2[0], pageHeight: e2[3] - e2[1], pageX: e2[0], pageY: e2[1] });
  }
  clone({ scale: e2 = this.scale, rotation: t2 = this.rotation, offsetX: i2 = this.offsetX, offsetY: n2 = this.offsetY, dontFlip: a2 = false } = {}) {
    return new PageViewport({ viewBox: this.viewBox.slice(), userUnit: this.userUnit, scale: e2, rotation: t2, offsetX: i2, offsetY: n2, dontFlip: a2 });
  }
  convertToViewportPoint(e2, t2) {
    const i2 = [e2, t2];
    return Util.applyTransform(i2, this.transform), i2;
  }
  convertToViewportRectangle(e2) {
    const t2 = [e2[0], e2[1]];
    Util.applyTransform(t2, this.transform);
    const i2 = [e2[2], e2[3]];
    return Util.applyTransform(i2, this.transform), [t2[0], t2[1], i2[0], i2[1]];
  }
  convertToPdfPoint(e2, t2) {
    const i2 = [e2, t2];
    return Util.applyInverseTransform(i2, this.transform), i2;
  }
}
class RenderingCancelledException extends uc {
  constructor(e2, t2 = 0) {
    super(e2, "RenderingCancelledException"), this.extraDelay = t2;
  }
}
function isDataScheme(e2) {
  const t2 = e2.length;
  let i2 = 0;
  for (; i2 < t2 && "" === e2[i2].trim(); ) i2++;
  return "data:" === e2.substring(i2, i2 + 5).toLowerCase();
}
function isPdfFile(e2) {
  return "string" == typeof e2 && /\.pdf$/i.test(e2);
}
function getFilenameFromUrl(e2) {
  return [e2] = e2.split(/[#?]/, 1), e2.substring(e2.lastIndexOf("/") + 1);
}
function getPdfFilenameFromUrl(e2, t2 = "document.pdf") {
  if ("string" != typeof e2) return t2;
  if (isDataScheme(e2)) return warn('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), t2;
  const i2 = ((e3) => {
    try {
      return new URL(e3);
    } catch {
      try {
        return new URL(decodeURIComponent(e3));
      } catch {
        try {
          return new URL(e3, "https://foo.bar");
        } catch {
          try {
            return new URL(decodeURIComponent(e3), "https://foo.bar");
          } catch {
            return null;
          }
        }
      }
    }
  })(e2);
  if (!i2) return t2;
  const decode = (e3) => {
    try {
      let t3 = decodeURIComponent(e3);
      return t3.includes("/") ? (t3 = t3.split("/").at(-1), t3.test(/^\.pdf$/i) ? t3 : e3) : t3;
    } catch {
      return e3;
    }
  }, n2 = /\.pdf$/i, a2 = i2.pathname.split("/").at(-1);
  if (n2.test(a2)) return decode(a2);
  if (i2.searchParams.size > 0) {
    const e3 = Array.from(i2.searchParams.values()).reverse();
    for (const t4 of e3) if (n2.test(t4)) return decode(t4);
    const t3 = Array.from(i2.searchParams.keys()).reverse();
    for (const e4 of t3) if (n2.test(e4)) return decode(e4);
  }
  if (i2.hash) {
    const e3 = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i.exec(i2.hash);
    if (e3) return decode(e3[0]);
  }
  return t2;
}
class StatTimer {
  started = /* @__PURE__ */ Object.create(null);
  times = [];
  time(e2) {
    e2 in this.started && warn(`Timer is already running for ${e2}`), this.started[e2] = Date.now();
  }
  timeEnd(e2) {
    e2 in this.started || warn(`Timer has not been started for ${e2}`), this.times.push({ name: e2, start: this.started[e2], end: Date.now() }), delete this.started[e2];
  }
  toString() {
    const e2 = [];
    let t2 = 0;
    for (const { name: e3 } of this.times) t2 = Math.max(e3.length, t2);
    for (const { name: i2, start: n2, end: a2 } of this.times) e2.push(`${i2.padEnd(t2)} ${a2 - n2}ms
`);
    return e2.join("");
  }
}
function isValidFetchUrl(e2, t2) {
  const i2 = t2 ? URL.parse(e2, t2) : URL.parse(e2);
  return "http:" === i2?.protocol || "https:" === i2?.protocol;
}
function noContextMenu(e2) {
  e2.preventDefault();
}
function stopEvent(e2) {
  e2.preventDefault(), e2.stopPropagation();
}
class PDFDateString {
  static #dt;
  static toDateObject(e2) {
    if (e2 instanceof Date) return e2;
    if (!e2 || "string" != typeof e2) return null;
    this.#dt ||= new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
    const t2 = this.#dt.exec(e2);
    if (!t2) return null;
    const i2 = parseInt(t2[1], 10);
    let n2 = parseInt(t2[2], 10);
    n2 = n2 >= 1 && n2 <= 12 ? n2 - 1 : 0;
    let a2 = parseInt(t2[3], 10);
    a2 = a2 >= 1 && a2 <= 31 ? a2 : 1;
    let s2 = parseInt(t2[4], 10);
    s2 = s2 >= 0 && s2 <= 23 ? s2 : 0;
    let r2 = parseInt(t2[5], 10);
    r2 = r2 >= 0 && r2 <= 59 ? r2 : 0;
    let o2 = parseInt(t2[6], 10);
    o2 = o2 >= 0 && o2 <= 59 ? o2 : 0;
    const l2 = t2[7] || "Z";
    let c2 = parseInt(t2[8], 10);
    c2 = c2 >= 0 && c2 <= 23 ? c2 : 0;
    let h2 = parseInt(t2[9], 10) || 0;
    return h2 = h2 >= 0 && h2 <= 59 ? h2 : 0, "-" === l2 ? (s2 += c2, r2 += h2) : "+" === l2 && (s2 -= c2, r2 -= h2), new Date(Date.UTC(i2, n2, a2, s2, r2, o2));
  }
}
function getXfaPageViewport(e2, { scale: t2 = 1, rotation: i2 = 0 }) {
  const { width: n2, height: a2 } = e2.attributes.style, s2 = [0, 0, parseInt(n2), parseInt(a2)];
  return new PageViewport({ viewBox: s2, userUnit: 1, scale: t2, rotation: i2 });
}
function getRGB(e2) {
  if (e2.startsWith("#")) {
    const t2 = parseInt(e2.slice(1), 16);
    return [(16711680 & t2) >> 16, (65280 & t2) >> 8, 255 & t2];
  }
  return e2.startsWith("rgb(") ? e2.slice(4, -1).split(",").map((e3) => parseInt(e3)) : e2.startsWith("rgba(") ? e2.slice(5, -1).split(",").map((e3) => parseInt(e3)).slice(0, 3) : (warn(`Not a valid color format: "${e2}"`), [0, 0, 0]);
}
function getCurrentTransform(e2) {
  const { a: t2, b: i2, c: n2, d: a2, e: s2, f: r2 } = e2.getTransform();
  return [t2, i2, n2, a2, s2, r2];
}
function getCurrentTransformInverse(e2) {
  const { a: t2, b: i2, c: n2, d: a2, e: s2, f: r2 } = e2.getTransform().invertSelf();
  return [t2, i2, n2, a2, s2, r2];
}
function setLayerDimensions(e2, t2, i2 = false, n2 = true) {
  if (t2 instanceof PageViewport) {
    const { pageWidth: n3, pageHeight: a2 } = t2.rawDims, { style: s2 } = e2, r2 = util_FeatureTest.isCSSRoundSupported, o2 = `var(--total-scale-factor) * ${n3}px`, l2 = `var(--total-scale-factor) * ${a2}px`, c2 = r2 ? `round(down, ${o2}, var(--scale-round-x))` : `calc(${o2})`, h2 = r2 ? `round(down, ${l2}, var(--scale-round-y))` : `calc(${l2})`;
    i2 && t2.rotation % 180 != 0 ? (s2.width = h2, s2.height = c2) : (s2.width = c2, s2.height = h2);
  }
  n2 && e2.setAttribute("data-main-rotation", t2.rotation);
}
class OutputScale {
  constructor() {
    const { pixelRatio: e2 } = OutputScale;
    this.sx = e2, this.sy = e2;
  }
  get scaled() {
    return 1 !== this.sx || 1 !== this.sy;
  }
  get symmetric() {
    return this.sx === this.sy;
  }
  limitCanvas(e2, t2, i2, n2, a2 = -1) {
    let s2 = 1 / 0, r2 = 1 / 0, o2 = 1 / 0;
    (i2 = OutputScale.capPixels(i2, a2)) > 0 && (s2 = Math.sqrt(i2 / (e2 * t2))), -1 !== n2 && (r2 = n2 / e2, o2 = n2 / t2);
    const l2 = Math.min(s2, r2, o2);
    return (this.sx > l2 || this.sy > l2) && (this.sx = l2, this.sy = l2, true);
  }
  static get pixelRatio() {
    return globalThis.devicePixelRatio || 1;
  }
  static capPixels(e2, t2) {
    if (t2 >= 0) {
      const i2 = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + t2 / 100));
      return e2 > 0 ? Math.min(e2, i2) : i2;
    }
    return e2;
  }
}
const yc = ["image/apng", "image/avif", "image/bmp", "image/gif", "image/jpeg", "image/png", "image/svg+xml", "image/webp", "image/x-icon"];
class ColorScheme {
  static get isDarkMode() {
    return shadow(this, "isDarkMode", !!window?.matchMedia?.("(prefers-color-scheme: dark)").matches);
  }
}
class CSSConstants {
  static get commentForegroundColor() {
    const e2 = document.createElement("span");
    e2.classList.add("comment", "sidebar");
    const { style: t2 } = e2;
    t2.width = t2.height = "0", t2.display = "none", t2.color = "var(--comment-fg-color)", document.body.append(e2);
    const { color: i2 } = window.getComputedStyle(e2);
    return e2.remove(), shadow(this, "commentForegroundColor", getRGB(i2));
  }
}
function applyOpacity(e2, t2, i2, n2) {
  const a2 = 255 * (1 - (n2 = Math.min(Math.max(n2 ?? 1, 0), 1)));
  return [e2 = Math.round(e2 * n2 + a2), t2 = Math.round(t2 * n2 + a2), i2 = Math.round(i2 * n2 + a2)];
}
function RGBToHSL(e2, t2) {
  const i2 = e2[0] / 255, n2 = e2[1] / 255, a2 = e2[2] / 255, s2 = Math.max(i2, n2, a2), r2 = Math.min(i2, n2, a2), o2 = (s2 + r2) / 2;
  if (s2 === r2) t2[0] = t2[1] = 0;
  else {
    const e3 = s2 - r2;
    switch (t2[1] = o2 < 0.5 ? e3 / (s2 + r2) : e3 / (2 - s2 - r2), s2) {
      case i2:
        t2[0] = 60 * ((n2 - a2) / e3 + (n2 < a2 ? 6 : 0));
        break;
      case n2:
        t2[0] = 60 * ((a2 - i2) / e3 + 2);
        break;
      case a2:
        t2[0] = 60 * ((i2 - n2) / e3 + 4);
    }
  }
  t2[2] = o2;
}
function HSLToRGB(e2, t2) {
  const i2 = e2[0], n2 = e2[1], a2 = e2[2], s2 = (1 - Math.abs(2 * a2 - 1)) * n2, r2 = s2 * (1 - Math.abs(i2 / 60 % 2 - 1)), o2 = a2 - s2 / 2;
  switch (Math.floor(i2 / 60)) {
    case 0:
      t2[0] = s2 + o2, t2[1] = r2 + o2, t2[2] = o2;
      break;
    case 1:
      t2[0] = r2 + o2, t2[1] = s2 + o2, t2[2] = o2;
      break;
    case 2:
      t2[0] = o2, t2[1] = s2 + o2, t2[2] = r2 + o2;
      break;
    case 3:
      t2[0] = o2, t2[1] = r2 + o2, t2[2] = s2 + o2;
      break;
    case 4:
      t2[0] = r2 + o2, t2[1] = o2, t2[2] = s2 + o2;
      break;
    case 5:
    case 6:
      t2[0] = s2 + o2, t2[1] = o2, t2[2] = r2 + o2;
  }
}
function computeLuminance(e2) {
  return e2 <= 0.03928 ? e2 / 12.92 : ((e2 + 0.055) / 1.055) ** 2.4;
}
function contrastRatio(e2, t2, i2) {
  HSLToRGB(e2, i2), i2.map(computeLuminance);
  const n2 = 0.2126 * i2[0] + 0.7152 * i2[1] + 0.0722 * i2[2];
  HSLToRGB(t2, i2), i2.map(computeLuminance);
  const a2 = 0.2126 * i2[0] + 0.7152 * i2[1] + 0.0722 * i2[2];
  return n2 > a2 ? (n2 + 0.05) / (a2 + 0.05) : (a2 + 0.05) / (n2 + 0.05);
}
const wc = /* @__PURE__ */ new Map();
function findContrastColor(e2, t2) {
  const i2 = e2[0] + 256 * e2[1] + 65536 * e2[2] + 16777216 * t2[0] + 4294967296 * t2[1] + 1099511627776 * t2[2];
  let n2 = wc.get(i2);
  if (n2) return n2;
  const a2 = new Float32Array(9), s2 = a2.subarray(0, 3), r2 = a2.subarray(3, 6);
  RGBToHSL(e2, r2);
  const o2 = a2.subarray(6, 9);
  RGBToHSL(t2, o2);
  const l2 = o2[2] < 0.5, c2 = l2 ? 12 : 4.5;
  if (r2[2] = l2 ? Math.sqrt(r2[2]) : 1 - Math.sqrt(1 - r2[2]), contrastRatio(r2, o2, s2) < c2) {
    let e3, t3;
    l2 ? (e3 = r2[2], t3 = 1) : (e3 = 0, t3 = r2[2]);
    const i3 = 5e-3;
    for (; t3 - e3 > i3; ) {
      const i4 = r2[2] = (e3 + t3) / 2;
      l2 === contrastRatio(r2, o2, s2) < c2 ? e3 = i4 : t3 = i4;
    }
    r2[2] = l2 ? t3 : e3;
  }
  return HSLToRGB(r2, s2), n2 = Util.makeHexColor(Math.round(255 * s2[0]), Math.round(255 * s2[1]), Math.round(255 * s2[2])), wc.set(i2, n2), n2;
}
function renderRichText({ html: e2, dir: t2, className: i2 }, n2) {
  const a2 = document.createDocumentFragment();
  if ("string" == typeof e2) {
    const i3 = document.createElement("p");
    i3.dir = t2 || "auto";
    const n3 = e2.split(/(?:\r\n?|\n)/);
    for (let e3 = 0, t3 = n3.length; e3 < t3; ++e3) {
      const a3 = n3[e3];
      i3.append(document.createTextNode(a3)), e3 < t3 - 1 && i3.append(document.createElement("br"));
    }
    a2.append(i3);
  } else XfaLayer.render({ xfaHtml: e2, div: a2, intent: "richText" });
  a2.firstChild.classList.add("richText", i2), n2.append(a2);
}
class EditorToolbar {
  #ut = null;
  #gt = null;
  #ft;
  #pt = null;
  #mt = null;
  #bt = null;
  #yt = null;
  #wt = null;
  static #At = null;
  constructor(e2) {
    this.#ft = e2, EditorToolbar.#At ||= Object.freeze({ freetext: "pdfjs-editor-remove-freetext-button", highlight: "pdfjs-editor-remove-highlight-button", ink: "pdfjs-editor-remove-ink-button", stamp: "pdfjs-editor-remove-stamp-button", signature: "pdfjs-editor-remove-signature-button" });
  }
  render() {
    const e2 = this.#ut = document.createElement("div");
    e2.classList.add("editToolbar", "hidden"), e2.setAttribute("role", "toolbar");
    const t2 = this.#ft._uiManager._signal;
    t2 instanceof AbortSignal && !t2.aborted && (e2.addEventListener("contextmenu", noContextMenu, { signal: t2 }), e2.addEventListener("pointerdown", EditorToolbar.#xt, { signal: t2 }));
    const i2 = this.#pt = document.createElement("div");
    i2.className = "buttons", e2.append(i2);
    const n2 = this.#ft.toolbarPosition;
    if (n2) {
      const { style: t3 } = e2, i3 = "ltr" === this.#ft._uiManager.direction ? 1 - n2[0] : n2[0];
      t3.insetInlineEnd = 100 * i3 + "%", t3.top = `calc(${100 * n2[1]}% + var(--editor-toolbar-vert-offset))`;
    }
    return e2;
  }
  get div() {
    return this.#ut;
  }
  static #xt(e2) {
    e2.stopPropagation();
  }
  #St(e2) {
    this.#ft._focusEventsAllowed = false, stopEvent(e2);
  }
  #vt(e2) {
    this.#ft._focusEventsAllowed = true, stopEvent(e2);
  }
  #Ct(e2) {
    const t2 = this.#ft._uiManager._signal;
    return t2 instanceof AbortSignal && !t2.aborted && (e2.addEventListener("focusin", this.#St.bind(this), { capture: true, signal: t2 }), e2.addEventListener("focusout", this.#vt.bind(this), { capture: true, signal: t2 }), e2.addEventListener("contextmenu", noContextMenu, { signal: t2 }), true);
  }
  hide() {
    this.#ut.classList.add("hidden"), this.#gt?.hideDropdown();
  }
  show() {
    this.#ut.classList.remove("hidden"), this.#mt?.shown(), this.#bt?.shown();
  }
  addDeleteButton() {
    const { editorType: e2, _uiManager: t2 } = this.#ft, i2 = document.createElement("button");
    i2.classList.add("basic", "deleteButton"), i2.tabIndex = 0, i2.setAttribute("data-l10n-id", EditorToolbar.#At[e2]), this.#Ct(i2) && i2.addEventListener("click", (e3) => {
      t2.delete();
    }, { signal: t2._signal }), this.#pt.append(i2);
  }
  get #kt() {
    const e2 = document.createElement("div");
    return e2.className = "divider", e2;
  }
  async addAltText(e2) {
    const t2 = await e2.render();
    this.#Ct(t2), this.#pt.append(t2, this.#kt), this.#mt = e2;
  }
  addComment(e2, t2 = null) {
    if (this.#bt) return;
    const i2 = e2.renderForToolbar();
    if (!i2) return;
    this.#Ct(i2);
    const n2 = this.#yt = this.#kt;
    t2 ? (this.#pt.insertBefore(i2, t2), this.#pt.insertBefore(n2, t2)) : this.#pt.append(i2, n2), this.#bt = e2, e2.toolbar = this;
  }
  addColorPicker(e2) {
    if (this.#gt) return;
    this.#gt = e2;
    const t2 = e2.renderButton();
    this.#Ct(t2), this.#pt.append(t2, this.#kt);
  }
  async addEditSignatureButton(e2) {
    const t2 = this.#wt = await e2.renderEditButton(this.#ft);
    this.#Ct(t2), this.#pt.append(t2, this.#kt);
  }
  removeButton(e2) {
    if ("comment" === e2) this.#bt?.removeToolbarCommentButton(), this.#bt = null, this.#yt?.remove(), this.#yt = null;
  }
  async addButton(e2, t2) {
    switch (e2) {
      case "colorPicker":
        this.addColorPicker(t2);
        break;
      case "altText":
        await this.addAltText(t2);
        break;
      case "editSignature":
        await this.addEditSignatureButton(t2);
        break;
      case "delete":
        this.addDeleteButton();
        break;
      case "comment":
        this.addComment(t2);
    }
  }
  async addButtonBefore(e2, t2, i2) {
    const n2 = this.#pt.querySelector(i2);
    n2 && "comment" === e2 && this.addComment(t2, n2);
  }
  updateEditSignatureButton(e2) {
    this.#wt && (this.#wt.title = e2);
  }
  remove() {
    this.#ut.remove(), this.#gt?.destroy(), this.#gt = null;
  }
}
class FloatingToolbar {
  #pt = null;
  #ut = null;
  #Tt;
  constructor(e2) {
    this.#Tt = e2;
  }
  #Ft() {
    const e2 = this.#ut = document.createElement("div");
    e2.className = "editToolbar", e2.setAttribute("role", "toolbar");
    const t2 = this.#Tt._signal;
    t2 instanceof AbortSignal && !t2.aborted && e2.addEventListener("contextmenu", noContextMenu, { signal: t2 });
    const i2 = this.#pt = document.createElement("div");
    return i2.className = "buttons", e2.append(i2), this.#Tt.hasCommentManager() && this.#It("commentButton", "pdfjs-comment-floating-button", "pdfjs-comment-floating-button-label", () => {
      this.#Tt.commentSelection("floating_button");
    }), this.#It("highlightButton", "pdfjs-highlight-floating-button1", "pdfjs-highlight-floating-button-label", () => {
      this.#Tt.highlightSelection("floating_button");
    }), e2;
  }
  #Et(e2, t2) {
    let i2 = 0, n2 = 0;
    for (const a2 of e2) {
      const e3 = a2.y + a2.height;
      if (e3 < i2) continue;
      const s2 = a2.x + (t2 ? a2.width : 0);
      e3 > i2 ? (n2 = s2, i2 = e3) : t2 ? s2 > n2 && (n2 = s2) : s2 < n2 && (n2 = s2);
    }
    return [t2 ? 1 - n2 : n2, i2];
  }
  show(e2, t2, i2) {
    const [n2, a2] = this.#Et(t2, i2), { style: s2 } = this.#ut ||= this.#Ft();
    e2.append(this.#ut), s2.insetInlineEnd = 100 * n2 + "%", s2.top = `calc(${100 * a2}% + var(--editor-toolbar-vert-offset))`;
  }
  hide() {
    this.#ut.remove();
  }
  #It(e2, t2, i2, n2) {
    const a2 = document.createElement("button");
    a2.classList.add("basic", e2), a2.tabIndex = 0, a2.setAttribute("data-l10n-id", t2);
    const s2 = document.createElement("span");
    a2.append(s2), s2.className = "visuallyHidden", s2.setAttribute("data-l10n-id", i2);
    const r2 = this.#Tt._signal;
    r2 instanceof AbortSignal && !r2.aborted && (a2.addEventListener("contextmenu", noContextMenu, { signal: r2 }), a2.addEventListener("click", n2, { signal: r2 })), this.#pt.append(a2);
  }
}
function bindEvents(e2, t2, i2) {
  for (const n2 of i2) t2.addEventListener(n2, e2[n2].bind(e2));
}
class IdManager {
  #Mt = 0;
  get id() {
    return `${$l}${this.#Mt++}`;
  }
}
class ImageManager {
  #Dt = getUuid();
  #Mt = 0;
  #Ot = null;
  static get _isSVGFittingCanvas() {
    const e2 = new OffscreenCanvas(1, 3).getContext("2d", { willReadFrequently: true }), t2 = new Image();
    t2.src = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>';
    return shadow(this, "_isSVGFittingCanvas", t2.decode().then(() => (e2.drawImage(t2, 0, 0, 1, 1, 0, 0, 1, 3), 0 === new Uint32Array(e2.getImageData(0, 0, 1, 1).data.buffer)[0])));
  }
  async #_t(e2, t2) {
    this.#Ot ||= /* @__PURE__ */ new Map();
    let i2 = this.#Ot.get(e2);
    if (null === i2) return null;
    if (i2?.bitmap) return i2.refCounter += 1, i2;
    try {
      let e3;
      if (i2 ||= { bitmap: null, id: `image_${this.#Dt}_${this.#Mt++}`, refCounter: 0, isSvg: false }, "string" == typeof t2 ? (i2.url = t2, e3 = await fetchData(t2, "blob")) : t2 instanceof File ? e3 = i2.file = t2 : t2 instanceof Blob && (e3 = t2), "image/svg+xml" === e3.type) {
        const t3 = ImageManager._isSVGFittingCanvas, n2 = new FileReader(), a2 = new Image(), s2 = new Promise((e4, s3) => {
          a2.onload = () => {
            i2.bitmap = a2, i2.isSvg = true, e4();
          }, n2.onload = async () => {
            const e5 = i2.svgUrl = n2.result;
            a2.src = await t3 ? `${e5}#svgView(preserveAspectRatio(none))` : e5;
          }, a2.onerror = n2.onerror = s3;
        });
        n2.readAsDataURL(e3), await s2;
      } else i2.bitmap = await createImageBitmap(e3);
      i2.refCounter = 1;
    } catch (e3) {
      warn(e3), i2 = null;
    }
    return this.#Ot.set(e2, i2), i2 && this.#Ot.set(i2.id, i2), i2;
  }
  async getFromFile(e2) {
    const { lastModified: t2, name: i2, size: n2, type: a2 } = e2;
    return this.#_t(`${t2}_${i2}_${n2}_${a2}`, e2);
  }
  async getFromUrl(e2) {
    return this.#_t(e2, e2);
  }
  async getFromBlob(e2, t2) {
    const i2 = await t2;
    return this.#_t(e2, i2);
  }
  async getFromId(e2) {
    this.#Ot ||= /* @__PURE__ */ new Map();
    const t2 = this.#Ot.get(e2);
    if (!t2) return null;
    if (t2.bitmap) return t2.refCounter += 1, t2;
    if (t2.file) return this.getFromFile(t2.file);
    if (t2.blobPromise) {
      const { blobPromise: e3 } = t2;
      return delete t2.blobPromise, this.getFromBlob(t2.id, e3);
    }
    return this.getFromUrl(t2.url);
  }
  getFromCanvas(e2, t2) {
    this.#Ot ||= /* @__PURE__ */ new Map();
    let i2 = this.#Ot.get(e2);
    if (i2?.bitmap) return i2.refCounter += 1, i2;
    const n2 = new OffscreenCanvas(t2.width, t2.height);
    return n2.getContext("2d").drawImage(t2, 0, 0), i2 = { bitmap: n2.transferToImageBitmap(), id: `image_${this.#Dt}_${this.#Mt++}`, refCounter: 1, isSvg: false }, this.#Ot.set(e2, i2), this.#Ot.set(i2.id, i2), i2;
  }
  getSvgUrl(e2) {
    const t2 = this.#Ot.get(e2);
    return t2?.isSvg ? t2.svgUrl : null;
  }
  deleteId(e2) {
    this.#Ot ||= /* @__PURE__ */ new Map();
    const t2 = this.#Ot.get(e2);
    if (!t2) return;
    if (t2.refCounter -= 1, 0 !== t2.refCounter) return;
    const { bitmap: i2 } = t2;
    if (!t2.url && !t2.file) {
      const e3 = new OffscreenCanvas(i2.width, i2.height);
      e3.getContext("bitmaprenderer").transferFromImageBitmap(i2), t2.blobPromise = e3.convertToBlob();
    }
    i2.close?.(), t2.bitmap = null;
  }
  isValidId(e2) {
    return e2.startsWith(`image_${this.#Dt}_`);
  }
}
class CommandManager {
  #Pt = [];
  #Rt = false;
  #Bt;
  #Nt = -1;
  constructor(e2 = 128) {
    this.#Bt = e2;
  }
  add({ cmd: e2, undo: t2, post: i2, mustExec: n2, type: a2 = NaN, overwriteIfSameType: s2 = false, keepUndo: r2 = false }) {
    if (n2 && e2(), this.#Rt) return;
    const o2 = { cmd: e2, undo: t2, post: i2, type: a2 };
    if (-1 === this.#Nt) return this.#Pt.length > 0 && (this.#Pt.length = 0), this.#Nt = 0, void this.#Pt.push(o2);
    if (s2 && this.#Pt[this.#Nt].type === a2) return r2 && (o2.undo = this.#Pt[this.#Nt].undo), void (this.#Pt[this.#Nt] = o2);
    const l2 = this.#Nt + 1;
    l2 === this.#Bt ? this.#Pt.splice(0, 1) : (this.#Nt = l2, l2 < this.#Pt.length && this.#Pt.splice(l2)), this.#Pt.push(o2);
  }
  undo() {
    if (-1 === this.#Nt) return;
    this.#Rt = true;
    const { undo: e2, post: t2 } = this.#Pt[this.#Nt];
    e2(), t2?.(), this.#Rt = false, this.#Nt -= 1;
  }
  redo() {
    if (this.#Nt < this.#Pt.length - 1) {
      this.#Nt += 1, this.#Rt = true;
      const { cmd: e2, post: t2 } = this.#Pt[this.#Nt];
      e2(), t2?.(), this.#Rt = false;
    }
  }
  hasSomethingToUndo() {
    return -1 !== this.#Nt;
  }
  hasSomethingToRedo() {
    return this.#Nt < this.#Pt.length - 1;
  }
  cleanType(e2) {
    if (-1 !== this.#Nt) {
      for (let t2 = this.#Nt; t2 >= 0; t2--) if (this.#Pt[t2].type !== e2) return this.#Pt.splice(t2 + 1, this.#Nt - t2), void (this.#Nt = t2);
      this.#Pt.length = 0, this.#Nt = -1;
    }
  }
  destroy() {
    this.#Pt = null;
  }
}
class KeyboardManager {
  constructor(e2) {
    this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
    const { isMac: t2 } = util_FeatureTest.platform;
    for (const [i2, n2, a2 = {}] of e2) for (const e3 of i2) {
      const i3 = e3.startsWith("mac+");
      t2 && i3 ? (this.callbacks.set(e3.slice(4), { callback: n2, options: a2 }), this.allKeys.add(e3.split("+").at(-1))) : t2 || i3 || (this.callbacks.set(e3, { callback: n2, options: a2 }), this.allKeys.add(e3.split("+").at(-1)));
    }
  }
  #Lt(e2) {
    e2.altKey && this.buffer.push("alt"), e2.ctrlKey && this.buffer.push("ctrl"), e2.metaKey && this.buffer.push("meta"), e2.shiftKey && this.buffer.push("shift"), this.buffer.push(e2.key);
    const t2 = this.buffer.join("+");
    return this.buffer.length = 0, t2;
  }
  exec(e2, t2) {
    if (!this.allKeys.has(t2.key)) return;
    const i2 = this.callbacks.get(this.#Lt(t2));
    if (!i2) return;
    const { callback: n2, options: { bubbles: a2 = false, args: s2 = [], checker: r2 = null } } = i2;
    r2 && !r2(e2, t2) || (n2.bind(e2, ...s2, t2)(), a2 || stopEvent(t2));
  }
}
class ColorManager {
  static _colorsMapping = /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]);
  get _colors() {
    const e2 = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
    return (function(e3) {
      const t2 = document.createElement("span");
      t2.style.visibility = "hidden", t2.style.colorScheme = "only light", document.body.append(t2);
      for (const i2 of e3.keys()) {
        t2.style.color = i2;
        const n2 = window.getComputedStyle(t2).color;
        e3.set(i2, getRGB(n2));
      }
      t2.remove();
    })(e2), shadow(this, "_colors", e2);
  }
  convert(e2) {
    const t2 = getRGB(e2);
    if (!window.matchMedia("(forced-colors: active)").matches) return t2;
    for (const [e3, i2] of this._colors) if (i2.every((e4, i3) => e4 === t2[i3])) return ColorManager._colorsMapping.get(e3);
    return t2;
  }
  getHexCode(e2) {
    const t2 = this._colors.get(e2);
    return t2 ? Util.makeHexColor(...t2) : e2;
  }
}
class AnnotationEditorUIManager {
  #Ut = new AbortController();
  #jt = null;
  #$t = null;
  #Ht = /* @__PURE__ */ new Map();
  #Xt = /* @__PURE__ */ new Map();
  #qt = null;
  #zt = null;
  #Wt = null;
  #Gt = new CommandManager();
  #Vt = null;
  #Kt = null;
  #Yt = null;
  #Jt = 0;
  #Zt = /* @__PURE__ */ new Set();
  #Qt = null;
  #ei = null;
  #ti = /* @__PURE__ */ new Set();
  _editorUndoBar = null;
  #ii = false;
  #ni = false;
  #ai = false;
  #si = null;
  #ri = null;
  #oi = null;
  #li = null;
  #ci = false;
  #hi = null;
  #di = new IdManager();
  #ui = false;
  #gi = false;
  #fi = false;
  #pi = null;
  #mi = null;
  #bi = null;
  #yi = null;
  #wi = null;
  #Ai = Hl.NONE;
  #xi = /* @__PURE__ */ new Set();
  #Si = null;
  #vi = null;
  #Ci = null;
  #ki = null;
  #Ti = null;
  #Fi = { isEditing: false, isEmpty: true, hasSomethingToUndo: false, hasSomethingToRedo: false, hasSelectedEditor: false, hasSelectedText: false };
  #Ii = [0, 0];
  #Ei = null;
  #Mi = null;
  #Di = null;
  #Oi = null;
  #_i = null;
  static TRANSLATE_SMALL = 1;
  static TRANSLATE_BIG = 10;
  static get _keyboardManager() {
    const e2 = AnnotationEditorUIManager.prototype, arrowChecker = (e3) => e3.#Mi.contains(document.activeElement) && "BUTTON" !== document.activeElement.tagName && e3.hasSomethingToControl(), textInputChecker = (e3, { target: t3 }) => {
      if (t3 instanceof HTMLInputElement) {
        const { type: e4 } = t3;
        return "text" !== e4 && "number" !== e4;
      }
      return true;
    }, t2 = this.TRANSLATE_SMALL, i2 = this.TRANSLATE_BIG;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], e2.selectAll, { checker: textInputChecker }], [["ctrl+z", "mac+meta+z"], e2.undo, { checker: textInputChecker }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], e2.redo, { checker: textInputChecker }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], e2.delete, { checker: textInputChecker }], [["Enter", "mac+Enter"], e2.addNewEditorFromKeyboard, { checker: (e3, { target: t3 }) => !(t3 instanceof HTMLButtonElement) && e3.#Mi.contains(t3) && !e3.isEnterHandled }], [[" ", "mac+ "], e2.addNewEditorFromKeyboard, { checker: (e3, { target: t3 }) => !(t3 instanceof HTMLButtonElement) && e3.#Mi.contains(document.activeElement) }], [["Escape", "mac+Escape"], e2.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], e2.translateSelectedEditors, { args: [-t2, 0], checker: arrowChecker }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e2.translateSelectedEditors, { args: [-i2, 0], checker: arrowChecker }], [["ArrowRight", "mac+ArrowRight"], e2.translateSelectedEditors, { args: [t2, 0], checker: arrowChecker }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e2.translateSelectedEditors, { args: [i2, 0], checker: arrowChecker }], [["ArrowUp", "mac+ArrowUp"], e2.translateSelectedEditors, { args: [0, -t2], checker: arrowChecker }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e2.translateSelectedEditors, { args: [0, -i2], checker: arrowChecker }], [["ArrowDown", "mac+ArrowDown"], e2.translateSelectedEditors, { args: [0, t2], checker: arrowChecker }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e2.translateSelectedEditors, { args: [0, i2], checker: arrowChecker }]]));
  }
  constructor(e2, t2, i2, n2, a2, s2, r2, o2, l2, c2, h2, d2, u2, g2, f2, p2) {
    const m2 = this._signal = this.#Ut.signal;
    this.#Mi = e2, this.#Di = t2, this.#Oi = i2, this.#qt = n2, this.#Vt = a2, this.#vi = s2, this.#Ti = o2, this._eventBus = r2, r2._on("editingaction", this.onEditingAction.bind(this), { signal: m2 }), r2._on("pagechanging", this.onPageChanging.bind(this), { signal: m2 }), r2._on("scalechanging", this.onScaleChanging.bind(this), { signal: m2 }), r2._on("rotationchanging", this.onRotationChanging.bind(this), { signal: m2 }), r2._on("setpreference", this.onSetPreference.bind(this), { signal: m2 }), r2._on("switchannotationeditorparams", (e3) => this.updateParams(e3.type, e3.value), { signal: m2 }), window.addEventListener("pointerdown", () => {
      this.#gi = true;
    }, { capture: true, signal: m2 }), window.addEventListener("pointerup", () => {
      this.#gi = false;
    }, { capture: true, signal: m2 }), this.#Pi(), this.#Ri(), this.#Bi(), this.#zt = o2.annotationStorage, this.#si = o2.filterFactory, this.#Ci = l2, this.#li = c2 || null, this.#ii = h2, this.#ni = d2, this.#ai = u2, this.#wi = g2 || null, this.viewParameters = { realScale: PixelsPerInch.PDF_TO_CSS_UNITS, rotation: 0 }, this.isShiftKeyDown = false, this._editorUndoBar = f2 || null, this._supportsPinchToZoom = false !== p2, a2?.setSidebarUiManager(this);
  }
  destroy() {
    this.#_i?.resolve(), this.#_i = null, this.#Ut?.abort(), this.#Ut = null, this._signal = null;
    for (const e2 of this.#Xt.values()) e2.destroy();
    this.#Xt.clear(), this.#Ht.clear(), this.#ti.clear(), this.#yi?.clear(), this.#jt = null, this.#xi.clear(), this.#Gt.destroy(), this.#qt?.destroy(), this.#Vt?.destroy(), this.#vi?.destroy(), this.#hi?.hide(), this.#hi = null, this.#bi?.destroy(), this.#bi = null, this.#$t = null, this.#ri && (clearTimeout(this.#ri), this.#ri = null), this.#Ei && (clearTimeout(this.#Ei), this.#Ei = null), this._editorUndoBar?.destroy(), this.#Ti = null;
  }
  combinedSignal(e2) {
    return AbortSignal.any([this._signal, e2.signal]);
  }
  get mlManager() {
    return this.#wi;
  }
  get useNewAltTextFlow() {
    return this.#ni;
  }
  get useNewAltTextWhenAddingImage() {
    return this.#ai;
  }
  get hcmFilter() {
    return shadow(this, "hcmFilter", this.#Ci ? this.#si.addHCMFilter(this.#Ci.foreground, this.#Ci.background) : "none");
  }
  get direction() {
    return shadow(this, "direction", getComputedStyle(this.#Mi).direction);
  }
  get _highlightColors() {
    return shadow(this, "_highlightColors", this.#li ? new Map(this.#li.split(",").map((e2) => ((e2 = e2.split("=").map((e3) => e3.trim()))[1] = e2[1].toUpperCase(), e2))) : null);
  }
  get highlightColors() {
    const { _highlightColors: e2 } = this;
    if (!e2) return shadow(this, "highlightColors", null);
    const t2 = /* @__PURE__ */ new Map(), i2 = !!this.#Ci;
    for (const [n2, a2] of e2) {
      const e3 = n2.endsWith("_HCM");
      i2 && e3 ? t2.set(n2.replace("_HCM", ""), a2) : i2 || e3 || t2.set(n2, a2);
    }
    return shadow(this, "highlightColors", t2);
  }
  get highlightColorNames() {
    return shadow(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (e2) => e2.reverse())) : null);
  }
  getNonHCMColor(e2) {
    if (!this._highlightColors) return e2;
    const t2 = this.highlightColorNames.get(e2);
    return this._highlightColors.get(t2) || e2;
  }
  getNonHCMColorName(e2) {
    return this.highlightColorNames.get(e2) || e2;
  }
  setCurrentDrawingSession(e2) {
    e2 ? (this.unselectAll(), this.disableUserSelect(true)) : this.disableUserSelect(false), this.#Yt = e2;
  }
  setMainHighlightColorPicker(e2) {
    this.#bi = e2;
  }
  editAltText(e2, t2 = false) {
    this.#qt?.editAltText(this, e2, t2);
  }
  hasCommentManager() {
    return !!this.#Vt;
  }
  editComment(e2, t2, i2, n2) {
    this.#Vt?.showDialog(this, e2, t2, i2, n2);
  }
  selectComment(e2, t2) {
    const i2 = this.#Xt.get(e2), n2 = i2?.getEditorByUID(t2);
    n2?.toggleComment(true, true);
  }
  updateComment(e2) {
    this.#Vt?.updateComment(e2.getData());
  }
  updatePopupColor(e2) {
    this.#Vt?.updatePopupColor(e2);
  }
  removeComment(e2) {
    this.#Vt?.removeComments([e2.uid]);
  }
  toggleComment(e2, t2, i2 = void 0) {
    this.#Vt?.toggleCommentPopup(e2, t2, i2);
  }
  makeCommentColor(e2, t2) {
    return e2 && this.#Vt?.makeCommentColor(e2, t2) || null;
  }
  getCommentDialogElement() {
    return this.#Vt?.dialogElement || null;
  }
  async waitForEditorsRendered(e2) {
    if (this.#Xt.has(e2 - 1)) return;
    const { resolve: t2, promise: i2 } = Promise.withResolvers(), onEditorsRendered = (i3) => {
      i3.pageNumber === e2 && (this._eventBus._off("editorsrendered", onEditorsRendered), t2());
    };
    this._eventBus.on("editorsrendered", onEditorsRendered), await i2;
  }
  getSignature(e2) {
    this.#vi?.getSignature({ uiManager: this, editor: e2 });
  }
  get signatureManager() {
    return this.#vi;
  }
  switchToMode(e2, t2) {
    this._eventBus.on("annotationeditormodechanged", t2, { once: true, signal: this._signal }), this._eventBus.dispatch("showannotationeditorui", { source: this, mode: e2 });
  }
  setPreference(e2, t2) {
    this._eventBus.dispatch("setpreference", { source: this, name: e2, value: t2 });
  }
  onSetPreference({ name: e2, value: t2 }) {
    if ("enableNewAltTextWhenAddingImage" === e2) this.#ai = t2;
  }
  onPageChanging({ pageNumber: e2 }) {
    this.#Jt = e2 - 1;
  }
  focusMainContainer() {
    this.#Mi.focus();
  }
  findParent(e2, t2) {
    for (const i2 of this.#Xt.values()) {
      const { x: n2, y: a2, width: s2, height: r2 } = i2.div.getBoundingClientRect();
      if (e2 >= n2 && e2 <= n2 + s2 && t2 >= a2 && t2 <= a2 + r2) return i2;
    }
    return null;
  }
  disableUserSelect(e2 = false) {
    this.#Di.classList.toggle("noUserSelect", e2);
  }
  addShouldRescale(e2) {
    this.#ti.add(e2);
  }
  removeShouldRescale(e2) {
    this.#ti.delete(e2);
  }
  onScaleChanging({ scale: e2 }) {
    this.commitOrRemove(), this.viewParameters.realScale = e2 * PixelsPerInch.PDF_TO_CSS_UNITS;
    for (const e3 of this.#ti) e3.onScaleChanging();
    this.#Yt?.onScaleChanging();
  }
  onRotationChanging({ pagesRotation: e2 }) {
    this.commitOrRemove(), this.viewParameters.rotation = e2;
  }
  #Ni({ anchorNode: e2 }) {
    return e2.nodeType === Node.TEXT_NODE ? e2.parentElement : e2;
  }
  #Li(e2) {
    const { currentLayer: t2 } = this;
    if (t2.hasTextLayer(e2)) return t2;
    for (const t3 of this.#Xt.values()) if (t3.hasTextLayer(e2)) return t3;
    return null;
  }
  highlightSelection(e2 = "", t2 = false) {
    const i2 = document.getSelection();
    if (!i2 || i2.isCollapsed) return;
    const { anchorNode: n2, anchorOffset: a2, focusNode: s2, focusOffset: r2 } = i2, o2 = i2.toString(), l2 = this.#Ni(i2).closest(".textLayer"), c2 = this.getSelectionBoxes(l2);
    if (!c2) return;
    i2.empty();
    const h2 = this.#Li(l2), d2 = this.#Ai === Hl.NONE, callback = () => {
      const i3 = h2?.createAndAddNewEditor({ x: 0, y: 0 }, false, { methodOfCreation: e2, boxes: c2, anchorNode: n2, anchorOffset: a2, focusNode: s2, focusOffset: r2, text: o2 });
      d2 && this.showAllEditors("highlight", true, true), t2 && i3?.editComment();
    };
    d2 ? this.switchToMode(Hl.HIGHLIGHT, callback) : callback();
  }
  commentSelection(e2 = "") {
    this.highlightSelection(e2, true);
  }
  #Ui() {
    const e2 = document.getSelection();
    if (!e2 || e2.isCollapsed) return;
    const t2 = this.#Ni(e2).closest(".textLayer"), i2 = this.getSelectionBoxes(t2);
    i2 && (this.#hi ||= new FloatingToolbar(this), this.#hi.show(t2, i2, "ltr" === this.direction));
  }
  getAndRemoveDataFromAnnotationStorage(e2) {
    if (!this.#zt) return null;
    const t2 = `${$l}${e2}`, i2 = this.#zt.getRawValue(t2);
    return i2 && this.#zt.remove(t2), i2;
  }
  addToAnnotationStorage(e2) {
    e2.isEmpty() || !this.#zt || this.#zt.has(e2.id) || this.#zt.setValue(e2.id, e2);
  }
  a11yAlert(e2, t2 = null) {
    const i2 = this.#Oi;
    i2 && (i2.setAttribute("data-l10n-id", e2), t2 ? i2.setAttribute("data-l10n-args", JSON.stringify(t2)) : i2.removeAttribute("data-l10n-args"));
  }
  #ji() {
    const e2 = document.getSelection();
    if (!e2 || e2.isCollapsed) return void (this.#Si && (this.#hi?.hide(), this.#Si = null, this.#$i({ hasSelectedText: false })));
    const { anchorNode: t2 } = e2;
    if (t2 === this.#Si) return;
    const i2 = this.#Ni(e2).closest(".textLayer");
    if (i2) {
      if (this.#hi?.hide(), this.#Si = t2, this.#$i({ hasSelectedText: true }), (this.#Ai === Hl.HIGHLIGHT || this.#Ai === Hl.NONE) && (this.#Ai === Hl.HIGHLIGHT && this.showAllEditors("highlight", true, true), this.#ci = this.isShiftKeyDown, !this.isShiftKeyDown)) {
        const e3 = this.#Ai === Hl.HIGHLIGHT ? this.#Li(i2) : null;
        if (e3?.toggleDrawing(), this.#gi) {
          const t3 = new AbortController(), i3 = this.combinedSignal(t3), pointerup = (i4) => {
            "pointerup" === i4.type && 0 !== i4.button || (t3.abort(), e3?.toggleDrawing(true), "pointerup" === i4.type && this.#Hi("main_toolbar"));
          };
          window.addEventListener("pointerup", pointerup, { signal: i3 }), window.addEventListener("blur", pointerup, { signal: i3 });
        } else e3?.toggleDrawing(true), this.#Hi("main_toolbar");
      }
    } else this.#Si && (this.#hi?.hide(), this.#Si = null, this.#$i({ hasSelectedText: false }));
  }
  #Hi(e2 = "") {
    this.#Ai === Hl.HIGHLIGHT ? this.highlightSelection(e2) : this.#ii && this.#Ui();
  }
  #Pi() {
    document.addEventListener("selectionchange", this.#ji.bind(this), { signal: this._signal });
  }
  #Xi() {
    if (this.#oi) return;
    this.#oi = new AbortController();
    const e2 = this.combinedSignal(this.#oi);
    window.addEventListener("focus", this.focus.bind(this), { signal: e2 }), window.addEventListener("blur", this.blur.bind(this), { signal: e2 });
  }
  #qi() {
    this.#oi?.abort(), this.#oi = null;
  }
  blur() {
    if (this.isShiftKeyDown = false, this.#ci && (this.#ci = false, this.#Hi("main_toolbar")), !this.hasSelection) return;
    const { activeElement: e2 } = document;
    for (const t2 of this.#xi) if (t2.div.contains(e2)) {
      this.#mi = [t2, e2], t2._focusEventsAllowed = false;
      break;
    }
  }
  focus() {
    if (!this.#mi) return;
    const [e2, t2] = this.#mi;
    this.#mi = null, t2.addEventListener("focusin", () => {
      e2._focusEventsAllowed = true;
    }, { once: true, signal: this._signal }), t2.focus();
  }
  #Bi() {
    if (this.#pi) return;
    this.#pi = new AbortController();
    const e2 = this.combinedSignal(this.#pi);
    window.addEventListener("keydown", this.keydown.bind(this), { signal: e2 }), window.addEventListener("keyup", this.keyup.bind(this), { signal: e2 });
  }
  #zi() {
    this.#pi?.abort(), this.#pi = null;
  }
  #Wi() {
    if (this.#Kt) return;
    this.#Kt = new AbortController();
    const e2 = this.combinedSignal(this.#Kt);
    document.addEventListener("copy", this.copy.bind(this), { signal: e2 }), document.addEventListener("cut", this.cut.bind(this), { signal: e2 }), document.addEventListener("paste", this.paste.bind(this), { signal: e2 });
  }
  #Gi() {
    this.#Kt?.abort(), this.#Kt = null;
  }
  #Ri() {
    const e2 = this._signal;
    document.addEventListener("dragover", this.dragOver.bind(this), { signal: e2 }), document.addEventListener("drop", this.drop.bind(this), { signal: e2 });
  }
  addEditListeners() {
    this.#Bi(), this.#Wi();
  }
  removeEditListeners() {
    this.#zi(), this.#Gi();
  }
  dragOver(e2) {
    for (const { type: t2 } of e2.dataTransfer.items) for (const i2 of this.#ei) if (i2.isHandlingMimeForPasting(t2)) return e2.dataTransfer.dropEffect = "copy", void e2.preventDefault();
  }
  drop(e2) {
    for (const t2 of e2.dataTransfer.items) for (const i2 of this.#ei) if (i2.isHandlingMimeForPasting(t2.type)) return i2.paste(t2, this.currentLayer), void e2.preventDefault();
  }
  copy(e2) {
    if (e2.preventDefault(), this.#jt?.commitOrRemove(), !this.hasSelection) return;
    const t2 = [];
    for (const e3 of this.#xi) {
      const i2 = e3.serialize(true);
      i2 && t2.push(i2);
    }
    0 !== t2.length && e2.clipboardData.setData("application/pdfjs", JSON.stringify(t2));
  }
  cut(e2) {
    this.copy(e2), this.delete();
  }
  async paste(e2) {
    e2.preventDefault();
    const { clipboardData: t2 } = e2;
    for (const e3 of t2.items) for (const t3 of this.#ei) if (t3.isHandlingMimeForPasting(e3.type)) return void t3.paste(e3, this.currentLayer);
    let i2 = t2.getData("application/pdfjs");
    if (!i2) return;
    try {
      i2 = JSON.parse(i2);
    } catch (e3) {
      return void warn(`paste: "${e3.message}".`);
    }
    if (!Array.isArray(i2)) return;
    this.unselectAll();
    const n2 = this.currentLayer;
    try {
      const e3 = [];
      for (const t3 of i2) {
        const i3 = await n2.deserialize(t3);
        if (!i3) return;
        e3.push(i3);
      }
      const cmd = () => {
        for (const t3 of e3) this.#Vi(t3);
        this.#Ki(e3);
      }, undo = () => {
        for (const t3 of e3) t3.remove();
      };
      this.addCommands({ cmd, undo, mustExec: true });
    } catch (e3) {
      warn(`paste: "${e3.message}".`);
    }
  }
  keydown(e2) {
    this.isShiftKeyDown || "Shift" !== e2.key || (this.isShiftKeyDown = true), this.#Ai === Hl.NONE || this.isEditorHandlingKeyboard || AnnotationEditorUIManager._keyboardManager.exec(this, e2);
  }
  keyup(e2) {
    this.isShiftKeyDown && "Shift" === e2.key && (this.isShiftKeyDown = false, this.#ci && (this.#ci = false, this.#Hi("main_toolbar")));
  }
  onEditingAction({ name: e2 }) {
    switch (e2) {
      case "undo":
      case "redo":
      case "delete":
      case "selectAll":
        this[e2]();
        break;
      case "highlightSelection":
        this.highlightSelection("context_menu");
        break;
      case "commentSelection":
        this.commentSelection("context_menu");
    }
  }
  #$i(e2) {
    Object.entries(e2).some(([e3, t2]) => this.#Fi[e3] !== t2) && (this._eventBus.dispatch("annotationeditorstateschanged", { source: this, details: Object.assign(this.#Fi, e2) }), this.#Ai === Hl.HIGHLIGHT && false === e2.hasSelectedEditor && this.#Yi([[Xl.HIGHLIGHT_FREE, true]]));
  }
  #Yi(e2) {
    this._eventBus.dispatch("annotationeditorparamschanged", { source: this, details: e2 });
  }
  setEditingState(e2) {
    e2 ? (this.#Xi(), this.#Wi(), this.#$i({ isEditing: this.#Ai !== Hl.NONE, isEmpty: this.#Ji(), hasSomethingToUndo: this.#Gt.hasSomethingToUndo(), hasSomethingToRedo: this.#Gt.hasSomethingToRedo(), hasSelectedEditor: false })) : (this.#qi(), this.#Gi(), this.#$i({ isEditing: false }), this.disableUserSelect(false));
  }
  registerEditorTypes(e2) {
    if (!this.#ei) {
      this.#ei = e2;
      for (const e3 of this.#ei) this.#Yi(e3.defaultPropertiesToUpdate);
    }
  }
  getId() {
    return this.#di.id;
  }
  get currentLayer() {
    return this.#Xt.get(this.#Jt);
  }
  getLayer(e2) {
    return this.#Xt.get(e2);
  }
  get currentPageIndex() {
    return this.#Jt;
  }
  addLayer(e2) {
    this.#Xt.set(e2.pageIndex, e2), this.#ui ? e2.enable() : e2.disable();
  }
  removeLayer(e2) {
    this.#Xt.delete(e2.pageIndex);
  }
  async updateMode(e2, t2 = null, i2 = false, n2 = false, a2 = false) {
    if (this.#Ai !== e2 && (!this.#_i || (await this.#_i.promise, this.#_i))) {
      if (this.#_i = Promise.withResolvers(), this.#Yt?.commitOrRemove(), this.#Ai === Hl.POPUP && this.#Vt?.hideSidebar(), this.#Vt?.destroyPopup(), this.#Ai = e2, e2 === Hl.NONE) {
        this.setEditingState(false), this.#Zi();
        for (const e3 of this.#Ht.values()) e3.hideStandaloneCommentButton();
        return this._editorUndoBar?.hide(), this.toggleComment(null), void this.#_i.resolve();
      }
      for (const e3 of this.#Ht.values()) e3.addStandaloneCommentButton();
      e2 === Hl.SIGNATURE && await this.#vi?.loadSignatures(), this.setEditingState(true), await this.#Qi(), this.unselectAll();
      for (const t3 of this.#Xt.values()) t3.updateMode(e2);
      if (e2 === Hl.POPUP) {
        this.#$t ||= await this.#Ti.getAnnotationsByType(new Set(this.#ei.map((e4) => e4._editorType)));
        const e3 = /* @__PURE__ */ new Set(), t3 = [];
        for (const i3 of this.#Ht.values()) {
          const { annotationElementId: n3, hasComment: a3, deleted: s2 } = i3;
          n3 && e3.add(n3), a3 && !s2 && t3.push(i3.getData());
        }
        for (const i3 of this.#$t) {
          const { id: n3, popupRef: a3, contentsObj: s2 } = i3;
          a3 && s2?.str && !e3.has(n3) && !this.#Zt.has(n3) && t3.push(i3);
        }
        this.#Vt?.showSidebar(t3);
      }
      if (!t2) return i2 && this.addNewEditorFromKeyboard(), void this.#_i.resolve();
      for (const e3 of this.#Ht.values()) e3.uid === t2 ? (this.setSelected(e3), a2 ? e3.editComment() : n2 ? e3.enterInEditMode() : e3.focus()) : e3.unselect();
      this.#_i.resolve();
    }
  }
  addNewEditorFromKeyboard() {
    this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor();
  }
  updateToolbar(e2) {
    e2.mode !== this.#Ai && this._eventBus.dispatch("switchannotationeditormode", { source: this, ...e2 });
  }
  updateParams(e2, t2) {
    if (this.#ei) {
      switch (e2) {
        case Xl.CREATE:
          return void this.currentLayer.addNewEditor(t2);
        case Xl.HIGHLIGHT_SHOW_ALL:
          this._eventBus.dispatch("reporttelemetry", { source: this, details: { type: "editing", data: { type: "highlight", action: "toggle_visibility" } } }), (this.#ki ||= /* @__PURE__ */ new Map()).set(e2, t2), this.showAllEditors("highlight", t2);
      }
      if (this.hasSelection) for (const i2 of this.#xi) i2.updateParams(e2, t2);
      else for (const i2 of this.#ei) i2.updateDefaultParams(e2, t2);
    }
  }
  showAllEditors(e2, t2, i2 = false) {
    for (const i3 of this.#Ht.values()) i3.editorType === e2 && i3.show(t2);
    (this.#ki?.get(Xl.HIGHLIGHT_SHOW_ALL) ?? true) !== t2 && this.#Yi([[Xl.HIGHLIGHT_SHOW_ALL, t2]]);
  }
  enableWaiting(e2 = false) {
    if (this.#fi !== e2) {
      this.#fi = e2;
      for (const t2 of this.#Xt.values()) e2 ? t2.disableClick() : t2.enableClick(), t2.div.classList.toggle("waiting", e2);
    }
  }
  async #Qi() {
    if (!this.#ui) {
      this.#ui = true;
      const e2 = [];
      for (const t2 of this.#Xt.values()) e2.push(t2.enable());
      await Promise.all(e2);
      for (const e3 of this.#Ht.values()) e3.enable();
    }
  }
  #Zi() {
    if (this.unselectAll(), this.#ui) {
      this.#ui = false;
      for (const e2 of this.#Xt.values()) e2.disable();
      for (const e2 of this.#Ht.values()) e2.disable();
    }
  }
  *getEditors(e2) {
    for (const t2 of this.#Ht.values()) t2.pageIndex === e2 && (yield t2);
  }
  getEditor(e2) {
    return this.#Ht.get(e2);
  }
  addEditor(e2) {
    this.#Ht.set(e2.id, e2);
  }
  removeEditor(e2) {
    e2.div.contains(document.activeElement) && (this.#ri && clearTimeout(this.#ri), this.#ri = setTimeout(() => {
      this.focusMainContainer(), this.#ri = null;
    }, 0)), this.#Ht.delete(e2.id), e2.annotationElementId && this.#yi?.delete(e2.annotationElementId), this.unselect(e2), e2.annotationElementId && this.#Zt.has(e2.annotationElementId) || this.#zt?.remove(e2.id);
  }
  addDeletedAnnotationElement(e2) {
    this.#Zt.add(e2.annotationElementId), this.addChangedExistingAnnotation(e2), e2.deleted = true;
  }
  isDeletedAnnotationElement(e2) {
    return this.#Zt.has(e2);
  }
  removeDeletedAnnotationElement(e2) {
    this.#Zt.delete(e2.annotationElementId), this.removeChangedExistingAnnotation(e2), e2.deleted = false;
  }
  #Vi(e2) {
    const t2 = this.#Xt.get(e2.pageIndex);
    t2 ? t2.addOrRebuild(e2) : (this.addEditor(e2), this.addToAnnotationStorage(e2));
  }
  setActiveEditor(e2) {
    this.#jt !== e2 && (this.#jt = e2, e2 && this.#Yi(e2.propertiesToUpdate));
  }
  get #en() {
    let e2 = null;
    for (e2 of this.#xi) ;
    return e2;
  }
  updateUI(e2) {
    this.#en === e2 && this.#Yi(e2.propertiesToUpdate);
  }
  updateUIForDefaultProperties(e2) {
    this.#Yi(e2.defaultPropertiesToUpdate);
  }
  toggleSelected(e2) {
    if (this.#xi.has(e2)) return this.#xi.delete(e2), e2.unselect(), void this.#$i({ hasSelectedEditor: this.hasSelection });
    this.#xi.add(e2), e2.select(), this.#Yi(e2.propertiesToUpdate), this.#$i({ hasSelectedEditor: true });
  }
  setSelected(e2) {
    this.updateToolbar({ mode: e2.mode, editId: e2.id }), this.#Yt?.commitOrRemove();
    for (const t2 of this.#xi) t2 !== e2 && t2.unselect();
    this.#xi.clear(), this.#xi.add(e2), e2.select(), this.#Yi(e2.propertiesToUpdate), this.#$i({ hasSelectedEditor: true });
  }
  isSelected(e2) {
    return this.#xi.has(e2);
  }
  get firstSelectedEditor() {
    return this.#xi.values().next().value;
  }
  unselect(e2) {
    e2.unselect(), this.#xi.delete(e2), this.#$i({ hasSelectedEditor: this.hasSelection });
  }
  get hasSelection() {
    return 0 !== this.#xi.size;
  }
  get isEnterHandled() {
    return 1 === this.#xi.size && this.firstSelectedEditor.isEnterHandled;
  }
  undo() {
    this.#Gt.undo(), this.#$i({ hasSomethingToUndo: this.#Gt.hasSomethingToUndo(), hasSomethingToRedo: true, isEmpty: this.#Ji() }), this._editorUndoBar?.hide();
  }
  redo() {
    this.#Gt.redo(), this.#$i({ hasSomethingToUndo: true, hasSomethingToRedo: this.#Gt.hasSomethingToRedo(), isEmpty: this.#Ji() });
  }
  addCommands(e2) {
    this.#Gt.add(e2), this.#$i({ hasSomethingToUndo: true, hasSomethingToRedo: false, isEmpty: this.#Ji() });
  }
  cleanUndoStack(e2) {
    this.#Gt.cleanType(e2);
  }
  #Ji() {
    if (0 === this.#Ht.size) return true;
    if (1 === this.#Ht.size) for (const e2 of this.#Ht.values()) return e2.isEmpty();
    return false;
  }
  delete() {
    this.commitOrRemove();
    const e2 = this.currentLayer?.endDrawingSession(true);
    if (!this.hasSelection && !e2) return;
    const t2 = e2 ? [e2] : [...this.#xi], undo = () => {
      for (const e3 of t2) this.#Vi(e3);
    };
    this.addCommands({ cmd: () => {
      this._editorUndoBar?.show(undo, 1 === t2.length ? t2[0].editorType : t2.length);
      for (const e3 of t2) e3.remove();
    }, undo, mustExec: true });
  }
  commitOrRemove() {
    this.#jt?.commitOrRemove();
  }
  hasSomethingToControl() {
    return this.#jt || this.hasSelection;
  }
  #Ki(e2) {
    for (const e3 of this.#xi) e3.unselect();
    this.#xi.clear();
    for (const t2 of e2) t2.isEmpty() || (this.#xi.add(t2), t2.select());
    this.#$i({ hasSelectedEditor: this.hasSelection });
  }
  selectAll() {
    for (const e2 of this.#xi) e2.commit();
    this.#Ki(this.#Ht.values());
  }
  unselectAll() {
    if ((!this.#jt || (this.#jt.commitOrRemove(), this.#Ai === Hl.NONE)) && !this.#Yt?.commitOrRemove() && this.hasSelection) {
      for (const e2 of this.#xi) e2.unselect();
      this.#xi.clear(), this.#$i({ hasSelectedEditor: false });
    }
  }
  translateSelectedEditors(e2, t2, i2 = false) {
    if (i2 || this.commitOrRemove(), !this.hasSelection) return;
    this.#Ii[0] += e2, this.#Ii[1] += t2;
    const [n2, a2] = this.#Ii, s2 = [...this.#xi];
    this.#Ei && clearTimeout(this.#Ei), this.#Ei = setTimeout(() => {
      this.#Ei = null, this.#Ii[0] = this.#Ii[1] = 0, this.addCommands({ cmd: () => {
        for (const e3 of s2) this.#Ht.has(e3.id) && (e3.translateInPage(n2, a2), e3.translationDone());
      }, undo: () => {
        for (const e3 of s2) this.#Ht.has(e3.id) && (e3.translateInPage(-n2, -a2), e3.translationDone());
      }, mustExec: false });
    }, 1e3);
    for (const i3 of s2) i3.translateInPage(e2, t2), i3.translationDone();
  }
  setUpDragSession() {
    if (this.hasSelection) {
      this.disableUserSelect(true), this.#Qt = /* @__PURE__ */ new Map();
      for (const e2 of this.#xi) this.#Qt.set(e2, { savedX: e2.x, savedY: e2.y, savedPageIndex: e2.pageIndex, newX: 0, newY: 0, newPageIndex: -1 });
    }
  }
  endDragSession() {
    if (!this.#Qt) return false;
    this.disableUserSelect(false);
    const e2 = this.#Qt;
    this.#Qt = null;
    let t2 = false;
    for (const [{ x: i2, y: n2, pageIndex: a2 }, s2] of e2) s2.newX = i2, s2.newY = n2, s2.newPageIndex = a2, t2 ||= i2 !== s2.savedX || n2 !== s2.savedY || a2 !== s2.savedPageIndex;
    if (!t2) return false;
    const move = (e3, t3, i2, n2) => {
      if (this.#Ht.has(e3.id)) {
        const a2 = this.#Xt.get(n2);
        a2 ? e3._setParentAndPosition(a2, t3, i2) : (e3.pageIndex = n2, e3.x = t3, e3.y = i2);
      }
    };
    return this.addCommands({ cmd: () => {
      for (const [t3, { newX: i2, newY: n2, newPageIndex: a2 }] of e2) move(t3, i2, n2, a2);
    }, undo: () => {
      for (const [t3, { savedX: i2, savedY: n2, savedPageIndex: a2 }] of e2) move(t3, i2, n2, a2);
    }, mustExec: true }), true;
  }
  dragSelectedEditors(e2, t2) {
    if (this.#Qt) for (const i2 of this.#Qt.keys()) i2.drag(e2, t2);
  }
  rebuild(e2) {
    if (null === e2.parent) {
      const t2 = this.getLayer(e2.pageIndex);
      t2 ? (t2.changeParent(e2), t2.addOrRebuild(e2)) : (this.addEditor(e2), this.addToAnnotationStorage(e2), e2.rebuild());
    } else e2.parent.addOrRebuild(e2);
  }
  get isEditorHandlingKeyboard() {
    return this.getActive()?.shouldGetKeyboardEvents() || 1 === this.#xi.size && this.firstSelectedEditor.shouldGetKeyboardEvents();
  }
  isActive(e2) {
    return this.#jt === e2;
  }
  getActive() {
    return this.#jt;
  }
  getMode() {
    return this.#Ai;
  }
  isEditingMode() {
    return this.#Ai !== Hl.NONE;
  }
  get imageManager() {
    return shadow(this, "imageManager", new ImageManager());
  }
  getSelectionBoxes(e2) {
    if (!e2) return null;
    const t2 = document.getSelection();
    for (let i3 = 0, n3 = t2.rangeCount; i3 < n3; i3++) if (!e2.contains(t2.getRangeAt(i3).commonAncestorContainer)) return null;
    const { x: i2, y: n2, width: a2, height: s2 } = e2.getBoundingClientRect();
    let r2;
    switch (e2.getAttribute("data-main-rotation")) {
      case "90":
        r2 = (e3, t3, r3, o3) => ({ x: (t3 - n2) / s2, y: 1 - (e3 + r3 - i2) / a2, width: o3 / s2, height: r3 / a2 });
        break;
      case "180":
        r2 = (e3, t3, r3, o3) => ({ x: 1 - (e3 + r3 - i2) / a2, y: 1 - (t3 + o3 - n2) / s2, width: r3 / a2, height: o3 / s2 });
        break;
      case "270":
        r2 = (e3, t3, r3, o3) => ({ x: 1 - (t3 + o3 - n2) / s2, y: (e3 - i2) / a2, width: o3 / s2, height: r3 / a2 });
        break;
      default:
        r2 = (e3, t3, r3, o3) => ({ x: (e3 - i2) / a2, y: (t3 - n2) / s2, width: r3 / a2, height: o3 / s2 });
    }
    const o2 = [];
    for (let e3 = 0, i3 = t2.rangeCount; e3 < i3; e3++) {
      const i4 = t2.getRangeAt(e3);
      if (!i4.collapsed) for (const { x: e4, y: t3, width: n3, height: a3 } of i4.getClientRects()) 0 !== n3 && 0 !== a3 && o2.push(r2(e4, t3, n3, a3));
    }
    return 0 === o2.length ? null : o2;
  }
  addChangedExistingAnnotation({ annotationElementId: e2, id: t2 }) {
    (this.#Wt ||= /* @__PURE__ */ new Map()).set(e2, t2);
  }
  removeChangedExistingAnnotation({ annotationElementId: e2 }) {
    this.#Wt?.delete(e2);
  }
  renderAnnotationElement(e2) {
    const t2 = this.#Wt?.get(e2.data.id);
    if (!t2) return;
    const i2 = this.#zt.getRawValue(t2);
    i2 && (this.#Ai !== Hl.NONE || i2.hasBeenModified) && i2.renderAnnotationElement(e2);
  }
  setMissingCanvas(e2, t2, i2) {
    const n2 = this.#yi?.get(e2);
    n2 && (n2.setCanvas(t2, i2), this.#yi.delete(e2));
  }
  addMissingCanvas(e2, t2) {
    (this.#yi ||= /* @__PURE__ */ new Map()).set(e2, t2);
  }
}
class AltText {
  #mt = null;
  #tn = false;
  #in = null;
  #nn = null;
  #an = null;
  #sn = null;
  #rn = false;
  #on = null;
  #ft = null;
  #ln = null;
  #cn = null;
  #hn = false;
  static #dn = null;
  static _l10n = null;
  constructor(e2) {
    this.#ft = e2, this.#hn = e2._uiManager.useNewAltTextFlow, AltText.#dn ||= Object.freeze({ added: "pdfjs-editor-new-alt-text-added-button", "added-label": "pdfjs-editor-new-alt-text-added-button-label", missing: "pdfjs-editor-new-alt-text-missing-button", "missing-label": "pdfjs-editor-new-alt-text-missing-button-label", review: "pdfjs-editor-new-alt-text-to-review-button", "review-label": "pdfjs-editor-new-alt-text-to-review-button-label" });
  }
  static initialize(e2) {
    AltText._l10n ??= e2;
  }
  async render() {
    const e2 = this.#in = document.createElement("button");
    e2.className = "altText", e2.tabIndex = "0";
    const t2 = this.#nn = document.createElement("span");
    e2.append(t2), this.#hn ? (e2.classList.add("new"), e2.setAttribute("data-l10n-id", AltText.#dn.missing), t2.setAttribute("data-l10n-id", AltText.#dn["missing-label"])) : (e2.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button"), t2.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button-label"));
    const i2 = this.#ft._uiManager._signal;
    e2.addEventListener("contextmenu", noContextMenu, { signal: i2 }), e2.addEventListener("pointerdown", (e3) => e3.stopPropagation(), { signal: i2 });
    const onClick = (e3) => {
      e3.preventDefault(), this.#ft._uiManager.editAltText(this.#ft), this.#hn && this.#ft._reportTelemetry({ action: "pdfjs.image.alt_text.image_status_label_clicked", data: { label: this.#un } });
    };
    return e2.addEventListener("click", onClick, { capture: true, signal: i2 }), e2.addEventListener("keydown", (t3) => {
      t3.target === e2 && "Enter" === t3.key && (this.#rn = true, onClick(t3));
    }, { signal: i2 }), await this.#gn(), e2;
  }
  get #un() {
    return (this.#mt ? "added" : null === this.#mt && this.guessedText && "review") || "missing";
  }
  finish() {
    this.#in && (this.#in.focus({ focusVisible: this.#rn }), this.#rn = false);
  }
  isEmpty() {
    return this.#hn ? null === this.#mt : !this.#mt && !this.#tn;
  }
  hasData() {
    return this.#hn ? null !== this.#mt || !!this.#ln : this.isEmpty();
  }
  get guessedText() {
    return this.#ln;
  }
  async setGuessedText(e2) {
    null === this.#mt && (this.#ln = e2, this.#cn = await AltText._l10n.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer", { generatedAltText: e2 }), this.#gn());
  }
  toggleAltTextBadge(e2 = false) {
    if (!this.#hn || this.#mt) return this.#on?.remove(), void (this.#on = null);
    if (!this.#on) {
      const e3 = this.#on = document.createElement("div");
      e3.className = "noAltTextBadge", this.#ft.div.append(e3);
    }
    this.#on.classList.toggle("hidden", !e2);
  }
  serialize(e2) {
    let t2 = this.#mt;
    return e2 || this.#ln !== t2 || (t2 = this.#cn), { altText: t2, decorative: this.#tn, guessedText: this.#ln, textWithDisclaimer: this.#cn };
  }
  get data() {
    return { altText: this.#mt, decorative: this.#tn };
  }
  set data({ altText: e2, decorative: t2, guessedText: i2, textWithDisclaimer: n2, cancel: a2 = false }) {
    i2 && (this.#ln = i2, this.#cn = n2), this.#mt === e2 && this.#tn === t2 || (a2 || (this.#mt = e2, this.#tn = t2), this.#gn());
  }
  toggle(e2 = false) {
    this.#in && (!e2 && this.#sn && (clearTimeout(this.#sn), this.#sn = null), this.#in.disabled = !e2);
  }
  shown() {
    this.#ft._reportTelemetry({ action: "pdfjs.image.alt_text.image_status_label_displayed", data: { label: this.#un } });
  }
  destroy() {
    this.#in?.remove(), this.#in = null, this.#nn = null, this.#an = null, this.#on?.remove(), this.#on = null;
  }
  async #gn() {
    const e2 = this.#in;
    if (!e2) return;
    if (this.#hn) {
      if (e2.classList.toggle("done", !!this.#mt), e2.setAttribute("data-l10n-id", AltText.#dn[this.#un]), this.#nn?.setAttribute("data-l10n-id", AltText.#dn[`${this.#un}-label`]), !this.#mt) return void this.#an?.remove();
    } else {
      if (!this.#mt && !this.#tn) return e2.classList.remove("done"), void this.#an?.remove();
      e2.classList.add("done"), e2.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-edit-button");
    }
    let t2 = this.#an;
    if (!t2) {
      this.#an = t2 = document.createElement("span"), t2.className = "tooltip", t2.setAttribute("role", "tooltip"), t2.id = `alt-text-tooltip-${this.#ft.id}`;
      const i3 = 100, n2 = this.#ft._uiManager._signal;
      n2.addEventListener("abort", () => {
        clearTimeout(this.#sn), this.#sn = null;
      }, { once: true }), e2.addEventListener("mouseenter", () => {
        this.#sn = setTimeout(() => {
          this.#sn = null, this.#an.classList.add("show"), this.#ft._reportTelemetry({ action: "alt_text_tooltip" });
        }, i3);
      }, { signal: n2 }), e2.addEventListener("mouseleave", () => {
        this.#sn && (clearTimeout(this.#sn), this.#sn = null), this.#an?.classList.remove("show");
      }, { signal: n2 });
    }
    this.#tn ? t2.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-decorative-tooltip") : (t2.removeAttribute("data-l10n-id"), t2.textContent = this.#mt), t2.parentNode || e2.append(t2);
    const i2 = this.#ft.getElementForAltText();
    i2?.setAttribute("aria-describedby", t2.id);
  }
}
class Comment {
  #fn = null;
  #pn = null;
  #mn = false;
  #ft = null;
  #bn = null;
  #yn = null;
  #_e = null;
  #wn = null;
  #An = false;
  #xn = null;
  constructor(e2) {
    this.#ft = e2;
  }
  renderForToolbar() {
    const e2 = this.#pn = document.createElement("button");
    return e2.className = "comment", this.#Ft(e2, false);
  }
  renderForStandalone() {
    const e2 = this.#fn = document.createElement("button");
    e2.className = "annotationCommentButton";
    const t2 = this.#ft.commentButtonPosition;
    if (t2) {
      const { style: i2 } = e2;
      i2.insetInlineEnd = `calc(${100 * ("ltr" === this.#ft._uiManager.direction ? 1 - t2[0] : t2[0])}% - var(--comment-button-dim))`, i2.top = `calc(${100 * t2[1]}% - var(--comment-button-dim))`;
      const n2 = this.#ft.commentButtonColor;
      n2 && (i2.backgroundColor = n2);
    }
    return this.#Ft(e2, true);
  }
  focusButton() {
    setTimeout(() => {
      (this.#fn ?? this.#pn)?.focus();
    }, 0);
  }
  onUpdatedColor() {
    if (!this.#fn) return;
    const e2 = this.#ft.commentButtonColor;
    e2 && (this.#fn.style.backgroundColor = e2), this.#ft._uiManager.updatePopupColor(this.#ft);
  }
  get commentButtonWidth() {
    return (this.#fn?.getBoundingClientRect().width ?? 0) / this.#ft.parent.boundingClientRect.width;
  }
  get commentPopupPositionInLayer() {
    if (this.#xn) return this.#xn;
    if (!this.#fn) return null;
    const { x: e2, y: t2, height: i2 } = this.#fn.getBoundingClientRect(), { x: n2, y: a2, width: s2, height: r2 } = this.#ft.parent.boundingClientRect;
    return [(e2 - n2) / s2, (t2 + i2 - a2) / r2];
  }
  set commentPopupPositionInLayer(e2) {
    this.#xn = e2;
  }
  hasDefaultPopupPosition() {
    return null === this.#xn;
  }
  removeStandaloneCommentButton() {
    this.#fn?.remove(), this.#fn = null;
  }
  removeToolbarCommentButton() {
    this.#pn?.remove(), this.#pn = null;
  }
  setCommentButtonStates({ selected: e2, hasPopup: t2 }) {
    this.#fn && (this.#fn.classList.toggle("selected", e2), this.#fn.ariaExpanded = t2);
  }
  #Ft(e2, t2) {
    if (!this.#ft._uiManager.hasCommentManager()) return null;
    e2.tabIndex = "0", e2.ariaHasPopup = "dialog", t2 ? (e2.ariaControls = "commentPopup", e2.setAttribute("data-l10n-id", "pdfjs-show-comment-button")) : (e2.ariaControlsElements = [this.#ft._uiManager.getCommentDialogElement()], e2.setAttribute("data-l10n-id", "pdfjs-editor-edit-comment-button"));
    const i2 = this.#ft._uiManager._signal;
    if (!(i2 instanceof AbortSignal) || i2.aborted) return e2;
    e2.addEventListener("contextmenu", noContextMenu, { signal: i2 }), t2 && (e2.addEventListener("focusin", (e3) => {
      this.#ft._focusEventsAllowed = false, stopEvent(e3);
    }, { capture: true, signal: i2 }), e2.addEventListener("focusout", (e3) => {
      this.#ft._focusEventsAllowed = true, stopEvent(e3);
    }, { capture: true, signal: i2 })), e2.addEventListener("pointerdown", (e3) => e3.stopPropagation(), { signal: i2 });
    const onClick = (t3) => {
      t3.preventDefault(), e2 === this.#pn ? this.edit() : this.#ft.toggleComment(true);
    };
    return e2.addEventListener("click", onClick, { capture: true, signal: i2 }), e2.addEventListener("keydown", (t3) => {
      t3.target === e2 && "Enter" === t3.key && (this.#mn = true, onClick(t3));
    }, { signal: i2 }), e2.addEventListener("pointerenter", () => {
      this.#ft.toggleComment(false, true);
    }, { signal: i2 }), e2.addEventListener("pointerleave", () => {
      this.#ft.toggleComment(false, false);
    }, { signal: i2 }), e2;
  }
  edit(e2) {
    const t2 = this.commentPopupPositionInLayer;
    let i2, n2;
    if (t2) [i2, n2] = t2;
    else {
      [i2, n2] = this.#ft.commentButtonPosition;
      const { width: e3, height: t3, x: a3, y: s3 } = this.#ft;
      i2 = a3 + i2 * e3, n2 = s3 + n2 * t3;
    }
    const a2 = this.#ft.parent.boundingClientRect, { x: s2, y: r2, width: o2, height: l2 } = a2;
    this.#ft._uiManager.editComment(this.#ft, s2 + i2 * o2, r2 + n2 * l2, { ...e2, parentDimensions: a2 });
  }
  finish() {
    this.#pn && (this.#pn.focus({ focusVisible: this.#mn }), this.#mn = false);
  }
  isDeleted() {
    return this.#An || "" === this.#_e;
  }
  isEmpty() {
    return null === this.#_e;
  }
  hasBeenEdited() {
    return this.isDeleted() || this.#_e !== this.#bn;
  }
  serialize() {
    return this.data;
  }
  get data() {
    return { text: this.#_e, richText: this.#yn, date: this.#wn, deleted: this.isDeleted() };
  }
  set data(e2) {
    if (e2 !== this.#_e && (this.#yn = null), null === e2) return this.#_e = "", void (this.#An = true);
    this.#_e = e2, this.#wn = /* @__PURE__ */ new Date(), this.#An = false;
  }
  setInitialText(e2, t2 = null) {
    this.#bn = e2, this.data = e2, this.#wn = null, this.#yn = t2;
  }
  shown() {
  }
  destroy() {
    this.#pn?.remove(), this.#pn = null, this.#fn?.remove(), this.#fn = null, this.#_e = "", this.#yn = null, this.#wn = null, this.#ft = null, this.#mn = false, this.#An = false;
  }
}
class TouchManager {
  #Mi;
  #Sn = false;
  #vn = null;
  #Cn;
  #kn;
  #Tn;
  #Fn;
  #In = null;
  #En;
  #Mn = null;
  #Dn;
  #On = null;
  constructor({ container: e2, isPinchingDisabled: t2 = null, isPinchingStopped: i2 = null, onPinchStart: n2 = null, onPinching: a2 = null, onPinchEnd: s2 = null, signal: r2 }) {
    this.#Mi = e2, this.#vn = i2, this.#Cn = t2, this.#kn = n2, this.#Tn = a2, this.#Fn = s2, this.#Dn = new AbortController(), this.#En = AbortSignal.any([r2, this.#Dn.signal]), e2.addEventListener("touchstart", this.#_n.bind(this), { passive: false, signal: this.#En });
  }
  get MIN_TOUCH_DISTANCE_TO_PINCH() {
    return 35 / OutputScale.pixelRatio;
  }
  #_n(e2) {
    if (this.#Cn?.()) return;
    if (1 === e2.touches.length) {
      if (this.#In) return;
      const e3 = this.#In = new AbortController(), t3 = AbortSignal.any([this.#En, e3.signal]), i3 = this.#Mi, n2 = { capture: true, signal: t3, passive: false }, cancelPointerDown = (e4) => {
        "touch" === e4.pointerType && (this.#In?.abort(), this.#In = null);
      };
      return i3.addEventListener("pointerdown", (e4) => {
        "touch" === e4.pointerType && (stopEvent(e4), cancelPointerDown(e4));
      }, n2), i3.addEventListener("pointerup", cancelPointerDown, n2), void i3.addEventListener("pointercancel", cancelPointerDown, n2);
    }
    if (!this.#On) {
      this.#On = new AbortController();
      const e3 = AbortSignal.any([this.#En, this.#On.signal]), t3 = this.#Mi, i3 = { signal: e3, capture: false, passive: false };
      t3.addEventListener("touchmove", this.#Pn.bind(this), i3);
      const n2 = this.#Rn.bind(this);
      t3.addEventListener("touchend", n2, i3), t3.addEventListener("touchcancel", n2, i3), i3.capture = true, t3.addEventListener("pointerdown", stopEvent, i3), t3.addEventListener("pointermove", stopEvent, i3), t3.addEventListener("pointercancel", stopEvent, i3), t3.addEventListener("pointerup", stopEvent, i3), this.#kn?.();
    }
    if (stopEvent(e2), 2 !== e2.touches.length || this.#vn?.()) return void (this.#Mn = null);
    let [t2, i2] = e2.touches;
    t2.identifier > i2.identifier && ([t2, i2] = [i2, t2]), this.#Mn = { touch0X: t2.screenX, touch0Y: t2.screenY, touch1X: i2.screenX, touch1Y: i2.screenY };
  }
  #Pn(e2) {
    if (!this.#Mn || 2 !== e2.touches.length) return;
    stopEvent(e2);
    let [t2, i2] = e2.touches;
    t2.identifier > i2.identifier && ([t2, i2] = [i2, t2]);
    const { screenX: n2, screenY: a2 } = t2, { screenX: s2, screenY: r2 } = i2, o2 = this.#Mn, { touch0X: l2, touch0Y: c2, touch1X: h2, touch1Y: d2 } = o2, u2 = h2 - l2, g2 = d2 - c2, f2 = s2 - n2, p2 = r2 - a2, m2 = Math.hypot(f2, p2) || 1, b2 = Math.hypot(u2, g2) || 1;
    if (!this.#Sn && Math.abs(b2 - m2) <= TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) return;
    if (o2.touch0X = n2, o2.touch0Y = a2, o2.touch1X = s2, o2.touch1Y = r2, !this.#Sn) return void (this.#Sn = true);
    const y2 = [(n2 + s2) / 2, (a2 + r2) / 2];
    this.#Tn?.(y2, b2, m2);
  }
  #Rn(e2) {
    e2.touches.length >= 2 || (this.#On && (this.#On.abort(), this.#On = null, this.#Fn?.()), this.#Mn && (stopEvent(e2), this.#Mn = null, this.#Sn = false));
  }
  destroy() {
    this.#Dn?.abort(), this.#Dn = null, this.#In?.abort(), this.#In = null;
  }
}
class AnnotationEditor {
  #Bn = null;
  #Nn = null;
  #mt = null;
  #bt = null;
  #fn = null;
  #Ln = false;
  #Un = null;
  #jn = "";
  #$n = null;
  #Hn = null;
  #Xn = null;
  #qn = null;
  #zn = null;
  #Wn = "";
  #Gn = false;
  #Vn = null;
  #Kn = false;
  #Yn = false;
  #Jn = false;
  #Zn = null;
  #Qn = 0;
  #ea = 0;
  #ta = null;
  #ia = null;
  isSelected = false;
  _isCopy = false;
  _editToolbar = null;
  _initialOptions = /* @__PURE__ */ Object.create(null);
  _initialData = null;
  _isVisible = true;
  _uiManager = null;
  _focusEventsAllowed = true;
  static _l10n = null;
  static _l10nResizer = null;
  #na = false;
  #aa = AnnotationEditor._zIndex++;
  static _borderLineWidth = -1;
  static _colorManager = new ColorManager();
  static _zIndex = 1;
  static _telemetryTimeout = 1e3;
  static get _resizerKeyboardManager() {
    const e2 = AnnotationEditor.prototype._resizeWithKeyboard, t2 = AnnotationEditorUIManager.TRANSLATE_SMALL, i2 = AnnotationEditorUIManager.TRANSLATE_BIG;
    return shadow(this, "_resizerKeyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], e2, { args: [-t2, 0] }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e2, { args: [-i2, 0] }], [["ArrowRight", "mac+ArrowRight"], e2, { args: [t2, 0] }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e2, { args: [i2, 0] }], [["ArrowUp", "mac+ArrowUp"], e2, { args: [0, -t2] }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e2, { args: [0, -i2] }], [["ArrowDown", "mac+ArrowDown"], e2, { args: [0, t2] }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e2, { args: [0, i2] }], [["Escape", "mac+Escape"], AnnotationEditor.prototype._stopResizingWithKeyboard]]));
  }
  constructor(e2) {
    this.parent = e2.parent, this.id = e2.id, this.width = this.height = null, this.pageIndex = e2.parent.pageIndex, this.name = e2.name, this.div = null, this._uiManager = e2.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = false, this._initialOptions.isCentered = e2.isCentered, this._structTreeParentId = null, this.annotationElementId = e2.annotationElementId || null, this.creationDate = e2.creationDate || /* @__PURE__ */ new Date(), this.modificationDate = e2.modificationDate || null;
    const { rotation: t2, rawDims: { pageWidth: i2, pageHeight: n2, pageX: a2, pageY: s2 } } = this.parent.viewport;
    this.rotation = t2, this.pageRotation = (360 + t2 - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [i2, n2], this.pageTranslation = [a2, s2];
    const [r2, o2] = this.parentDimensions;
    this.x = e2.x / r2, this.y = e2.y / o2, this.isAttachedToDOM = false, this.deleted = false;
  }
  get editorType() {
    return Object.getPrototypeOf(this).constructor._type;
  }
  get mode() {
    return Object.getPrototypeOf(this).constructor._editorType;
  }
  static get isDrawer() {
    return false;
  }
  static get _defaultLineColor() {
    return shadow(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }
  static deleteAnnotationElement(e2) {
    const t2 = new FakeEditor({ id: e2.parent.getNextId(), parent: e2.parent, uiManager: e2._uiManager });
    t2.annotationElementId = e2.annotationElementId, t2.deleted = true, t2._uiManager.addToAnnotationStorage(t2);
  }
  static initialize(e2, t2) {
    if (AnnotationEditor._l10n ??= e2, AnnotationEditor._l10nResizer ||= Object.freeze({ topLeft: "pdfjs-editor-resizer-top-left", topMiddle: "pdfjs-editor-resizer-top-middle", topRight: "pdfjs-editor-resizer-top-right", middleRight: "pdfjs-editor-resizer-middle-right", bottomRight: "pdfjs-editor-resizer-bottom-right", bottomMiddle: "pdfjs-editor-resizer-bottom-middle", bottomLeft: "pdfjs-editor-resizer-bottom-left", middleLeft: "pdfjs-editor-resizer-middle-left" }), -1 !== AnnotationEditor._borderLineWidth) return;
    const i2 = getComputedStyle(document.documentElement);
    AnnotationEditor._borderLineWidth = parseFloat(i2.getPropertyValue("--outline-width")) || 0;
  }
  static updateDefaultParams(e2, t2) {
  }
  static get defaultPropertiesToUpdate() {
    return [];
  }
  static isHandlingMimeForPasting(e2) {
    return false;
  }
  static paste(e2, t2) {
    unreachable("Not implemented");
  }
  get propertiesToUpdate() {
    return [];
  }
  get _isDraggable() {
    return this.#na;
  }
  set _isDraggable(e2) {
    this.#na = e2, this.div?.classList.toggle("draggable", e2);
  }
  get uid() {
    return this.annotationElementId || this.id;
  }
  get isEnterHandled() {
    return true;
  }
  center() {
    const [e2, t2] = this.pageDimensions;
    switch (this.parentRotation) {
      case 90:
        this.x -= this.height * t2 / (2 * e2), this.y += this.width * e2 / (2 * t2);
        break;
      case 180:
        this.x += this.width / 2, this.y += this.height / 2;
        break;
      case 270:
        this.x += this.height * t2 / (2 * e2), this.y -= this.width * e2 / (2 * t2);
        break;
      default:
        this.x -= this.width / 2, this.y -= this.height / 2;
    }
    this.fixAndSetPosition();
  }
  addCommands(e2) {
    this._uiManager.addCommands(e2);
  }
  get currentLayer() {
    return this._uiManager.currentLayer;
  }
  setInBackground() {
    this.div.style.zIndex = 0;
  }
  setInForeground() {
    this.div.style.zIndex = this.#aa;
  }
  setParent(e2) {
    null !== e2 ? (this.pageIndex = e2.pageIndex, this.pageDimensions = e2.pageDimensions) : (this.#sa(), this.#qn?.remove(), this.#qn = null), this.parent = e2;
  }
  focusin(e2) {
    this._focusEventsAllowed && (this.#Gn ? this.#Gn = false : this.parent.setSelected(this));
  }
  focusout(e2) {
    if (!this._focusEventsAllowed) return;
    if (!this.isAttachedToDOM) return;
    const t2 = e2.relatedTarget;
    t2?.closest(`#${this.id}`) || (e2.preventDefault(), this.parent?.isMultipleSelection || this.commitOrRemove());
  }
  commitOrRemove() {
    this.isEmpty() ? this.remove() : this.commit();
  }
  commit() {
    this.isInEditMode() && this.addToAnnotationStorage();
  }
  addToAnnotationStorage() {
    this._uiManager.addToAnnotationStorage(this);
  }
  setAt(e2, t2, i2, n2) {
    const [a2, s2] = this.parentDimensions;
    [i2, n2] = this.screenToPageTranslation(i2, n2), this.x = (e2 + i2) / a2, this.y = (t2 + n2) / s2, this.fixAndSetPosition();
  }
  _moveAfterPaste(e2, t2) {
    const [i2, n2] = this.parentDimensions;
    this.setAt(e2 * i2, t2 * n2, this.width * i2, this.height * n2), this._onTranslated();
  }
  #ra([e2, t2], i2, n2) {
    [i2, n2] = this.screenToPageTranslation(i2, n2), this.x += i2 / e2, this.y += n2 / t2, this._onTranslating(this.x, this.y), this.fixAndSetPosition();
  }
  translate(e2, t2) {
    this.#ra(this.parentDimensions, e2, t2);
  }
  translateInPage(e2, t2) {
    this.#Vn ||= [this.x, this.y, this.width, this.height], this.#ra(this.pageDimensions, e2, t2), this.div.scrollIntoView({ block: "nearest" });
  }
  translationDone() {
    this._onTranslated(this.x, this.y);
  }
  drag(e2, t2) {
    this.#Vn ||= [this.x, this.y, this.width, this.height];
    const { div: i2, parentDimensions: [n2, a2] } = this;
    if (this.x += e2 / n2, this.y += t2 / a2, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
      const { x: e3, y: t3 } = this.div.getBoundingClientRect();
      this.parent.findNewParent(this, e3, t3) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
    }
    let { x: s2, y: r2 } = this;
    const [o2, l2] = this.getBaseTranslation();
    s2 += o2, r2 += l2;
    const { style: c2 } = i2;
    c2.left = `${(100 * s2).toFixed(2)}%`, c2.top = `${(100 * r2).toFixed(2)}%`, this._onTranslating(s2, r2), i2.scrollIntoView({ block: "nearest" });
  }
  _onTranslating(e2, t2) {
  }
  _onTranslated(e2, t2) {
  }
  get _hasBeenMoved() {
    return !!this.#Vn && (this.#Vn[0] !== this.x || this.#Vn[1] !== this.y);
  }
  get _hasBeenResized() {
    return !!this.#Vn && (this.#Vn[2] !== this.width || this.#Vn[3] !== this.height);
  }
  getBaseTranslation() {
    const [e2, t2] = this.parentDimensions, { _borderLineWidth: i2 } = AnnotationEditor, n2 = i2 / e2, a2 = i2 / t2;
    switch (this.rotation) {
      case 90:
        return [-n2, a2];
      case 180:
        return [n2, a2];
      case 270:
        return [n2, -a2];
      default:
        return [-n2, -a2];
    }
  }
  get _mustFixPosition() {
    return true;
  }
  fixAndSetPosition(e2 = this.rotation) {
    const { div: { style: t2 }, pageDimensions: [i2, n2] } = this;
    let { x: a2, y: s2, width: r2, height: o2 } = this;
    if (r2 *= i2, o2 *= n2, a2 *= i2, s2 *= n2, this._mustFixPosition) switch (e2) {
      case 0:
        a2 = MathClamp(a2, 0, i2 - r2), s2 = MathClamp(s2, 0, n2 - o2);
        break;
      case 90:
        a2 = MathClamp(a2, 0, i2 - o2), s2 = MathClamp(s2, r2, n2);
        break;
      case 180:
        a2 = MathClamp(a2, r2, i2), s2 = MathClamp(s2, o2, n2);
        break;
      case 270:
        a2 = MathClamp(a2, o2, i2), s2 = MathClamp(s2, 0, n2 - r2);
    }
    this.x = a2 /= i2, this.y = s2 /= n2;
    const [l2, c2] = this.getBaseTranslation();
    a2 += l2, s2 += c2, t2.left = `${(100 * a2).toFixed(2)}%`, t2.top = `${(100 * s2).toFixed(2)}%`, this.moveInDOM();
  }
  static #oa(e2, t2, i2) {
    switch (i2) {
      case 90:
        return [t2, -e2];
      case 180:
        return [-e2, -t2];
      case 270:
        return [-t2, e2];
      default:
        return [e2, t2];
    }
  }
  screenToPageTranslation(e2, t2) {
    return AnnotationEditor.#oa(e2, t2, this.parentRotation);
  }
  pageTranslationToScreen(e2, t2) {
    return AnnotationEditor.#oa(e2, t2, 360 - this.parentRotation);
  }
  #la(e2) {
    switch (e2) {
      case 90: {
        const [e3, t2] = this.pageDimensions;
        return [0, -e3 / t2, t2 / e3, 0];
      }
      case 180:
        return [-1, 0, 0, -1];
      case 270: {
        const [e3, t2] = this.pageDimensions;
        return [0, e3 / t2, -t2 / e3, 0];
      }
      default:
        return [1, 0, 0, 1];
    }
  }
  get parentScale() {
    return this._uiManager.viewParameters.realScale;
  }
  get parentRotation() {
    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
  }
  get parentDimensions() {
    const { parentScale: e2, pageDimensions: [t2, i2] } = this;
    return [t2 * e2, i2 * e2];
  }
  setDims() {
    const { div: { style: e2 }, width: t2, height: i2 } = this;
    e2.width = `${(100 * t2).toFixed(2)}%`, e2.height = `${(100 * i2).toFixed(2)}%`;
  }
  getInitialTranslation() {
    return [0, 0];
  }
  #ca() {
    if (this.#$n) return;
    this.#$n = document.createElement("div"), this.#$n.classList.add("resizers");
    const e2 = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"], t2 = this._uiManager._signal;
    for (const i2 of e2) {
      const e3 = document.createElement("div");
      this.#$n.append(e3), e3.classList.add("resizer", i2), e3.setAttribute("data-resizer-name", i2), e3.addEventListener("pointerdown", this.#ha.bind(this, i2), { signal: t2 }), e3.addEventListener("contextmenu", noContextMenu, { signal: t2 }), e3.tabIndex = -1;
    }
    this.div.prepend(this.#$n);
  }
  #ha(e2, t2) {
    t2.preventDefault();
    const { isMac: i2 } = util_FeatureTest.platform;
    if (0 !== t2.button || t2.ctrlKey && i2) return;
    this.#mt?.toggle(false);
    const n2 = this._isDraggable;
    this._isDraggable = false, this.#Hn = [t2.screenX, t2.screenY];
    const a2 = new AbortController(), s2 = this._uiManager.combinedSignal(a2);
    this.parent.togglePointerEvents(false), window.addEventListener("pointermove", this.#da.bind(this, e2), { passive: true, capture: true, signal: s2 }), window.addEventListener("touchmove", stopEvent, { passive: false, signal: s2 }), window.addEventListener("contextmenu", noContextMenu, { signal: s2 }), this.#Xn = { savedX: this.x, savedY: this.y, savedWidth: this.width, savedHeight: this.height };
    const r2 = this.parent.div.style.cursor, o2 = this.div.style.cursor;
    this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(t2.target).cursor;
    const pointerUpCallback = () => {
      a2.abort(), this.parent.togglePointerEvents(true), this.#mt?.toggle(true), this._isDraggable = n2, this.parent.div.style.cursor = r2, this.div.style.cursor = o2, this.#ua();
    };
    window.addEventListener("pointerup", pointerUpCallback, { signal: s2 }), window.addEventListener("blur", pointerUpCallback, { signal: s2 });
  }
  #ga(e2, t2, i2, n2) {
    this.width = i2, this.height = n2, this.x = e2, this.y = t2, this.setDims(), this.fixAndSetPosition(), this._onResized();
  }
  _onResized() {
  }
  #ua() {
    if (!this.#Xn) return;
    const { savedX: e2, savedY: t2, savedWidth: i2, savedHeight: n2 } = this.#Xn;
    this.#Xn = null;
    const a2 = this.x, s2 = this.y, r2 = this.width, o2 = this.height;
    a2 === e2 && s2 === t2 && r2 === i2 && o2 === n2 || this.addCommands({ cmd: this.#ga.bind(this, a2, s2, r2, o2), undo: this.#ga.bind(this, e2, t2, i2, n2), mustExec: true });
  }
  static _round(e2) {
    return Math.round(1e4 * e2) / 1e4;
  }
  #da(e2, t2) {
    const [i2, n2] = this.parentDimensions, a2 = this.x, s2 = this.y, r2 = this.width, o2 = this.height, l2 = AnnotationEditor.MIN_SIZE / i2, c2 = AnnotationEditor.MIN_SIZE / n2, h2 = this.#la(this.rotation), transf = (e3, t3) => [h2[0] * e3 + h2[2] * t3, h2[1] * e3 + h2[3] * t3], d2 = this.#la(360 - this.rotation);
    let u2, g2, f2 = false, p2 = false;
    switch (e2) {
      case "topLeft":
        f2 = true, u2 = (e3, t3) => [0, 0], g2 = (e3, t3) => [e3, t3];
        break;
      case "topMiddle":
        u2 = (e3, t3) => [e3 / 2, 0], g2 = (e3, t3) => [e3 / 2, t3];
        break;
      case "topRight":
        f2 = true, u2 = (e3, t3) => [e3, 0], g2 = (e3, t3) => [0, t3];
        break;
      case "middleRight":
        p2 = true, u2 = (e3, t3) => [e3, t3 / 2], g2 = (e3, t3) => [0, t3 / 2];
        break;
      case "bottomRight":
        f2 = true, u2 = (e3, t3) => [e3, t3], g2 = (e3, t3) => [0, 0];
        break;
      case "bottomMiddle":
        u2 = (e3, t3) => [e3 / 2, t3], g2 = (e3, t3) => [e3 / 2, 0];
        break;
      case "bottomLeft":
        f2 = true, u2 = (e3, t3) => [0, t3], g2 = (e3, t3) => [e3, 0];
        break;
      case "middleLeft":
        p2 = true, u2 = (e3, t3) => [0, t3 / 2], g2 = (e3, t3) => [e3, t3 / 2];
    }
    const m2 = u2(r2, o2), b2 = g2(r2, o2);
    let y2 = transf(...b2);
    const w2 = AnnotationEditor._round(a2 + y2[0]), x2 = AnnotationEditor._round(s2 + y2[1]);
    let S2, v2, C2 = 1, k2 = 1;
    if (t2.fromKeyboard) ({ deltaX: S2, deltaY: v2 } = t2);
    else {
      const { screenX: e3, screenY: i3 } = t2, [n3, a3] = this.#Hn;
      [S2, v2] = this.screenToPageTranslation(e3 - n3, i3 - a3), this.#Hn[0] = e3, this.#Hn[1] = i3;
    }
    var T2, F2;
    if ([S2, v2] = (T2 = S2 / i2, F2 = v2 / n2, [d2[0] * T2 + d2[2] * F2, d2[1] * T2 + d2[3] * F2]), f2) {
      const e3 = Math.hypot(r2, o2);
      C2 = k2 = Math.max(Math.min(Math.hypot(b2[0] - m2[0] - S2, b2[1] - m2[1] - v2) / e3, 1 / r2, 1 / o2), l2 / r2, c2 / o2);
    } else p2 ? C2 = MathClamp(Math.abs(b2[0] - m2[0] - S2), l2, 1) / r2 : k2 = MathClamp(Math.abs(b2[1] - m2[1] - v2), c2, 1) / o2;
    const E2 = AnnotationEditor._round(r2 * C2), M2 = AnnotationEditor._round(o2 * k2);
    y2 = transf(...g2(E2, M2));
    const D2 = w2 - y2[0], O2 = x2 - y2[1];
    this.#Vn ||= [this.x, this.y, this.width, this.height], this.width = E2, this.height = M2, this.x = D2, this.y = O2, this.setDims(), this.fixAndSetPosition(), this._onResizing();
  }
  _onResizing() {
  }
  altTextFinish() {
    this.#mt?.finish();
  }
  get toolbarButtons() {
    return null;
  }
  async addEditToolbar() {
    if (this._editToolbar || this.#Yn) return this._editToolbar;
    this._editToolbar = new EditorToolbar(this), this.div.append(this._editToolbar.render());
    const { toolbarButtons: e2 } = this;
    if (e2) for (const [t2, i2] of e2) await this._editToolbar.addButton(t2, i2);
    return this.hasComment || this._editToolbar.addButton("comment", this.addCommentButton()), this._editToolbar.addButton("delete"), this._editToolbar;
  }
  addCommentButtonInToolbar() {
    this._editToolbar?.addButtonBefore("comment", this.addCommentButton(), ".deleteButton");
  }
  removeCommentButtonFromToolbar() {
    this._editToolbar?.removeButton("comment");
  }
  removeEditToolbar() {
    this._editToolbar?.remove(), this._editToolbar = null, this.#mt?.destroy();
  }
  addContainer(e2) {
    const t2 = this._editToolbar?.div;
    t2 ? t2.before(e2) : this.div.append(e2);
  }
  getClientDimensions() {
    return this.div.getBoundingClientRect();
  }
  createAltText() {
    return this.#mt || (AltText.initialize(AnnotationEditor._l10n), this.#mt = new AltText(this), this.#Bn && (this.#mt.data = this.#Bn, this.#Bn = null)), this.#mt;
  }
  get altTextData() {
    return this.#mt?.data;
  }
  set altTextData(e2) {
    this.#mt && (this.#mt.data = e2);
  }
  get guessedAltText() {
    return this.#mt?.guessedText;
  }
  async setGuessedAltText(e2) {
    await this.#mt?.setGuessedText(e2);
  }
  serializeAltText(e2) {
    return this.#mt?.serialize(e2);
  }
  hasAltText() {
    return !!this.#mt && !this.#mt.isEmpty();
  }
  hasAltTextData() {
    return this.#mt?.hasData() ?? false;
  }
  focusCommentButton() {
    this.#bt?.focusButton();
  }
  addCommentButton() {
    return this.#bt ||= new Comment(this);
  }
  addStandaloneCommentButton() {
    this.#fn ? this._uiManager.isEditingMode() && this.#fn.classList.remove("hidden") : this.hasComment && (this.#fn = this.#bt.renderForStandalone(), this.div.append(this.#fn));
  }
  removeStandaloneCommentButton() {
    this.#bt.removeStandaloneCommentButton(), this.#fn = null;
  }
  hideStandaloneCommentButton() {
    this.#fn?.classList.add("hidden");
  }
  get comment() {
    const { data: { richText: e2, text: t2, date: i2, deleted: n2 } } = this.#bt;
    return { text: t2, richText: e2, date: i2, deleted: n2, color: this.getNonHCMColor(), opacity: this.opacity ?? 1 };
  }
  set comment(e2) {
    this.#bt ||= new Comment(this), this.#bt.data = e2, this.hasComment ? (this.removeCommentButtonFromToolbar(), this.addStandaloneCommentButton(), this._uiManager.updateComment(this)) : (this.addCommentButtonInToolbar(), this.removeStandaloneCommentButton(), this._uiManager.removeComment(this));
  }
  setCommentData({ comment: e2, popupRef: t2, richText: i2 }) {
    if (!t2) return;
    if (this.#bt ||= new Comment(this), this.#bt.setInitialText(e2, i2), !this.annotationElementId) return;
    const n2 = this._uiManager.getAndRemoveDataFromAnnotationStorage(this.annotationElementId);
    n2 && this.updateFromAnnotationLayer(n2);
  }
  get hasEditedComment() {
    return this.#bt?.hasBeenEdited();
  }
  get hasDeletedComment() {
    return this.#bt?.isDeleted();
  }
  get hasComment() {
    return !!this.#bt && !this.#bt.isEmpty() && !this.#bt.isDeleted();
  }
  async editComment(e2) {
    this.#bt ||= new Comment(this), this.#bt.edit(e2);
  }
  toggleComment(e2, t2 = void 0) {
    this.hasComment && this._uiManager.toggleComment(this, e2, t2);
  }
  setSelectedCommentButton(e2) {
    this.#bt.setSelectedButton(e2);
  }
  addComment(e2) {
    if (this.hasEditedComment) {
      const t2 = 180, i2 = 100, [, , , n2] = e2.rect, [a2] = this.pageDimensions, [s2] = this.pageTranslation, r2 = s2 + a2 + 1, o2 = n2 - i2, l2 = r2 + t2;
      e2.popup = { contents: this.comment.text, deleted: this.comment.deleted, rect: [r2, o2, l2, n2] };
    }
  }
  updateFromAnnotationLayer({ popup: { contents: e2, deleted: t2 } }) {
    this.#bt.data = t2 ? null : e2;
  }
  get parentBoundingClientRect() {
    return this.parent.boundingClientRect;
  }
  render() {
    const e2 = this.div = document.createElement("div");
    e2.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), e2.className = this.name, e2.setAttribute("id", this.id), e2.tabIndex = this.#Ln ? -1 : 0, e2.setAttribute("role", "application"), this.defaultL10nId && e2.setAttribute("data-l10n-id", this.defaultL10nId), this._isVisible || e2.classList.add("hidden"), this.setInForeground(), this.#fa();
    const [t2, i2] = this.parentDimensions;
    this.parentRotation % 180 != 0 && (e2.style.maxWidth = `${(100 * i2 / t2).toFixed(2)}%`, e2.style.maxHeight = `${(100 * t2 / i2).toFixed(2)}%`);
    const [n2, a2] = this.getInitialTranslation();
    return this.translate(n2, a2), bindEvents(this, e2, ["keydown", "pointerdown", "dblclick"]), this.isResizable && this._uiManager._supportsPinchToZoom && (this.#ia ||= new TouchManager({ container: e2, isPinchingDisabled: () => !this.isSelected, onPinchStart: this.#pa.bind(this), onPinching: this.#ma.bind(this), onPinchEnd: this.#ba.bind(this), signal: this._uiManager._signal })), this.addStandaloneCommentButton(), this._uiManager._editorUndoBar?.hide(), e2;
  }
  #pa() {
    this.#Xn = { savedX: this.x, savedY: this.y, savedWidth: this.width, savedHeight: this.height }, this.#mt?.toggle(false), this.parent.togglePointerEvents(false);
  }
  #ma(e2, t2, i2) {
    let n2 = i2 / t2 * 0.7 + 1 - 0.7;
    if (1 === n2) return;
    const a2 = this.#la(this.rotation), transf = (e3, t3) => [a2[0] * e3 + a2[2] * t3, a2[1] * e3 + a2[3] * t3], [s2, r2] = this.parentDimensions, o2 = this.x, l2 = this.y, c2 = this.width, h2 = this.height, d2 = AnnotationEditor.MIN_SIZE / s2, u2 = AnnotationEditor.MIN_SIZE / r2;
    n2 = Math.max(Math.min(n2, 1 / c2, 1 / h2), d2 / c2, u2 / h2);
    const g2 = AnnotationEditor._round(c2 * n2), f2 = AnnotationEditor._round(h2 * n2);
    if (g2 === c2 && f2 === h2) return;
    this.#Vn ||= [o2, l2, c2, h2];
    const p2 = transf(c2 / 2, h2 / 2), m2 = AnnotationEditor._round(o2 + p2[0]), b2 = AnnotationEditor._round(l2 + p2[1]), y2 = transf(g2 / 2, f2 / 2);
    this.x = m2 - y2[0], this.y = b2 - y2[1], this.width = g2, this.height = f2, this.setDims(), this.fixAndSetPosition(), this._onResizing();
  }
  #ba() {
    this.#mt?.toggle(true), this.parent.togglePointerEvents(true), this.#ua();
  }
  pointerdown(e2) {
    const { isMac: t2 } = util_FeatureTest.platform;
    0 !== e2.button || e2.ctrlKey && t2 ? e2.preventDefault() : (this.#Gn = true, this._isDraggable ? this.#ya(e2) : this.#wa(e2));
  }
  #wa(e2) {
    const { isMac: t2 } = util_FeatureTest.platform;
    e2.ctrlKey && !t2 || e2.shiftKey || e2.metaKey && t2 ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
  }
  #ya(e2) {
    const { isSelected: t2 } = this;
    this._uiManager.setUpDragSession();
    let i2 = false;
    const n2 = new AbortController(), a2 = this._uiManager.combinedSignal(n2), s2 = { capture: true, passive: false, signal: a2 }, cancelDrag = (e3) => {
      n2.abort(), this.#Un = null, this.#Gn = false, this._uiManager.endDragSession() || this.#wa(e3), i2 && this._onStopDragging();
    };
    t2 && (this.#Qn = e2.clientX, this.#ea = e2.clientY, this.#Un = e2.pointerId, this.#jn = e2.pointerType, window.addEventListener("pointermove", (e3) => {
      i2 || (i2 = true, this._uiManager.toggleComment(this, true, false), this._onStartDragging());
      const { clientX: t3, clientY: n3, pointerId: a3 } = e3;
      if (a3 !== this.#Un) return void stopEvent(e3);
      const [s3, r2] = this.screenToPageTranslation(t3 - this.#Qn, n3 - this.#ea);
      this.#Qn = t3, this.#ea = n3, this._uiManager.dragSelectedEditors(s3, r2);
    }, s2), window.addEventListener("touchmove", stopEvent, s2), window.addEventListener("pointerdown", (e3) => {
      e3.pointerType === this.#jn && (this.#ia || e3.isPrimary) && cancelDrag(e3), stopEvent(e3);
    }, s2));
    const pointerUpCallback = (e3) => {
      this.#Un && this.#Un !== e3.pointerId ? stopEvent(e3) : cancelDrag(e3);
    };
    window.addEventListener("pointerup", pointerUpCallback, { signal: a2 }), window.addEventListener("blur", pointerUpCallback, { signal: a2 });
  }
  _onStartDragging() {
  }
  _onStopDragging() {
  }
  moveInDOM() {
    this.#Zn && clearTimeout(this.#Zn), this.#Zn = setTimeout(() => {
      this.#Zn = null, this.parent?.moveEditorInDOM(this);
    }, 0);
  }
  _setParentAndPosition(e2, t2, i2) {
    e2.changeParent(this), this.x = t2, this.y = i2, this.fixAndSetPosition(), this._onTranslated();
  }
  getRect(e2, t2, i2 = this.rotation) {
    const n2 = this.parentScale, [a2, s2] = this.pageDimensions, [r2, o2] = this.pageTranslation, l2 = e2 / n2, c2 = t2 / n2, h2 = this.x * a2, d2 = this.y * s2, u2 = this.width * a2, g2 = this.height * s2;
    switch (i2) {
      case 0:
        return [h2 + l2 + r2, s2 - d2 - c2 - g2 + o2, h2 + l2 + u2 + r2, s2 - d2 - c2 + o2];
      case 90:
        return [h2 + c2 + r2, s2 - d2 + l2 + o2, h2 + c2 + g2 + r2, s2 - d2 + l2 + u2 + o2];
      case 180:
        return [h2 - l2 - u2 + r2, s2 - d2 + c2 + o2, h2 - l2 + r2, s2 - d2 + c2 + g2 + o2];
      case 270:
        return [h2 - c2 - g2 + r2, s2 - d2 - l2 - u2 + o2, h2 - c2 + r2, s2 - d2 - l2 + o2];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getRectInCurrentCoords(e2, t2) {
    const [i2, n2, a2, s2] = e2, r2 = a2 - i2, o2 = s2 - n2;
    switch (this.rotation) {
      case 0:
        return [i2, t2 - s2, r2, o2];
      case 90:
        return [i2, t2 - n2, o2, r2];
      case 180:
        return [a2, t2 - n2, r2, o2];
      case 270:
        return [a2, t2 - s2, o2, r2];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getPDFRect() {
    return this.getRect(0, 0);
  }
  getNonHCMColor() {
    return this.color && AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));
  }
  onUpdatedColor() {
    this.#bt?.onUpdatedColor();
  }
  getData() {
    const { comment: { text: e2, color: t2, date: i2, opacity: n2, deleted: a2, richText: s2 }, uid: r2, pageIndex: o2, creationDate: l2, modificationDate: c2 } = this;
    return { id: r2, pageIndex: o2, rect: this.getPDFRect(), richText: s2, contentsObj: { str: e2 }, creationDate: l2, modificationDate: i2 || c2, popupRef: !a2, color: t2, opacity: n2 };
  }
  onceAdded(e2) {
  }
  isEmpty() {
    return false;
  }
  enableEditMode() {
    return !this.isInEditMode() && (this.parent.setEditingState(false), this.#Yn = true, true);
  }
  disableEditMode() {
    return !!this.isInEditMode() && (this.parent.setEditingState(true), this.#Yn = false, true);
  }
  isInEditMode() {
    return this.#Yn;
  }
  shouldGetKeyboardEvents() {
    return this.#Jn;
  }
  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }
  get isOnScreen() {
    const { top: e2, left: t2, bottom: i2, right: n2 } = this.getClientDimensions(), { innerHeight: a2, innerWidth: s2 } = window;
    return t2 < s2 && n2 > 0 && e2 < a2 && i2 > 0;
  }
  #fa() {
    if (this.#zn || !this.div) return;
    this.#zn = new AbortController();
    const e2 = this._uiManager.combinedSignal(this.#zn);
    this.div.addEventListener("focusin", this.focusin.bind(this), { signal: e2 }), this.div.addEventListener("focusout", this.focusout.bind(this), { signal: e2 });
  }
  rebuild() {
    this.#fa();
  }
  rotate(e2) {
  }
  resize() {
  }
  serializeDeleted() {
    return { id: this.annotationElementId, deleted: true, pageIndex: this.pageIndex, popupRef: this._initialData?.popupRef || "" };
  }
  serialize(e2 = false, t2 = null) {
    return { annotationType: this.mode, pageIndex: this.pageIndex, rect: this.getPDFRect(), rotation: this.rotation, structTreeParentId: this._structTreeParentId, popupRef: this._initialData?.popupRef || "" };
  }
  static async deserialize(e2, t2, i2) {
    const n2 = new this.prototype.constructor({ parent: t2, id: t2.getNextId(), uiManager: i2, annotationElementId: e2.annotationElementId, creationDate: e2.creationDate, modificationDate: e2.modificationDate });
    n2.rotation = e2.rotation, n2.#Bn = e2.accessibilityData, n2._isCopy = e2.isCopy || false;
    const [a2, s2] = n2.pageDimensions, [r2, o2, l2, c2] = n2.getRectInCurrentCoords(e2.rect, s2);
    return n2.x = r2 / a2, n2.y = o2 / s2, n2.width = l2 / a2, n2.height = c2 / s2, n2;
  }
  get hasBeenModified() {
    return !!this.annotationElementId && (this.deleted || null !== this.serialize());
  }
  remove() {
    if (this.#zn?.abort(), this.#zn = null, this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), this.#Zn && (clearTimeout(this.#Zn), this.#Zn = null), this.#sa(), this.removeEditToolbar(), this.#ta) {
      for (const e2 of this.#ta.values()) clearTimeout(e2);
      this.#ta = null;
    }
    this.parent = null, this.#ia?.destroy(), this.#ia = null;
  }
  get isResizable() {
    return false;
  }
  makeResizable() {
    this.isResizable && (this.#ca(), this.#$n.classList.remove("hidden"));
  }
  get toolbarPosition() {
    return null;
  }
  get commentButtonPosition() {
    return "ltr" === this._uiManager.direction ? [1, 0] : [0, 0];
  }
  get commentButtonPositionInPage() {
    const { commentButtonPosition: [e2, t2] } = this, [i2, n2, a2, s2] = this.getPDFRect();
    return [AnnotationEditor._round(i2 + (a2 - i2) * e2), AnnotationEditor._round(n2 + (s2 - n2) * (1 - t2))];
  }
  get commentButtonColor() {
    return this._uiManager.makeCommentColor(this.getNonHCMColor(), this.opacity);
  }
  get commentPopupPosition() {
    return this.#bt.commentPopupPositionInLayer;
  }
  set commentPopupPosition(e2) {
    this.#bt.commentPopupPositionInLayer = e2;
  }
  hasDefaultPopupPosition() {
    return this.#bt.hasDefaultPopupPosition();
  }
  get commentButtonWidth() {
    return this.#bt.commentButtonWidth;
  }
  get elementBeforePopup() {
    return this.div;
  }
  setCommentButtonStates(e2) {
    this.#bt.setCommentButtonStates(e2);
  }
  keydown(e2) {
    if (!this.isResizable || e2.target !== this.div || "Enter" !== e2.key) return;
    this._uiManager.setSelected(this), this.#Xn = { savedX: this.x, savedY: this.y, savedWidth: this.width, savedHeight: this.height };
    const t2 = this.#$n.children;
    if (!this.#Nn) {
      this.#Nn = Array.from(t2);
      const e3 = this.#Aa.bind(this), i3 = this.#xa.bind(this), n3 = this._uiManager._signal;
      for (const t3 of this.#Nn) {
        const a3 = t3.getAttribute("data-resizer-name");
        t3.setAttribute("role", "spinbutton"), t3.addEventListener("keydown", e3, { signal: n3 }), t3.addEventListener("blur", i3, { signal: n3 }), t3.addEventListener("focus", this.#Sa.bind(this, a3), { signal: n3 }), t3.setAttribute("data-l10n-id", AnnotationEditor._l10nResizer[a3]);
      }
    }
    const i2 = this.#Nn[0];
    let n2 = 0;
    for (const e3 of t2) {
      if (e3 === i2) break;
      n2++;
    }
    const a2 = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#Nn.length / 4);
    if (a2 !== n2) {
      if (a2 < n2) for (let e4 = 0; e4 < n2 - a2; e4++) this.#$n.append(this.#$n.firstChild);
      else if (a2 > n2) for (let e4 = 0; e4 < a2 - n2; e4++) this.#$n.firstChild.before(this.#$n.lastChild);
      let e3 = 0;
      for (const i3 of t2) {
        const t3 = this.#Nn[e3++].getAttribute("data-resizer-name");
        i3.setAttribute("data-l10n-id", AnnotationEditor._l10nResizer[t3]);
      }
    }
    this.#va(0), this.#Jn = true, this.#$n.firstChild.focus({ focusVisible: true }), e2.preventDefault(), e2.stopImmediatePropagation();
  }
  #Aa(e2) {
    AnnotationEditor._resizerKeyboardManager.exec(this, e2);
  }
  #xa(e2) {
    this.#Jn && e2.relatedTarget?.parentNode !== this.#$n && this.#sa();
  }
  #Sa(e2) {
    this.#Wn = this.#Jn ? e2 : "";
  }
  #va(e2) {
    if (this.#Nn) for (const t2 of this.#Nn) t2.tabIndex = e2;
  }
  _resizeWithKeyboard(e2, t2) {
    this.#Jn && this.#da(this.#Wn, { deltaX: e2, deltaY: t2, fromKeyboard: true });
  }
  #sa() {
    this.#Jn = false, this.#va(-1), this.#ua();
  }
  _stopResizingWithKeyboard() {
    this.#sa(), this.div.focus();
  }
  select() {
    this.isSelected && this._editToolbar ? this._editToolbar.show() : (this.isSelected = true, this.makeResizable(), this.div?.classList.add("selectedEditor"), this._editToolbar ? (this._editToolbar?.show(), this.#mt?.toggleAltTextBadge(false)) : this.addEditToolbar().then(() => {
      this.div?.classList.contains("selectedEditor") && this._editToolbar?.show();
    }));
  }
  focus() {
    this.div && !this.div.contains(document.activeElement) && setTimeout(() => this.div?.focus({ preventScroll: true }), 0);
  }
  unselect() {
    this.isSelected && (this.isSelected = false, this.#$n?.classList.add("hidden"), this.div?.classList.remove("selectedEditor"), this.div?.contains(document.activeElement) && this._uiManager.currentLayer.div.focus({ preventScroll: true }), this._editToolbar?.hide(), this.#mt?.toggleAltTextBadge(true), this.hasComment && this._uiManager.toggleComment(this, false, false));
  }
  updateParams(e2, t2) {
  }
  disableEditing() {
  }
  enableEditing() {
  }
  get canChangeContent() {
    return false;
  }
  enterInEditMode() {
    this.canChangeContent && (this.enableEditMode(), this.div.focus());
  }
  dblclick(e2) {
    "BUTTON" !== e2.target.nodeName && (this.enterInEditMode(), this.parent.updateToolbar({ mode: this.constructor._editorType, editId: this.id }));
  }
  getElementForAltText() {
    return this.div;
  }
  get contentDiv() {
    return this.div;
  }
  get isEditing() {
    return this.#Kn;
  }
  set isEditing(e2) {
    this.#Kn = e2, this.parent && (e2 ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
  }
  static get MIN_SIZE() {
    return 16;
  }
  static canCreateNewEmptyEditor() {
    return true;
  }
  get telemetryInitialData() {
    return { action: "added" };
  }
  get telemetryFinalData() {
    return null;
  }
  _reportTelemetry(e2, t2 = false) {
    if (t2) {
      this.#ta ||= /* @__PURE__ */ new Map();
      const { action: t3 } = e2;
      let i2 = this.#ta.get(t3);
      return i2 && clearTimeout(i2), i2 = setTimeout(() => {
        this._reportTelemetry(e2), this.#ta.delete(t3), 0 === this.#ta.size && (this.#ta = null);
      }, AnnotationEditor._telemetryTimeout), void this.#ta.set(t3, i2);
    }
    e2.type ||= this.editorType, this._uiManager._eventBus.dispatch("reporttelemetry", { source: this, details: { type: "editing", data: e2 } });
  }
  show(e2 = this._isVisible) {
    this.div.classList.toggle("hidden", !e2), this._isVisible = e2;
  }
  enable() {
    this.div && (this.div.tabIndex = 0), this.#Ln = false;
  }
  disable() {
    this.div && (this.div.tabIndex = -1), this.#Ln = true;
  }
  updateFakeAnnotationElement(e2) {
    if (this.#qn || this.deleted) return this.deleted ? (this.#qn.remove(), void (this.#qn = null)) : void ((this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized) && this.#qn.updateEdited({ rect: this.getPDFRect(), popup: this.comment }));
    this.#qn = e2.addFakeAnnotation(this);
  }
  renderAnnotationElement(e2) {
    if (this.deleted) return e2.hide(), null;
    let t2 = e2.container.querySelector(".annotationContent");
    if (t2) {
      if ("CANVAS" === t2.nodeName) {
        const e3 = t2;
        t2 = document.createElement("div"), t2.classList.add("annotationContent", this.editorType), e3.before(t2);
      }
    } else t2 = document.createElement("div"), t2.classList.add("annotationContent", this.editorType), e2.container.prepend(t2);
    return t2;
  }
  resetAnnotationElement(e2) {
    const { firstChild: t2 } = e2.container;
    "DIV" === t2?.nodeName && t2.classList.contains("annotationContent") && t2.remove();
  }
}
class FakeEditor extends AnnotationEditor {
  constructor(e2) {
    super(e2), this.annotationElementId = e2.annotationElementId, this.deleted = true;
  }
  serialize() {
    return this.serializeDeleted();
  }
}
const Ac = 3285377520, xc = 4294901760, Sc = 65535;
class MurmurHash3_64 {
  constructor(e2) {
    this.h1 = e2 ? 4294967295 & e2 : Ac, this.h2 = e2 ? 4294967295 & e2 : Ac;
  }
  update(e2) {
    let t2, i2;
    if ("string" == typeof e2) {
      t2 = new Uint8Array(2 * e2.length), i2 = 0;
      for (let n3 = 0, a3 = e2.length; n3 < a3; n3++) {
        const a4 = e2.charCodeAt(n3);
        a4 <= 255 ? t2[i2++] = a4 : (t2[i2++] = a4 >>> 8, t2[i2++] = 255 & a4);
      }
    } else {
      if (!ArrayBuffer.isView(e2)) throw new Error("Invalid data format, must be a string or TypedArray.");
      t2 = e2.slice(), i2 = t2.byteLength;
    }
    const n2 = i2 >> 2, a2 = i2 - 4 * n2, s2 = new Uint32Array(t2.buffer, 0, n2);
    let r2 = 0, o2 = 0, l2 = this.h1, c2 = this.h2;
    const h2 = 3432918353, d2 = 461845907, u2 = 11601, g2 = 13715;
    for (let e3 = 0; e3 < n2; e3++) 1 & e3 ? (r2 = s2[e3], r2 = r2 * h2 & xc | r2 * u2 & Sc, r2 = r2 << 15 | r2 >>> 17, r2 = r2 * d2 & xc | r2 * g2 & Sc, l2 ^= r2, l2 = l2 << 13 | l2 >>> 19, l2 = 5 * l2 + 3864292196) : (o2 = s2[e3], o2 = o2 * h2 & xc | o2 * u2 & Sc, o2 = o2 << 15 | o2 >>> 17, o2 = o2 * d2 & xc | o2 * g2 & Sc, c2 ^= o2, c2 = c2 << 13 | c2 >>> 19, c2 = 5 * c2 + 3864292196);
    switch (r2 = 0, a2) {
      case 3:
        r2 ^= t2[4 * n2 + 2] << 16;
      case 2:
        r2 ^= t2[4 * n2 + 1] << 8;
      case 1:
        r2 ^= t2[4 * n2], r2 = r2 * h2 & xc | r2 * u2 & Sc, r2 = r2 << 15 | r2 >>> 17, r2 = r2 * d2 & xc | r2 * g2 & Sc, 1 & n2 ? l2 ^= r2 : c2 ^= r2;
    }
    this.h1 = l2, this.h2 = c2;
  }
  hexdigest() {
    let e2 = this.h1, t2 = this.h2;
    return e2 ^= t2 >>> 1, e2 = 3981806797 * e2 & xc | 36045 * e2 & Sc, t2 = 4283543511 * t2 & xc | (2950163797 * (t2 << 16 | e2 >>> 16) & xc) >>> 16, e2 ^= t2 >>> 1, e2 = 444984403 * e2 & xc | 60499 * e2 & Sc, t2 = 3301882366 * t2 & xc | (3120437893 * (t2 << 16 | e2 >>> 16) & xc) >>> 16, e2 ^= t2 >>> 1, (e2 >>> 0).toString(16).padStart(8, "0") + (t2 >>> 0).toString(16).padStart(8, "0");
  }
}
const vc = Object.freeze({ map: null, hash: "", transfer: void 0 });
class AnnotationStorage {
  #Ca = false;
  #ka = null;
  #Ta = null;
  #Fa = /* @__PURE__ */ new Map();
  constructor() {
    this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
  }
  getValue(e2, t2) {
    const i2 = this.#Fa.get(e2);
    return void 0 === i2 ? t2 : Object.assign(t2, i2);
  }
  getRawValue(e2) {
    return this.#Fa.get(e2);
  }
  remove(e2) {
    const t2 = this.#Fa.get(e2);
    if (void 0 !== t2 && (t2 instanceof AnnotationEditor && this.#Ta.delete(t2.annotationElementId), this.#Fa.delete(e2), 0 === this.#Fa.size && this.resetModified(), "function" == typeof this.onAnnotationEditor)) {
      for (const e3 of this.#Fa.values()) if (e3 instanceof AnnotationEditor) return;
      this.onAnnotationEditor(null);
    }
  }
  setValue(e2, t2) {
    const i2 = this.#Fa.get(e2);
    let n2 = false;
    if (void 0 !== i2) for (const [e3, a2] of Object.entries(t2)) i2[e3] !== a2 && (n2 = true, i2[e3] = a2);
    else n2 = true, this.#Fa.set(e2, t2);
    n2 && this.#Ia(), t2 instanceof AnnotationEditor && ((this.#Ta ||= /* @__PURE__ */ new Map()).set(t2.annotationElementId, t2), "function" == typeof this.onAnnotationEditor && this.onAnnotationEditor(t2.constructor._type));
  }
  has(e2) {
    return this.#Fa.has(e2);
  }
  get size() {
    return this.#Fa.size;
  }
  #Ia() {
    this.#Ca || (this.#Ca = true, "function" == typeof this.onSetModified && this.onSetModified());
  }
  resetModified() {
    this.#Ca && (this.#Ca = false, "function" == typeof this.onResetModified && this.onResetModified());
  }
  get print() {
    return new PrintAnnotationStorage(this);
  }
  get serializable() {
    if (0 === this.#Fa.size) return vc;
    const e2 = /* @__PURE__ */ new Map(), t2 = new MurmurHash3_64(), i2 = [], n2 = /* @__PURE__ */ Object.create(null);
    let a2 = false;
    for (const [i3, s2] of this.#Fa) {
      const r2 = s2 instanceof AnnotationEditor ? s2.serialize(false, n2) : s2;
      r2 && (e2.set(i3, r2), t2.update(`${i3}:${JSON.stringify(r2)}`), a2 ||= !!r2.bitmap);
    }
    if (a2) for (const t3 of e2.values()) t3.bitmap && i2.push(t3.bitmap);
    return e2.size > 0 ? { map: e2, hash: t2.hexdigest(), transfer: i2 } : vc;
  }
  get editorStats() {
    let e2 = null;
    const t2 = /* @__PURE__ */ new Map();
    let i2 = 0, n2 = 0;
    for (const a2 of this.#Fa.values()) {
      if (!(a2 instanceof AnnotationEditor)) {
        a2.popup && (a2.popup.deleted ? n2 += 1 : i2 += 1);
        continue;
      }
      a2.isCommentDeleted ? n2 += 1 : a2.hasEditedComment && (i2 += 1);
      const s2 = a2.telemetryFinalData;
      if (!s2) continue;
      const { type: r2 } = s2;
      t2.has(r2) || t2.set(r2, Object.getPrototypeOf(a2).constructor), e2 ||= /* @__PURE__ */ Object.create(null);
      const o2 = e2[r2] ||= /* @__PURE__ */ new Map();
      for (const [e3, t3] of Object.entries(s2)) {
        if ("type" === e3) continue;
        let i3 = o2.get(e3);
        i3 || (i3 = /* @__PURE__ */ new Map(), o2.set(e3, i3));
        const n3 = i3.get(t3) ?? 0;
        i3.set(t3, n3 + 1);
      }
    }
    if ((n2 > 0 || i2 > 0) && (e2 ||= /* @__PURE__ */ Object.create(null), e2.comments = { deleted: n2, edited: i2 }), !e2) return null;
    for (const [i3, n3] of t2) e2[i3] = n3.computeTelemetryFinalData(e2[i3]);
    return e2;
  }
  resetModifiedIds() {
    this.#ka = null;
  }
  updateEditor(e2, t2) {
    const i2 = this.#Ta?.get(e2);
    return !!i2 && (i2.updateFromAnnotationLayer(t2), true);
  }
  getEditor(e2) {
    return this.#Ta?.get(e2) || null;
  }
  get modifiedIds() {
    if (this.#ka) return this.#ka;
    const e2 = [];
    if (this.#Ta) for (const t2 of this.#Ta.values()) t2.serialize() && e2.push(t2.annotationElementId);
    return this.#ka = { ids: new Set(e2), hash: e2.join(",") };
  }
  [Symbol.iterator]() {
    return this.#Fa.entries();
  }
}
class PrintAnnotationStorage extends AnnotationStorage {
  #Ea;
  constructor(e2) {
    super();
    const { map: t2, hash: i2, transfer: n2 } = e2.serializable, a2 = structuredClone(t2, n2 ? { transfer: n2 } : null);
    this.#Ea = { map: a2, hash: i2, transfer: n2 };
  }
  get print() {
    unreachable("Should not call PrintAnnotationStorage.print");
  }
  get serializable() {
    return this.#Ea;
  }
  get modifiedIds() {
    return shadow(this, "modifiedIds", { ids: /* @__PURE__ */ new Set(), hash: "" });
  }
}
class FontLoader {
  #Ma = /* @__PURE__ */ new Set();
  constructor({ ownerDocument: e2 = globalThis.document, styleElement: t2 = null }) {
    this._document = e2, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
  }
  addNativeFontFace(e2) {
    this.nativeFontFaces.add(e2), this._document.fonts.add(e2);
  }
  removeNativeFontFace(e2) {
    this.nativeFontFaces.delete(e2), this._document.fonts.delete(e2);
  }
  insertRule(e2) {
    this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
    const t2 = this.styleElement.sheet;
    t2.insertRule(e2, t2.cssRules.length);
  }
  clear() {
    for (const e2 of this.nativeFontFaces) this._document.fonts.delete(e2);
    this.nativeFontFaces.clear(), this.#Ma.clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
  }
  async loadSystemFont({ systemFontInfo: e2, disableFontFace: t2, _inspectFont: i2 }) {
    if (e2 && !this.#Ma.has(e2.loadedName)) {
      if (assert(!t2, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
        const { loadedName: t3, src: n2, style: a2 } = e2, s2 = new FontFace(t3, n2, a2);
        this.addNativeFontFace(s2);
        try {
          await s2.load(), this.#Ma.add(t3), i2?.(e2);
        } catch {
          warn(`Cannot load system font: ${e2.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(s2);
        }
        return;
      }
      unreachable("Not implemented: loadSystemFont without the Font Loading API.");
    }
  }
  async bind(e2) {
    if (e2.attached || e2.missingFile && !e2.systemFontInfo) return;
    if (e2.attached = true, e2.systemFontInfo) return void await this.loadSystemFont(e2);
    if (this.isFontLoadingAPISupported) {
      const t3 = e2.createNativeFontFace();
      if (t3) {
        this.addNativeFontFace(t3);
        try {
          await t3.loaded;
        } catch (i2) {
          throw warn(`Failed to load font '${t3.family}': '${i2}'.`), e2.disableFontFace = true, i2;
        }
      }
      return;
    }
    const t2 = e2.createFontFaceRule();
    if (t2) {
      if (this.insertRule(t2), this.isSyncFontLoadingSupported) return;
      await new Promise((t3) => {
        const i2 = this._queueLoadingCallback(t3);
        this._prepareFontLoadEvent(e2, i2);
      });
    }
  }
  get isFontLoadingAPISupported() {
    return shadow(this, "isFontLoadingAPISupported", !!this._document?.fonts);
  }
  get isSyncFontLoadingSupported() {
    return shadow(this, "isSyncFontLoadingSupported", Fl || util_FeatureTest.platform.isFirefox);
  }
  _queueLoadingCallback(e2) {
    const { loadingRequests: t2 } = this, i2 = { done: false, complete: function() {
      for (assert(!i2.done, "completeRequest() cannot be called twice."), i2.done = true; t2.length > 0 && t2[0].done; ) {
        const e3 = t2.shift();
        setTimeout(e3.callback, 0);
      }
    }, callback: e2 };
    return t2.push(i2), i2;
  }
  get _loadTestFont() {
    return shadow(this, "_loadTestFont", atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA=="));
  }
  _prepareFontLoadEvent(e2, t2) {
    function int32(e3, t3) {
      return e3.charCodeAt(t3) << 24 | e3.charCodeAt(t3 + 1) << 16 | e3.charCodeAt(t3 + 2) << 8 | 255 & e3.charCodeAt(t3 + 3);
    }
    function spliceString(e3, t3, i3, n3) {
      return e3.substring(0, t3) + n3 + e3.substring(t3 + i3);
    }
    let i2, n2;
    const a2 = this._document.createElement("canvas");
    a2.width = 1, a2.height = 1;
    const s2 = a2.getContext("2d");
    let r2 = 0;
    const o2 = `lt${Date.now()}${this.loadTestFontId++}`;
    let l2 = this._loadTestFont;
    l2 = spliceString(l2, 976, o2.length, o2);
    const c2 = 1482184792;
    let h2 = int32(l2, 16);
    for (i2 = 0, n2 = o2.length - 3; i2 < n2; i2 += 4) h2 = h2 - c2 + int32(o2, i2) | 0;
    var d2;
    i2 < o2.length && (h2 = h2 - c2 + int32(o2 + "XXX", i2) | 0), l2 = spliceString(l2, 16, 4, (d2 = h2, String.fromCharCode(d2 >> 24 & 255, d2 >> 16 & 255, d2 >> 8 & 255, 255 & d2)));
    const u2 = `@font-face {font-family:"${o2}";src:${`url(data:font/opentype;base64,${btoa(l2)});`}}`;
    this.insertRule(u2);
    const g2 = this._document.createElement("div");
    g2.style.visibility = "hidden", g2.style.width = g2.style.height = "10px", g2.style.position = "absolute", g2.style.top = g2.style.left = "0px";
    for (const t3 of [e2.loadedName, o2]) {
      const e3 = this._document.createElement("span");
      e3.textContent = "Hi", e3.style.fontFamily = t3, g2.append(e3);
    }
    this._document.body.append(g2), (function isFontReady(e3, t3) {
      if (++r2 > 30) return warn("Load test font never loaded."), void t3();
      s2.font = "30px " + e3, s2.fillText(".", 0, 20), s2.getImageData(0, 0, 1, 1).data[3] > 0 ? t3() : setTimeout(isFontReady.bind(null, e3, t3));
    })(o2, () => {
      g2.remove(), t2.complete();
    });
  }
}
class FontFaceObject {
  #Da;
  constructor(e2, t2 = null, i2, n2) {
    this.compiledGlyphs = /* @__PURE__ */ Object.create(null), this.#Da = e2, this._inspectFont = t2, i2 && Object.assign(this, i2), n2 && (this.charProcOperatorList = n2);
  }
  createNativeFontFace() {
    if (!this.data || this.disableFontFace) return null;
    let e2;
    if (this.cssFontInfo) {
      const t2 = { weight: this.cssFontInfo.fontWeight };
      this.cssFontInfo.italicAngle && (t2.style = `oblique ${this.cssFontInfo.italicAngle}deg`), e2 = new FontFace(this.cssFontInfo.fontFamily, this.data, t2);
    } else e2 = new FontFace(this.loadedName, this.data, {});
    return this._inspectFont?.(this), e2;
  }
  createFontFaceRule() {
    if (!this.data || this.disableFontFace) return null;
    const e2 = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;
    let t2;
    if (this.cssFontInfo) {
      let i2 = `font-weight: ${this.cssFontInfo.fontWeight};`;
      this.cssFontInfo.italicAngle && (i2 += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), t2 = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${i2}src:${e2}}`;
    } else t2 = `@font-face {font-family:"${this.loadedName}";src:${e2}}`;
    return this._inspectFont?.(this, e2), t2;
  }
  getPathGenerator(e2, t2) {
    if (void 0 !== this.compiledGlyphs[t2]) return this.compiledGlyphs[t2];
    const i2 = this.loadedName + "_path_" + t2;
    let n2;
    try {
      n2 = e2.get(i2);
    } catch (e3) {
      warn(`getPathGenerator - ignoring character: "${e3}".`);
    }
    const a2 = new Path2D(n2 || "");
    return this.fontExtraProperties || e2.delete(i2), this.compiledGlyphs[t2] = a2;
  }
  get black() {
    return this.#Da.black;
  }
  get bold() {
    return this.#Da.bold;
  }
  get disableFontFace() {
    return this.#Da.disableFontFace ?? false;
  }
  get fontExtraProperties() {
    return this.#Da.fontExtraProperties ?? false;
  }
  get isInvalidPDFjsFont() {
    return this.#Da.isInvalidPDFjsFont;
  }
  get isType3Font() {
    return this.#Da.isType3Font;
  }
  get italic() {
    return this.#Da.italic;
  }
  get missingFile() {
    return this.#Da.missingFile;
  }
  get remeasure() {
    return this.#Da.remeasure;
  }
  get vertical() {
    return this.#Da.vertical;
  }
  get ascent() {
    return this.#Da.ascent;
  }
  get defaultWidth() {
    return this.#Da.defaultWidth;
  }
  get descent() {
    return this.#Da.descent;
  }
  get bbox() {
    return this.#Da.bbox;
  }
  get fontMatrix() {
    return this.#Da.fontMatrix;
  }
  get fallbackName() {
    return this.#Da.fallbackName;
  }
  get loadedName() {
    return this.#Da.loadedName;
  }
  get mimetype() {
    return this.#Da.mimetype;
  }
  get name() {
    return this.#Da.name;
  }
  get data() {
    return this.#Da.data;
  }
  clearData() {
    this.#Da.clearData();
  }
  get cssFontInfo() {
    return this.#Da.cssFontInfo;
  }
  get systemFontInfo() {
    return this.#Da.systemFontInfo;
  }
  get defaultVMetrics() {
    return this.#Da.defaultVMetrics;
  }
}
function getFactoryUrlProp(e2) {
  if ("string" != typeof e2) return null;
  if (e2.endsWith("/")) return e2;
  throw new Error(`Invalid factory url: "${e2}" must include trailing slash.`);
}
const isRefProxy = (e2) => "object" == typeof e2 && Number.isInteger(e2?.num) && e2.num >= 0 && Number.isInteger(e2?.gen) && e2.gen >= 0, Cc = (function(e2, t2, i2) {
  if (!Array.isArray(i2) || i2.length < 2) return false;
  const [n2, a2, ...s2] = i2;
  if (!e2(n2) && !Number.isInteger(n2)) return false;
  if (!t2(a2)) return false;
  const r2 = s2.length;
  let o2 = true;
  switch (a2.name) {
    case "XYZ":
      if (r2 < 2 || r2 > 3) return false;
      break;
    case "Fit":
    case "FitB":
      return 0 === r2;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (r2 > 1) return false;
      break;
    case "FitR":
      if (4 !== r2) return false;
      o2 = false;
      break;
    default:
      return false;
  }
  for (const e3 of s2) if (!("number" == typeof e3 || o2 && null === e3)) return false;
  return true;
}).bind(null, isRefProxy, (e2) => "object" == typeof e2 && "string" == typeof e2?.name);
class LoopbackPort {
  #Oa = /* @__PURE__ */ new Map();
  #_a = Promise.resolve();
  postMessage(e2, t2) {
    const i2 = { data: structuredClone(e2, t2 ? { transfer: t2 } : null) };
    this.#_a.then(() => {
      for (const [e3] of this.#Oa) e3.call(this, i2);
    });
  }
  addEventListener(e2, t2, i2 = null) {
    let n2 = null;
    if (i2?.signal instanceof AbortSignal) {
      const { signal: a2 } = i2;
      if (a2.aborted) return void warn("LoopbackPort - cannot use an `aborted` signal.");
      const onAbort = () => this.removeEventListener(e2, t2);
      n2 = () => a2.removeEventListener("abort", onAbort), a2.addEventListener("abort", onAbort);
    }
    this.#Oa.set(t2, n2);
  }
  removeEventListener(e2, t2) {
    const i2 = this.#Oa.get(t2);
    i2?.(), this.#Oa.delete(t2);
  }
  terminate() {
    for (const [, e2] of this.#Oa) e2?.();
    this.#Oa.clear();
  }
}
const kc = 1, Tc = 2, Fc = 1, Ic = 2, Ec = 3, Mc = 4, Dc = 5, Oc = 6, _c = 7, Pc = 8;
function onFn() {
}
function wrapReason(e2) {
  if (e2 instanceof AbortException || e2 instanceof InvalidPDFException || e2 instanceof PasswordException || e2 instanceof ResponseException || e2 instanceof UnknownErrorException) return e2;
  switch (e2 instanceof Error || "object" == typeof e2 && null !== e2 || unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), e2.name) {
    case "AbortException":
      return new AbortException(e2.message);
    case "InvalidPDFException":
      return new InvalidPDFException(e2.message);
    case "PasswordException":
      return new PasswordException(e2.message, e2.code);
    case "ResponseException":
      return new ResponseException(e2.message, e2.status, e2.missing);
    case "UnknownErrorException":
      return new UnknownErrorException(e2.message, e2.details);
  }
  return new UnknownErrorException(e2.message, e2.toString());
}
class MessageHandler {
  #rt = new AbortController();
  constructor(e2, t2, i2) {
    this.sourceName = e2, this.targetName = t2, this.comObj = i2, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), i2.addEventListener("message", this.#ot.bind(this), { signal: this.#rt.signal });
  }
  #ot({ data: e2 }) {
    if (e2.targetName !== this.sourceName) return;
    if (e2.stream) return void this.#lt(e2);
    if (e2.callback) {
      const t3 = e2.callbackId, i2 = this.callbackCapabilities[t3];
      if (!i2) throw new Error(`Cannot resolve callback ${t3}`);
      if (delete this.callbackCapabilities[t3], e2.callback === kc) i2.resolve(e2.data);
      else {
        if (e2.callback !== Tc) throw new Error("Unexpected callback case");
        i2.reject(wrapReason(e2.reason));
      }
      return;
    }
    const t2 = this.actionHandler[e2.action];
    if (!t2) throw new Error(`Unknown action from worker: ${e2.action}`);
    if (e2.callbackId) {
      const i2 = this.sourceName, n2 = e2.sourceName, a2 = this.comObj;
      return void Promise.try(t2, e2.data).then(function(t3) {
        a2.postMessage({ sourceName: i2, targetName: n2, callback: kc, callbackId: e2.callbackId, data: t3 });
      }, function(t3) {
        a2.postMessage({ sourceName: i2, targetName: n2, callback: Tc, callbackId: e2.callbackId, reason: wrapReason(t3) });
      });
    }
    e2.streamId ? this.#ct(e2) : t2(e2.data);
  }
  on(e2, t2) {
    const i2 = this.actionHandler;
    if (i2[e2]) throw new Error(`There is already an actionName called "${e2}"`);
    i2[e2] = t2;
  }
  send(e2, t2, i2) {
    this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e2, data: t2 }, i2);
  }
  sendWithPromise(e2, t2, i2) {
    const n2 = this.callbackId++, a2 = Promise.withResolvers();
    this.callbackCapabilities[n2] = a2;
    try {
      this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e2, callbackId: n2, data: t2 }, i2);
    } catch (e3) {
      a2.reject(e3);
    }
    return a2.promise;
  }
  sendWithStream(e2, t2, i2, n2) {
    const a2 = this.streamId++, s2 = this.sourceName, r2 = this.targetName, o2 = this.comObj;
    return new ReadableStream({ start: (i3) => {
      const l2 = Promise.withResolvers();
      return this.streamControllers[a2] = { controller: i3, startCall: l2, pullCall: null, cancelCall: null, isClosed: false }, o2.postMessage({ sourceName: s2, targetName: r2, action: e2, streamId: a2, data: t2, desiredSize: i3.desiredSize }, n2), l2.promise;
    }, pull: (e3) => {
      const t3 = Promise.withResolvers();
      return this.streamControllers[a2].pullCall = t3, o2.postMessage({ sourceName: s2, targetName: r2, stream: Oc, streamId: a2, desiredSize: e3.desiredSize }), t3.promise;
    }, cancel: (e3) => {
      assert(e3 instanceof Error, "cancel must have a valid reason");
      const t3 = Promise.withResolvers();
      return this.streamControllers[a2].cancelCall = t3, this.streamControllers[a2].isClosed = true, o2.postMessage({ sourceName: s2, targetName: r2, stream: Fc, streamId: a2, reason: wrapReason(e3) }), t3.promise;
    } }, i2);
  }
  #ct(e2) {
    const t2 = e2.streamId, i2 = this.sourceName, n2 = e2.sourceName, a2 = this.comObj, s2 = this, r2 = this.actionHandler[e2.action], o2 = { enqueue(e3, s3 = 1, r3) {
      if (this.isCancelled) return;
      const o3 = this.desiredSize;
      this.desiredSize -= s3, o3 > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), a2.postMessage({ sourceName: i2, targetName: n2, stream: Mc, streamId: t2, chunk: e3 }, r3);
    }, close() {
      this.isCancelled || (this.isCancelled = true, a2.postMessage({ sourceName: i2, targetName: n2, stream: Ec, streamId: t2 }), delete s2.streamSinks[t2]);
    }, error(e3) {
      assert(e3 instanceof Error, "error must have a valid reason"), this.isCancelled || (this.isCancelled = true, a2.postMessage({ sourceName: i2, targetName: n2, stream: Dc, streamId: t2, reason: wrapReason(e3) }));
    }, sinkCapability: Promise.withResolvers(), onPull: null, onCancel: null, isCancelled: false, desiredSize: e2.desiredSize, ready: null };
    o2.sinkCapability.resolve(), o2.ready = o2.sinkCapability.promise, this.streamSinks[t2] = o2, Promise.try(r2, e2.data, o2).then(function() {
      a2.postMessage({ sourceName: i2, targetName: n2, stream: Pc, streamId: t2, success: true });
    }, function(e3) {
      a2.postMessage({ sourceName: i2, targetName: n2, stream: Pc, streamId: t2, reason: wrapReason(e3) });
    });
  }
  #lt(e2) {
    const t2 = e2.streamId, i2 = this.sourceName, n2 = e2.sourceName, a2 = this.comObj, s2 = this.streamControllers[t2], r2 = this.streamSinks[t2];
    switch (e2.stream) {
      case Pc:
        e2.success ? s2.startCall.resolve() : s2.startCall.reject(wrapReason(e2.reason));
        break;
      case _c:
        e2.success ? s2.pullCall.resolve() : s2.pullCall.reject(wrapReason(e2.reason));
        break;
      case Oc:
        if (!r2) {
          a2.postMessage({ sourceName: i2, targetName: n2, stream: _c, streamId: t2, success: true });
          break;
        }
        r2.desiredSize <= 0 && e2.desiredSize > 0 && r2.sinkCapability.resolve(), r2.desiredSize = e2.desiredSize, Promise.try(r2.onPull || onFn).then(function() {
          a2.postMessage({ sourceName: i2, targetName: n2, stream: _c, streamId: t2, success: true });
        }, function(e3) {
          a2.postMessage({ sourceName: i2, targetName: n2, stream: _c, streamId: t2, reason: wrapReason(e3) });
        });
        break;
      case Mc:
        if (assert(s2, "enqueue should have stream controller"), s2.isClosed) break;
        s2.controller.enqueue(e2.chunk);
        break;
      case Ec:
        if (assert(s2, "close should have stream controller"), s2.isClosed) break;
        s2.isClosed = true, s2.controller.close(), this.#ht(s2, t2);
        break;
      case Dc:
        assert(s2, "error should have stream controller"), s2.controller.error(wrapReason(e2.reason)), this.#ht(s2, t2);
        break;
      case Ic:
        e2.success ? s2.cancelCall.resolve() : s2.cancelCall.reject(wrapReason(e2.reason)), this.#ht(s2, t2);
        break;
      case Fc:
        if (!r2) break;
        const o2 = wrapReason(e2.reason);
        Promise.try(r2.onCancel || onFn, o2).then(function() {
          a2.postMessage({ sourceName: i2, targetName: n2, stream: Ic, streamId: t2, success: true });
        }, function(e3) {
          a2.postMessage({ sourceName: i2, targetName: n2, stream: Ic, streamId: t2, reason: wrapReason(e3) });
        }), r2.sinkCapability.reject(o2), r2.isCancelled = true, delete this.streamSinks[t2];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  }
  async #ht(e2, t2) {
    await Promise.allSettled([e2.startCall?.promise, e2.pullCall?.promise, e2.cancelCall?.promise]), delete this.streamControllers[t2];
  }
  destroy() {
    this.#rt?.abort(), this.#rt = null;
  }
}
class BaseCanvasFactory {
  #Pa = false;
  constructor({ enableHWA: e2 = false }) {
    this.#Pa = e2;
  }
  create(e2, t2) {
    if (e2 <= 0 || t2 <= 0) throw new Error("Invalid canvas size");
    const i2 = this._createCanvas(e2, t2);
    return { canvas: i2, context: i2.getContext("2d", { willReadFrequently: !this.#Pa }) };
  }
  reset(e2, t2, i2) {
    if (!e2.canvas) throw new Error("Canvas is not specified");
    if (t2 <= 0 || i2 <= 0) throw new Error("Invalid canvas size");
    e2.canvas.width = t2, e2.canvas.height = i2;
  }
  destroy(e2) {
    if (!e2.canvas) throw new Error("Canvas is not specified");
    e2.canvas.width = 0, e2.canvas.height = 0, e2.canvas = null, e2.context = null;
  }
  _createCanvas(e2, t2) {
    unreachable("Abstract method `_createCanvas` called.");
  }
}
class DOMCanvasFactory extends BaseCanvasFactory {
  constructor({ ownerDocument: e2 = globalThis.document, enableHWA: t2 = false }) {
    super({ enableHWA: t2 }), this._document = e2;
  }
  _createCanvas(e2, t2) {
    const i2 = this._document.createElement("canvas");
    return i2.width = e2, i2.height = t2, i2;
  }
}
class BaseCMapReaderFactory {
  constructor({ baseUrl: e2 = null, isCompressed: t2 = true }) {
    this.baseUrl = e2, this.isCompressed = t2;
  }
  async fetch({ name: e2 }) {
    if (!this.baseUrl) throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
    if (!e2) throw new Error("CMap name must be specified.");
    const t2 = this.baseUrl + e2 + (this.isCompressed ? ".bcmap" : "");
    return this._fetch(t2).then((e3) => ({ cMapData: e3, isCompressed: this.isCompressed })).catch((e3) => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${t2}`);
    });
  }
  async _fetch(e2) {
    unreachable("Abstract method `_fetch` called.");
  }
}
class DOMCMapReaderFactory extends BaseCMapReaderFactory {
  async _fetch(e2) {
    const t2 = await fetchData(e2, this.isCompressed ? "arraybuffer" : "text");
    return t2 instanceof ArrayBuffer ? new Uint8Array(t2) : stringToBytes(t2);
  }
}
class BaseFilterFactory {
  addFilter(e2) {
    return "none";
  }
  addHCMFilter(e2, t2) {
    return "none";
  }
  addAlphaFilter(e2) {
    return "none";
  }
  addLuminosityFilter(e2) {
    return "none";
  }
  addHighlightHCMFilter(e2, t2, i2, n2, a2) {
    return "none";
  }
  destroy(e2 = false) {
  }
}
class DOMFilterFactory extends BaseFilterFactory {
  #Ra;
  #Ba;
  #Na;
  #La;
  #Ua;
  #ja;
  #Mt = 0;
  constructor({ docId: e2, ownerDocument: t2 = globalThis.document }) {
    super(), this.#La = e2, this.#Ua = t2;
  }
  get #Ot() {
    return this.#Ba ||= /* @__PURE__ */ new Map();
  }
  get #$a() {
    return this.#ja ||= /* @__PURE__ */ new Map();
  }
  get #Ha() {
    if (!this.#Na) {
      const e2 = this.#Ua.createElement("div"), { style: t2 } = e2;
      t2.visibility = "hidden", t2.contain = "strict", t2.width = t2.height = 0, t2.position = "absolute", t2.top = t2.left = 0, t2.zIndex = -1;
      const i2 = this.#Ua.createElementNS(bc, "svg");
      i2.setAttribute("width", 0), i2.setAttribute("height", 0), this.#Na = this.#Ua.createElementNS(bc, "defs"), e2.append(i2), i2.append(this.#Na), this.#Ua.body.append(e2);
    }
    return this.#Na;
  }
  #Xa(e2) {
    if (1 === e2.length) {
      const t3 = e2[0], i3 = new Array(256);
      for (let e3 = 0; e3 < 256; e3++) i3[e3] = t3[e3] / 255;
      const n3 = i3.join(",");
      return [n3, n3, n3];
    }
    const [t2, i2, n2] = e2, a2 = new Array(256), s2 = new Array(256), r2 = new Array(256);
    for (let e3 = 0; e3 < 256; e3++) a2[e3] = t2[e3] / 255, s2[e3] = i2[e3] / 255, r2[e3] = n2[e3] / 255;
    return [a2.join(","), s2.join(","), r2.join(",")];
  }
  #qa(e2) {
    if (void 0 === this.#Ra) {
      this.#Ra = "";
      const e3 = this.#Ua.URL;
      e3 !== this.#Ua.baseURI && (isDataScheme(e3) ? warn('#createUrl: ignore "data:"-URL for performance reasons.') : this.#Ra = updateUrlHash(e3, ""));
    }
    return `url(${this.#Ra}#${e2})`;
  }
  addFilter(e2) {
    if (!e2) return "none";
    let t2 = this.#Ot.get(e2);
    if (t2) return t2;
    const [i2, n2, a2] = this.#Xa(e2), s2 = 1 === e2.length ? i2 : `${i2}${n2}${a2}`;
    if (t2 = this.#Ot.get(s2), t2) return this.#Ot.set(e2, t2), t2;
    const r2 = `g_${this.#La}_transfer_map_${this.#Mt++}`, o2 = this.#qa(r2);
    this.#Ot.set(e2, o2), this.#Ot.set(s2, o2);
    const l2 = this.#za(r2);
    return this.#Wa(i2, n2, a2, l2), o2;
  }
  addHCMFilter(e2, t2) {
    const i2 = `${e2}-${t2}`, n2 = "base";
    let a2 = this.#$a.get(n2);
    if (a2?.key === i2) return a2.url;
    if (a2 ? (a2.filter?.remove(), a2.key = i2, a2.url = "none", a2.filter = null) : (a2 = { key: i2, url: "none", filter: null }, this.#$a.set(n2, a2)), !e2 || !t2) return a2.url;
    const s2 = this.#Ga(e2);
    e2 = Util.makeHexColor(...s2);
    const r2 = this.#Ga(t2);
    if (t2 = Util.makeHexColor(...r2), this.#Ha.style.color = "", "#000000" === e2 && "#ffffff" === t2 || e2 === t2) return a2.url;
    const o2 = new Array(256);
    for (let e3 = 0; e3 <= 255; e3++) {
      const t3 = e3 / 255;
      o2[e3] = t3 <= 0.03928 ? t3 / 12.92 : ((t3 + 0.055) / 1.055) ** 2.4;
    }
    const l2 = o2.join(","), c2 = `g_${this.#La}_hcm_filter`, h2 = a2.filter = this.#za(c2);
    this.#Wa(l2, l2, l2, h2), this.#Va(h2);
    const getSteps = (e3, t3) => {
      const i3 = s2[e3] / 255, n3 = r2[e3] / 255, a3 = new Array(t3 + 1);
      for (let e4 = 0; e4 <= t3; e4++) a3[e4] = i3 + e4 / t3 * (n3 - i3);
      return a3.join(",");
    };
    return this.#Wa(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), h2), a2.url = this.#qa(c2), a2.url;
  }
  addAlphaFilter(e2) {
    let t2 = this.#Ot.get(e2);
    if (t2) return t2;
    const [i2] = this.#Xa([e2]), n2 = `alpha_${i2}`;
    if (t2 = this.#Ot.get(n2), t2) return this.#Ot.set(e2, t2), t2;
    const a2 = `g_${this.#La}_alpha_map_${this.#Mt++}`, s2 = this.#qa(a2);
    this.#Ot.set(e2, s2), this.#Ot.set(n2, s2);
    const r2 = this.#za(a2);
    return this.#Ka(i2, r2), s2;
  }
  addLuminosityFilter(e2) {
    let t2, i2, n2 = this.#Ot.get(e2 || "luminosity");
    if (n2) return n2;
    if (e2 ? ([t2] = this.#Xa([e2]), i2 = `luminosity_${t2}`) : i2 = "luminosity", n2 = this.#Ot.get(i2), n2) return this.#Ot.set(e2, n2), n2;
    const a2 = `g_${this.#La}_luminosity_map_${this.#Mt++}`, s2 = this.#qa(a2);
    this.#Ot.set(e2, s2), this.#Ot.set(i2, s2);
    const r2 = this.#za(a2);
    return this.#Ya(r2), e2 && this.#Ka(t2, r2), s2;
  }
  addHighlightHCMFilter(e2, t2, i2, n2, a2) {
    const s2 = `${t2}-${i2}-${n2}-${a2}`;
    let r2 = this.#$a.get(e2);
    if (r2?.key === s2) return r2.url;
    if (r2 ? (r2.filter?.remove(), r2.key = s2, r2.url = "none", r2.filter = null) : (r2 = { key: s2, url: "none", filter: null }, this.#$a.set(e2, r2)), !t2 || !i2) return r2.url;
    const [o2, l2] = [t2, i2].map(this.#Ga.bind(this));
    let c2 = Math.round(0.2126 * o2[0] + 0.7152 * o2[1] + 0.0722 * o2[2]), h2 = Math.round(0.2126 * l2[0] + 0.7152 * l2[1] + 0.0722 * l2[2]), [d2, u2] = [n2, a2].map(this.#Ga.bind(this));
    h2 < c2 && ([c2, h2, d2, u2] = [h2, c2, u2, d2]), this.#Ha.style.color = "";
    const getSteps = (e3, t3, i3) => {
      const n3 = new Array(256), a3 = (h2 - c2) / i3, s3 = e3 / 255, r3 = (t3 - e3) / (255 * i3);
      let o3 = 0;
      for (let e4 = 0; e4 <= i3; e4++) {
        const t4 = Math.round(c2 + e4 * a3), i4 = s3 + e4 * r3;
        for (let e5 = o3; e5 <= t4; e5++) n3[e5] = i4;
        o3 = t4 + 1;
      }
      for (let e4 = o3; e4 < 256; e4++) n3[e4] = n3[o3 - 1];
      return n3.join(",");
    }, g2 = `g_${this.#La}_hcm_${e2}_filter`, f2 = r2.filter = this.#za(g2);
    return this.#Va(f2), this.#Wa(getSteps(d2[0], u2[0], 5), getSteps(d2[1], u2[1], 5), getSteps(d2[2], u2[2], 5), f2), r2.url = this.#qa(g2), r2.url;
  }
  destroy(e2 = false) {
    e2 && this.#ja?.size || (this.#Na?.parentNode.parentNode.remove(), this.#Na = null, this.#Ba?.clear(), this.#Ba = null, this.#ja?.clear(), this.#ja = null, this.#Mt = 0);
  }
  #Ya(e2) {
    const t2 = this.#Ua.createElementNS(bc, "feColorMatrix");
    t2.setAttribute("type", "matrix"), t2.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0"), e2.append(t2);
  }
  #Va(e2) {
    const t2 = this.#Ua.createElementNS(bc, "feColorMatrix");
    t2.setAttribute("type", "matrix"), t2.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), e2.append(t2);
  }
  #za(e2) {
    const t2 = this.#Ua.createElementNS(bc, "filter");
    return t2.setAttribute("color-interpolation-filters", "sRGB"), t2.setAttribute("id", e2), this.#Ha.append(t2), t2;
  }
  #Ja(e2, t2, i2) {
    const n2 = this.#Ua.createElementNS(bc, t2);
    n2.setAttribute("type", "discrete"), n2.setAttribute("tableValues", i2), e2.append(n2);
  }
  #Wa(e2, t2, i2, n2) {
    const a2 = this.#Ua.createElementNS(bc, "feComponentTransfer");
    n2.append(a2), this.#Ja(a2, "feFuncR", e2), this.#Ja(a2, "feFuncG", t2), this.#Ja(a2, "feFuncB", i2);
  }
  #Ka(e2, t2) {
    const i2 = this.#Ua.createElementNS(bc, "feComponentTransfer");
    t2.append(i2), this.#Ja(i2, "feFuncA", e2);
  }
  #Ga(e2) {
    return this.#Ha.style.color = e2, getRGB(getComputedStyle(this.#Ha).getPropertyValue("color"));
  }
}
class BaseStandardFontDataFactory {
  constructor({ baseUrl: e2 = null }) {
    this.baseUrl = e2;
  }
  async fetch({ filename: e2 }) {
    if (!this.baseUrl) throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
    if (!e2) throw new Error("Font filename must be specified.");
    const t2 = `${this.baseUrl}${e2}`;
    return this._fetch(t2).catch((e3) => {
      throw new Error(`Unable to load font data at: ${t2}`);
    });
  }
  async _fetch(e2) {
    unreachable("Abstract method `_fetch` called.");
  }
}
class DOMStandardFontDataFactory extends BaseStandardFontDataFactory {
  async _fetch(e2) {
    const t2 = await fetchData(e2, "arraybuffer");
    return new Uint8Array(t2);
  }
}
class BaseWasmFactory {
  constructor({ baseUrl: e2 = null }) {
    this.baseUrl = e2;
  }
  async fetch({ filename: e2 }) {
    if (!this.baseUrl) throw new Error("Ensure that the `wasmUrl` API parameter is provided.");
    if (!e2) throw new Error("Wasm filename must be specified.");
    const t2 = `${this.baseUrl}${e2}`;
    return this._fetch(t2).catch((e3) => {
      throw new Error(`Unable to load wasm data at: ${t2}`);
    });
  }
  async _fetch(e2) {
    unreachable("Abstract method `_fetch` called.");
  }
}
class DOMWasmFactory extends BaseWasmFactory {
  async _fetch(e2) {
    const t2 = await fetchData(e2, "arraybuffer");
    return new Uint8Array(t2);
  }
}
async function node_utils_fetchData(e2) {
  const t2 = process.getBuiltinModule("fs"), i2 = await t2.promises.readFile(e2);
  return new Uint8Array(i2);
}
class NodeFilterFactory extends BaseFilterFactory {
}
class NodeCanvasFactory extends BaseCanvasFactory {
  _createCanvas(e2, t2) {
    process.getBuiltinModule("module").createRequire(import.meta.url);
    return new Proxy({}, { get: (e3, t3) => () => {
      throw new Error("@napi-rs/canvas is not available in this environment");
    } }).createCanvas(e2, t2);
  }
}
class NodeCMapReaderFactory extends BaseCMapReaderFactory {
  async _fetch(e2) {
    return node_utils_fetchData(e2);
  }
}
class NodeStandardFontDataFactory extends BaseStandardFontDataFactory {
  async _fetch(e2) {
    return node_utils_fetchData(e2);
  }
}
class NodeWasmFactory extends BaseWasmFactory {
  async _fetch(e2) {
    return node_utils_fetchData(e2);
  }
}
const Rc = "__forcedDependency", { floor: Bc, ceil: Nc } = Math;
function expandBBox(e2, t2, i2, n2, a2, s2) {
  e2[4 * t2 + 0] = Math.min(e2[4 * t2 + 0], i2), e2[4 * t2 + 1] = Math.min(e2[4 * t2 + 1], n2), e2[4 * t2 + 2] = Math.max(e2[4 * t2 + 2], a2), e2[4 * t2 + 3] = Math.max(e2[4 * t2 + 3], s2);
}
const Lc = new Uint32Array(new Uint8Array([255, 255, 0, 0]).buffer)[0];
class BBoxReader {
  #Za;
  #Qa;
  constructor(e2, t2) {
    this.#Za = e2, this.#Qa = t2;
  }
  get length() {
    return this.#Za.length;
  }
  isEmpty(e2) {
    return this.#Za[e2] === Lc;
  }
  minX(e2) {
    return this.#Qa[4 * e2 + 0] / 256;
  }
  minY(e2) {
    return this.#Qa[4 * e2 + 1] / 256;
  }
  maxX(e2) {
    return (this.#Qa[4 * e2 + 2] + 1) / 256;
  }
  maxY(e2) {
    return (this.#Qa[4 * e2 + 3] + 1) / 256;
  }
}
const ensureDebugMetadata = (e2, t2) => {
  if (!e2) return;
  let i2 = e2.get(t2);
  return i2 || (i2 = { dependencies: /* @__PURE__ */ new Set(), isRenderingOperation: false }, e2.set(t2, i2)), i2;
};
class CanvasDependencyTracker {
  #es = { __proto__: null };
  #ts = { __proto__: null, transform: [], moveText: [], sameLineText: [], [Rc]: [] };
  #is = /* @__PURE__ */ new Map();
  #ns = [];
  #as = [];
  #ss = [[1, 0, 0, 1, 0, 0]];
  #rs = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
  #os = new Float64Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
  #ls = -1;
  #cs = /* @__PURE__ */ new Set();
  #hs = /* @__PURE__ */ new Map();
  #ds = /* @__PURE__ */ new Map();
  #us;
  #gs;
  #fs;
  #Za;
  #ps;
  constructor(e2, t2, i2 = false) {
    this.#us = e2.width, this.#gs = e2.height, this.#ms(t2), i2 && (this.#ps = /* @__PURE__ */ new Map());
  }
  growOperationsCount(e2) {
    e2 >= this.#Za.length && this.#ms(e2, this.#Za);
  }
  #ms(e2, t2) {
    const i2 = new ArrayBuffer(4 * e2);
    this.#fs = new Uint8ClampedArray(i2), this.#Za = new Uint32Array(i2), t2 && t2.length > 0 ? (this.#Za.set(t2), this.#Za.fill(Lc, t2.length)) : this.#Za.fill(Lc);
  }
  save(e2) {
    return this.#es = { __proto__: this.#es }, this.#ts = { __proto__: this.#ts, transform: { __proto__: this.#ts.transform }, moveText: { __proto__: this.#ts.moveText }, sameLineText: { __proto__: this.#ts.sameLineText }, [Rc]: { __proto__: this.#ts[Rc] } }, this.#rs = { __proto__: this.#rs }, this.#ns.push(e2), this;
  }
  restore(e2) {
    const t2 = Object.getPrototypeOf(this.#es);
    if (null === t2) return this;
    this.#es = t2, this.#ts = Object.getPrototypeOf(this.#ts), this.#rs = Object.getPrototypeOf(this.#rs);
    const i2 = this.#ns.pop();
    return void 0 !== i2 && (ensureDebugMetadata(this.#ps, e2)?.dependencies.add(i2), this.#Za[e2] = this.#Za[i2]), this;
  }
  recordOpenMarker(e2) {
    return this.#ns.push(e2), this;
  }
  getOpenMarker() {
    return 0 === this.#ns.length ? null : this.#ns.at(-1);
  }
  recordCloseMarker(e2) {
    const t2 = this.#ns.pop();
    return void 0 !== t2 && (ensureDebugMetadata(this.#ps, e2)?.dependencies.add(t2), this.#Za[e2] = this.#Za[t2]), this;
  }
  beginMarkedContent(e2) {
    return this.#as.push(e2), this;
  }
  endMarkedContent(e2) {
    const t2 = this.#as.pop();
    return void 0 !== t2 && (ensureDebugMetadata(this.#ps, e2)?.dependencies.add(t2), this.#Za[e2] = this.#Za[t2]), this;
  }
  pushBaseTransform(e2) {
    return this.#ss.push(Util.multiplyByDOMMatrix(this.#ss.at(-1), e2.getTransform())), this;
  }
  popBaseTransform() {
    return this.#ss.length > 1 && this.#ss.pop(), this;
  }
  recordSimpleData(e2, t2) {
    return this.#es[e2] = t2, this;
  }
  recordIncrementalData(e2, t2) {
    return this.#ts[e2].push(t2), this;
  }
  resetIncrementalData(e2, t2) {
    return this.#ts[e2].length = 0, this;
  }
  recordNamedData(e2, t2) {
    return this.#is.set(e2, t2), this;
  }
  recordSimpleDataFromNamed(e2, t2, i2) {
    this.#es[e2] = this.#is.get(t2) ?? i2;
  }
  recordFutureForcedDependency(e2, t2) {
    return this.recordIncrementalData(Rc, t2), this;
  }
  inheritSimpleDataAsFutureForcedDependencies(e2) {
    for (const t2 of e2) t2 in this.#es && this.recordFutureForcedDependency(t2, this.#es[t2]);
    return this;
  }
  inheritPendingDependenciesAsFutureForcedDependencies() {
    for (const e2 of this.#cs) this.recordFutureForcedDependency(Rc, e2);
    return this;
  }
  resetBBox(e2) {
    return this.#ls !== e2 && (this.#ls = e2, this.#os[0] = 1 / 0, this.#os[1] = 1 / 0, this.#os[2] = -1 / 0, this.#os[3] = -1 / 0), this;
  }
  recordClipBox(e2, t2, i2, n2, a2, s2) {
    const r2 = Util.multiplyByDOMMatrix(this.#ss.at(-1), t2.getTransform()), o2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    Util.axialAlignedBoundingBox([i2, a2, n2, s2], r2, o2);
    const l2 = Util.intersect(this.#rs, o2);
    return l2 ? (this.#rs[0] = l2[0], this.#rs[1] = l2[1], this.#rs[2] = l2[2], this.#rs[3] = l2[3]) : (this.#rs[0] = this.#rs[1] = 1 / 0, this.#rs[2] = this.#rs[3] = -1 / 0), this;
  }
  recordBBox(e2, t2, i2, n2, a2, s2) {
    const r2 = this.#rs;
    if (r2[0] === 1 / 0) return this;
    const o2 = Util.multiplyByDOMMatrix(this.#ss.at(-1), t2.getTransform());
    if (r2[0] === -1 / 0) return Util.axialAlignedBoundingBox([i2, a2, n2, s2], o2, this.#os), this;
    const l2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    return Util.axialAlignedBoundingBox([i2, a2, n2, s2], o2, l2), this.#os[0] = Math.min(this.#os[0], Math.max(l2[0], r2[0])), this.#os[1] = Math.min(this.#os[1], Math.max(l2[1], r2[1])), this.#os[2] = Math.max(this.#os[2], Math.min(l2[2], r2[2])), this.#os[3] = Math.max(this.#os[3], Math.min(l2[3], r2[3])), this;
  }
  recordCharacterBBox(e2, t2, i2, n2 = 1, a2 = 0, s2 = 0, r2) {
    const o2 = i2.bbox;
    let l2, c2;
    if (o2 && (l2 = o2[2] !== o2[0] && o2[3] !== o2[1] && this.#ds.get(i2), false !== l2 && (c2 = [0, 0, 0, 0], Util.axialAlignedBoundingBox(o2, i2.fontMatrix, c2), 1 === n2 && 0 === a2 && 0 === s2 || Util.scaleMinMax([n2, 0, 0, -n2, a2, s2], c2), l2))) return this.recordBBox(e2, t2, c2[0], c2[2], c2[1], c2[3]);
    if (!r2) return this.recordFullPageBBox(e2);
    const h2 = r2();
    return o2 && c2 && void 0 === l2 && (l2 = c2[0] <= a2 - h2.actualBoundingBoxLeft && c2[2] >= a2 + h2.actualBoundingBoxRight && c2[1] <= s2 - h2.actualBoundingBoxAscent && c2[3] >= s2 + h2.actualBoundingBoxDescent, this.#ds.set(i2, l2), l2) ? this.recordBBox(e2, t2, c2[0], c2[2], c2[1], c2[3]) : this.recordBBox(e2, t2, a2 - h2.actualBoundingBoxLeft, a2 + h2.actualBoundingBoxRight, s2 - h2.actualBoundingBoxAscent, s2 + h2.actualBoundingBoxDescent);
  }
  recordFullPageBBox(e2) {
    return this.#os[0] = Math.max(0, this.#rs[0]), this.#os[1] = Math.max(0, this.#rs[1]), this.#os[2] = Math.min(this.#us, this.#rs[2]), this.#os[3] = Math.min(this.#gs, this.#rs[3]), this;
  }
  getSimpleIndex(e2) {
    return this.#es[e2];
  }
  recordDependencies(e2, t2) {
    const i2 = this.#cs, n2 = this.#es, a2 = this.#ts;
    for (const e3 of t2) e3 in this.#es ? i2.add(n2[e3]) : e3 in a2 && a2[e3].forEach(i2.add, i2);
    return this;
  }
  recordNamedDependency(e2, t2) {
    return this.#is.has(t2) && this.#cs.add(this.#is.get(t2)), this;
  }
  recordOperation(e2, t2 = false) {
    if (this.recordDependencies(e2, [Rc]), this.#ps) {
      const t3 = ensureDebugMetadata(this.#ps, e2), { dependencies: i2 } = t3;
      this.#cs.forEach(i2.add, i2), this.#ns.forEach(i2.add, i2), this.#as.forEach(i2.add, i2), i2.delete(e2), t3.isRenderingOperation = true;
    }
    if (this.#ls === e2) {
      const i2 = Bc(256 * this.#os[0] / this.#us), n2 = Bc(256 * this.#os[1] / this.#gs), a2 = Nc(256 * this.#os[2] / this.#us), s2 = Nc(256 * this.#os[3] / this.#gs);
      expandBBox(this.#fs, e2, i2, n2, a2, s2);
      for (const t3 of this.#cs) t3 !== e2 && expandBBox(this.#fs, t3, i2, n2, a2, s2);
      for (const t3 of this.#ns) t3 !== e2 && expandBBox(this.#fs, t3, i2, n2, a2, s2);
      for (const t3 of this.#as) t3 !== e2 && expandBBox(this.#fs, t3, i2, n2, a2, s2);
      t2 || (this.#cs.clear(), this.#ls = -1);
    }
    return this;
  }
  recordShowTextOperation(e2, t2 = false) {
    const i2 = Array.from(this.#cs);
    this.recordOperation(e2, t2), this.recordIncrementalData("sameLineText", e2);
    for (const e3 of i2) this.recordIncrementalData("sameLineText", e3);
    return this;
  }
  bboxToClipBoxDropOperation(e2, t2 = false) {
    return this.#ls === e2 && (this.#ls = -1, this.#rs[0] = Math.max(this.#rs[0], this.#os[0]), this.#rs[1] = Math.max(this.#rs[1], this.#os[1]), this.#rs[2] = Math.min(this.#rs[2], this.#os[2]), this.#rs[3] = Math.min(this.#rs[3], this.#os[3]), t2 || this.#cs.clear()), this;
  }
  _takePendingDependencies() {
    const e2 = this.#cs;
    return this.#cs = /* @__PURE__ */ new Set(), e2;
  }
  _extractOperation(e2) {
    const t2 = this.#hs.get(e2);
    return this.#hs.delete(e2), t2;
  }
  _pushPendingDependencies(e2) {
    for (const t2 of e2) this.#cs.add(t2);
  }
  take() {
    return this.#ds.clear(), new BBoxReader(this.#Za, this.#fs);
  }
  takeDebugMetadata() {
    return this.#ps;
  }
}
class CanvasNestedDependencyTracker {
  #bs;
  #ys;
  #ws;
  #As = 0;
  #xs = 0;
  constructor(e2, t2, i2) {
    if (e2 instanceof CanvasNestedDependencyTracker && e2.#ws === !!i2) return e2;
    this.#bs = e2, this.#ys = t2, this.#ws = !!i2;
  }
  growOperationsCount() {
    throw new Error("Unreachable");
  }
  save(e2) {
    return this.#xs++, this.#bs.save(this.#ys), this;
  }
  restore(e2) {
    return this.#xs > 0 && (this.#bs.restore(this.#ys), this.#xs--), this;
  }
  recordOpenMarker(e2) {
    return this.#As++, this;
  }
  getOpenMarker() {
    return this.#As > 0 ? this.#ys : this.#bs.getOpenMarker();
  }
  recordCloseMarker(e2) {
    return this.#As--, this;
  }
  beginMarkedContent(e2) {
    return this;
  }
  endMarkedContent(e2) {
    return this;
  }
  pushBaseTransform(e2) {
    return this.#bs.pushBaseTransform(e2), this;
  }
  popBaseTransform() {
    return this.#bs.popBaseTransform(), this;
  }
  recordSimpleData(e2, t2) {
    return this.#bs.recordSimpleData(e2, this.#ys), this;
  }
  recordIncrementalData(e2, t2) {
    return this.#bs.recordIncrementalData(e2, this.#ys), this;
  }
  resetIncrementalData(e2, t2) {
    return this.#bs.resetIncrementalData(e2, this.#ys), this;
  }
  recordNamedData(e2, t2) {
    return this;
  }
  recordSimpleDataFromNamed(e2, t2, i2) {
    return this.#bs.recordSimpleDataFromNamed(e2, t2, this.#ys), this;
  }
  recordFutureForcedDependency(e2, t2) {
    return this.#bs.recordFutureForcedDependency(e2, this.#ys), this;
  }
  inheritSimpleDataAsFutureForcedDependencies(e2) {
    return this.#bs.inheritSimpleDataAsFutureForcedDependencies(e2), this;
  }
  inheritPendingDependenciesAsFutureForcedDependencies() {
    return this.#bs.inheritPendingDependenciesAsFutureForcedDependencies(), this;
  }
  resetBBox(e2) {
    return this.#ws || this.#bs.resetBBox(this.#ys), this;
  }
  recordClipBox(e2, t2, i2, n2, a2, s2) {
    return this.#ws || this.#bs.recordClipBox(this.#ys, t2, i2, n2, a2, s2), this;
  }
  recordBBox(e2, t2, i2, n2, a2, s2) {
    return this.#ws || this.#bs.recordBBox(this.#ys, t2, i2, n2, a2, s2), this;
  }
  recordCharacterBBox(e2, t2, i2, n2, a2, s2, r2) {
    return this.#ws || this.#bs.recordCharacterBBox(this.#ys, t2, i2, n2, a2, s2, r2), this;
  }
  recordFullPageBBox(e2) {
    return this.#ws || this.#bs.recordFullPageBBox(this.#ys), this;
  }
  getSimpleIndex(e2) {
    return this.#bs.getSimpleIndex(e2);
  }
  recordDependencies(e2, t2) {
    return this.#bs.recordDependencies(this.#ys, t2), this;
  }
  recordNamedDependency(e2, t2) {
    return this.#bs.recordNamedDependency(this.#ys, t2), this;
  }
  recordOperation(e2) {
    return this.#bs.recordOperation(this.#ys, true), this;
  }
  recordShowTextOperation(e2) {
    return this.#bs.recordShowTextOperation(this.#ys, true), this;
  }
  bboxToClipBoxDropOperation(e2) {
    return this.#ws || this.#bs.bboxToClipBoxDropOperation(this.#ys, true), this;
  }
  take() {
    throw new Error("Unreachable");
  }
  takeDebugMetadata() {
    throw new Error("Unreachable");
  }
}
const Uc = ["path", "transform", "filter", "strokeColor", "strokeAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "dash"], jc = ["path", "transform", "filter", "fillColor", "fillAlpha", "globalCompositeOperation", "SMask"], $c = ["transform", "SMask", "filter", "fillAlpha", "strokeAlpha", "globalCompositeOperation"], Hc = ["filter", "fillColor", "fillAlpha"], Xc = ["transform", "leading", "charSpacing", "wordSpacing", "hScale", "textRise", "moveText", "textMatrix", "font", "fontObj", "filter", "fillColor", "textRenderingMode", "SMask", "fillAlpha", "strokeAlpha", "globalCompositeOperation", "sameLineText"], qc = ["transform"], zc = ["transform", "fillColor"], Wc = "Fill", Gc = "Stroke", Vc = "Shading";
function applyBoundingBox(e2, t2) {
  if (!t2) return;
  const i2 = t2[2] - t2[0], n2 = t2[3] - t2[1], a2 = new Path2D();
  a2.rect(t2[0], t2[1], i2, n2), e2.clip(a2);
}
class BaseShadingPattern {
  isModifyingCurrentTransform() {
    return false;
  }
  getPattern() {
    unreachable("Abstract method `getPattern` called.");
  }
}
class RadialAxialShadingPattern extends BaseShadingPattern {
  constructor(e2) {
    super(), this._type = e2[1], this._bbox = e2[2], this._colorStops = e2[3], this._p0 = e2[4], this._p1 = e2[5], this._r0 = e2[6], this._r1 = e2[7], this.matrix = null;
  }
  _createGradient(e2) {
    let t2;
    "axial" === this._type ? t2 = e2.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : "radial" === this._type && (t2 = e2.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
    for (const e3 of this._colorStops) t2.addColorStop(e3[0], e3[1]);
    return t2;
  }
  getPattern(e2, t2, i2, n2) {
    let a2;
    if (n2 === Gc || n2 === Wc) {
      const s2 = t2.current.getClippedPathBoundingBox(n2, getCurrentTransform(e2)) || [0, 0, 0, 0], r2 = Math.ceil(s2[2] - s2[0]) || 1, o2 = Math.ceil(s2[3] - s2[1]) || 1, l2 = t2.cachedCanvases.getCanvas("pattern", r2, o2), c2 = l2.context;
      c2.clearRect(0, 0, c2.canvas.width, c2.canvas.height), c2.beginPath(), c2.rect(0, 0, c2.canvas.width, c2.canvas.height), c2.translate(-s2[0], -s2[1]), i2 = Util.transform(i2, [1, 0, 0, 1, s2[0], s2[1]]), c2.transform(...t2.baseTransform), this.matrix && c2.transform(...this.matrix), applyBoundingBox(c2, this._bbox), c2.fillStyle = this._createGradient(c2), c2.fill(), a2 = e2.createPattern(l2.canvas, "no-repeat");
      const h2 = new DOMMatrix(i2);
      a2.setTransform(h2);
    } else applyBoundingBox(e2, this._bbox), a2 = this._createGradient(e2);
    return a2;
  }
}
function drawTriangle(e2, t2, i2, n2, a2, s2, r2, o2) {
  const l2 = t2.coords, c2 = t2.colors, h2 = e2.data, d2 = 4 * e2.width;
  let u2;
  l2[i2 + 1] > l2[n2 + 1] && (u2 = i2, i2 = n2, n2 = u2, u2 = s2, s2 = r2, r2 = u2), l2[n2 + 1] > l2[a2 + 1] && (u2 = n2, n2 = a2, a2 = u2, u2 = r2, r2 = o2, o2 = u2), l2[i2 + 1] > l2[n2 + 1] && (u2 = i2, i2 = n2, n2 = u2, u2 = s2, s2 = r2, r2 = u2);
  const g2 = (l2[i2] + t2.offsetX) * t2.scaleX, f2 = (l2[i2 + 1] + t2.offsetY) * t2.scaleY, p2 = (l2[n2] + t2.offsetX) * t2.scaleX, m2 = (l2[n2 + 1] + t2.offsetY) * t2.scaleY, b2 = (l2[a2] + t2.offsetX) * t2.scaleX, y2 = (l2[a2 + 1] + t2.offsetY) * t2.scaleY;
  if (f2 >= y2) return;
  const w2 = c2[s2], x2 = c2[s2 + 1], S2 = c2[s2 + 2], v2 = c2[r2], C2 = c2[r2 + 1], k2 = c2[r2 + 2], T2 = c2[o2], F2 = c2[o2 + 1], E2 = c2[o2 + 2], M2 = Math.round(f2), D2 = Math.round(y2);
  let O2, _2, R2, N2, L2, U2, j2, $2;
  for (let e3 = M2; e3 <= D2; e3++) {
    if (e3 < m2) {
      const t4 = e3 < f2 ? 0 : (f2 - e3) / (f2 - m2);
      O2 = g2 - (g2 - p2) * t4, _2 = w2 - (w2 - v2) * t4, R2 = x2 - (x2 - C2) * t4, N2 = S2 - (S2 - k2) * t4;
    } else {
      let t4;
      t4 = e3 > y2 ? 1 : m2 === y2 ? 0 : (m2 - e3) / (m2 - y2), O2 = p2 - (p2 - b2) * t4, _2 = v2 - (v2 - T2) * t4, R2 = C2 - (C2 - F2) * t4, N2 = k2 - (k2 - E2) * t4;
    }
    let t3;
    t3 = e3 < f2 ? 0 : e3 > y2 ? 1 : (f2 - e3) / (f2 - y2), L2 = g2 - (g2 - b2) * t3, U2 = w2 - (w2 - T2) * t3, j2 = x2 - (x2 - F2) * t3, $2 = S2 - (S2 - E2) * t3;
    const i3 = Math.round(Math.min(O2, L2)), n3 = Math.round(Math.max(O2, L2));
    let a3 = d2 * e3 + 4 * i3;
    for (let e4 = i3; e4 <= n3; e4++) t3 = (O2 - e4) / (O2 - L2), t3 < 0 ? t3 = 0 : t3 > 1 && (t3 = 1), h2[a3++] = _2 - (_2 - U2) * t3 | 0, h2[a3++] = R2 - (R2 - j2) * t3 | 0, h2[a3++] = N2 - (N2 - $2) * t3 | 0, h2[a3++] = 255;
  }
}
function drawFigure(e2, t2, i2) {
  const n2 = t2.coords, a2 = t2.colors;
  let s2, r2;
  switch (t2.type) {
    case "lattice":
      const o2 = t2.verticesPerRow, l2 = Math.floor(n2.length / o2) - 1, c2 = o2 - 1;
      for (s2 = 0; s2 < l2; s2++) {
        let t3 = s2 * o2;
        for (let s3 = 0; s3 < c2; s3++, t3++) drawTriangle(e2, i2, n2[t3], n2[t3 + 1], n2[t3 + o2], a2[t3], a2[t3 + 1], a2[t3 + o2]), drawTriangle(e2, i2, n2[t3 + o2 + 1], n2[t3 + 1], n2[t3 + o2], a2[t3 + o2 + 1], a2[t3 + 1], a2[t3 + o2]);
      }
      break;
    case "triangles":
      for (s2 = 0, r2 = n2.length; s2 < r2; s2 += 3) drawTriangle(e2, i2, n2[s2], n2[s2 + 1], n2[s2 + 2], a2[s2], a2[s2 + 1], a2[s2 + 2]);
      break;
    default:
      throw new Error("illegal figure");
  }
}
class MeshShadingPattern extends BaseShadingPattern {
  constructor(e2) {
    super(), this._coords = e2[2], this._colors = e2[3], this._figures = e2[4], this._bounds = e2[5], this._bbox = e2[6], this._background = e2[7], this.matrix = null;
  }
  _createMeshCanvas(e2, t2, i2) {
    const n2 = Math.floor(this._bounds[0]), a2 = Math.floor(this._bounds[1]), s2 = Math.ceil(this._bounds[2]) - n2, r2 = Math.ceil(this._bounds[3]) - a2, o2 = Math.min(Math.ceil(Math.abs(s2 * e2[0] * 1.1)), 3e3), l2 = Math.min(Math.ceil(Math.abs(r2 * e2[1] * 1.1)), 3e3), c2 = s2 / o2, h2 = r2 / l2, d2 = { coords: this._coords, colors: this._colors, offsetX: -n2, offsetY: -a2, scaleX: 1 / c2, scaleY: 1 / h2 }, u2 = o2 + 4, g2 = l2 + 4, f2 = i2.getCanvas("mesh", u2, g2), p2 = f2.context, m2 = p2.createImageData(o2, l2);
    if (t2) {
      const e3 = m2.data;
      for (let i3 = 0, n3 = e3.length; i3 < n3; i3 += 4) e3[i3] = t2[0], e3[i3 + 1] = t2[1], e3[i3 + 2] = t2[2], e3[i3 + 3] = 255;
    }
    for (const e3 of this._figures) drawFigure(m2, e3, d2);
    p2.putImageData(m2, 2, 2);
    return { canvas: f2.canvas, offsetX: n2 - 2 * c2, offsetY: a2 - 2 * h2, scaleX: c2, scaleY: h2 };
  }
  isModifyingCurrentTransform() {
    return true;
  }
  getPattern(e2, t2, i2, n2) {
    applyBoundingBox(e2, this._bbox);
    const a2 = new Float32Array(2);
    if (n2 === Vc) Util.singularValueDecompose2dScale(getCurrentTransform(e2), a2);
    else if (this.matrix) {
      Util.singularValueDecompose2dScale(this.matrix, a2);
      const [e3, i3] = a2;
      Util.singularValueDecompose2dScale(t2.baseTransform, a2), a2[0] *= e3, a2[1] *= i3;
    } else Util.singularValueDecompose2dScale(t2.baseTransform, a2);
    const s2 = this._createMeshCanvas(a2, n2 === Vc ? null : this._background, t2.cachedCanvases);
    return n2 !== Vc && (e2.setTransform(...t2.baseTransform), this.matrix && e2.transform(...this.matrix)), e2.translate(s2.offsetX, s2.offsetY), e2.scale(s2.scaleX, s2.scaleY), e2.createPattern(s2.canvas, "no-repeat");
  }
}
class DummyShadingPattern extends BaseShadingPattern {
  getPattern() {
    return "hotpink";
  }
}
const Kc = 1, Yc = 2;
class TilingPattern {
  static MAX_PATTERN_SIZE = 3e3;
  constructor(e2, t2, i2, n2) {
    this.color = e2[1], this.operatorList = e2[2], this.matrix = e2[3], this.bbox = e2[4], this.xstep = e2[5], this.ystep = e2[6], this.paintType = e2[7], this.tilingType = e2[8], this.ctx = t2, this.canvasGraphicsFactory = i2, this.baseTransform = n2;
  }
  createPatternCanvas(e2, t2) {
    const { bbox: i2, operatorList: n2, paintType: a2, tilingType: s2, color: r2, canvasGraphicsFactory: o2 } = this;
    let { xstep: l2, ystep: c2 } = this;
    l2 = Math.abs(l2), c2 = Math.abs(c2), info("TilingType: " + s2);
    const h2 = i2[0], d2 = i2[1], u2 = i2[2], g2 = i2[3], f2 = u2 - h2, p2 = g2 - d2, m2 = new Float32Array(2);
    Util.singularValueDecompose2dScale(this.matrix, m2);
    const [b2, y2] = m2;
    Util.singularValueDecompose2dScale(this.baseTransform, m2);
    const w2 = b2 * m2[0], x2 = y2 * m2[1];
    let S2 = f2, v2 = p2, C2 = false, k2 = false;
    const T2 = Math.ceil(l2 * w2), F2 = Math.ceil(c2 * x2);
    T2 >= Math.ceil(f2 * w2) ? S2 = l2 : C2 = true, F2 >= Math.ceil(p2 * x2) ? v2 = c2 : k2 = true;
    const E2 = this.getSizeAndScale(S2, this.ctx.canvas.width, w2), M2 = this.getSizeAndScale(v2, this.ctx.canvas.height, x2), D2 = e2.cachedCanvases.getCanvas("pattern", E2.size, M2.size), O2 = D2.context, _2 = o2.createCanvasGraphics(O2, t2);
    if (_2.groupLevel = e2.groupLevel, this.setFillAndStrokeStyleToContext(_2, a2, r2), O2.translate(-E2.scale * h2, -M2.scale * d2), _2.transform(0, E2.scale, 0, 0, M2.scale, 0, 0), O2.save(), _2.dependencyTracker?.save(), this.clipBbox(_2, h2, d2, u2, g2), _2.baseTransform = getCurrentTransform(_2.ctx), _2.executeOperatorList(n2), _2.endDrawing(), _2.dependencyTracker?.restore(), O2.restore(), C2 || k2) {
      const t3 = D2.canvas;
      C2 && (S2 = l2), k2 && (v2 = c2);
      const i3 = this.getSizeAndScale(S2, this.ctx.canvas.width, w2), n3 = this.getSizeAndScale(v2, this.ctx.canvas.height, x2), a3 = i3.size, s3 = n3.size, r3 = e2.cachedCanvases.getCanvas("pattern-workaround", a3, s3), o3 = r3.context, u3 = C2 ? Math.floor(f2 / l2) : 0, g3 = k2 ? Math.floor(p2 / c2) : 0;
      for (let e3 = 0; e3 <= u3; e3++) for (let i4 = 0; i4 <= g3; i4++) o3.drawImage(t3, a3 * e3, s3 * i4, a3, s3, 0, 0, a3, s3);
      return { canvas: r3.canvas, scaleX: i3.scale, scaleY: n3.scale, offsetX: h2, offsetY: d2 };
    }
    return { canvas: D2.canvas, scaleX: E2.scale, scaleY: M2.scale, offsetX: h2, offsetY: d2 };
  }
  getSizeAndScale(e2, t2, i2) {
    const n2 = Math.max(TilingPattern.MAX_PATTERN_SIZE, t2);
    let a2 = Math.ceil(e2 * i2);
    return a2 >= n2 ? a2 = n2 : i2 = a2 / e2, { scale: i2, size: a2 };
  }
  clipBbox(e2, t2, i2, n2, a2) {
    const s2 = n2 - t2, r2 = a2 - i2;
    e2.ctx.rect(t2, i2, s2, r2), Util.axialAlignedBoundingBox([t2, i2, n2, a2], getCurrentTransform(e2.ctx), e2.current.minMax), e2.clip(), e2.endPath();
  }
  setFillAndStrokeStyleToContext(e2, t2, i2) {
    const n2 = e2.ctx, a2 = e2.current;
    switch (t2) {
      case Kc:
        const { fillStyle: e3, strokeStyle: s2 } = this.ctx;
        n2.fillStyle = a2.fillColor = e3, n2.strokeStyle = a2.strokeColor = s2;
        break;
      case Yc:
        n2.fillStyle = n2.strokeStyle = i2, a2.fillColor = a2.strokeColor = i2;
        break;
      default:
        throw new FormatError(`Unsupported paint type: ${t2}`);
    }
  }
  isModifyingCurrentTransform() {
    return false;
  }
  getPattern(e2, t2, i2, n2, a2) {
    let s2 = i2;
    n2 !== Vc && (s2 = Util.transform(s2, t2.baseTransform), this.matrix && (s2 = Util.transform(s2, this.matrix)));
    const r2 = this.createPatternCanvas(t2, a2);
    let o2 = new DOMMatrix(s2);
    o2 = o2.translate(r2.offsetX, r2.offsetY), o2 = o2.scale(1 / r2.scaleX, 1 / r2.scaleY);
    const l2 = e2.createPattern(r2.canvas, "repeat");
    return l2.setTransform(o2), l2;
  }
}
function convertBlackAndWhiteToRGBA({ src: e2, srcPos: t2 = 0, dest: i2, width: n2, height: a2, nonBlackColor: s2 = 4294967295, inverseDecode: r2 = false }) {
  const o2 = util_FeatureTest.isLittleEndian ? 4278190080 : 255, [l2, c2] = r2 ? [s2, o2] : [o2, s2], h2 = n2 >> 3, d2 = 7 & n2, u2 = e2.length;
  i2 = new Uint32Array(i2.buffer);
  let g2 = 0;
  for (let n3 = 0; n3 < a2; n3++) {
    for (const n5 = t2 + h2; t2 < n5; t2++) {
      const n6 = t2 < u2 ? e2[t2] : 255;
      i2[g2++] = 128 & n6 ? c2 : l2, i2[g2++] = 64 & n6 ? c2 : l2, i2[g2++] = 32 & n6 ? c2 : l2, i2[g2++] = 16 & n6 ? c2 : l2, i2[g2++] = 8 & n6 ? c2 : l2, i2[g2++] = 4 & n6 ? c2 : l2, i2[g2++] = 2 & n6 ? c2 : l2, i2[g2++] = 1 & n6 ? c2 : l2;
    }
    if (0 === d2) continue;
    const n4 = t2 < u2 ? e2[t2++] : 255;
    for (let e3 = 0; e3 < d2; e3++) i2[g2++] = n4 & 1 << 7 - e3 ? c2 : l2;
  }
  return { srcPos: t2, destPos: g2 };
}
const Jc = 16, Zc = new DOMMatrix(), Qc = new Float32Array(2), eh = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
class CachedCanvases {
  constructor(e2) {
    this.canvasFactory = e2, this.cache = /* @__PURE__ */ Object.create(null);
  }
  getCanvas(e2, t2, i2) {
    let n2;
    return void 0 !== this.cache[e2] ? (n2 = this.cache[e2], this.canvasFactory.reset(n2, t2, i2)) : (n2 = this.canvasFactory.create(t2, i2), this.cache[e2] = n2), n2;
  }
  delete(e2) {
    delete this.cache[e2];
  }
  clear() {
    for (const e2 in this.cache) {
      const t2 = this.cache[e2];
      this.canvasFactory.destroy(t2), delete this.cache[e2];
    }
  }
}
function drawImageAtIntegerCoords(e2, t2, i2, n2, a2, s2, r2, o2, l2, c2) {
  const [h2, d2, u2, g2, f2, p2] = getCurrentTransform(e2);
  if (0 === d2 && 0 === u2) {
    const m2 = r2 * h2 + f2, b2 = Math.round(m2), y2 = o2 * g2 + p2, w2 = Math.round(y2), x2 = (r2 + l2) * h2 + f2, S2 = Math.abs(Math.round(x2) - b2) || 1, v2 = (o2 + c2) * g2 + p2, C2 = Math.abs(Math.round(v2) - w2) || 1;
    return e2.setTransform(Math.sign(h2), 0, 0, Math.sign(g2), b2, w2), e2.drawImage(t2, i2, n2, a2, s2, 0, 0, S2, C2), e2.setTransform(h2, d2, u2, g2, f2, p2), [S2, C2];
  }
  if (0 === h2 && 0 === g2) {
    const m2 = o2 * u2 + f2, b2 = Math.round(m2), y2 = r2 * d2 + p2, w2 = Math.round(y2), x2 = (o2 + c2) * u2 + f2, S2 = Math.abs(Math.round(x2) - b2) || 1, v2 = (r2 + l2) * d2 + p2, C2 = Math.abs(Math.round(v2) - w2) || 1;
    return e2.setTransform(0, Math.sign(d2), Math.sign(u2), 0, b2, w2), e2.drawImage(t2, i2, n2, a2, s2, 0, 0, C2, S2), e2.setTransform(h2, d2, u2, g2, f2, p2), [C2, S2];
  }
  e2.drawImage(t2, i2, n2, a2, s2, r2, o2, l2, c2);
  return [Math.hypot(h2, d2) * l2, Math.hypot(u2, g2) * c2];
}
class CanvasExtraState {
  alphaIsShape = false;
  fontSize = 0;
  fontSizeScale = 1;
  textMatrix = null;
  textMatrixScale = 1;
  fontMatrix = Il;
  leading = 0;
  x = 0;
  y = 0;
  lineX = 0;
  lineY = 0;
  charSpacing = 0;
  wordSpacing = 0;
  textHScale = 1;
  textRenderingMode = zl;
  textRise = 0;
  fillColor = "#000000";
  strokeColor = "#000000";
  patternFill = false;
  patternStroke = false;
  fillAlpha = 1;
  strokeAlpha = 1;
  lineWidth = 1;
  activeSMask = null;
  transferMaps = "none";
  constructor(e2, t2, i2) {
    i2?.(this), this.clipBox = new Float32Array([0, 0, e2, t2]), this.minMax = eh.slice();
  }
  clone() {
    const e2 = Object.create(this);
    return e2.clipBox = this.clipBox.slice(), e2.minMax = this.minMax.slice(), e2;
  }
  getPathBoundingBox(e2 = Wc, t2 = null) {
    const i2 = this.minMax.slice();
    if (e2 === Gc) {
      t2 || unreachable("Stroke bounding box must include transform."), Util.singularValueDecompose2dScale(t2, Qc);
      const e3 = Qc[0] * this.lineWidth / 2, n2 = Qc[1] * this.lineWidth / 2;
      i2[0] -= e3, i2[1] -= n2, i2[2] += e3, i2[3] += n2;
    }
    return i2;
  }
  updateClipFromPath() {
    const e2 = Util.intersect(this.clipBox, this.getPathBoundingBox());
    this.startNewPathAndClipBox(e2 || [0, 0, 0, 0]);
  }
  isEmptyClip() {
    return this.minMax[0] === 1 / 0;
  }
  startNewPathAndClipBox(e2) {
    this.clipBox.set(e2, 0), this.minMax.set(eh, 0);
  }
  getClippedPathBoundingBox(e2 = Wc, t2 = null) {
    return Util.intersect(this.clipBox, this.getPathBoundingBox(e2, t2));
  }
}
function putBinaryImageData(e2, t2) {
  if (t2 instanceof ImageData) return void e2.putImageData(t2, 0, 0);
  const i2 = t2.height, n2 = t2.width, a2 = i2 % Jc, s2 = (i2 - a2) / Jc, r2 = 0 === a2 ? s2 : s2 + 1, o2 = e2.createImageData(n2, Jc);
  let l2, c2 = 0;
  const h2 = t2.data, d2 = o2.data;
  let u2, g2, f2, p2;
  if (t2.kind === Jl.GRAYSCALE_1BPP) {
    const t3 = h2.byteLength, i3 = new Uint32Array(d2.buffer, 0, d2.byteLength >> 2), p3 = i3.length, m2 = n2 + 7 >> 3, b2 = 4294967295, y2 = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
    for (u2 = 0; u2 < r2; u2++) {
      for (f2 = u2 < s2 ? Jc : a2, l2 = 0, g2 = 0; g2 < f2; g2++) {
        const e3 = t3 - c2;
        let a3 = 0;
        const s3 = e3 > m2 ? n2 : 8 * e3 - 7, r3 = -8 & s3;
        let o3 = 0, d3 = 0;
        for (; a3 < r3; a3 += 8) d3 = h2[c2++], i3[l2++] = 128 & d3 ? b2 : y2, i3[l2++] = 64 & d3 ? b2 : y2, i3[l2++] = 32 & d3 ? b2 : y2, i3[l2++] = 16 & d3 ? b2 : y2, i3[l2++] = 8 & d3 ? b2 : y2, i3[l2++] = 4 & d3 ? b2 : y2, i3[l2++] = 2 & d3 ? b2 : y2, i3[l2++] = 1 & d3 ? b2 : y2;
        for (; a3 < s3; a3++) 0 === o3 && (d3 = h2[c2++], o3 = 128), i3[l2++] = d3 & o3 ? b2 : y2, o3 >>= 1;
      }
      for (; l2 < p3; ) i3[l2++] = 0;
      e2.putImageData(o2, 0, u2 * Jc);
    }
  } else if (t2.kind === Jl.RGBA_32BPP) {
    for (g2 = 0, p2 = n2 * Jc * 4, u2 = 0; u2 < s2; u2++) d2.set(h2.subarray(c2, c2 + p2)), c2 += p2, e2.putImageData(o2, 0, g2), g2 += Jc;
    u2 < r2 && (p2 = n2 * a2 * 4, d2.set(h2.subarray(c2, c2 + p2)), e2.putImageData(o2, 0, g2));
  } else {
    if (t2.kind !== Jl.RGB_24BPP) throw new Error(`bad image kind: ${t2.kind}`);
    for (f2 = Jc, p2 = n2 * f2, u2 = 0; u2 < r2; u2++) {
      for (u2 >= s2 && (f2 = a2, p2 = n2 * f2), l2 = 0, g2 = p2; g2--; ) d2[l2++] = h2[c2++], d2[l2++] = h2[c2++], d2[l2++] = h2[c2++], d2[l2++] = 255;
      e2.putImageData(o2, 0, u2 * Jc);
    }
  }
}
function putBinaryImageMask(e2, t2) {
  if (t2.bitmap) return void e2.drawImage(t2.bitmap, 0, 0);
  const i2 = t2.height, n2 = t2.width, a2 = i2 % Jc, s2 = (i2 - a2) / Jc, r2 = 0 === a2 ? s2 : s2 + 1, o2 = e2.createImageData(n2, Jc);
  let l2 = 0;
  const c2 = t2.data, h2 = o2.data;
  for (let t3 = 0; t3 < r2; t3++) {
    const i3 = t3 < s2 ? Jc : a2;
    ({ srcPos: l2 } = convertBlackAndWhiteToRGBA({ src: c2, srcPos: l2, dest: h2, width: n2, height: i3, nonBlackColor: 0 })), e2.putImageData(o2, 0, t3 * Jc);
  }
}
function copyCtxState(e2, t2) {
  const i2 = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const n2 of i2) void 0 !== e2[n2] && (t2[n2] = e2[n2]);
  void 0 !== e2.setLineDash && (t2.setLineDash(e2.getLineDash()), t2.lineDashOffset = e2.lineDashOffset);
}
function resetCtxToDefault(e2) {
  e2.strokeStyle = e2.fillStyle = "#000000", e2.fillRule = "nonzero", e2.globalAlpha = 1, e2.lineWidth = 1, e2.lineCap = "butt", e2.lineJoin = "miter", e2.miterLimit = 10, e2.globalCompositeOperation = "source-over", e2.font = "10px sans-serif", void 0 !== e2.setLineDash && (e2.setLineDash([]), e2.lineDashOffset = 0);
  const { filter: t2 } = e2;
  "none" !== t2 && "" !== t2 && (e2.filter = "none");
}
function getImageSmoothingEnabled(e2, t2) {
  if (t2) return true;
  Util.singularValueDecompose2dScale(e2, Qc);
  const i2 = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);
  return Qc[0] <= i2 && Qc[1] <= i2;
}
const th = ["butt", "round", "square"], ih = ["miter", "round", "bevel"], nh = {}, ah = {};
class CanvasGraphics {
  constructor(e2, t2, i2, n2, a2, { optionalContentConfig: s2, markedContentStack: r2 = null }, o2, l2, c2) {
    this.ctx = e2, this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = false, this.res = null, this.xobjs = null, this.commonObjs = t2, this.objs = i2, this.canvasFactory = n2, this.filterFactory = a2, this.groupStack = [], this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = true, this.markedContentStack = r2 || [], this.optionalContentConfig = s2, this.cachedCanvases = new CachedCanvases(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = o2, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = l2, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map(), this.dependencyTracker = c2 ?? null;
  }
  getObject(e2, t2, i2 = null) {
    return "string" == typeof t2 ? (this.dependencyTracker?.recordNamedDependency(e2, t2), t2.startsWith("g_") ? this.commonObjs.get(t2) : this.objs.get(t2)) : i2;
  }
  beginDrawing({ transform: e2, viewport: t2, transparency: i2 = false, background: n2 = null }) {
    const a2 = this.ctx.canvas.width, s2 = this.ctx.canvas.height, r2 = this.ctx.fillStyle;
    if (this.ctx.fillStyle = n2 || "#ffffff", this.ctx.fillRect(0, 0, a2, s2), this.ctx.fillStyle = r2, i2) {
      const e3 = this.cachedCanvases.getCanvas("transparent", a2, s2);
      this.compositeCtx = this.ctx, this.transparentCanvas = e3.canvas, this.ctx = e3.context, this.ctx.save(), this.ctx.transform(...getCurrentTransform(this.compositeCtx));
    }
    this.ctx.save(), resetCtxToDefault(this.ctx), e2 && (this.ctx.transform(...e2), this.outputScaleX = e2[0], this.outputScaleY = e2[0]), this.ctx.transform(...t2.transform), this.viewportScale = t2.scale, this.baseTransform = getCurrentTransform(this.ctx);
  }
  executeOperatorList(e2, t2, i2, n2, a2) {
    const s2 = e2.argsArray, r2 = e2.fnArray;
    let o2 = t2 || 0;
    const l2 = s2.length;
    if (l2 === o2) return o2;
    const c2 = l2 - o2 > 10 && "function" == typeof i2, h2 = c2 ? Date.now() + 15 : 0;
    let d2 = 0;
    const u2 = this.commonObjs, g2 = this.objs;
    let f2, p2;
    for (; ; ) {
      if (void 0 !== n2 && o2 === n2.nextBreakPoint) return n2.breakIt(o2, i2), o2;
      if (!a2 || a2(o2)) if (f2 = r2[o2], p2 = s2[o2] ?? null, f2 !== sc.dependency) null === p2 ? this[f2](o2) : this[f2](o2, ...p2);
      else for (const e3 of p2) {
        this.dependencyTracker?.recordNamedData(e3, o2);
        const t3 = e3.startsWith("g_") ? u2 : g2;
        if (!t3.has(e3)) return t3.get(e3, i2), o2;
      }
      if (o2++, o2 === l2) return o2;
      if (c2 && ++d2 > 10) {
        if (Date.now() > h2) return i2(), o2;
        d2 = 0;
      }
    }
  }
  #Ss() {
    for (; this.stateStack.length || this.inSMaskMode; ) this.restore();
    this.current.activeSMask = null, this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
  }
  endDrawing() {
    this.#Ss(), this.cachedCanvases.clear(), this.cachedPatterns.clear();
    for (const e2 of this._cachedBitmapsMap.values()) {
      for (const t2 of e2.values()) "undefined" != typeof HTMLCanvasElement && t2 instanceof HTMLCanvasElement && (t2.width = t2.height = 0);
      e2.clear();
    }
    this._cachedBitmapsMap.clear(), this.#vs();
  }
  #vs() {
    if (this.pageColors) {
      const e2 = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
      if ("none" !== e2) {
        const t2 = this.ctx.filter;
        this.ctx.filter = e2, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = t2;
      }
    }
  }
  _scaleImage(e2, t2) {
    const i2 = e2.width ?? e2.displayWidth, n2 = e2.height ?? e2.displayHeight;
    let a2, s2, r2 = Math.max(Math.hypot(t2[0], t2[1]), 1), o2 = Math.max(Math.hypot(t2[2], t2[3]), 1), l2 = i2, c2 = n2, h2 = "prescale1";
    for (; r2 > 2 && l2 > 1 || o2 > 2 && c2 > 1; ) {
      let t3 = l2, i3 = c2;
      r2 > 2 && l2 > 1 && (t3 = l2 >= 16384 ? Math.floor(l2 / 2) - 1 || 1 : Math.ceil(l2 / 2), r2 /= l2 / t3), o2 > 2 && c2 > 1 && (i3 = c2 >= 16384 ? Math.floor(c2 / 2) - 1 || 1 : Math.ceil(c2) / 2, o2 /= c2 / i3), a2 = this.cachedCanvases.getCanvas(h2, t3, i3), s2 = a2.context, s2.clearRect(0, 0, t3, i3), s2.drawImage(e2, 0, 0, l2, c2, 0, 0, t3, i3), e2 = a2.canvas, l2 = t3, c2 = i3, h2 = "prescale1" === h2 ? "prescale2" : "prescale1";
    }
    return { img: e2, paintWidth: l2, paintHeight: c2 };
  }
  _createMaskCanvas(e2, t2) {
    const i2 = this.ctx, { width: n2, height: a2 } = t2, s2 = this.current.fillColor, r2 = this.current.patternFill, o2 = getCurrentTransform(i2);
    let l2, c2, h2, d2;
    if ((t2.bitmap || t2.data) && t2.count > 1) {
      const i3 = t2.bitmap || t2.data.buffer;
      c2 = JSON.stringify(r2 ? o2 : [o2.slice(0, 4), s2]), l2 = this._cachedBitmapsMap.get(i3), l2 || (l2 = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(i3, l2));
      const n3 = l2.get(c2);
      if (n3 && !r2) {
        const t3 = Math.round(Math.min(o2[0], o2[2]) + o2[4]), i4 = Math.round(Math.min(o2[1], o2[3]) + o2[5]);
        return this.dependencyTracker?.recordDependencies(e2, zc), { canvas: n3, offsetX: t3, offsetY: i4 };
      }
      h2 = n3;
    }
    h2 || (d2 = this.cachedCanvases.getCanvas("maskCanvas", n2, a2), putBinaryImageMask(d2.context, t2));
    let u2 = Util.transform(o2, [1 / n2, 0, 0, -1 / a2, 0, 0]);
    u2 = Util.transform(u2, [1, 0, 0, 1, 0, -a2]);
    const g2 = eh.slice();
    Util.axialAlignedBoundingBox([0, 0, n2, a2], u2, g2);
    const [f2, p2, m2, b2] = g2, y2 = Math.round(m2 - f2) || 1, w2 = Math.round(b2 - p2) || 1, x2 = this.cachedCanvases.getCanvas("fillCanvas", y2, w2), S2 = x2.context, v2 = f2, C2 = p2;
    S2.translate(-v2, -C2), S2.transform(...u2), h2 || (h2 = this._scaleImage(d2.canvas, getCurrentTransformInverse(S2)), h2 = h2.img, l2 && r2 && l2.set(c2, h2)), S2.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(S2), t2.interpolate), drawImageAtIntegerCoords(S2, h2, 0, 0, h2.width, h2.height, 0, 0, n2, a2), S2.globalCompositeOperation = "source-in";
    const k2 = Util.transform(getCurrentTransformInverse(S2), [1, 0, 0, 1, -v2, -C2]);
    return S2.fillStyle = r2 ? s2.getPattern(i2, this, k2, Wc, e2) : s2, S2.fillRect(0, 0, n2, a2), l2 && !r2 && (this.cachedCanvases.delete("fillCanvas"), l2.set(c2, x2.canvas)), this.dependencyTracker?.recordDependencies(e2, zc), { canvas: x2.canvas, offsetX: Math.round(v2), offsetY: Math.round(C2) };
  }
  setLineWidth(e2, t2) {
    this.dependencyTracker?.recordSimpleData("lineWidth", e2), t2 !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = t2, this.ctx.lineWidth = t2;
  }
  setLineCap(e2, t2) {
    this.dependencyTracker?.recordSimpleData("lineCap", e2), this.ctx.lineCap = th[t2];
  }
  setLineJoin(e2, t2) {
    this.dependencyTracker?.recordSimpleData("lineJoin", e2), this.ctx.lineJoin = ih[t2];
  }
  setMiterLimit(e2, t2) {
    this.dependencyTracker?.recordSimpleData("miterLimit", e2), this.ctx.miterLimit = t2;
  }
  setDash(e2, t2, i2) {
    this.dependencyTracker?.recordSimpleData("dash", e2);
    const n2 = this.ctx;
    void 0 !== n2.setLineDash && (n2.setLineDash(t2), n2.lineDashOffset = i2);
  }
  setRenderingIntent(e2, t2) {
  }
  setFlatness(e2, t2) {
  }
  setGState(e2, t2) {
    for (const [i2, n2] of t2) switch (i2) {
      case "LW":
        this.setLineWidth(e2, n2);
        break;
      case "LC":
        this.setLineCap(e2, n2);
        break;
      case "LJ":
        this.setLineJoin(e2, n2);
        break;
      case "ML":
        this.setMiterLimit(e2, n2);
        break;
      case "D":
        this.setDash(e2, n2[0], n2[1]);
        break;
      case "RI":
        this.setRenderingIntent(e2, n2);
        break;
      case "FL":
        this.setFlatness(e2, n2);
        break;
      case "Font":
        this.setFont(e2, n2[0], n2[1]);
        break;
      case "CA":
        this.dependencyTracker?.recordSimpleData("strokeAlpha", e2), this.current.strokeAlpha = n2;
        break;
      case "ca":
        this.dependencyTracker?.recordSimpleData("fillAlpha", e2), this.ctx.globalAlpha = this.current.fillAlpha = n2;
        break;
      case "BM":
        this.dependencyTracker?.recordSimpleData("globalCompositeOperation", e2), this.ctx.globalCompositeOperation = n2;
        break;
      case "SMask":
        this.dependencyTracker?.recordSimpleData("SMask", e2), this.current.activeSMask = n2 ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
        break;
      case "TR":
        this.dependencyTracker?.recordSimpleData("filter", e2), this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(n2);
    }
  }
  get inSMaskMode() {
    return !!this.suspendedCtx;
  }
  checkSMaskState() {
    const e2 = this.inSMaskMode;
    this.current.activeSMask && !e2 ? this.beginSMaskMode() : !this.current.activeSMask && e2 && this.endSMaskMode();
  }
  beginSMaskMode(e2) {
    if (this.inSMaskMode) throw new Error("beginSMaskMode called while already in smask mode");
    const t2 = this.ctx.canvas.width, i2 = this.ctx.canvas.height, n2 = "smaskGroupAt" + this.groupLevel, a2 = this.cachedCanvases.getCanvas(n2, t2, i2);
    this.suspendedCtx = this.ctx;
    const s2 = this.ctx = a2.context;
    s2.setTransform(this.suspendedCtx.getTransform()), copyCtxState(this.suspendedCtx, s2), (function(e3, t3) {
      if (e3._removeMirroring) throw new Error("Context is already forwarding operations.");
      e3.__originalSave = e3.save, e3.__originalRestore = e3.restore, e3.__originalRotate = e3.rotate, e3.__originalScale = e3.scale, e3.__originalTranslate = e3.translate, e3.__originalTransform = e3.transform, e3.__originalSetTransform = e3.setTransform, e3.__originalResetTransform = e3.resetTransform, e3.__originalClip = e3.clip, e3.__originalMoveTo = e3.moveTo, e3.__originalLineTo = e3.lineTo, e3.__originalBezierCurveTo = e3.bezierCurveTo, e3.__originalRect = e3.rect, e3.__originalClosePath = e3.closePath, e3.__originalBeginPath = e3.beginPath, e3._removeMirroring = () => {
        e3.save = e3.__originalSave, e3.restore = e3.__originalRestore, e3.rotate = e3.__originalRotate, e3.scale = e3.__originalScale, e3.translate = e3.__originalTranslate, e3.transform = e3.__originalTransform, e3.setTransform = e3.__originalSetTransform, e3.resetTransform = e3.__originalResetTransform, e3.clip = e3.__originalClip, e3.moveTo = e3.__originalMoveTo, e3.lineTo = e3.__originalLineTo, e3.bezierCurveTo = e3.__originalBezierCurveTo, e3.rect = e3.__originalRect, e3.closePath = e3.__originalClosePath, e3.beginPath = e3.__originalBeginPath, delete e3._removeMirroring;
      }, e3.save = function() {
        t3.save(), this.__originalSave();
      }, e3.restore = function() {
        t3.restore(), this.__originalRestore();
      }, e3.translate = function(e4, i3) {
        t3.translate(e4, i3), this.__originalTranslate(e4, i3);
      }, e3.scale = function(e4, i3) {
        t3.scale(e4, i3), this.__originalScale(e4, i3);
      }, e3.transform = function(e4, i3, n3, a3, s3, r2) {
        t3.transform(e4, i3, n3, a3, s3, r2), this.__originalTransform(e4, i3, n3, a3, s3, r2);
      }, e3.setTransform = function(e4, i3, n3, a3, s3, r2) {
        t3.setTransform(e4, i3, n3, a3, s3, r2), this.__originalSetTransform(e4, i3, n3, a3, s3, r2);
      }, e3.resetTransform = function() {
        t3.resetTransform(), this.__originalResetTransform();
      }, e3.rotate = function(e4) {
        t3.rotate(e4), this.__originalRotate(e4);
      }, e3.clip = function(e4) {
        t3.clip(e4), this.__originalClip(e4);
      }, e3.moveTo = function(e4, i3) {
        t3.moveTo(e4, i3), this.__originalMoveTo(e4, i3);
      }, e3.lineTo = function(e4, i3) {
        t3.lineTo(e4, i3), this.__originalLineTo(e4, i3);
      }, e3.bezierCurveTo = function(e4, i3, n3, a3, s3, r2) {
        t3.bezierCurveTo(e4, i3, n3, a3, s3, r2), this.__originalBezierCurveTo(e4, i3, n3, a3, s3, r2);
      }, e3.rect = function(e4, i3, n3, a3) {
        t3.rect(e4, i3, n3, a3), this.__originalRect(e4, i3, n3, a3);
      }, e3.closePath = function() {
        t3.closePath(), this.__originalClosePath();
      }, e3.beginPath = function() {
        t3.beginPath(), this.__originalBeginPath();
      };
    })(s2, this.suspendedCtx), this.setGState(e2, [["BM", "source-over"]]);
  }
  endSMaskMode() {
    if (!this.inSMaskMode) throw new Error("endSMaskMode called while not in smask mode");
    this.ctx._removeMirroring(), copyCtxState(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
  }
  compose(e2) {
    if (!this.current.activeSMask) return;
    e2 ? (e2[0] = Math.floor(e2[0]), e2[1] = Math.floor(e2[1]), e2[2] = Math.ceil(e2[2]), e2[3] = Math.ceil(e2[3])) : e2 = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    const t2 = this.current.activeSMask, i2 = this.suspendedCtx;
    this.composeSMask(i2, t2, this.ctx, e2), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
  }
  composeSMask(e2, t2, i2, n2) {
    const a2 = n2[0], s2 = n2[1], r2 = n2[2] - a2, o2 = n2[3] - s2;
    0 !== r2 && 0 !== o2 && (this.genericComposeSMask(t2.context, i2, r2, o2, t2.subtype, t2.backdrop, t2.transferMap, a2, s2, t2.offsetX, t2.offsetY), e2.save(), e2.globalAlpha = 1, e2.globalCompositeOperation = "source-over", e2.setTransform(1, 0, 0, 1, 0, 0), e2.drawImage(i2.canvas, 0, 0), e2.restore());
  }
  genericComposeSMask(e2, t2, i2, n2, a2, s2, r2, o2, l2, c2, h2) {
    let d2 = e2.canvas, u2 = o2 - c2, g2 = l2 - h2;
    if (s2) if (u2 < 0 || g2 < 0 || u2 + i2 > d2.width || g2 + n2 > d2.height) {
      const e3 = this.cachedCanvases.getCanvas("maskExtension", i2, n2), t3 = e3.context;
      t3.drawImage(d2, -u2, -g2), t3.globalCompositeOperation = "destination-atop", t3.fillStyle = s2, t3.fillRect(0, 0, i2, n2), t3.globalCompositeOperation = "source-over", d2 = e3.canvas, u2 = g2 = 0;
    } else {
      e2.save(), e2.globalAlpha = 1, e2.setTransform(1, 0, 0, 1, 0, 0);
      const t3 = new Path2D();
      t3.rect(u2, g2, i2, n2), e2.clip(t3), e2.globalCompositeOperation = "destination-atop", e2.fillStyle = s2, e2.fillRect(u2, g2, i2, n2), e2.restore();
    }
    t2.save(), t2.globalAlpha = 1, t2.setTransform(1, 0, 0, 1, 0, 0), "Alpha" === a2 && r2 ? t2.filter = this.filterFactory.addAlphaFilter(r2) : "Luminosity" === a2 && (t2.filter = this.filterFactory.addLuminosityFilter(r2));
    const f2 = new Path2D();
    f2.rect(o2, l2, i2, n2), t2.clip(f2), t2.globalCompositeOperation = "destination-in", t2.drawImage(d2, u2, g2, i2, n2, o2, l2, i2, n2), t2.restore();
  }
  save(e2) {
    this.inSMaskMode && copyCtxState(this.ctx, this.suspendedCtx), this.ctx.save();
    const t2 = this.current;
    this.stateStack.push(t2), this.current = t2.clone(), this.dependencyTracker?.save(e2);
  }
  restore(e2) {
    this.dependencyTracker?.restore(e2), 0 !== this.stateStack.length ? (this.current = this.stateStack.pop(), this.ctx.restore(), this.inSMaskMode && copyCtxState(this.suspendedCtx, this.ctx), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null) : this.inSMaskMode && this.endSMaskMode();
  }
  transform(e2, t2, i2, n2, a2, s2, r2) {
    this.dependencyTracker?.recordIncrementalData("transform", e2), this.ctx.transform(t2, i2, n2, a2, s2, r2), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
  }
  constructPath(e2, t2, i2, n2) {
    let [a2] = i2;
    if (!n2) return a2 ||= i2[0] = new Path2D(), void this[t2](e2, a2);
    if (null !== this.dependencyTracker) {
      const i3 = t2 === sc.stroke ? this.current.lineWidth / 2 : 0;
      this.dependencyTracker.resetBBox(e2).recordBBox(e2, this.ctx, n2[0] - i3, n2[2] + i3, n2[1] - i3, n2[3] + i3).recordDependencies(e2, ["transform"]);
    }
    if (!(a2 instanceof Path2D)) {
      const e3 = i2[0] = new Path2D();
      for (let t3 = 0, i3 = a2.length; t3 < i3; ) switch (a2[t3++]) {
        case rc:
          e3.moveTo(a2[t3++], a2[t3++]);
          break;
        case oc:
          e3.lineTo(a2[t3++], a2[t3++]);
          break;
        case lc:
          e3.bezierCurveTo(a2[t3++], a2[t3++], a2[t3++], a2[t3++], a2[t3++], a2[t3++]);
          break;
        case cc:
          e3.closePath();
          break;
        default:
          warn(`Unrecognized drawing path operator: ${a2[t3 - 1]}`);
      }
      a2 = e3;
    }
    Util.axialAlignedBoundingBox(n2, getCurrentTransform(this.ctx), this.current.minMax), this[t2](e2, a2), this._pathStartIdx = e2;
  }
  closePath(e2) {
    this.ctx.closePath();
  }
  stroke(e2, t2, i2 = true) {
    const n2 = this.ctx, a2 = this.current.strokeColor;
    if (n2.globalAlpha = this.current.strokeAlpha, this.contentVisible) if ("object" == typeof a2 && a2?.getPattern) {
      const i3 = a2.isModifyingCurrentTransform() ? n2.getTransform() : null;
      if (n2.save(), n2.strokeStyle = a2.getPattern(n2, this, getCurrentTransformInverse(n2), Gc, e2), i3) {
        const e3 = new Path2D();
        e3.addPath(t2, n2.getTransform().invertSelf().multiplySelf(i3)), t2 = e3;
      }
      this.rescaleAndStroke(t2, false), n2.restore();
    } else this.rescaleAndStroke(t2, true);
    this.dependencyTracker?.recordDependencies(e2, Uc), i2 && this.consumePath(e2, t2, this.current.getClippedPathBoundingBox(Gc, getCurrentTransform(this.ctx))), n2.globalAlpha = this.current.fillAlpha;
  }
  closeStroke(e2, t2) {
    this.stroke(e2, t2);
  }
  fill(e2, t2, i2 = true) {
    const n2 = this.ctx, a2 = this.current.fillColor;
    let s2 = false;
    if (this.current.patternFill) {
      const i3 = a2.isModifyingCurrentTransform() ? n2.getTransform() : null;
      if (this.dependencyTracker?.save(e2), n2.save(), n2.fillStyle = a2.getPattern(n2, this, getCurrentTransformInverse(n2), Wc, e2), i3) {
        const e3 = new Path2D();
        e3.addPath(t2, n2.getTransform().invertSelf().multiplySelf(i3)), t2 = e3;
      }
      s2 = true;
    }
    const r2 = this.current.getClippedPathBoundingBox();
    this.contentVisible && null !== r2 && (this.pendingEOFill ? (n2.fill(t2, "evenodd"), this.pendingEOFill = false) : n2.fill(t2)), this.dependencyTracker?.recordDependencies(e2, jc), s2 && (n2.restore(), this.dependencyTracker?.restore(e2)), i2 && this.consumePath(e2, t2, r2);
  }
  eoFill(e2, t2) {
    this.pendingEOFill = true, this.fill(e2, t2);
  }
  fillStroke(e2, t2) {
    this.fill(e2, t2, false), this.stroke(e2, t2, false), this.consumePath(e2, t2);
  }
  eoFillStroke(e2, t2) {
    this.pendingEOFill = true, this.fillStroke(e2, t2);
  }
  closeFillStroke(e2, t2) {
    this.fillStroke(e2, t2);
  }
  closeEOFillStroke(e2, t2) {
    this.pendingEOFill = true, this.fillStroke(e2, t2);
  }
  endPath(e2, t2) {
    this.consumePath(e2, t2);
  }
  rawFillPath(e2, t2) {
    this.ctx.fill(t2), this.dependencyTracker?.recordDependencies(e2, Hc).recordOperation(e2);
  }
  clip(e2) {
    this.dependencyTracker?.recordFutureForcedDependency("clipMode", e2), this.pendingClip = nh;
  }
  eoClip(e2) {
    this.dependencyTracker?.recordFutureForcedDependency("clipMode", e2), this.pendingClip = ah;
  }
  beginText(e2) {
    this.current.textMatrix = null, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0, this.dependencyTracker?.recordOpenMarker(e2).resetIncrementalData("sameLineText").resetIncrementalData("moveText", e2);
  }
  endText(e2) {
    const t2 = this.pendingTextPaths, i2 = this.ctx;
    if (this.dependencyTracker) {
      const { dependencyTracker: i3 } = this;
      void 0 !== t2 && i3.recordFutureForcedDependency("textClip", i3.getOpenMarker()).recordFutureForcedDependency("textClip", e2), i3.recordCloseMarker(e2);
    }
    if (void 0 !== t2) {
      const e3 = new Path2D(), n2 = i2.getTransform().invertSelf();
      for (const { transform: i3, x: a2, y: s2, fontSize: r2, path: o2 } of t2) o2 && e3.addPath(o2, new DOMMatrix(i3).preMultiplySelf(n2).translate(a2, s2).scale(r2, -r2));
      i2.clip(e3);
    }
    delete this.pendingTextPaths;
  }
  setCharSpacing(e2, t2) {
    this.dependencyTracker?.recordSimpleData("charSpacing", e2), this.current.charSpacing = t2;
  }
  setWordSpacing(e2, t2) {
    this.dependencyTracker?.recordSimpleData("wordSpacing", e2), this.current.wordSpacing = t2;
  }
  setHScale(e2, t2) {
    this.dependencyTracker?.recordSimpleData("hScale", e2), this.current.textHScale = t2 / 100;
  }
  setLeading(e2, t2) {
    this.dependencyTracker?.recordSimpleData("leading", e2), this.current.leading = -t2;
  }
  setFont(e2, t2, i2) {
    this.dependencyTracker?.recordSimpleData("font", e2).recordSimpleDataFromNamed("fontObj", t2, e2);
    const n2 = this.commonObjs.get(t2), a2 = this.current;
    if (!n2) throw new Error(`Can't find font for ${t2}`);
    if (a2.fontMatrix = n2.fontMatrix || Il, 0 !== a2.fontMatrix[0] && 0 !== a2.fontMatrix[3] || warn("Invalid font matrix for font " + t2), i2 < 0 ? (i2 = -i2, a2.fontDirection = -1) : a2.fontDirection = 1, this.current.font = n2, this.current.fontSize = i2, n2.isType3Font) return;
    const s2 = n2.loadedName || "sans-serif", r2 = n2.systemFontInfo?.css || `"${s2}", ${n2.fallbackName}`;
    let o2 = "normal";
    n2.black ? o2 = "900" : n2.bold && (o2 = "bold");
    const l2 = n2.italic ? "italic" : "normal";
    let c2 = i2;
    i2 < 16 ? c2 = 16 : i2 > 100 && (c2 = 100), this.current.fontSizeScale = i2 / c2, this.ctx.font = `${l2} ${o2} ${c2}px ${r2}`;
  }
  setTextRenderingMode(e2, t2) {
    this.dependencyTracker?.recordSimpleData("textRenderingMode", e2), this.current.textRenderingMode = t2;
  }
  setTextRise(e2, t2) {
    this.dependencyTracker?.recordSimpleData("textRise", e2), this.current.textRise = t2;
  }
  moveText(e2, t2, i2) {
    this.dependencyTracker?.resetIncrementalData("sameLineText").recordIncrementalData("moveText", e2), this.current.x = this.current.lineX += t2, this.current.y = this.current.lineY += i2;
  }
  setLeadingMoveText(e2, t2, i2) {
    this.setLeading(e2, -i2), this.moveText(e2, t2, i2);
  }
  setTextMatrix(e2, t2) {
    this.dependencyTracker?.recordSimpleData("textMatrix", e2);
    const { current: i2 } = this;
    i2.textMatrix = t2, i2.textMatrixScale = Math.hypot(t2[0], t2[1]), i2.x = i2.lineX = 0, i2.y = i2.lineY = 0;
  }
  nextLine(e2) {
    this.moveText(e2, 0, this.current.leading), this.dependencyTracker?.recordIncrementalData("moveText", this.dependencyTracker.getSimpleIndex("leading") ?? e2);
  }
  #Cs(e2, t2, i2) {
    const n2 = new Path2D();
    return n2.addPath(e2, new DOMMatrix(i2).invertSelf().multiplySelf(t2)), n2;
  }
  paintChar(e2, t2, i2, n2, a2, s2) {
    const r2 = this.ctx, o2 = this.current, l2 = o2.font, c2 = o2.textRenderingMode, h2 = o2.fontSize / o2.fontSizeScale, d2 = c2 & Kl, u2 = !!(c2 & Yl), g2 = o2.patternFill && !l2.missingFile, f2 = o2.patternStroke && !l2.missingFile;
    let p2;
    if ((l2.disableFontFace || u2 || g2 || f2) && !l2.missingFile && (p2 = l2.getPathGenerator(this.commonObjs, t2)), p2 && (l2.disableFontFace || g2 || f2)) {
      let t3;
      if (r2.save(), r2.translate(i2, n2), r2.scale(h2, -h2), this.dependencyTracker?.recordCharacterBBox(e2, r2, l2), d2 === zl || d2 === Gl) if (a2) {
        t3 = r2.getTransform(), r2.setTransform(...a2);
        const e3 = this.#Cs(p2, t3, a2);
        r2.fill(e3);
      } else r2.fill(p2);
      if (d2 === Wl || d2 === Gl) if (s2) {
        t3 ||= r2.getTransform(), r2.setTransform(...s2);
        const { a: e3, b: i3, c: n3, d: a3 } = t3, o3 = Util.inverseTransform(s2), l3 = Util.transform([e3, i3, n3, a3, 0, 0], o3);
        Util.singularValueDecompose2dScale(l3, Qc), r2.lineWidth *= Math.max(Qc[0], Qc[1]) / h2, r2.stroke(this.#Cs(p2, t3, s2));
      } else r2.lineWidth /= h2, r2.stroke(p2);
      r2.restore();
    } else d2 !== zl && d2 !== Gl || (r2.fillText(t2, i2, n2), this.dependencyTracker?.recordCharacterBBox(e2, r2, l2, h2, i2, n2, () => r2.measureText(t2))), d2 !== Wl && d2 !== Gl || (this.dependencyTracker && this.dependencyTracker?.recordCharacterBBox(e2, r2, l2, h2, i2, n2, () => r2.measureText(t2)).recordDependencies(e2, Uc), r2.strokeText(t2, i2, n2));
    if (u2) {
      (this.pendingTextPaths ||= []).push({ transform: getCurrentTransform(r2), x: i2, y: n2, fontSize: h2, path: p2 }), this.dependencyTracker?.recordCharacterBBox(e2, r2, l2, h2, i2, n2);
    }
  }
  get isFontSubpixelAAEnabled() {
    const { context: e2 } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    e2.scale(1.5, 1), e2.fillText("I", 0, 10);
    const t2 = e2.getImageData(0, 0, 10, 10).data;
    let i2 = false;
    for (let e3 = 3; e3 < t2.length; e3 += 4) if (t2[e3] > 0 && t2[e3] < 255) {
      i2 = true;
      break;
    }
    return shadow(this, "isFontSubpixelAAEnabled", i2);
  }
  showText(e2, t2) {
    this.dependencyTracker && (this.dependencyTracker.recordDependencies(e2, Xc).resetBBox(e2), this.current.textRenderingMode & Yl && this.dependencyTracker.recordFutureForcedDependency("textClip", e2).inheritPendingDependenciesAsFutureForcedDependencies());
    const i2 = this.current, n2 = i2.font;
    if (n2.isType3Font) return this.showType3Text(e2, t2), void this.dependencyTracker?.recordShowTextOperation(e2);
    const a2 = i2.fontSize;
    if (0 === a2) return void this.dependencyTracker?.recordOperation(e2);
    const s2 = this.ctx, r2 = i2.fontSizeScale, o2 = i2.charSpacing, l2 = i2.wordSpacing, c2 = i2.fontDirection, h2 = i2.textHScale * c2, d2 = t2.length, u2 = n2.vertical, g2 = u2 ? 1 : -1, f2 = n2.defaultVMetrics, p2 = a2 * i2.fontMatrix[0], m2 = i2.textRenderingMode === zl && !n2.disableFontFace && !i2.patternFill;
    let b2, y2;
    if (s2.save(), i2.textMatrix && s2.transform(...i2.textMatrix), s2.translate(i2.x, i2.y + i2.textRise), c2 > 0 ? s2.scale(h2, -1) : s2.scale(h2, 1), i2.patternFill) {
      s2.save();
      const t3 = i2.fillColor.getPattern(s2, this, getCurrentTransformInverse(s2), Wc, e2);
      b2 = getCurrentTransform(s2), s2.restore(), s2.fillStyle = t3;
    }
    if (i2.patternStroke) {
      s2.save();
      const t3 = i2.strokeColor.getPattern(s2, this, getCurrentTransformInverse(s2), Gc, e2);
      y2 = getCurrentTransform(s2), s2.restore(), s2.strokeStyle = t3;
    }
    let w2 = i2.lineWidth;
    const x2 = i2.textMatrixScale;
    if (0 === x2 || 0 === w2) {
      const e3 = i2.textRenderingMode & Kl;
      e3 !== Wl && e3 !== Gl || (w2 = this.getSinglePixelWidth());
    } else w2 /= x2;
    if (1 !== r2 && (s2.scale(r2, r2), w2 /= r2), s2.lineWidth = w2, n2.isInvalidPDFjsFont) {
      const n3 = [];
      let a3 = 0;
      for (const e3 of t2) n3.push(e3.unicode), a3 += e3.width;
      const r3 = n3.join("");
      if (s2.fillText(r3, 0, 0), null !== this.dependencyTracker) {
        const t3 = s2.measureText(r3);
        this.dependencyTracker.recordBBox(e2, this.ctx, -t3.actualBoundingBoxLeft, t3.actualBoundingBoxRight, -t3.actualBoundingBoxAscent, t3.actualBoundingBoxDescent).recordShowTextOperation(e2);
      }
      return i2.x += a3 * p2 * h2, s2.restore(), void this.compose();
    }
    let S2, v2 = 0;
    for (S2 = 0; S2 < d2; ++S2) {
      const i3 = t2[S2];
      if ("number" == typeof i3) {
        v2 += g2 * i3 * a2 / 1e3;
        continue;
      }
      let h3 = false;
      const d3 = (i3.isSpace ? l2 : 0) + o2, w3 = i3.fontChar, x3 = i3.accent;
      let C2, k2, T2, F2 = i3.width;
      if (u2) {
        const e3 = i3.vmetric || f2, t3 = -(i3.vmetric ? e3[1] : 0.5 * F2) * p2, n3 = e3[2] * p2;
        F2 = e3 ? -e3[0] : F2, C2 = t3 / r2, k2 = (v2 + n3) / r2;
      } else C2 = v2 / r2, k2 = 0;
      if (n2.remeasure && F2 > 0) {
        T2 = s2.measureText(w3);
        const e3 = 1e3 * T2.width / a2 * r2;
        if (F2 < e3 && this.isFontSubpixelAAEnabled) {
          const t3 = F2 / e3;
          h3 = true, s2.save(), s2.scale(t3, 1), C2 /= t3;
        } else F2 !== e3 && (C2 += (F2 - e3) / 2e3 * a2 / r2);
      }
      if (this.contentVisible && (i3.isInFont || n2.missingFile)) {
        if (m2 && !x3) s2.fillText(w3, C2, k2), this.dependencyTracker?.recordCharacterBBox(e2, s2, T2 ? { bbox: null } : n2, a2 / r2, C2, k2, () => T2 ?? s2.measureText(w3));
        else if (this.paintChar(e2, w3, C2, k2, b2, y2), x3) {
          const t3 = C2 + a2 * x3.offset.x / r2, i4 = k2 - a2 * x3.offset.y / r2;
          this.paintChar(e2, x3.fontChar, t3, i4, b2, y2);
        }
      }
      v2 += u2 ? F2 * p2 - d3 * c2 : F2 * p2 + d3 * c2, h3 && s2.restore();
    }
    u2 ? i2.y -= v2 : i2.x += v2 * h2, s2.restore(), this.compose(), this.dependencyTracker?.recordShowTextOperation(e2);
  }
  showType3Text(e2, t2) {
    const i2 = this.ctx, n2 = this.current, a2 = n2.font, s2 = n2.fontSize, r2 = n2.fontDirection, o2 = a2.vertical ? 1 : -1, l2 = n2.charSpacing, c2 = n2.wordSpacing, h2 = n2.textHScale * r2, d2 = n2.fontMatrix || Il, u2 = t2.length;
    let g2, f2, p2, m2;
    if (n2.textRenderingMode === Vl || 0 === s2) return;
    this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, i2.save(), n2.textMatrix && i2.transform(...n2.textMatrix), i2.translate(n2.x, n2.y + n2.textRise), i2.scale(h2, r2);
    const b2 = this.dependencyTracker;
    for (this.dependencyTracker = b2 ? new CanvasNestedDependencyTracker(b2, e2) : null, g2 = 0; g2 < u2; ++g2) {
      if (f2 = t2[g2], "number" == typeof f2) {
        m2 = o2 * f2 * s2 / 1e3, this.ctx.translate(m2, 0), n2.x += m2 * h2;
        continue;
      }
      const e3 = (f2.isSpace ? c2 : 0) + l2, r3 = a2.charProcOperatorList[f2.operatorListId];
      r3 ? this.contentVisible && (this.save(), i2.scale(s2, s2), i2.transform(...d2), this.executeOperatorList(r3), this.restore()) : warn(`Type3 character "${f2.operatorListId}" is not available.`);
      const u3 = [f2.width, 0];
      Util.applyTransform(u3, d2), p2 = u3[0] * s2 + e3, i2.translate(p2, 0), n2.x += p2 * h2;
    }
    i2.restore(), b2 && (this.dependencyTracker = b2);
  }
  setCharWidth(e2, t2, i2) {
  }
  setCharWidthAndBounds(e2, t2, i2, n2, a2, s2, r2) {
    const o2 = new Path2D();
    o2.rect(n2, a2, s2 - n2, r2 - a2), this.ctx.clip(o2), this.dependencyTracker?.recordBBox(e2, this.ctx, n2, s2, a2, r2).recordClipBox(e2, this.ctx, n2, s2, a2, r2), this.endPath(e2);
  }
  getColorN_Pattern(e2, t2) {
    let i2;
    if ("TilingPattern" === t2[0]) {
      const e3 = this.baseTransform || getCurrentTransform(this.ctx), n2 = { createCanvasGraphics: (e4, t3) => new CanvasGraphics(e4, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: this.optionalContentConfig, markedContentStack: this.markedContentStack }, void 0, void 0, this.dependencyTracker ? new CanvasNestedDependencyTracker(this.dependencyTracker, t3, true) : null) };
      i2 = new TilingPattern(t2, this.ctx, n2, e3);
    } else i2 = this._getPattern(e2, t2[1], t2[2]);
    return i2;
  }
  setStrokeColorN(e2, ...t2) {
    this.dependencyTracker?.recordSimpleData("strokeColor", e2), this.current.strokeColor = this.getColorN_Pattern(e2, t2), this.current.patternStroke = true;
  }
  setFillColorN(e2, ...t2) {
    this.dependencyTracker?.recordSimpleData("fillColor", e2), this.current.fillColor = this.getColorN_Pattern(e2, t2), this.current.patternFill = true;
  }
  setStrokeRGBColor(e2, t2) {
    this.dependencyTracker?.recordSimpleData("strokeColor", e2), this.ctx.strokeStyle = this.current.strokeColor = t2, this.current.patternStroke = false;
  }
  setStrokeTransparent(e2) {
    this.dependencyTracker?.recordSimpleData("strokeColor", e2), this.ctx.strokeStyle = this.current.strokeColor = "transparent", this.current.patternStroke = false;
  }
  setFillRGBColor(e2, t2) {
    this.dependencyTracker?.recordSimpleData("fillColor", e2), this.ctx.fillStyle = this.current.fillColor = t2, this.current.patternFill = false;
  }
  setFillTransparent(e2) {
    this.dependencyTracker?.recordSimpleData("fillColor", e2), this.ctx.fillStyle = this.current.fillColor = "transparent", this.current.patternFill = false;
  }
  _getPattern(e2, t2, i2 = null) {
    let n2;
    return this.cachedPatterns.has(t2) ? n2 = this.cachedPatterns.get(t2) : (n2 = (function(e3) {
      switch (e3[0]) {
        case "RadialAxial":
          return new RadialAxialShadingPattern(e3);
        case "Mesh":
          return new MeshShadingPattern(e3);
        case "Dummy":
          return new DummyShadingPattern();
      }
      throw new Error(`Unknown IR type: ${e3[0]}`);
    })(this.getObject(e2, t2)), this.cachedPatterns.set(t2, n2)), i2 && (n2.matrix = i2), n2;
  }
  shadingFill(e2, t2) {
    if (!this.contentVisible) return;
    const i2 = this.ctx;
    this.save(e2);
    const n2 = this._getPattern(e2, t2);
    i2.fillStyle = n2.getPattern(i2, this, getCurrentTransformInverse(i2), Vc, e2);
    const a2 = getCurrentTransformInverse(i2);
    if (a2) {
      const { width: e3, height: t3 } = i2.canvas, n3 = eh.slice();
      Util.axialAlignedBoundingBox([0, 0, e3, t3], a2, n3);
      const [s2, r2, o2, l2] = n3;
      this.ctx.fillRect(s2, r2, o2 - s2, l2 - r2);
    } else this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    this.dependencyTracker?.resetBBox(e2).recordFullPageBBox(e2).recordDependencies(e2, qc).recordDependencies(e2, jc).recordOperation(e2), this.compose(this.current.getClippedPathBoundingBox()), this.restore(e2);
  }
  beginInlineImage() {
    unreachable("Should not call beginInlineImage");
  }
  beginImageData() {
    unreachable("Should not call beginImageData");
  }
  paintFormXObjectBegin(e2, t2, i2) {
    if (this.contentVisible && (this.save(e2), this.baseTransformStack.push(this.baseTransform), t2 && this.transform(e2, ...t2), this.baseTransform = getCurrentTransform(this.ctx), i2)) {
      Util.axialAlignedBoundingBox(i2, this.baseTransform, this.current.minMax);
      const [t3, n2, a2, s2] = i2, r2 = new Path2D();
      r2.rect(t3, n2, a2 - t3, s2 - n2), this.ctx.clip(r2), this.dependencyTracker?.recordClipBox(e2, this.ctx, t3, a2, n2, s2), this.endPath(e2);
    }
  }
  paintFormXObjectEnd(e2) {
    this.contentVisible && (this.restore(e2), this.baseTransform = this.baseTransformStack.pop());
  }
  beginGroup(e2, t2) {
    if (!this.contentVisible) return;
    this.save(e2), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
    const i2 = this.ctx;
    t2.isolated || info("TODO: Support non-isolated groups."), t2.knockout && warn("Knockout groups not supported.");
    const n2 = getCurrentTransform(i2);
    if (t2.matrix && i2.transform(...t2.matrix), !t2.bbox) throw new Error("Bounding box is required.");
    let a2 = eh.slice();
    Util.axialAlignedBoundingBox(t2.bbox, getCurrentTransform(i2), a2);
    const s2 = [0, 0, i2.canvas.width, i2.canvas.height];
    a2 = Util.intersect(a2, s2) || [0, 0, 0, 0];
    const r2 = Math.floor(a2[0]), o2 = Math.floor(a2[1]), l2 = Math.max(Math.ceil(a2[2]) - r2, 1), c2 = Math.max(Math.ceil(a2[3]) - o2, 1);
    this.current.startNewPathAndClipBox([0, 0, l2, c2]);
    let h2 = "groupAt" + this.groupLevel;
    t2.smask && (h2 += "_smask_" + this.smaskCounter++ % 2);
    const d2 = this.cachedCanvases.getCanvas(h2, l2, c2), u2 = d2.context;
    u2.translate(-r2, -o2), u2.transform(...n2);
    let g2 = new Path2D();
    const [f2, p2, m2, b2] = t2.bbox;
    if (g2.rect(f2, p2, m2 - f2, b2 - p2), t2.matrix) {
      const e3 = new Path2D();
      e3.addPath(g2, new DOMMatrix(t2.matrix)), g2 = e3;
    }
    u2.clip(g2), t2.smask && this.smaskStack.push({ canvas: d2.canvas, context: u2, offsetX: r2, offsetY: o2, subtype: t2.smask.subtype, backdrop: t2.smask.backdrop, transferMap: t2.smask.transferMap || null, startTransformInverse: null }), t2.smask && !this.dependencyTracker || (i2.setTransform(1, 0, 0, 1, 0, 0), i2.translate(r2, o2), i2.save()), copyCtxState(i2, u2), this.ctx = u2, this.dependencyTracker?.inheritSimpleDataAsFutureForcedDependencies(["fillAlpha", "strokeAlpha", "globalCompositeOperation"]).pushBaseTransform(i2), this.setGState(e2, [["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(i2), this.groupLevel++;
  }
  endGroup(e2, t2) {
    if (!this.contentVisible) return;
    this.groupLevel--;
    const i2 = this.ctx, n2 = this.groupStack.pop();
    if (this.ctx = n2, this.ctx.imageSmoothingEnabled = false, this.dependencyTracker?.popBaseTransform(), t2.smask) this.tempSMask = this.smaskStack.pop(), this.restore(e2), this.dependencyTracker && this.ctx.restore();
    else {
      this.ctx.restore();
      const t3 = getCurrentTransform(this.ctx);
      this.restore(e2), this.ctx.save(), this.ctx.setTransform(...t3);
      const n3 = eh.slice();
      Util.axialAlignedBoundingBox([0, 0, i2.canvas.width, i2.canvas.height], t3, n3), this.ctx.drawImage(i2.canvas, 0, 0), this.ctx.restore(), this.compose(n3);
    }
  }
  beginAnnotation(e2, t2, i2, n2, a2, s2) {
    if (this.#Ss(), resetCtxToDefault(this.ctx), this.ctx.save(), this.save(e2), this.baseTransform && this.ctx.setTransform(...this.baseTransform), i2) {
      const a3 = i2[2] - i2[0], r2 = i2[3] - i2[1];
      if (s2 && this.annotationCanvasMap) {
        (n2 = n2.slice())[4] -= i2[0], n2[5] -= i2[1], (i2 = i2.slice())[0] = i2[1] = 0, i2[2] = a3, i2[3] = r2, Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), Qc);
        const { viewportScale: e3 } = this, s3 = Math.ceil(a3 * this.outputScaleX * e3), o2 = Math.ceil(r2 * this.outputScaleY * e3);
        this.annotationCanvas = this.canvasFactory.create(s3, o2);
        const { canvas: l2, context: c2 } = this.annotationCanvas;
        this.annotationCanvasMap.set(t2, l2), this.annotationCanvas.savedCtx = this.ctx, this.ctx = c2, this.ctx.save(), this.ctx.setTransform(Qc[0], 0, 0, -Qc[1], 0, r2 * Qc[1]), resetCtxToDefault(this.ctx);
      } else {
        resetCtxToDefault(this.ctx), this.endPath(e2);
        const t3 = new Path2D();
        t3.rect(i2[0], i2[1], a3, r2), this.ctx.clip(t3);
      }
    }
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(e2, ...n2), this.transform(e2, ...a2);
  }
  endAnnotation(e2) {
    this.annotationCanvas && (this.ctx.restore(), this.#vs(), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
  }
  paintImageMaskXObject(e2, t2) {
    if (!this.contentVisible) return;
    const i2 = t2.count;
    (t2 = this.getObject(e2, t2.data, t2)).count = i2;
    const n2 = this.ctx, a2 = this._createMaskCanvas(e2, t2), s2 = a2.canvas;
    n2.save(), n2.setTransform(1, 0, 0, 1, 0, 0), n2.drawImage(s2, a2.offsetX, a2.offsetY), this.dependencyTracker?.resetBBox(e2).recordBBox(e2, this.ctx, a2.offsetX, a2.offsetX + s2.width, a2.offsetY, a2.offsetY + s2.height).recordOperation(e2), n2.restore(), this.compose();
  }
  paintImageMaskXObjectRepeat(e2, t2, i2, n2 = 0, a2 = 0, s2, r2) {
    if (!this.contentVisible) return;
    t2 = this.getObject(e2, t2.data, t2);
    const o2 = this.ctx;
    o2.save();
    const l2 = getCurrentTransform(o2);
    o2.transform(i2, n2, a2, s2, 0, 0);
    const c2 = this._createMaskCanvas(e2, t2);
    o2.setTransform(1, 0, 0, 1, c2.offsetX - l2[4], c2.offsetY - l2[5]), this.dependencyTracker?.resetBBox(e2);
    for (let t3 = 0, h2 = r2.length; t3 < h2; t3 += 2) {
      const h3 = Util.transform(l2, [i2, n2, a2, s2, r2[t3], r2[t3 + 1]]);
      o2.drawImage(c2.canvas, h3[4], h3[5]), this.dependencyTracker?.recordBBox(e2, this.ctx, h3[4], h3[4] + c2.canvas.width, h3[5], h3[5] + c2.canvas.height);
    }
    o2.restore(), this.compose(), this.dependencyTracker?.recordOperation(e2);
  }
  paintImageMaskXObjectGroup(e2, t2) {
    if (!this.contentVisible) return;
    const i2 = this.ctx, n2 = this.current.fillColor, a2 = this.current.patternFill;
    this.dependencyTracker?.resetBBox(e2).recordDependencies(e2, zc);
    for (const s2 of t2) {
      const { data: t3, width: r2, height: o2, transform: l2 } = s2, c2 = this.cachedCanvases.getCanvas("maskCanvas", r2, o2), h2 = c2.context;
      h2.save();
      putBinaryImageMask(h2, this.getObject(e2, t3, s2)), h2.globalCompositeOperation = "source-in", h2.fillStyle = a2 ? n2.getPattern(h2, this, getCurrentTransformInverse(i2), Wc, e2) : n2, h2.fillRect(0, 0, r2, o2), h2.restore(), i2.save(), i2.transform(...l2), i2.scale(1, -1), drawImageAtIntegerCoords(i2, c2.canvas, 0, 0, r2, o2, 0, -1, 1, 1), this.dependencyTracker?.recordBBox(e2, i2, 0, r2, 0, o2), i2.restore();
    }
    this.compose(), this.dependencyTracker?.recordOperation(e2);
  }
  paintImageXObject(e2, t2) {
    if (!this.contentVisible) return;
    const i2 = this.getObject(e2, t2);
    i2 ? this.paintInlineImageXObject(e2, i2) : warn("Dependent image isn't ready yet");
  }
  paintImageXObjectRepeat(e2, t2, i2, n2, a2) {
    if (!this.contentVisible) return;
    const s2 = this.getObject(e2, t2);
    if (!s2) return void warn("Dependent image isn't ready yet");
    const r2 = s2.width, o2 = s2.height, l2 = [];
    for (let e3 = 0, t3 = a2.length; e3 < t3; e3 += 2) l2.push({ transform: [i2, 0, 0, n2, a2[e3], a2[e3 + 1]], x: 0, y: 0, w: r2, h: o2 });
    this.paintInlineImageXObjectGroup(e2, s2, l2);
  }
  applyTransferMapsToCanvas(e2) {
    return "none" !== this.current.transferMaps && (e2.filter = this.current.transferMaps, e2.drawImage(e2.canvas, 0, 0), e2.filter = "none"), e2.canvas;
  }
  applyTransferMapsToBitmap(e2) {
    if ("none" === this.current.transferMaps) return e2.bitmap;
    const { bitmap: t2, width: i2, height: n2 } = e2, a2 = this.cachedCanvases.getCanvas("inlineImage", i2, n2), s2 = a2.context;
    return s2.filter = this.current.transferMaps, s2.drawImage(t2, 0, 0), s2.filter = "none", a2.canvas;
  }
  paintInlineImageXObject(e2, t2) {
    if (!this.contentVisible) return;
    const i2 = t2.width, n2 = t2.height, a2 = this.ctx;
    this.save(e2);
    const { filter: s2 } = a2;
    let r2;
    if ("none" !== s2 && "" !== s2 && (a2.filter = "none"), a2.scale(1 / i2, -1 / n2), t2.bitmap) r2 = this.applyTransferMapsToBitmap(t2);
    else if ("function" == typeof HTMLElement && t2 instanceof HTMLElement || !t2.data) r2 = t2;
    else {
      const e3 = this.cachedCanvases.getCanvas("inlineImage", i2, n2).context;
      putBinaryImageData(e3, t2), r2 = this.applyTransferMapsToCanvas(e3);
    }
    const o2 = this._scaleImage(r2, getCurrentTransformInverse(a2));
    a2.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(a2), t2.interpolate), this.dependencyTracker?.resetBBox(e2).recordBBox(e2, a2, 0, i2, -n2, 0).recordDependencies(e2, $c).recordOperation(e2), drawImageAtIntegerCoords(a2, o2.img, 0, 0, o2.paintWidth, o2.paintHeight, 0, -n2, i2, n2), this.compose(), this.restore(e2);
  }
  paintInlineImageXObjectGroup(e2, t2, i2) {
    if (!this.contentVisible) return;
    const n2 = this.ctx;
    let a2;
    if (t2.bitmap) a2 = t2.bitmap;
    else {
      const e3 = t2.width, i3 = t2.height, n3 = this.cachedCanvases.getCanvas("inlineImage", e3, i3).context;
      putBinaryImageData(n3, t2), a2 = this.applyTransferMapsToCanvas(n3);
    }
    this.dependencyTracker?.resetBBox(e2);
    for (const t3 of i2) n2.save(), n2.transform(...t3.transform), n2.scale(1, -1), drawImageAtIntegerCoords(n2, a2, t3.x, t3.y, t3.w, t3.h, 0, -1, 1, 1), this.dependencyTracker?.recordBBox(e2, n2, 0, 1, -1, 0), n2.restore();
    this.dependencyTracker?.recordOperation(e2), this.compose();
  }
  paintSolidColorImageMask(e2) {
    this.contentVisible && (this.dependencyTracker?.resetBBox(e2).recordBBox(e2, this.ctx, 0, 1, 0, 1).recordDependencies(e2, jc).recordOperation(e2), this.ctx.fillRect(0, 0, 1, 1), this.compose());
  }
  markPoint(e2, t2) {
  }
  markPointProps(e2, t2, i2) {
  }
  beginMarkedContent(e2, t2) {
    this.dependencyTracker?.beginMarkedContent(e2), this.markedContentStack.push({ visible: true });
  }
  beginMarkedContentProps(e2, t2, i2) {
    this.dependencyTracker?.beginMarkedContent(e2), "OC" === t2 ? this.markedContentStack.push({ visible: this.optionalContentConfig.isVisible(i2) }) : this.markedContentStack.push({ visible: true }), this.contentVisible = this.isContentVisible();
  }
  endMarkedContent(e2) {
    this.dependencyTracker?.endMarkedContent(e2), this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
  }
  beginCompat(e2) {
  }
  endCompat(e2) {
  }
  consumePath(e2, t2, i2) {
    const n2 = this.current.isEmptyClip();
    this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(i2);
    const a2 = this.ctx;
    this.pendingClip ? (n2 || (this.pendingClip === ah ? a2.clip(t2, "evenodd") : a2.clip(t2)), this.pendingClip = null, this.dependencyTracker?.bboxToClipBoxDropOperation(e2).recordFutureForcedDependency("clipPath", e2)) : this.dependencyTracker?.recordOperation(e2), this.current.startNewPathAndClipBox(this.current.clipBox);
  }
  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const e2 = getCurrentTransform(this.ctx);
      if (0 === e2[1] && 0 === e2[2]) this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(e2[0]), Math.abs(e2[3]));
      else {
        const t2 = Math.abs(e2[0] * e2[3] - e2[2] * e2[1]), i2 = Math.hypot(e2[0], e2[2]), n2 = Math.hypot(e2[1], e2[3]);
        this._cachedGetSinglePixelWidth = Math.max(i2, n2) / t2;
      }
    }
    return this._cachedGetSinglePixelWidth;
  }
  getScaleForStroking() {
    if (-1 === this._cachedScaleForStroking[0]) {
      const { lineWidth: e2 } = this.current, { a: t2, b: i2, c: n2, d: a2 } = this.ctx.getTransform();
      let s2, r2;
      if (0 === i2 && 0 === n2) {
        const i3 = Math.abs(t2), n3 = Math.abs(a2);
        if (i3 === n3) if (0 === e2) s2 = r2 = 1 / i3;
        else {
          const t3 = i3 * e2;
          s2 = r2 = t3 < 1 ? 1 / t3 : 1;
        }
        else if (0 === e2) s2 = 1 / i3, r2 = 1 / n3;
        else {
          const t3 = i3 * e2, a3 = n3 * e2;
          s2 = t3 < 1 ? 1 / t3 : 1, r2 = a3 < 1 ? 1 / a3 : 1;
        }
      } else {
        const o2 = Math.abs(t2 * a2 - i2 * n2), l2 = Math.hypot(t2, i2), c2 = Math.hypot(n2, a2);
        if (0 === e2) s2 = c2 / o2, r2 = l2 / o2;
        else {
          const t3 = e2 * o2;
          s2 = c2 > t3 ? c2 / t3 : 1, r2 = l2 > t3 ? l2 / t3 : 1;
        }
      }
      this._cachedScaleForStroking[0] = s2, this._cachedScaleForStroking[1] = r2;
    }
    return this._cachedScaleForStroking;
  }
  rescaleAndStroke(e2, t2) {
    const { ctx: i2, current: { lineWidth: n2 } } = this, [a2, s2] = this.getScaleForStroking();
    if (a2 === s2) return i2.lineWidth = (n2 || 1) * a2, void i2.stroke(e2);
    const r2 = i2.getLineDash();
    t2 && i2.save(), i2.scale(a2, s2), Zc.a = 1 / a2, Zc.d = 1 / s2;
    const o2 = new Path2D();
    if (o2.addPath(e2, Zc), r2.length > 0) {
      const e3 = Math.max(a2, s2);
      i2.setLineDash(r2.map((t3) => t3 / e3)), i2.lineDashOffset /= e3;
    }
    i2.lineWidth = n2 || 1, i2.stroke(o2), t2 && i2.restore();
  }
  isContentVisible() {
    for (let e2 = this.markedContentStack.length - 1; e2 >= 0; e2--) if (!this.markedContentStack[e2].visible) return false;
    return true;
  }
}
for (const e2 in sc) void 0 !== CanvasGraphics.prototype[e2] && (CanvasGraphics.prototype[sc[e2]] = CanvasGraphics.prototype[e2]);
class CssFontInfo2 {
  #R;
  #W;
  #G;
  static strings = ["fontFamily", "fontWeight", "italicAngle"];
  static write(e2) {
    const t2 = new TextEncoder(), i2 = {};
    let n2 = 0;
    for (const a3 of CssFontInfo2.strings) {
      const s3 = t2.encode(e2[a3]);
      i2[a3] = s3, n2 += 4 + s3.length;
    }
    const a2 = new ArrayBuffer(n2), s2 = new Uint8Array(a2), r2 = new DataView(a2);
    let o2 = 0;
    for (const e3 of CssFontInfo2.strings) {
      const t3 = i2[e3], n3 = t3.length;
      r2.setUint32(o2, n3), s2.set(t3, o2 + 4), o2 += 4 + n3;
    }
    return assert(o2 === a2.byteLength, "CssFontInfo.write: Buffer overflow"), a2;
  }
  constructor(e2) {
    this.#R = e2, this.#W = new DataView(this.#R), this.#G = new TextDecoder();
  }
  #V(e2) {
    assert(e2 < CssFontInfo2.strings.length, "Invalid string index");
    let t2 = 0;
    for (let i3 = 0; i3 < e2; i3++) t2 += this.#W.getUint32(t2) + 4;
    const i2 = this.#W.getUint32(t2);
    return this.#G.decode(new Uint8Array(this.#R, t2 + 4, i2));
  }
  get fontFamily() {
    return this.#V(0);
  }
  get fontWeight() {
    return this.#V(1);
  }
  get italicAngle() {
    return this.#V(2);
  }
}
class SystemFontInfo2 {
  #R;
  #W;
  #G;
  static strings = ["css", "loadedName", "baseFontName", "src"];
  static write(e2) {
    const t2 = new TextEncoder(), i2 = {};
    let n2 = 0;
    for (const a3 of SystemFontInfo2.strings) {
      const s3 = t2.encode(e2[a3]);
      i2[a3] = s3, n2 += 4 + s3.length;
    }
    n2 += 4;
    let a2, s2, r2 = 1 + n2;
    e2.style && (a2 = t2.encode(e2.style.style), s2 = t2.encode(e2.style.weight), r2 += 4 + a2.length + 4 + s2.length);
    const o2 = new ArrayBuffer(r2), l2 = new Uint8Array(o2), c2 = new DataView(o2);
    let h2 = 0;
    c2.setUint8(h2++, e2.guessFallback ? 1 : 0), c2.setUint32(h2, 0), h2 += 4, n2 = 0;
    for (const e3 of SystemFontInfo2.strings) {
      const t3 = i2[e3], a3 = t3.length;
      n2 += 4 + a3, c2.setUint32(h2, a3), l2.set(t3, h2 + 4), h2 += 4 + a3;
    }
    return c2.setUint32(h2 - n2 - 4, n2), e2.style && (c2.setUint32(h2, a2.length), l2.set(a2, h2 + 4), h2 += 4 + a2.length, c2.setUint32(h2, s2.length), l2.set(s2, h2 + 4), h2 += 4 + s2.length), assert(h2 <= o2.byteLength, "SubstitionInfo.write: Buffer overflow"), o2.transferToFixedLength(h2);
  }
  constructor(e2) {
    this.#R = e2, this.#W = new DataView(this.#R), this.#G = new TextDecoder();
  }
  get guessFallback() {
    return 0 !== this.#W.getUint8(0);
  }
  #V(e2) {
    assert(e2 < SystemFontInfo2.strings.length, "Invalid string index");
    let t2 = 5;
    for (let i3 = 0; i3 < e2; i3++) t2 += this.#W.getUint32(t2) + 4;
    const i2 = this.#W.getUint32(t2);
    return this.#G.decode(new Uint8Array(this.#R, t2 + 4, i2));
  }
  get css() {
    return this.#V(0);
  }
  get loadedName() {
    return this.#V(1);
  }
  get baseFontName() {
    return this.#V(2);
  }
  get src() {
    return this.#V(3);
  }
  get style() {
    let e2 = 1;
    e2 += 4 + this.#W.getUint32(e2);
    const t2 = this.#W.getUint32(e2), i2 = this.#G.decode(new Uint8Array(this.#R, e2 + 4, t2));
    e2 += 4 + t2;
    const n2 = this.#W.getUint32(e2);
    return { style: i2, weight: this.#G.decode(new Uint8Array(this.#R, e2 + 4, n2)) };
  }
}
class FontInfo2 {
  static bools = ["black", "bold", "disableFontFace", "fontExtraProperties", "isInvalidPDFjsFont", "isType3Font", "italic", "missingFile", "remeasure", "vertical"];
  static numbers = ["ascent", "defaultWidth", "descent"];
  static strings = ["fallbackName", "loadedName", "mimetype", "name"];
  static #K = Math.ceil(2 * this.bools.length / 8);
  static #Y = this.#K + 8 * this.numbers.length;
  static #J = this.#Y + 1 + 8;
  static #Z = this.#J + 1 + 48;
  static #Q = this.#Z + 1 + 6;
  #R;
  #G;
  #W;
  constructor({ data: e2, extra: t2 }) {
    this.#R = e2, this.#G = new TextDecoder(), this.#W = new DataView(this.#R), t2 && Object.assign(this, t2);
  }
  #ee(e2) {
    assert(e2 < FontInfo2.bools.length, "Invalid boolean index");
    const t2 = Math.floor(e2 / 4), i2 = 2 * e2 % 8, n2 = this.#W.getUint8(t2) >> i2 & 3;
    return 0 === n2 ? void 0 : 2 === n2;
  }
  get black() {
    return this.#ee(0);
  }
  get bold() {
    return this.#ee(1);
  }
  get disableFontFace() {
    return this.#ee(2);
  }
  get fontExtraProperties() {
    return this.#ee(3);
  }
  get isInvalidPDFjsFont() {
    return this.#ee(4);
  }
  get isType3Font() {
    return this.#ee(5);
  }
  get italic() {
    return this.#ee(6);
  }
  get missingFile() {
    return this.#ee(7);
  }
  get remeasure() {
    return this.#ee(8);
  }
  get vertical() {
    return this.#ee(9);
  }
  #te(e2) {
    return assert(e2 < FontInfo2.numbers.length, "Invalid number index"), this.#W.getFloat64(FontInfo2.#K + 8 * e2);
  }
  get ascent() {
    return this.#te(0);
  }
  get defaultWidth() {
    return this.#te(1);
  }
  get descent() {
    return this.#te(2);
  }
  get bbox() {
    let e2 = FontInfo2.#Y;
    if (0 === this.#W.getUint8(e2)) return;
    e2 += 1;
    const t2 = [];
    for (let i2 = 0; i2 < 4; i2++) t2.push(this.#W.getInt16(e2, true)), e2 += 2;
    return t2;
  }
  get fontMatrix() {
    let e2 = FontInfo2.#J;
    if (0 === this.#W.getUint8(e2)) return;
    e2 += 1;
    const t2 = [];
    for (let i2 = 0; i2 < 6; i2++) t2.push(this.#W.getFloat64(e2, true)), e2 += 8;
    return t2;
  }
  get defaultVMetrics() {
    let e2 = FontInfo2.#Z;
    if (0 === this.#W.getUint8(e2)) return;
    e2 += 1;
    const t2 = [];
    for (let i2 = 0; i2 < 3; i2++) t2.push(this.#W.getInt16(e2, true)), e2 += 2;
    return t2;
  }
  #V(e2) {
    assert(e2 < FontInfo2.strings.length, "Invalid string index");
    let t2 = FontInfo2.#Q + 4;
    for (let i3 = 0; i3 < e2; i3++) t2 += this.#W.getUint32(t2) + 4;
    const i2 = this.#W.getUint32(t2), n2 = new Uint8Array(i2);
    return n2.set(new Uint8Array(this.#R, t2 + 4, i2)), this.#G.decode(n2);
  }
  get fallbackName() {
    return this.#V(0);
  }
  get loadedName() {
    return this.#V(1);
  }
  get mimetype() {
    return this.#V(2);
  }
  get name() {
    return this.#V(3);
  }
  get data() {
    let e2 = FontInfo2.#Q;
    e2 += 4 + this.#W.getUint32(e2);
    e2 += 4 + this.#W.getUint32(e2);
    e2 += 4 + this.#W.getUint32(e2);
    const t2 = this.#W.getUint32(e2);
    if (0 !== t2) return new Uint8Array(this.#R, e2 + 4, t2);
  }
  clearData() {
    let e2 = FontInfo2.#Q;
    e2 += 4 + this.#W.getUint32(e2);
    e2 += 4 + this.#W.getUint32(e2);
    e2 += 4 + this.#W.getUint32(e2);
    const t2 = this.#W.getUint32(e2);
    new Uint8Array(this.#R, e2 + 4, t2).fill(0), this.#W.setUint32(e2, 0);
  }
  get cssFontInfo() {
    let e2 = FontInfo2.#Q;
    e2 += 4 + this.#W.getUint32(e2);
    e2 += 4 + this.#W.getUint32(e2);
    const t2 = this.#W.getUint32(e2);
    if (0 === t2) return null;
    const i2 = new Uint8Array(t2);
    return i2.set(new Uint8Array(this.#R, e2 + 4, t2)), new CssFontInfo2(i2.buffer);
  }
  get systemFontInfo() {
    let e2 = FontInfo2.#Q;
    e2 += 4 + this.#W.getUint32(e2);
    const t2 = this.#W.getUint32(e2);
    if (0 === t2) return null;
    const i2 = new Uint8Array(t2);
    return i2.set(new Uint8Array(this.#R, e2 + 4, t2)), new SystemFontInfo2(i2.buffer);
  }
  static write(e2) {
    const t2 = e2.systemFontInfo ? SystemFontInfo2.write(e2.systemFontInfo) : null, i2 = e2.cssFontInfo ? CssFontInfo2.write(e2.cssFontInfo) : null, n2 = new TextEncoder(), a2 = {};
    let s2 = 0;
    for (const t3 of FontInfo2.strings) a2[t3] = n2.encode(e2[t3]), s2 += 4 + a2[t3].length;
    const r2 = FontInfo2.#Q + 4 + s2 + 4 + (t2 ? t2.byteLength : 0) + 4 + (i2 ? i2.byteLength : 0) + 4 + (e2.data ? e2.data.length : 0), o2 = new ArrayBuffer(r2), l2 = new Uint8Array(o2), c2 = new DataView(o2);
    let h2 = 0;
    const d2 = FontInfo2.bools.length;
    let u2 = 0, g2 = 0;
    for (let t3 = 0; t3 < d2; t3++) {
      const i3 = e2[FontInfo2.bools[t3]];
      u2 |= (void 0 === i3 ? 0 : i3 ? 2 : 1) << g2, g2 += 2, 8 !== g2 && t3 !== d2 - 1 || (c2.setUint8(h2++, u2), u2 = 0, g2 = 0);
    }
    assert(h2 === FontInfo2.#K, "FontInfo.write: Boolean properties offset mismatch");
    for (const t3 of FontInfo2.numbers) c2.setFloat64(h2, e2[t3]), h2 += 8;
    if (assert(h2 === FontInfo2.#Y, "FontInfo.write: Number properties offset mismatch"), e2.bbox) {
      c2.setUint8(h2++, 4);
      for (const t3 of e2.bbox) c2.setInt16(h2, t3, true), h2 += 2;
    } else c2.setUint8(h2++, 0), h2 += 8;
    if (assert(h2 === FontInfo2.#J, "FontInfo.write: BBox properties offset mismatch"), e2.fontMatrix) {
      c2.setUint8(h2++, 6);
      for (const t3 of e2.fontMatrix) c2.setFloat64(h2, t3, true), h2 += 8;
    } else c2.setUint8(h2++, 0), h2 += 48;
    if (assert(h2 === FontInfo2.#Z, "FontInfo.write: FontMatrix properties offset mismatch"), e2.defaultVMetrics) {
      c2.setUint8(h2++, 1);
      for (const t3 of e2.defaultVMetrics) c2.setInt16(h2, t3, true), h2 += 2;
    } else c2.setUint8(h2++, 0), h2 += 6;
    assert(h2 === FontInfo2.#Q, "FontInfo.write: DefaultVMetrics properties offset mismatch"), c2.setUint32(FontInfo2.#Q, 0), h2 += 4;
    for (const e3 of FontInfo2.strings) {
      const t3 = a2[e3], i3 = t3.length;
      c2.setUint32(h2, i3), l2.set(t3, h2 + 4), h2 += 4 + i3;
    }
    if (c2.setUint32(FontInfo2.#Q, h2 - FontInfo2.#Q - 4), t2) {
      const e3 = t2.byteLength;
      c2.setUint32(h2, e3), assert(h2 + 4 + e3 <= o2.byteLength, "FontInfo.write: Buffer overflow at systemFontInfo"), l2.set(new Uint8Array(t2), h2 + 4), h2 += 4 + e3;
    } else c2.setUint32(h2, 0), h2 += 4;
    if (i2) {
      const e3 = i2.byteLength;
      c2.setUint32(h2, e3), assert(h2 + 4 + e3 <= o2.byteLength, "FontInfo.write: Buffer overflow at cssFontInfo"), l2.set(new Uint8Array(i2), h2 + 4), h2 += 4 + e3;
    } else c2.setUint32(h2, 0), h2 += 4;
    return void 0 === e2.data ? (c2.setUint32(h2, 0), h2 += 4) : (c2.setUint32(h2, e2.data.length), l2.set(e2.data, h2 + 4), h2 += 4 + e2.data.length), assert(h2 <= o2.byteLength, "FontInfo.write: Buffer overflow"), o2.transferToFixedLength(h2);
  }
}
class GlobalWorkerOptions {
  static #ks = null;
  static #Ts = "";
  static get workerPort() {
    return this.#ks;
  }
  static set workerPort(e2) {
    if (!("undefined" != typeof Worker && e2 instanceof Worker) && null !== e2) throw new Error("Invalid `workerPort` type.");
    this.#ks = e2;
  }
  static get workerSrc() {
    return this.#Ts;
  }
  static set workerSrc(e2) {
    if ("string" != typeof e2) throw new Error("Invalid `workerSrc` type.");
    this.#Ts = e2;
  }
}
class Metadata {
  #Fs;
  #Is;
  constructor({ parsedData: e2, rawData: t2 }) {
    this.#Fs = e2, this.#Is = t2;
  }
  getRaw() {
    return this.#Is;
  }
  get(e2) {
    return this.#Fs.get(e2) ?? null;
  }
  [Symbol.iterator]() {
    return this.#Fs.entries();
  }
}
const sh = Symbol("INTERNAL");
class OptionalContentGroup {
  #Es = false;
  #Ms = false;
  #Ds = false;
  #Os = true;
  constructor(e2, { name: t2, intent: i2, usage: n2, rbGroups: a2 }) {
    this.#Es = !!(e2 & Dl), this.#Ms = !!(e2 & _l), this.name = t2, this.intent = i2, this.usage = n2, this.rbGroups = a2;
  }
  get visible() {
    if (this.#Ds) return this.#Os;
    if (!this.#Os) return false;
    const { print: e2, view: t2 } = this.usage;
    return this.#Es ? "OFF" !== t2?.viewState : !this.#Ms || "OFF" !== e2?.printState;
  }
  _setVisible(e2, t2, i2 = false) {
    e2 !== sh && unreachable("Internal method `_setVisible` called."), this.#Ds = i2, this.#Os = t2;
  }
}
class OptionalContentConfig {
  #_s = null;
  #Ps = /* @__PURE__ */ new Map();
  #Rs = null;
  #Bs = null;
  constructor(e2, t2 = Dl) {
    if (this.renderingIntent = t2, this.name = null, this.creator = null, null !== e2) {
      this.name = e2.name, this.creator = e2.creator, this.#Bs = e2.order;
      for (const i2 of e2.groups) this.#Ps.set(i2.id, new OptionalContentGroup(t2, i2));
      if ("OFF" === e2.baseState) for (const e3 of this.#Ps.values()) e3._setVisible(sh, false);
      for (const t3 of e2.on) this.#Ps.get(t3)._setVisible(sh, true);
      for (const t3 of e2.off) this.#Ps.get(t3)._setVisible(sh, false);
      this.#Rs = this.getHash();
    }
  }
  #Ns(e2) {
    const t2 = e2.length;
    if (t2 < 2) return true;
    const i2 = e2[0];
    for (let n2 = 1; n2 < t2; n2++) {
      const t3 = e2[n2];
      let a2;
      if (Array.isArray(t3)) a2 = this.#Ns(t3);
      else {
        if (!this.#Ps.has(t3)) return warn(`Optional content group not found: ${t3}`), true;
        a2 = this.#Ps.get(t3).visible;
      }
      switch (i2) {
        case "And":
          if (!a2) return false;
          break;
        case "Or":
          if (a2) return true;
          break;
        case "Not":
          return !a2;
        default:
          return true;
      }
    }
    return "And" === i2;
  }
  isVisible(e2) {
    if (0 === this.#Ps.size) return true;
    if (!e2) return info("Optional content group not defined."), true;
    if ("OCG" === e2.type) return this.#Ps.has(e2.id) ? this.#Ps.get(e2.id).visible : (warn(`Optional content group not found: ${e2.id}`), true);
    if ("OCMD" === e2.type) {
      if (e2.expression) return this.#Ns(e2.expression);
      if (!e2.policy || "AnyOn" === e2.policy) {
        for (const t2 of e2.ids) {
          if (!this.#Ps.has(t2)) return warn(`Optional content group not found: ${t2}`), true;
          if (this.#Ps.get(t2).visible) return true;
        }
        return false;
      }
      if ("AllOn" === e2.policy) {
        for (const t2 of e2.ids) {
          if (!this.#Ps.has(t2)) return warn(`Optional content group not found: ${t2}`), true;
          if (!this.#Ps.get(t2).visible) return false;
        }
        return true;
      }
      if ("AnyOff" === e2.policy) {
        for (const t2 of e2.ids) {
          if (!this.#Ps.has(t2)) return warn(`Optional content group not found: ${t2}`), true;
          if (!this.#Ps.get(t2).visible) return true;
        }
        return false;
      }
      if ("AllOff" === e2.policy) {
        for (const t2 of e2.ids) {
          if (!this.#Ps.has(t2)) return warn(`Optional content group not found: ${t2}`), true;
          if (this.#Ps.get(t2).visible) return false;
        }
        return true;
      }
      return warn(`Unknown optional content policy ${e2.policy}.`), true;
    }
    return warn(`Unknown group type ${e2.type}.`), true;
  }
  setVisibility(e2, t2 = true, i2 = true) {
    const n2 = this.#Ps.get(e2);
    if (n2) {
      if (i2 && t2 && n2.rbGroups.length) for (const t3 of n2.rbGroups) for (const i3 of t3) i3 !== e2 && this.#Ps.get(i3)?._setVisible(sh, false, true);
      n2._setVisible(sh, !!t2, true), this.#_s = null;
    } else warn(`Optional content group not found: ${e2}`);
  }
  setOCGState({ state: e2, preserveRB: t2 }) {
    let i2;
    for (const n2 of e2) {
      switch (n2) {
        case "ON":
        case "OFF":
        case "Toggle":
          i2 = n2;
          continue;
      }
      const e3 = this.#Ps.get(n2);
      if (e3) switch (i2) {
        case "ON":
          this.setVisibility(n2, true, t2);
          break;
        case "OFF":
          this.setVisibility(n2, false, t2);
          break;
        case "Toggle":
          this.setVisibility(n2, !e3.visible, t2);
      }
    }
    this.#_s = null;
  }
  get hasInitialVisibility() {
    return null === this.#Rs || this.getHash() === this.#Rs;
  }
  getOrder() {
    return this.#Ps.size ? this.#Bs ? this.#Bs.slice() : [...this.#Ps.keys()] : null;
  }
  getGroup(e2) {
    return this.#Ps.get(e2) || null;
  }
  getHash() {
    if (null !== this.#_s) return this.#_s;
    const e2 = new MurmurHash3_64();
    for (const [t2, i2] of this.#Ps) e2.update(`${t2}:${i2.visible}`);
    return this.#_s = e2.hexdigest();
  }
  [Symbol.iterator]() {
    return this.#Ps.entries();
  }
}
class PDFDataTransportStream {
  constructor(e2, { disableRange: t2 = false, disableStream: i2 = false }) {
    assert(e2, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    const { length: n2, initialData: a2, progressiveDone: s2, contentDispositionFilename: r2 } = e2;
    if (this._queuedChunks = [], this._progressiveDone = s2, this._contentDispositionFilename = r2, a2?.length > 0) {
      const e3 = a2 instanceof Uint8Array && a2.byteLength === a2.buffer.byteLength ? a2.buffer : new Uint8Array(a2).buffer;
      this._queuedChunks.push(e3);
    }
    this._pdfDataRangeTransport = e2, this._isStreamingSupported = !i2, this._isRangeSupported = !t2, this._contentLength = n2, this._fullRequestReader = null, this._rangeReaders = [], e2.addRangeListener((e3, t3) => {
      this._onReceiveData({ begin: e3, chunk: t3 });
    }), e2.addProgressListener((e3, t3) => {
      this._onProgress({ loaded: e3, total: t3 });
    }), e2.addProgressiveReadListener((e3) => {
      this._onReceiveData({ chunk: e3 });
    }), e2.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    }), e2.transportReady();
  }
  _onReceiveData({ begin: e2, chunk: t2 }) {
    const i2 = t2 instanceof Uint8Array && t2.byteLength === t2.buffer.byteLength ? t2.buffer : new Uint8Array(t2).buffer;
    if (void 0 === e2) this._fullRequestReader ? this._fullRequestReader._enqueue(i2) : this._queuedChunks.push(i2);
    else {
      assert(this._rangeReaders.some(function(t3) {
        return t3._begin === e2 && (t3._enqueue(i2), true);
      }), "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  _onProgress(e2) {
    void 0 === e2.total ? this._rangeReaders[0]?.onProgress?.({ loaded: e2.loaded }) : this._fullRequestReader?.onProgress?.({ loaded: e2.loaded, total: e2.total });
  }
  _onProgressiveDone() {
    this._fullRequestReader?.progressiveDone(), this._progressiveDone = true;
  }
  _removeRangeReader(e2) {
    const t2 = this._rangeReaders.indexOf(e2);
    t2 >= 0 && this._rangeReaders.splice(t2, 1);
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const e2 = this._queuedChunks;
    return this._queuedChunks = null, new PDFDataTransportStreamReader(this, e2, this._progressiveDone, this._contentDispositionFilename);
  }
  getRangeReader(e2, t2) {
    if (t2 <= this._progressiveDataLength) return null;
    const i2 = new PDFDataTransportStreamRangeReader(this, e2, t2);
    return this._pdfDataRangeTransport.requestDataRange(e2, t2), this._rangeReaders.push(i2), i2;
  }
  cancelAllRequests(e2) {
    this._fullRequestReader?.cancel(e2);
    for (const t2 of this._rangeReaders.slice(0)) t2.cancel(e2);
    this._pdfDataRangeTransport.abort();
  }
}
class PDFDataTransportStreamReader {
  constructor(e2, t2, i2 = false, n2 = null) {
    this._stream = e2, this._done = i2 || false, this._filename = isPdfFile(n2) ? n2 : null, this._queuedChunks = t2 || [], this._loaded = 0;
    for (const e3 of this._queuedChunks) this._loaded += e3.byteLength;
    this._requests = [], this._headersReady = Promise.resolve(), e2._fullRequestReader = this, this.onProgress = null;
  }
  _enqueue(e2) {
    if (!this._done) {
      if (this._requests.length > 0) {
        this._requests.shift().resolve({ value: e2, done: false });
      } else this._queuedChunks.push(e2);
      this._loaded += e2.byteLength;
    }
  }
  get headersReady() {
    return this._headersReady;
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }
  get contentLength() {
    return this._stream._contentLength;
  }
  async read() {
    if (this._queuedChunks.length > 0) {
      return { value: this._queuedChunks.shift(), done: false };
    }
    if (this._done) return { value: void 0, done: true };
    const e2 = Promise.withResolvers();
    return this._requests.push(e2), e2.promise;
  }
  cancel(e2) {
    this._done = true;
    for (const e3 of this._requests) e3.resolve({ value: void 0, done: true });
    this._requests.length = 0;
  }
  progressiveDone() {
    this._done || (this._done = true);
  }
}
class PDFDataTransportStreamRangeReader {
  constructor(e2, t2, i2) {
    this._stream = e2, this._begin = t2, this._end = i2, this._queuedChunk = null, this._requests = [], this._done = false, this.onProgress = null;
  }
  _enqueue(e2) {
    if (!this._done) {
      if (0 === this._requests.length) this._queuedChunk = e2;
      else {
        this._requests.shift().resolve({ value: e2, done: false });
        for (const e3 of this._requests) e3.resolve({ value: void 0, done: true });
        this._requests.length = 0;
      }
      this._done = true, this._stream._removeRangeReader(this);
    }
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    if (this._queuedChunk) {
      const e3 = this._queuedChunk;
      return this._queuedChunk = null, { value: e3, done: false };
    }
    if (this._done) return { value: void 0, done: true };
    const e2 = Promise.withResolvers();
    return this._requests.push(e2), e2.promise;
  }
  cancel(e2) {
    this._done = true;
    for (const e3 of this._requests) e3.resolve({ value: void 0, done: true });
    this._requests.length = 0, this._stream._removeRangeReader(this);
  }
}
function createHeaders(e2, t2) {
  const i2 = new Headers();
  if (!e2 || !t2 || "object" != typeof t2) return i2;
  for (const e3 in t2) {
    const n2 = t2[e3];
    void 0 !== n2 && i2.append(e3, n2);
  }
  return i2;
}
function getResponseOrigin(e2) {
  return URL.parse(e2)?.origin ?? null;
}
function validateRangeRequestCapabilities({ responseHeaders: e2, isHttp: t2, rangeChunkSize: i2, disableRange: n2 }) {
  const a2 = { allowRangeRequests: false, suggestedLength: void 0 }, s2 = parseInt(e2.get("Content-Length"), 10);
  if (!Number.isInteger(s2)) return a2;
  if (a2.suggestedLength = s2, s2 <= 2 * i2) return a2;
  if (n2 || !t2) return a2;
  if ("bytes" !== e2.get("Accept-Ranges")) return a2;
  return "identity" !== (e2.get("Content-Encoding") || "identity") || (a2.allowRangeRequests = true), a2;
}
function extractFilenameFromHeader(e2) {
  const t2 = e2.get("Content-Disposition");
  if (t2) {
    let e3 = (function(e4) {
      let t3 = true, i2 = toParamRegExp("filename\\*", "i").exec(e4);
      if (i2) {
        i2 = i2[1];
        let e5 = rfc2616unquote(i2);
        return e5 = unescape(e5), e5 = rfc5987decode(e5), e5 = rfc2047decode(e5), fixupEncoding(e5);
      }
      if (i2 = (function(e5) {
        const t4 = [];
        let i3;
        const n2 = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
        for (; null !== (i3 = n2.exec(e5)); ) {
          let [, e6, n3, a3] = i3;
          if (e6 = parseInt(e6, 10), e6 in t4) {
            if (0 === e6) break;
          } else t4[e6] = [n3, a3];
        }
        const a2 = [];
        for (let e6 = 0; e6 < t4.length && e6 in t4; ++e6) {
          let [i4, n3] = t4[e6];
          n3 = rfc2616unquote(n3), i4 && (n3 = unescape(n3), 0 === e6 && (n3 = rfc5987decode(n3))), a2.push(n3);
        }
        return a2.join("");
      })(e4), i2) return fixupEncoding(rfc2047decode(i2));
      if (i2 = toParamRegExp("filename", "i").exec(e4), i2) {
        i2 = i2[1];
        let e5 = rfc2616unquote(i2);
        return e5 = rfc2047decode(e5), fixupEncoding(e5);
      }
      function toParamRegExp(e5, t4) {
        return new RegExp("(?:^|;)\\s*" + e5 + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', t4);
      }
      function textdecode(e5, i3) {
        if (e5) {
          if (!/^[\x00-\xFF]+$/.test(i3)) return i3;
          try {
            const n2 = new TextDecoder(e5, { fatal: true }), a2 = stringToBytes(i3);
            i3 = n2.decode(a2), t3 = false;
          } catch {
          }
        }
        return i3;
      }
      function fixupEncoding(e5) {
        return t3 && /[\x80-\xff]/.test(e5) && (e5 = textdecode("utf-8", e5), t3 && (e5 = textdecode("iso-8859-1", e5))), e5;
      }
      function rfc2616unquote(e5) {
        if (e5.startsWith('"')) {
          const t4 = e5.slice(1).split('\\"');
          for (let e6 = 0; e6 < t4.length; ++e6) {
            const i3 = t4[e6].indexOf('"');
            -1 !== i3 && (t4[e6] = t4[e6].slice(0, i3), t4.length = e6 + 1), t4[e6] = t4[e6].replaceAll(/\\(.)/g, "$1");
          }
          e5 = t4.join('"');
        }
        return e5;
      }
      function rfc5987decode(e5) {
        const t4 = e5.indexOf("'");
        return -1 === t4 ? e5 : textdecode(e5.slice(0, t4), e5.slice(t4 + 1).replace(/^[^']*'/, ""));
      }
      function rfc2047decode(e5) {
        return !e5.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(e5) ? e5 : e5.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(e6, t4, i3, n2) {
          if ("q" === i3 || "Q" === i3) return textdecode(t4, n2 = (n2 = n2.replaceAll("_", " ")).replaceAll(/=([0-9a-fA-F]{2})/g, function(e7, t5) {
            return String.fromCharCode(parseInt(t5, 16));
          }));
          try {
            n2 = atob(n2);
          } catch {
          }
          return textdecode(t4, n2);
        });
      }
      return "";
    })(t2);
    if (e3.includes("%")) try {
      e3 = decodeURIComponent(e3);
    } catch {
    }
    if (isPdfFile(e3)) return e3;
  }
  return null;
}
function createResponseError(e2, t2) {
  return new ResponseException(`Unexpected server response (${e2}) while retrieving PDF "${t2}".`, e2, 404 === e2 || 0 === e2 && t2.startsWith("file:"));
}
function validateResponseStatus(e2) {
  return 200 === e2 || 206 === e2;
}
function createFetchOptions(e2, t2, i2) {
  return { method: "GET", headers: e2, signal: i2.signal, mode: "cors", credentials: t2 ? "include" : "same-origin", redirect: "follow" };
}
function getArrayBuffer(e2) {
  return e2 instanceof Uint8Array ? e2.buffer : e2 instanceof ArrayBuffer ? e2 : (warn(`getArrayBuffer - unexpected data format: ${e2}`), new Uint8Array(e2).buffer);
}
class PDFFetchStream {
  _responseOrigin = null;
  constructor(e2) {
    this.source = e2, this.isHttp = /^https?:/i.test(e2.url), this.headers = createHeaders(this.isHttp, e2.httpHeaders), this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  getFullReader() {
    return assert(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new PDFFetchStreamReader(this), this._fullRequestReader;
  }
  getRangeReader(e2, t2) {
    if (t2 <= this._progressiveDataLength) return null;
    const i2 = new PDFFetchStreamRangeReader(this, e2, t2);
    return this._rangeRequestReaders.push(i2), i2;
  }
  cancelAllRequests(e2) {
    this._fullRequestReader?.cancel(e2);
    for (const t2 of this._rangeRequestReaders.slice(0)) t2.cancel(e2);
  }
}
class PDFFetchStreamReader {
  constructor(e2) {
    this._stream = e2, this._reader = null, this._loaded = 0, this._filename = null;
    const t2 = e2.source;
    this._withCredentials = t2.withCredentials || false, this._contentLength = t2.length, this._headersCapability = Promise.withResolvers(), this._disableRange = t2.disableRange || false, this._rangeChunkSize = t2.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = true), this._abortController = new AbortController(), this._isStreamingSupported = !t2.disableStream, this._isRangeSupported = !t2.disableRange;
    const i2 = new Headers(e2.headers), n2 = t2.url;
    fetch(n2, createFetchOptions(i2, this._withCredentials, this._abortController)).then((t3) => {
      if (e2._responseOrigin = getResponseOrigin(t3.url), !validateResponseStatus(t3.status)) throw createResponseError(t3.status, n2);
      this._reader = t3.body.getReader(), this._headersCapability.resolve();
      const i3 = t3.headers, { allowRangeRequests: a2, suggestedLength: s2 } = validateRangeRequestCapabilities({ responseHeaders: i3, isHttp: e2.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange });
      this._isRangeSupported = a2, this._contentLength = s2 || this._contentLength, this._filename = extractFilenameFromHeader(i3), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new AbortException("Streaming is disabled."));
    }).catch(this._headersCapability.reject), this.onProgress = null;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._headersCapability.promise;
    const { value: e2, done: t2 } = await this._reader.read();
    return t2 ? { value: e2, done: t2 } : (this._loaded += e2.byteLength, this.onProgress?.({ loaded: this._loaded, total: this._contentLength }), { value: getArrayBuffer(e2), done: false });
  }
  cancel(e2) {
    this._reader?.cancel(e2), this._abortController.abort();
  }
}
class PDFFetchStreamRangeReader {
  constructor(e2, t2, i2) {
    this._stream = e2, this._reader = null, this._loaded = 0;
    const n2 = e2.source;
    this._withCredentials = n2.withCredentials || false, this._readCapability = Promise.withResolvers(), this._isStreamingSupported = !n2.disableStream, this._abortController = new AbortController();
    const a2 = new Headers(e2.headers);
    a2.append("Range", `bytes=${t2}-${i2 - 1}`);
    const s2 = n2.url;
    fetch(s2, createFetchOptions(a2, this._withCredentials, this._abortController)).then((t3) => {
      const i3 = getResponseOrigin(t3.url);
      if (i3 !== e2._responseOrigin) throw new Error(`Expected range response-origin "${i3}" to match "${e2._responseOrigin}".`);
      if (!validateResponseStatus(t3.status)) throw createResponseError(t3.status, s2);
      this._readCapability.resolve(), this._reader = t3.body.getReader();
    }).catch(this._readCapability.reject), this.onProgress = null;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._readCapability.promise;
    const { value: e2, done: t2 } = await this._reader.read();
    return t2 ? { value: e2, done: t2 } : (this._loaded += e2.byteLength, this.onProgress?.({ loaded: this._loaded }), { value: getArrayBuffer(e2), done: false });
  }
  cancel(e2) {
    this._reader?.cancel(e2), this._abortController.abort();
  }
}
class NetworkManager {
  _responseOrigin = null;
  constructor({ url: e2, httpHeaders: t2, withCredentials: i2 }) {
    this.url = e2, this.isHttp = /^https?:/i.test(e2), this.headers = createHeaders(this.isHttp, t2), this.withCredentials = i2 || false, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
  }
  request(e2) {
    const t2 = new XMLHttpRequest(), i2 = this.currXhrId++, n2 = this.pendingRequests[i2] = { xhr: t2 };
    t2.open("GET", this.url), t2.withCredentials = this.withCredentials;
    for (const [e3, i3] of this.headers) t2.setRequestHeader(e3, i3);
    return this.isHttp && "begin" in e2 && "end" in e2 ? (t2.setRequestHeader("Range", `bytes=${e2.begin}-${e2.end - 1}`), n2.expectedStatus = 206) : n2.expectedStatus = 200, t2.responseType = "arraybuffer", assert(e2.onError, "Expected `onError` callback to be provided."), t2.onerror = () => {
      e2.onError(t2.status);
    }, t2.onreadystatechange = this.onStateChange.bind(this, i2), t2.onprogress = this.onProgress.bind(this, i2), n2.onHeadersReceived = e2.onHeadersReceived, n2.onDone = e2.onDone, n2.onError = e2.onError, n2.onProgress = e2.onProgress, t2.send(null), i2;
  }
  onProgress(e2, t2) {
    const i2 = this.pendingRequests[e2];
    i2 && i2.onProgress?.(t2);
  }
  onStateChange(e2, t2) {
    const i2 = this.pendingRequests[e2];
    if (!i2) return;
    const n2 = i2.xhr;
    if (n2.readyState >= 2 && i2.onHeadersReceived && (i2.onHeadersReceived(), delete i2.onHeadersReceived), 4 !== n2.readyState) return;
    if (!(e2 in this.pendingRequests)) return;
    if (delete this.pendingRequests[e2], 0 === n2.status && this.isHttp) return void i2.onError(n2.status);
    const a2 = n2.status || 200;
    if (!(200 === a2 && 206 === i2.expectedStatus) && a2 !== i2.expectedStatus) return void i2.onError(n2.status);
    const s2 = (function(e3) {
      const t3 = e3.response;
      return "string" != typeof t3 ? t3 : stringToBytes(t3).buffer;
    })(n2);
    if (206 === a2) {
      const e3 = n2.getResponseHeader("Content-Range"), t3 = /bytes (\d+)-(\d+)\/(\d+)/.exec(e3);
      t3 ? i2.onDone({ begin: parseInt(t3[1], 10), chunk: s2 }) : (warn('Missing or invalid "Content-Range" header.'), i2.onError(0));
    } else s2 ? i2.onDone({ begin: 0, chunk: s2 }) : i2.onError(n2.status);
  }
  getRequestXhr(e2) {
    return this.pendingRequests[e2].xhr;
  }
  isPendingRequest(e2) {
    return e2 in this.pendingRequests;
  }
  abortRequest(e2) {
    const t2 = this.pendingRequests[e2].xhr;
    delete this.pendingRequests[e2], t2.abort();
  }
}
class PDFNetworkStream {
  constructor(e2) {
    this._source = e2, this._manager = new NetworkManager(e2), this._rangeChunkSize = e2.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  _onRangeRequestReaderClosed(e2) {
    const t2 = this._rangeRequestReaders.indexOf(e2);
    t2 >= 0 && this._rangeRequestReaders.splice(t2, 1);
  }
  getFullReader() {
    return assert(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source), this._fullRequestReader;
  }
  getRangeReader(e2, t2) {
    const i2 = new PDFNetworkStreamRangeRequestReader(this._manager, e2, t2);
    return i2.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(i2), i2;
  }
  cancelAllRequests(e2) {
    this._fullRequestReader?.cancel(e2);
    for (const t2 of this._rangeRequestReaders.slice(0)) t2.cancel(e2);
  }
}
class PDFNetworkStreamFullRequestReader {
  constructor(e2, t2) {
    this._manager = e2, this._url = t2.url, this._fullRequestId = e2.request({ onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) }), this._headersCapability = Promise.withResolvers(), this._disableRange = t2.disableRange || false, this._contentLength = t2.length, this._rangeChunkSize = t2.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = true), this._isStreamingSupported = false, this._isRangeSupported = false, this._cachedChunks = [], this._requests = [], this._done = false, this._storedError = void 0, this._filename = null, this.onProgress = null;
  }
  _onHeadersReceived() {
    const e2 = this._fullRequestId, t2 = this._manager.getRequestXhr(e2);
    this._manager._responseOrigin = getResponseOrigin(t2.responseURL);
    const i2 = t2.getAllResponseHeaders(), n2 = new Headers(i2 ? i2.trimStart().replace(/[^\S ]+$/, "").split(/[\r\n]+/).map((e3) => {
      const [t3, ...i3] = e3.split(": ");
      return [t3, i3.join(": ")];
    }) : []), { allowRangeRequests: a2, suggestedLength: s2 } = validateRangeRequestCapabilities({ responseHeaders: n2, isHttp: this._manager.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange });
    a2 && (this._isRangeSupported = true), this._contentLength = s2 || this._contentLength, this._filename = extractFilenameFromHeader(n2), this._isRangeSupported && this._manager.abortRequest(e2), this._headersCapability.resolve();
  }
  _onDone(e2) {
    if (e2) if (this._requests.length > 0) {
      this._requests.shift().resolve({ value: e2.chunk, done: false });
    } else this._cachedChunks.push(e2.chunk);
    if (this._done = true, !(this._cachedChunks.length > 0)) {
      for (const e3 of this._requests) e3.resolve({ value: void 0, done: true });
      this._requests.length = 0;
    }
  }
  _onError(e2) {
    this._storedError = createResponseError(e2, this._url), this._headersCapability.reject(this._storedError);
    for (const e3 of this._requests) e3.reject(this._storedError);
    this._requests.length = 0, this._cachedChunks.length = 0;
  }
  _onProgress(e2) {
    this.onProgress?.({ loaded: e2.loaded, total: e2.lengthComputable ? e2.total : this._contentLength });
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get contentLength() {
    return this._contentLength;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  async read() {
    if (await this._headersCapability.promise, this._storedError) throw this._storedError;
    if (this._cachedChunks.length > 0) {
      return { value: this._cachedChunks.shift(), done: false };
    }
    if (this._done) return { value: void 0, done: true };
    const e2 = Promise.withResolvers();
    return this._requests.push(e2), e2.promise;
  }
  cancel(e2) {
    this._done = true, this._headersCapability.reject(e2);
    for (const e3 of this._requests) e3.resolve({ value: void 0, done: true });
    this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
  }
}
class PDFNetworkStreamRangeRequestReader {
  constructor(e2, t2, i2) {
    this._manager = e2, this._url = e2.url, this._requestId = e2.request({ begin: t2, end: i2, onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) }), this._requests = [], this._queuedChunk = null, this._done = false, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
  }
  _onHeadersReceived() {
    const e2 = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);
    e2 !== this._manager._responseOrigin && (this._storedError = new Error(`Expected range response-origin "${e2}" to match "${this._manager._responseOrigin}".`), this._onError(0));
  }
  _close() {
    this.onClosed?.(this);
  }
  _onDone(e2) {
    const t2 = e2.chunk;
    if (this._requests.length > 0) {
      this._requests.shift().resolve({ value: t2, done: false });
    } else this._queuedChunk = t2;
    this._done = true;
    for (const e3 of this._requests) e3.resolve({ value: void 0, done: true });
    this._requests.length = 0, this._close();
  }
  _onError(e2) {
    this._storedError ??= createResponseError(e2, this._url);
    for (const e3 of this._requests) e3.reject(this._storedError);
    this._requests.length = 0, this._queuedChunk = null;
  }
  _onProgress(e2) {
    this.isStreamingSupported || this.onProgress?.({ loaded: e2.loaded });
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    if (this._storedError) throw this._storedError;
    if (null !== this._queuedChunk) {
      const e3 = this._queuedChunk;
      return this._queuedChunk = null, { value: e3, done: false };
    }
    if (this._done) return { value: void 0, done: true };
    const e2 = Promise.withResolvers();
    return this._requests.push(e2), e2.promise;
  }
  cancel(e2) {
    this._done = true;
    for (const e3 of this._requests) e3.resolve({ value: void 0, done: true });
    this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
  }
}
const rh = /^[a-z][a-z0-9\-+.]+:/i;
class PDFNodeStream {
  constructor(e2) {
    this.source = e2, this.url = (function(e3) {
      if (rh.test(e3)) return new URL(e3);
      const t2 = process.getBuiltinModule("url");
      return new URL(t2.pathToFileURL(e3));
    })(e2.url), assert("file:" === this.url.protocol, "PDFNodeStream only supports file:// URLs."), this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  getFullReader() {
    return assert(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = new PDFNodeStreamFsFullReader(this), this._fullRequestReader;
  }
  getRangeReader(e2, t2) {
    if (t2 <= this._progressiveDataLength) return null;
    const i2 = new PDFNodeStreamFsRangeReader(this, e2, t2);
    return this._rangeRequestReaders.push(i2), i2;
  }
  cancelAllRequests(e2) {
    this._fullRequestReader?.cancel(e2);
    for (const t2 of this._rangeRequestReaders.slice(0)) t2.cancel(e2);
  }
}
class PDFNodeStreamFsFullReader {
  constructor(e2) {
    this._url = e2.url, this._done = false, this._storedError = null, this.onProgress = null;
    const t2 = e2.source;
    this._contentLength = t2.length, this._loaded = 0, this._filename = null, this._disableRange = t2.disableRange || false, this._rangeChunkSize = t2.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = true), this._isStreamingSupported = !t2.disableStream, this._isRangeSupported = !t2.disableRange, this._readableStream = null, this._readCapability = Promise.withResolvers(), this._headersCapability = Promise.withResolvers();
    const i2 = process.getBuiltinModule("fs");
    i2.promises.lstat(this._url).then((e3) => {
      this._contentLength = e3.size, this._setReadableStream(i2.createReadStream(this._url)), this._headersCapability.resolve();
    }, (e3) => {
      "ENOENT" === e3.code && (e3 = createResponseError(0, this._url.href)), this._storedError = e3, this._headersCapability.reject(e3);
    });
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    if (await this._readCapability.promise, this._done) return { value: void 0, done: true };
    if (this._storedError) throw this._storedError;
    const e2 = this._readableStream.read();
    if (null === e2) return this._readCapability = Promise.withResolvers(), this.read();
    this._loaded += e2.length, this.onProgress?.({ loaded: this._loaded, total: this._contentLength });
    return { value: new Uint8Array(e2).buffer, done: false };
  }
  cancel(e2) {
    this._readableStream ? this._readableStream.destroy(e2) : this._error(e2);
  }
  _error(e2) {
    this._storedError = e2, this._readCapability.resolve();
  }
  _setReadableStream(e2) {
    this._readableStream = e2, e2.on("readable", () => {
      this._readCapability.resolve();
    }), e2.on("end", () => {
      e2.destroy(), this._done = true, this._readCapability.resolve();
    }), e2.on("error", (e3) => {
      this._error(e3);
    }), !this._isStreamingSupported && this._isRangeSupported && this._error(new AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
  }
}
class PDFNodeStreamFsRangeReader {
  constructor(e2, t2, i2) {
    this._url = e2.url, this._done = false, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = Promise.withResolvers();
    const n2 = e2.source;
    this._isStreamingSupported = !n2.disableStream;
    const a2 = process.getBuiltinModule("fs");
    this._setReadableStream(a2.createReadStream(this._url, { start: t2, end: i2 - 1 }));
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    if (await this._readCapability.promise, this._done) return { value: void 0, done: true };
    if (this._storedError) throw this._storedError;
    const e2 = this._readableStream.read();
    if (null === e2) return this._readCapability = Promise.withResolvers(), this.read();
    this._loaded += e2.length, this.onProgress?.({ loaded: this._loaded });
    return { value: new Uint8Array(e2).buffer, done: false };
  }
  cancel(e2) {
    this._readableStream ? this._readableStream.destroy(e2) : this._error(e2);
  }
  _error(e2) {
    this._storedError = e2, this._readCapability.resolve();
  }
  _setReadableStream(e2) {
    this._readableStream = e2, e2.on("readable", () => {
      this._readCapability.resolve();
    }), e2.on("end", () => {
      e2.destroy(), this._done = true, this._readCapability.resolve();
    }), e2.on("error", (e3) => {
      this._error(e3);
    }), this._storedError && this._readableStream.destroy(this._storedError);
  }
}
const oh = Symbol("INITIAL_DATA");
class PDFObjects {
  #Ls = /* @__PURE__ */ Object.create(null);
  #Us(e2) {
    return this.#Ls[e2] ||= { ...Promise.withResolvers(), data: oh };
  }
  get(e2, t2 = null) {
    if (t2) {
      const i3 = this.#Us(e2);
      return i3.promise.then(() => t2(i3.data)), null;
    }
    const i2 = this.#Ls[e2];
    if (!i2 || i2.data === oh) throw new Error(`Requesting object that isn't resolved yet ${e2}.`);
    return i2.data;
  }
  has(e2) {
    const t2 = this.#Ls[e2];
    return !!t2 && t2.data !== oh;
  }
  delete(e2) {
    const t2 = this.#Ls[e2];
    return !(!t2 || t2.data === oh) && (delete this.#Ls[e2], true);
  }
  resolve(e2, t2 = null) {
    const i2 = this.#Us(e2);
    i2.data = t2, i2.resolve();
  }
  clear() {
    for (const e2 in this.#Ls) {
      const { data: t2 } = this.#Ls[e2];
      t2?.bitmap?.close();
    }
    this.#Ls = /* @__PURE__ */ Object.create(null);
  }
  *[Symbol.iterator]() {
    for (const e2 in this.#Ls) {
      const { data: t2 } = this.#Ls[e2];
      t2 !== oh && (yield [e2, t2]);
    }
  }
}
class TextLayer {
  #js = Promise.withResolvers();
  #Mi = null;
  #$s = false;
  #Hs = !!globalThis.FontInspector?.enabled;
  #Xs = null;
  #qs = null;
  #zs = 0;
  #Ws = 0;
  #Gs = null;
  #Vs = null;
  #Ks = 0;
  #Ys = 0;
  #Js = /* @__PURE__ */ Object.create(null);
  #Zs = [];
  #Qs = null;
  #er = [];
  #tr = /* @__PURE__ */ new WeakMap();
  #ir = null;
  static #nr = /* @__PURE__ */ new Map();
  static #ar = /* @__PURE__ */ new Map();
  static #sr = /* @__PURE__ */ new WeakMap();
  static #rr = null;
  static #or = /* @__PURE__ */ new Set();
  constructor({ textContentSource: e2, container: t2, viewport: i2 }) {
    if (e2 instanceof ReadableStream) this.#Qs = e2;
    else {
      if ("object" != typeof e2) throw new Error('No "textContentSource" parameter specified.');
      this.#Qs = new ReadableStream({ start(t3) {
        t3.enqueue(e2), t3.close();
      } });
    }
    this.#Mi = this.#Vs = t2, this.#Ys = i2.scale * OutputScale.pixelRatio, this.#Ks = i2.rotation, this.#qs = { div: null, properties: null, ctx: null };
    const { pageWidth: n2, pageHeight: a2, pageX: s2, pageY: r2 } = i2.rawDims;
    this.#ir = [1, 0, 0, -1, -s2, r2 + a2], this.#Ws = n2, this.#zs = a2, TextLayer.#lr(), setLayerDimensions(t2, i2), this.#js.promise.finally(() => {
      TextLayer.#or.delete(this), this.#qs = null, this.#Js = null;
    }).catch(() => {
    });
  }
  static get fontFamilyMap() {
    const { isWindows: e2, isFirefox: t2 } = util_FeatureTest.platform;
    return shadow(this, "fontFamilyMap", /* @__PURE__ */ new Map([["sans-serif", (e2 && t2 ? "Calibri, " : "") + "sans-serif"], ["monospace", (e2 && t2 ? "Lucida Console, " : "") + "monospace"]]));
  }
  render() {
    const pump = () => {
      this.#Gs.read().then(({ value: e2, done: t2 }) => {
        t2 ? this.#js.resolve() : (this.#Xs ??= e2.lang, Object.assign(this.#Js, e2.styles), this.#cr(e2.items), pump());
      }, this.#js.reject);
    };
    return this.#Gs = this.#Qs.getReader(), TextLayer.#or.add(this), pump(), this.#js.promise;
  }
  update({ viewport: e2, onBefore: t2 = null }) {
    const i2 = e2.scale * OutputScale.pixelRatio, n2 = e2.rotation;
    if (n2 !== this.#Ks && (t2?.(), this.#Ks = n2, setLayerDimensions(this.#Vs, { rotation: n2 })), i2 !== this.#Ys) {
      t2?.(), this.#Ys = i2;
      const e3 = { div: null, properties: null, ctx: TextLayer.#hr(this.#Xs) };
      for (const t3 of this.#er) e3.properties = this.#tr.get(t3), e3.div = t3, this.#dr(e3);
    }
  }
  cancel() {
    const e2 = new AbortException("TextLayer task cancelled.");
    this.#Gs?.cancel(e2).catch(() => {
    }), this.#Gs = null, this.#js.reject(e2);
  }
  get textDivs() {
    return this.#er;
  }
  get textContentItemsStr() {
    return this.#Zs;
  }
  #cr(e2) {
    if (this.#$s) return;
    this.#qs.ctx ??= TextLayer.#hr(this.#Xs);
    const t2 = this.#er, i2 = this.#Zs;
    for (const n2 of e2) {
      if (t2.length > 1e5) return warn("Ignoring additional textDivs for performance reasons."), void (this.#$s = true);
      if (void 0 !== n2.str) i2.push(n2.str), this.#ur(n2);
      else if ("beginMarkedContentProps" === n2.type || "beginMarkedContent" === n2.type) {
        const e3 = this.#Mi;
        this.#Mi = document.createElement("span"), this.#Mi.classList.add("markedContent"), n2.id && this.#Mi.setAttribute("id", `${n2.id}`), e3.append(this.#Mi);
      } else "endMarkedContent" === n2.type && (this.#Mi = this.#Mi.parentNode);
    }
  }
  #ur(e2) {
    const t2 = document.createElement("span"), i2 = { angle: 0, canvasWidth: 0, hasText: "" !== e2.str, hasEOL: e2.hasEOL, fontSize: 0 };
    this.#er.push(t2);
    const n2 = Util.transform(this.#ir, e2.transform);
    let a2 = Math.atan2(n2[1], n2[0]);
    const s2 = this.#Js[e2.fontName];
    s2.vertical && (a2 += Math.PI / 2);
    let r2 = this.#Hs && s2.fontSubstitution || s2.fontFamily;
    r2 = TextLayer.fontFamilyMap.get(r2) || r2;
    const o2 = Math.hypot(n2[2], n2[3]), l2 = o2 * TextLayer.#gr(r2, s2, this.#Xs);
    let c2, h2;
    0 === a2 ? (c2 = n2[4], h2 = n2[5] - l2) : (c2 = n2[4] + l2 * Math.sin(a2), h2 = n2[5] - l2 * Math.cos(a2));
    const d2 = "calc(var(--total-scale-factor) *", u2 = t2.style;
    this.#Mi === this.#Vs ? (u2.left = `${(100 * c2 / this.#Ws).toFixed(2)}%`, u2.top = `${(100 * h2 / this.#zs).toFixed(2)}%`) : (u2.left = `${d2}${c2.toFixed(2)}px)`, u2.top = `${d2}${h2.toFixed(2)}px)`), u2.fontSize = `${d2}${(TextLayer.#rr * o2).toFixed(2)}px)`, u2.fontFamily = r2, i2.fontSize = o2, t2.setAttribute("role", "presentation"), t2.textContent = e2.str, t2.dir = e2.dir, this.#Hs && (t2.dataset.fontName = s2.fontSubstitutionLoadedName || e2.fontName), 0 !== a2 && (i2.angle = a2 * (180 / Math.PI));
    let g2 = false;
    if (e2.str.length > 1) g2 = true;
    else if (" " !== e2.str && e2.transform[0] !== e2.transform[3]) {
      const t3 = Math.abs(e2.transform[0]), i3 = Math.abs(e2.transform[3]);
      t3 !== i3 && Math.max(t3, i3) / Math.min(t3, i3) > 1.5 && (g2 = true);
    }
    if (g2 && (i2.canvasWidth = s2.vertical ? e2.height : e2.width), this.#tr.set(t2, i2), this.#qs.div = t2, this.#qs.properties = i2, this.#dr(this.#qs), i2.hasText && this.#Mi.append(t2), i2.hasEOL) {
      const e3 = document.createElement("br");
      e3.setAttribute("role", "presentation"), this.#Mi.append(e3);
    }
  }
  #dr(e2) {
    const { div: t2, properties: i2, ctx: n2 } = e2, { style: a2 } = t2;
    let s2 = "";
    if (TextLayer.#rr > 1 && (s2 = `scale(${1 / TextLayer.#rr})`), 0 !== i2.canvasWidth && i2.hasText) {
      const { fontFamily: e3 } = a2, { canvasWidth: r2, fontSize: o2 } = i2;
      TextLayer.#fr(n2, o2 * this.#Ys, e3);
      const { width: l2 } = n2.measureText(t2.textContent);
      l2 > 0 && (s2 = `scaleX(${r2 * this.#Ys / l2}) ${s2}`);
    }
    0 !== i2.angle && (s2 = `rotate(${i2.angle}deg) ${s2}`), s2.length > 0 && (a2.transform = s2);
  }
  static cleanup() {
    if (!(this.#or.size > 0)) {
      this.#nr.clear();
      for (const { canvas: e2 } of this.#ar.values()) e2.remove();
      this.#ar.clear();
    }
  }
  static #hr(e2 = null) {
    let t2 = this.#ar.get(e2 ||= "");
    if (!t2) {
      const i2 = document.createElement("canvas");
      i2.className = "hiddenCanvasElement", i2.lang = e2, document.body.append(i2), t2 = i2.getContext("2d", { alpha: false, willReadFrequently: true }), this.#ar.set(e2, t2), this.#sr.set(t2, { size: 0, family: "" });
    }
    return t2;
  }
  static #fr(e2, t2, i2) {
    const n2 = this.#sr.get(e2);
    t2 === n2.size && i2 === n2.family || (e2.font = `${t2}px ${i2}`, n2.size = t2, n2.family = i2);
  }
  static #lr() {
    if (null !== this.#rr) return;
    const e2 = document.createElement("div");
    e2.style.opacity = 0, e2.style.lineHeight = 1, e2.style.fontSize = "1px", e2.style.position = "absolute", e2.textContent = "X", document.body.append(e2), this.#rr = e2.getBoundingClientRect().height, e2.remove();
  }
  static #gr(e2, t2, i2) {
    const n2 = this.#nr.get(e2);
    if (n2) return n2;
    const a2 = this.#hr(i2);
    a2.canvas.width = a2.canvas.height = 30, this.#fr(a2, 30, e2);
    const s2 = a2.measureText(""), r2 = s2.fontBoundingBoxAscent, o2 = Math.abs(s2.fontBoundingBoxDescent);
    a2.canvas.width = a2.canvas.height = 0;
    let l2 = 0.8;
    return r2 ? l2 = r2 / (r2 + o2) : (util_FeatureTest.platform.isFirefox && warn("Enable the `dom.textMetrics.fontBoundingBox.enabled` preference in `about:config` to improve TextLayer rendering."), t2.ascent ? l2 = t2.ascent : t2.descent && (l2 = 1 + t2.descent)), this.#nr.set(e2, l2), l2;
  }
}
function getDocument(e2 = {}) {
  "string" == typeof e2 || e2 instanceof URL ? e2 = { url: e2 } : (e2 instanceof ArrayBuffer || ArrayBuffer.isView(e2)) && (e2 = { data: e2 });
  const t2 = new PDFDocumentLoadingTask(), { docId: i2 } = t2, n2 = e2.url ? (function(e3) {
    if (e3 instanceof URL) return e3.href;
    if ("string" == typeof e3) {
      if (Fl) return e3;
      const t3 = URL.parse(e3, window.location);
      if (t3) return t3.href;
    }
    throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
  })(e2.url) : null, a2 = e2.data ? (function(e3) {
    if (Fl && "undefined" != typeof Buffer && e3 instanceof Buffer) throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
    if (e3 instanceof Uint8Array && e3.byteLength === e3.buffer.byteLength) return e3;
    if ("string" == typeof e3) return stringToBytes(e3);
    if (e3 instanceof ArrayBuffer || ArrayBuffer.isView(e3) || "object" == typeof e3 && !isNaN(e3?.length)) return new Uint8Array(e3);
    throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
  })(e2.data) : null, s2 = e2.httpHeaders || null, r2 = true === e2.withCredentials, o2 = e2.password ?? null, l2 = e2.range instanceof PDFDataRangeTransport ? e2.range : null, c2 = Number.isInteger(e2.rangeChunkSize) && e2.rangeChunkSize > 0 ? e2.rangeChunkSize : 65536;
  let h2 = e2.worker instanceof PDFWorker ? e2.worker : null;
  const d2 = e2.verbosity, u2 = "string" != typeof e2.docBaseUrl || isDataScheme(e2.docBaseUrl) ? null : e2.docBaseUrl, g2 = getFactoryUrlProp(e2.cMapUrl), f2 = false !== e2.cMapPacked, p2 = e2.CMapReaderFactory || (Fl ? NodeCMapReaderFactory : DOMCMapReaderFactory), m2 = getFactoryUrlProp(e2.iccUrl), b2 = getFactoryUrlProp(e2.standardFontDataUrl), y2 = e2.StandardFontDataFactory || (Fl ? NodeStandardFontDataFactory : DOMStandardFontDataFactory), w2 = getFactoryUrlProp(e2.wasmUrl), x2 = e2.WasmFactory || (Fl ? NodeWasmFactory : DOMWasmFactory), S2 = true !== e2.stopAtErrors, v2 = Number.isInteger(e2.maxImageSize) && e2.maxImageSize > -1 ? e2.maxImageSize : -1, C2 = false !== e2.isEvalSupported, k2 = "boolean" == typeof e2.isOffscreenCanvasSupported ? e2.isOffscreenCanvasSupported : !Fl, T2 = "boolean" == typeof e2.isImageDecoderSupported ? e2.isImageDecoderSupported : !Fl && (util_FeatureTest.platform.isFirefox || !globalThis.chrome), F2 = Number.isInteger(e2.canvasMaxAreaInBytes) ? e2.canvasMaxAreaInBytes : -1, E2 = "boolean" == typeof e2.disableFontFace ? e2.disableFontFace : Fl, M2 = true === e2.fontExtraProperties, D2 = true === e2.enableXfa, O2 = e2.ownerDocument || globalThis.document, _2 = true === e2.disableRange, R2 = true === e2.disableStream, N2 = true === e2.disableAutoFetch, L2 = true === e2.pdfBug, U2 = e2.CanvasFactory || (Fl ? NodeCanvasFactory : DOMCanvasFactory), j2 = e2.FilterFactory || (Fl ? NodeFilterFactory : DOMFilterFactory), $2 = true === e2.enableHWA, H2 = false !== e2.useWasm, X2 = l2 ? l2.length : e2.length ?? NaN, q2 = "boolean" == typeof e2.useSystemFonts ? e2.useSystemFonts : !Fl && !E2, z2 = "boolean" == typeof e2.useWorkerFetch ? e2.useWorkerFetch : !!(p2 === DOMCMapReaderFactory && y2 === DOMStandardFontDataFactory && x2 === DOMWasmFactory && g2 && b2 && w2 && isValidFetchUrl(g2, document.baseURI) && isValidFetchUrl(b2, document.baseURI) && isValidFetchUrl(w2, document.baseURI));
  setVerbosityLevel(d2);
  const W2 = { canvasFactory: new U2({ ownerDocument: O2, enableHWA: $2 }), filterFactory: new j2({ docId: i2, ownerDocument: O2 }), cMapReaderFactory: z2 ? null : new p2({ baseUrl: g2, isCompressed: f2 }), standardFontDataFactory: z2 ? null : new y2({ baseUrl: b2 }), wasmFactory: z2 ? null : new x2({ baseUrl: w2 }) };
  h2 || (h2 = PDFWorker.create({ verbosity: d2, port: GlobalWorkerOptions.workerPort }), t2._worker = h2);
  const G2 = { docId: i2, apiVersion: "5.4.296", data: a2, password: o2, disableAutoFetch: N2, rangeChunkSize: c2, length: X2, docBaseUrl: u2, enableXfa: D2, evaluatorOptions: { maxImageSize: v2, disableFontFace: E2, ignoreErrors: S2, isEvalSupported: C2, isOffscreenCanvasSupported: k2, isImageDecoderSupported: T2, canvasMaxAreaInBytes: F2, fontExtraProperties: M2, useSystemFonts: q2, useWasm: H2, useWorkerFetch: z2, cMapUrl: g2, iccUrl: m2, standardFontDataUrl: b2, wasmUrl: w2 } }, V2 = { ownerDocument: O2, pdfBug: L2, styleElement: null, loadingParams: { disableAutoFetch: N2, enableXfa: D2 } };
  return h2.promise.then(function() {
    if (t2.destroyed) throw new Error("Loading aborted");
    if (h2.destroyed) throw new Error("Worker was destroyed");
    const e3 = h2.messageHandler.sendWithPromise("GetDocRequest", G2, a2 ? [a2.buffer] : null);
    let o3;
    if (l2) o3 = new PDFDataTransportStream(l2, { disableRange: _2, disableStream: R2 });
    else if (!a2) {
      if (!n2) throw new Error("getDocument - no `url` parameter provided.");
      const e4 = isValidFetchUrl(n2) ? PDFFetchStream : Fl ? PDFNodeStream : PDFNetworkStream;
      o3 = new e4({ url: n2, length: X2, httpHeaders: s2, withCredentials: r2, rangeChunkSize: c2, disableRange: _2, disableStream: R2 });
    }
    return e3.then((e4) => {
      if (t2.destroyed) throw new Error("Loading aborted");
      if (h2.destroyed) throw new Error("Worker was destroyed");
      const n3 = new MessageHandler(i2, e4, h2.port), a3 = new WorkerTransport(n3, t2, o3, V2, W2, $2);
      t2._transport = a3, n3.send("Ready", null);
    });
  }).catch(t2._capability.reject), t2;
}
class PDFDocumentLoadingTask {
  static #La = 0;
  _capability = Promise.withResolvers();
  _transport = null;
  _worker = null;
  docId = "d" + PDFDocumentLoadingTask.#La++;
  destroyed = false;
  onPassword = null;
  onProgress = null;
  get promise() {
    return this._capability.promise;
  }
  async destroy() {
    this.destroyed = true;
    try {
      this._worker?.port && (this._worker._pendingDestroy = true), await this._transport?.destroy();
    } catch (e2) {
      throw this._worker?.port && delete this._worker._pendingDestroy, e2;
    }
    this._transport = null, this._worker?.destroy(), this._worker = null;
  }
  async getData() {
    return this._transport.getData();
  }
}
class PDFDataRangeTransport {
  #js = Promise.withResolvers();
  #pr = [];
  #mr = [];
  #br = [];
  #yr = [];
  constructor(e2, t2, i2 = false, n2 = null) {
    this.length = e2, this.initialData = t2, this.progressiveDone = i2, this.contentDispositionFilename = n2;
  }
  addRangeListener(e2) {
    this.#yr.push(e2);
  }
  addProgressListener(e2) {
    this.#br.push(e2);
  }
  addProgressiveReadListener(e2) {
    this.#mr.push(e2);
  }
  addProgressiveDoneListener(e2) {
    this.#pr.push(e2);
  }
  onDataRange(e2, t2) {
    for (const i2 of this.#yr) i2(e2, t2);
  }
  onDataProgress(e2, t2) {
    this.#js.promise.then(() => {
      for (const i2 of this.#br) i2(e2, t2);
    });
  }
  onDataProgressiveRead(e2) {
    this.#js.promise.then(() => {
      for (const t2 of this.#mr) t2(e2);
    });
  }
  onDataProgressiveDone() {
    this.#js.promise.then(() => {
      for (const e2 of this.#pr) e2();
    });
  }
  transportReady() {
    this.#js.resolve();
  }
  requestDataRange(e2, t2) {
    unreachable("Abstract method PDFDataRangeTransport.requestDataRange");
  }
  abort() {
  }
}
class PDFDocumentProxy {
  constructor(e2, t2) {
    this._pdfInfo = e2, this._transport = t2;
  }
  get annotationStorage() {
    return this._transport.annotationStorage;
  }
  get canvasFactory() {
    return this._transport.canvasFactory;
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get numPages() {
    return this._pdfInfo.numPages;
  }
  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }
  get isPureXfa() {
    return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }
  getPage(e2) {
    return this._transport.getPage(e2);
  }
  getPageIndex(e2) {
    return this._transport.getPageIndex(e2);
  }
  getDestinations() {
    return this._transport.getDestinations();
  }
  getDestination(e2) {
    return this._transport.getDestination(e2);
  }
  getPageLabels() {
    return this._transport.getPageLabels();
  }
  getPageLayout() {
    return this._transport.getPageLayout();
  }
  getPageMode() {
    return this._transport.getPageMode();
  }
  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }
  getOpenAction() {
    return this._transport.getOpenAction();
  }
  getAttachments() {
    return this._transport.getAttachments();
  }
  getAnnotationsByType(e2, t2) {
    return this._transport.getAnnotationsByType(e2, t2);
  }
  getJSActions() {
    return this._transport.getDocJSActions();
  }
  getOutline() {
    return this._transport.getOutline();
  }
  getOptionalContentConfig({ intent: e2 = "display" } = {}) {
    const { renderingIntent: t2 } = this._transport.getRenderingIntent(e2);
    return this._transport.getOptionalContentConfig(t2);
  }
  getPermissions() {
    return this._transport.getPermissions();
  }
  getMetadata() {
    return this._transport.getMetadata();
  }
  getMarkInfo() {
    return this._transport.getMarkInfo();
  }
  getData() {
    return this._transport.getData();
  }
  saveDocument() {
    return this._transport.saveDocument();
  }
  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }
  cleanup(e2 = false) {
    return this._transport.startCleanup(e2 || this.isPureXfa);
  }
  destroy() {
    return this.loadingTask.destroy();
  }
  cachedPageNumber(e2) {
    return this._transport.cachedPageNumber(e2);
  }
  get loadingParams() {
    return this._transport.loadingParams;
  }
  get loadingTask() {
    return this._transport.loadingTask;
  }
  getFieldObjects() {
    return this._transport.getFieldObjects();
  }
  hasJSActions() {
    return this._transport.hasJSActions();
  }
  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }
}
class PDFPageProxy {
  #wr = false;
  constructor(e2, t2, i2, n2 = false) {
    this._pageIndex = e2, this._pageInfo = t2, this._transport = i2, this._stats = n2 ? new StatTimer() : null, this._pdfBug = n2, this.commonObjs = i2.commonObjs, this.objs = new PDFObjects(), this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = false, this.recordedBBoxes = null;
  }
  get pageNumber() {
    return this._pageIndex + 1;
  }
  get rotate() {
    return this._pageInfo.rotate;
  }
  get ref() {
    return this._pageInfo.ref;
  }
  get userUnit() {
    return this._pageInfo.userUnit;
  }
  get view() {
    return this._pageInfo.view;
  }
  getViewport({ scale: e2, rotation: t2 = this.rotate, offsetX: i2 = 0, offsetY: n2 = 0, dontFlip: a2 = false } = {}) {
    return new PageViewport({ viewBox: this.view, userUnit: this.userUnit, scale: e2, rotation: t2, offsetX: i2, offsetY: n2, dontFlip: a2 });
  }
  getAnnotations({ intent: e2 = "display" } = {}) {
    const { renderingIntent: t2 } = this._transport.getRenderingIntent(e2);
    return this._transport.getAnnotations(this._pageIndex, t2);
  }
  getJSActions() {
    return this._transport.getPageJSActions(this._pageIndex);
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get isPureXfa() {
    return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  async getXfa() {
    return this._transport._htmlForXfa?.children[this._pageIndex] || null;
  }
  render({ canvasContext: e2, canvas: t2 = e2.canvas, viewport: i2, intent: n2 = "display", annotationMode: a2 = jl.ENABLE, transform: s2 = null, background: r2 = null, optionalContentConfigPromise: o2 = null, annotationCanvasMap: l2 = null, pageColors: c2 = null, printAnnotationStorage: h2 = null, isEditing: d2 = false, recordOperations: u2 = false, operationsFilter: g2 = null }) {
    this._stats?.time("Overall");
    const f2 = this._transport.getRenderingIntent(n2, a2, h2, d2), { renderingIntent: p2, cacheKey: m2 } = f2;
    this.#wr = false, o2 ||= this._transport.getOptionalContentConfig(p2);
    let b2 = this._intentStates.get(m2);
    b2 || (b2 = /* @__PURE__ */ Object.create(null), this._intentStates.set(m2, b2)), b2.streamReaderCancelTimeout && (clearTimeout(b2.streamReaderCancelTimeout), b2.streamReaderCancelTimeout = null);
    const y2 = !!(p2 & _l);
    b2.displayReadyCapability || (b2.displayReadyCapability = Promise.withResolvers(), b2.operatorList = { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null }, this._stats?.time("Page Request"), this._pumpOperatorList(f2));
    const w2 = Boolean(this._pdfBug && globalThis.StepperManager?.enabled), x2 = !this.recordedBBoxes && (u2 || w2), complete = (e3) => {
      if (b2.renderTasks.delete(S2), x2) {
        const e4 = S2.gfx?.dependencyTracker.take();
        e4 && (S2.stepper && S2.stepper.setOperatorBBoxes(e4, S2.gfx.dependencyTracker.takeDebugMetadata()), u2 && (this.recordedBBoxes = e4));
      }
      y2 && (this.#wr = true), this.#Ar(), e3 ? (S2.capability.reject(e3), this._abortOperatorList({ intentState: b2, reason: e3 instanceof Error ? e3 : new Error(e3) })) : S2.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"), globalThis.Stats?.enabled && globalThis.Stats.add(this.pageNumber, this._stats));
    }, S2 = new InternalRenderTask({ callback: complete, params: { canvas: t2, canvasContext: e2, dependencyTracker: x2 ? new CanvasDependencyTracker(t2, b2.operatorList.length, w2) : null, viewport: i2, transform: s2, background: r2 }, objs: this.objs, commonObjs: this.commonObjs, annotationCanvasMap: l2, operatorList: b2.operatorList, pageIndex: this._pageIndex, canvasFactory: this._transport.canvasFactory, filterFactory: this._transport.filterFactory, useRequestAnimationFrame: !y2, pdfBug: this._pdfBug, pageColors: c2, enableHWA: this._transport.enableHWA, operationsFilter: g2 });
    (b2.renderTasks ||= /* @__PURE__ */ new Set()).add(S2);
    const v2 = S2.task;
    return Promise.all([b2.displayReadyCapability.promise, o2]).then(([e3, t3]) => {
      if (this.destroyed) complete();
      else {
        if (this._stats?.time("Rendering"), !(t3.renderingIntent & p2)) throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
        S2.initializeGraphics({ transparency: e3, optionalContentConfig: t3 }), S2.operatorListChanged();
      }
    }).catch(complete), v2;
  }
  getOperatorList({ intent: e2 = "display", annotationMode: t2 = jl.ENABLE, printAnnotationStorage: i2 = null, isEditing: n2 = false } = {}) {
    const a2 = this._transport.getRenderingIntent(e2, t2, i2, n2, true);
    let s2, r2 = this._intentStates.get(a2.cacheKey);
    return r2 || (r2 = /* @__PURE__ */ Object.create(null), this._intentStates.set(a2.cacheKey, r2)), r2.opListReadCapability || (s2 = /* @__PURE__ */ Object.create(null), s2.operatorListChanged = function() {
      r2.operatorList.lastChunk && (r2.opListReadCapability.resolve(r2.operatorList), r2.renderTasks.delete(s2));
    }, r2.opListReadCapability = Promise.withResolvers(), (r2.renderTasks ||= /* @__PURE__ */ new Set()).add(s2), r2.operatorList = { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null }, this._stats?.time("Page Request"), this._pumpOperatorList(a2)), r2.opListReadCapability.promise;
  }
  streamTextContent({ includeMarkedContent: e2 = false, disableNormalization: t2 = false } = {}) {
    return this._transport.messageHandler.sendWithStream("GetTextContent", { pageIndex: this._pageIndex, includeMarkedContent: true === e2, disableNormalization: true === t2 }, { highWaterMark: 100, size: (e3) => e3.items.length });
  }
  getTextContent(e2 = {}) {
    if (this._transport._htmlForXfa) return this.getXfa().then((e3) => XfaText.textContent(e3));
    const t2 = this.streamTextContent(e2);
    return new Promise(function(e3, i2) {
      const n2 = t2.getReader(), a2 = { items: [], styles: /* @__PURE__ */ Object.create(null), lang: null };
      !(function pump() {
        n2.read().then(function({ value: t3, done: i3 }) {
          i3 ? e3(a2) : (a2.lang ??= t3.lang, Object.assign(a2.styles, t3.styles), a2.items.push(...t3.items), pump());
        }, i2);
      })();
    });
  }
  getStructTree() {
    return this._transport.getStructTree(this._pageIndex);
  }
  _destroy() {
    this.destroyed = true;
    const e2 = [];
    for (const t2 of this._intentStates.values()) if (this._abortOperatorList({ intentState: t2, reason: new Error("Page was destroyed."), force: true }), !t2.opListReadCapability) for (const i2 of t2.renderTasks) e2.push(i2.completed), i2.cancel();
    return this.objs.clear(), this.#wr = false, Promise.all(e2);
  }
  cleanup(e2 = false) {
    this.#wr = true;
    const t2 = this.#Ar();
    return e2 && t2 && (this._stats &&= new StatTimer()), t2;
  }
  #Ar() {
    if (!this.#wr || this.destroyed) return false;
    for (const { renderTasks: e2, operatorList: t2 } of this._intentStates.values()) if (e2.size > 0 || !t2.lastChunk) return false;
    return this._intentStates.clear(), this.objs.clear(), this.#wr = false, true;
  }
  _startRenderPage(e2, t2) {
    const i2 = this._intentStates.get(t2);
    i2 && (this._stats?.timeEnd("Page Request"), i2.displayReadyCapability?.resolve(e2));
  }
  _renderPageChunk(e2, t2) {
    for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) t2.operatorList.fnArray.push(e2.fnArray[i2]), t2.operatorList.argsArray.push(e2.argsArray[i2]);
    t2.operatorList.lastChunk = e2.lastChunk, t2.operatorList.separateAnnots = e2.separateAnnots;
    for (const e3 of t2.renderTasks) e3.operatorListChanged();
    e2.lastChunk && this.#Ar();
  }
  _pumpOperatorList({ renderingIntent: e2, cacheKey: t2, annotationStorageSerializable: i2, modifiedIds: n2 }) {
    const { map: a2, transfer: s2 } = i2, r2 = this._transport.messageHandler.sendWithStream("GetOperatorList", { pageIndex: this._pageIndex, intent: e2, cacheKey: t2, annotationStorage: a2, modifiedIds: n2 }, s2).getReader(), o2 = this._intentStates.get(t2);
    o2.streamReader = r2;
    const pump = () => {
      r2.read().then(({ value: e3, done: t3 }) => {
        t3 ? o2.streamReader = null : this._transport.destroyed || (this._renderPageChunk(e3, o2), pump());
      }, (e3) => {
        if (o2.streamReader = null, !this._transport.destroyed) {
          if (o2.operatorList) {
            o2.operatorList.lastChunk = true;
            for (const e4 of o2.renderTasks) e4.operatorListChanged();
            this.#Ar();
          }
          if (o2.displayReadyCapability) o2.displayReadyCapability.reject(e3);
          else {
            if (!o2.opListReadCapability) throw e3;
            o2.opListReadCapability.reject(e3);
          }
        }
      });
    };
    pump();
  }
  _abortOperatorList({ intentState: e2, reason: t2, force: i2 = false }) {
    if (e2.streamReader) {
      if (e2.streamReaderCancelTimeout && (clearTimeout(e2.streamReaderCancelTimeout), e2.streamReaderCancelTimeout = null), !i2) {
        if (e2.renderTasks.size > 0) return;
        if (t2 instanceof RenderingCancelledException) {
          let i3 = 100;
          return t2.extraDelay > 0 && t2.extraDelay < 1e3 && (i3 += t2.extraDelay), void (e2.streamReaderCancelTimeout = setTimeout(() => {
            e2.streamReaderCancelTimeout = null, this._abortOperatorList({ intentState: e2, reason: t2, force: true });
          }, i3));
        }
      }
      if (e2.streamReader.cancel(new AbortException(t2.message)).catch(() => {
      }), e2.streamReader = null, !this._transport.destroyed) {
        for (const [t3, i3] of this._intentStates) if (i3 === e2) {
          this._intentStates.delete(t3);
          break;
        }
        this.cleanup();
      }
    }
  }
  get stats() {
    return this._stats;
  }
}
const _PDFWorker = class _PDFWorker {
  constructor({ name: e2 = null, port: t2 = null, verbosity: i2 = getVerbosityLevel() } = {}) {
    __privateAdd(this, _PDFWorker_instances);
    __privateAdd(this, _js, Promise.withResolvers());
    __privateAdd(this, _xr, null);
    __privateAdd(this, _ks, null);
    __privateAdd(this, _Sr, null);
    if (this.name = e2, this.destroyed = false, this.verbosity = i2, t2) {
      if (__privateGet(_PDFWorker, _kr).has(t2)) throw new Error("Cannot use more than one PDFWorker per port.");
      __privateGet(_PDFWorker, _kr).set(t2, this), __privateMethod(this, _PDFWorker_instances, Tr_fn).call(this, t2);
    } else __privateMethod(this, _PDFWorker_instances, Fr_fn).call(this);
  }
  get promise() {
    return __privateGet(this, _js).promise;
  }
  get port() {
    return __privateGet(this, _ks);
  }
  get messageHandler() {
    return __privateGet(this, _xr);
  }
  destroy() {
    this.destroyed = true, __privateGet(this, _Sr)?.terminate(), __privateSet(this, _Sr, null), __privateGet(_PDFWorker, _kr).delete(__privateGet(this, _ks)), __privateSet(this, _ks, null), __privateGet(this, _xr)?.destroy(), __privateSet(this, _xr, null);
  }
  static create(e2) {
    const t2 = __privateGet(this, _kr).get(e2?.port);
    if (t2) {
      if (t2._pendingDestroy) throw new Error("PDFWorker.create - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
      return t2;
    }
    return new _PDFWorker(e2);
  }
  static get workerSrc() {
    if (GlobalWorkerOptions.workerSrc) return GlobalWorkerOptions.workerSrc;
    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }
  static get _setupFakeWorkerGlobal() {
    return shadow(this, "_setupFakeWorkerGlobal", (async () => {
      if (__privateGet(this, _PDFWorker_static, Er_get)) return __privateGet(this, _PDFWorker_static, Er_get);
      return (await import(this.workerSrc)).WorkerMessageHandler;
    })());
  }
};
_js = new WeakMap();
_xr = new WeakMap();
_ks = new WeakMap();
_Sr = new WeakMap();
_vr = new WeakMap();
_Cr = new WeakMap();
_kr = new WeakMap();
_PDFWorker_instances = new WeakSet();
Ir_fn = function() {
  __privateGet(this, _js).resolve(), __privateGet(this, _xr).send("configure", { verbosity: this.verbosity });
};
Tr_fn = function(e2) {
  __privateSet(this, _ks, e2), __privateSet(this, _xr, new MessageHandler("main", "worker", e2)), __privateGet(this, _xr).on("ready", () => {
  }), __privateMethod(this, _PDFWorker_instances, Ir_fn).call(this);
};
Fr_fn = function() {
  if (__privateGet(_PDFWorker, _Cr) || __privateGet(_PDFWorker, _PDFWorker_static, Er_get)) return void __privateMethod(this, _PDFWorker_instances, Mr_fn).call(this);
  let { workerSrc: e2 } = _PDFWorker;
  try {
    _PDFWorker._isSameOrigin(window.location, e2) || (e2 = _PDFWorker._createCDNWrapper(new URL(e2, window.location).href));
    const t2 = new Worker(e2, { type: "module" }), i2 = new MessageHandler("main", "worker", t2), terminateEarly = () => {
      n2.abort(), i2.destroy(), t2.terminate(), this.destroyed ? __privateGet(this, _js).reject(new Error("Worker was destroyed")) : __privateMethod(this, _PDFWorker_instances, Mr_fn).call(this);
    }, n2 = new AbortController();
    t2.addEventListener("error", () => {
      __privateGet(this, _Sr) || terminateEarly();
    }, { signal: n2.signal }), i2.on("test", (e3) => {
      n2.abort(), !this.destroyed && e3 ? (__privateSet(this, _xr, i2), __privateSet(this, _ks, t2), __privateSet(this, _Sr, t2), __privateMethod(this, _PDFWorker_instances, Ir_fn).call(this)) : terminateEarly();
    }), i2.on("ready", (e3) => {
      if (n2.abort(), this.destroyed) terminateEarly();
      else try {
        sendTest();
      } catch {
        __privateMethod(this, _PDFWorker_instances, Mr_fn).call(this);
      }
    });
    const sendTest = () => {
      const e3 = new Uint8Array();
      i2.send("test", e3, [e3.buffer]);
    };
    return void sendTest();
  } catch {
    info("The worker has been disabled.");
  }
  __privateMethod(this, _PDFWorker_instances, Mr_fn).call(this);
};
Mr_fn = function() {
  __privateGet(_PDFWorker, _Cr) || (warn("Setting up fake worker."), __privateSet(_PDFWorker, _Cr, true)), _PDFWorker._setupFakeWorkerGlobal.then((e2) => {
    if (this.destroyed) return void __privateGet(this, _js).reject(new Error("Worker was destroyed"));
    const t2 = new LoopbackPort();
    __privateSet(this, _ks, t2);
    const i2 = "fake" + __privateWrapper(_PDFWorker, _vr)._++, n2 = new MessageHandler(i2 + "_worker", i2, t2);
    e2.setup(n2, t2), __privateSet(this, _xr, new MessageHandler(i2, i2 + "_worker", t2)), __privateMethod(this, _PDFWorker_instances, Ir_fn).call(this);
  }).catch((e2) => {
    __privateGet(this, _js).reject(new Error(`Setting up fake worker failed: "${e2.message}".`));
  });
};
_PDFWorker_static = new WeakSet();
Er_get = function() {
  try {
    return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
  } catch {
    return null;
  }
};
__privateAdd(_PDFWorker, _PDFWorker_static);
__privateAdd(_PDFWorker, _vr, 0);
__privateAdd(_PDFWorker, _Cr, true);
__privateAdd(_PDFWorker, _kr, /* @__PURE__ */ new WeakMap());
Fl && (__privateSet(_PDFWorker, _Cr, true), GlobalWorkerOptions.workerSrc ||= "./pdf.worker.mjs"), _PDFWorker._isSameOrigin = (e2, t2) => {
  const i2 = URL.parse(e2);
  if (!i2?.origin || "null" === i2.origin) return false;
  const n2 = new URL(t2, i2);
  return i2.origin === n2.origin;
}, _PDFWorker._createCDNWrapper = (e2) => {
  const t2 = `await import("${e2}");`;
  return URL.createObjectURL(new Blob([t2], { type: "text/javascript" }));
}, _PDFWorker.fromPort = (e2) => {
  var t2;
  if (t2 = "`PDFWorker.fromPort` - please use `PDFWorker.create` instead.", console.log("Deprecated API usage: " + t2), !e2?.port) throw new Error("PDFWorker.fromPort - invalid method signature.");
  return _PDFWorker.create(e2);
};
let PDFWorker = _PDFWorker;
class WorkerTransport {
  #Dr = /* @__PURE__ */ new Map();
  #Or = /* @__PURE__ */ new Map();
  #Ze = /* @__PURE__ */ new Map();
  #_r = /* @__PURE__ */ new Map();
  #Pr = null;
  constructor(e2, t2, i2, n2, a2, s2) {
    this.messageHandler = e2, this.loadingTask = t2, this.commonObjs = new PDFObjects(), this.fontLoader = new FontLoader({ ownerDocument: n2.ownerDocument, styleElement: n2.styleElement }), this.loadingParams = n2.loadingParams, this._params = n2, this.canvasFactory = a2.canvasFactory, this.filterFactory = a2.filterFactory, this.cMapReaderFactory = a2.cMapReaderFactory, this.standardFontDataFactory = a2.standardFontDataFactory, this.wasmFactory = a2.wasmFactory, this.destroyed = false, this.destroyCapability = null, this._networkStream = i2, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = Promise.withResolvers(), this.enableHWA = s2, this.setupMessageHandler();
  }
  #Rr(e2, t2 = null) {
    const i2 = this.#Dr.get(e2);
    if (i2) return i2;
    const n2 = this.messageHandler.sendWithPromise(e2, t2);
    return this.#Dr.set(e2, n2), n2;
  }
  get annotationStorage() {
    return shadow(this, "annotationStorage", new AnnotationStorage());
  }
  getRenderingIntent(e2, t2 = jl.ENABLE, i2 = null, n2 = false, a2 = false) {
    let s2 = Dl, r2 = vc;
    switch (e2) {
      case "any":
        s2 = Ml;
        break;
      case "display":
        break;
      case "print":
        s2 = _l;
        break;
      default:
        warn(`getRenderingIntent - invalid intent: ${e2}`);
    }
    const o2 = s2 & _l && i2 instanceof PrintAnnotationStorage ? i2 : this.annotationStorage;
    switch (t2) {
      case jl.DISABLE:
        s2 += Bl;
        break;
      case jl.ENABLE:
        break;
      case jl.ENABLE_FORMS:
        s2 += Pl;
        break;
      case jl.ENABLE_STORAGE:
        s2 += Rl, r2 = o2.serializable;
        break;
      default:
        warn(`getRenderingIntent - invalid annotationMode: ${t2}`);
    }
    n2 && (s2 += Nl), a2 && (s2 += Ll);
    const { ids: l2, hash: c2 } = o2.modifiedIds;
    return { renderingIntent: s2, cacheKey: [s2, r2.hash, c2].join("_"), annotationStorageSerializable: r2, modifiedIds: l2 };
  }
  destroy() {
    if (this.destroyCapability) return this.destroyCapability.promise;
    this.destroyed = true, this.destroyCapability = Promise.withResolvers(), this.#Pr?.reject(new Error("Worker was destroyed during onPassword callback"));
    const e2 = [];
    for (const t3 of this.#Or.values()) e2.push(t3._destroy());
    this.#Or.clear(), this.#Ze.clear(), this.#_r.clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
    const t2 = this.messageHandler.sendWithPromise("Terminate", null);
    return e2.push(t2), Promise.all(e2).then(() => {
      this.commonObjs.clear(), this.fontLoader.clear(), this.#Dr.clear(), this.filterFactory.destroy(), TextLayer.cleanup(), this._networkStream?.cancelAllRequests(new AbortException("Worker was terminated.")), this.messageHandler?.destroy(), this.messageHandler = null, this.destroyCapability.resolve();
    }, this.destroyCapability.reject), this.destroyCapability.promise;
  }
  setupMessageHandler() {
    const { messageHandler: e2, loadingTask: t2 } = this;
    e2.on("GetReader", (e3, t3) => {
      assert(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (e4) => {
        this._lastProgress = { loaded: e4.loaded, total: e4.total };
      }, t3.onPull = () => {
        this._fullReader.read().then(function({ value: e4, done: i2 }) {
          i2 ? t3.close() : (assert(e4 instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), t3.enqueue(new Uint8Array(e4), 1, [e4]));
        }).catch((e4) => {
          t3.error(e4);
        });
      }, t3.onCancel = (e4) => {
        this._fullReader.cancel(e4), t3.ready.catch((e5) => {
          if (!this.destroyed) throw e5;
        });
      };
    }), e2.on("ReaderHeadersReady", async (e3) => {
      await this._fullReader.headersReady;
      const { isStreamingSupported: i2, isRangeSupported: n2, contentLength: a2 } = this._fullReader;
      return i2 && n2 || (this._lastProgress && t2.onProgress?.(this._lastProgress), this._fullReader.onProgress = (e4) => {
        t2.onProgress?.({ loaded: e4.loaded, total: e4.total });
      }), { isStreamingSupported: i2, isRangeSupported: n2, contentLength: a2 };
    }), e2.on("GetRangeReader", (e3, t3) => {
      assert(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
      const i2 = this._networkStream.getRangeReader(e3.begin, e3.end);
      i2 ? (t3.onPull = () => {
        i2.read().then(function({ value: e4, done: i3 }) {
          i3 ? t3.close() : (assert(e4 instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), t3.enqueue(new Uint8Array(e4), 1, [e4]));
        }).catch((e4) => {
          t3.error(e4);
        });
      }, t3.onCancel = (e4) => {
        i2.cancel(e4), t3.ready.catch((e5) => {
          if (!this.destroyed) throw e5;
        });
      }) : t3.close();
    }), e2.on("GetDoc", ({ pdfInfo: e3 }) => {
      this._numPages = e3.numPages, this._htmlForXfa = e3.htmlForXfa, delete e3.htmlForXfa, t2._capability.resolve(new PDFDocumentProxy(e3, this));
    }), e2.on("DocException", (e3) => {
      t2._capability.reject(wrapReason(e3));
    }), e2.on("PasswordRequest", (e3) => {
      this.#Pr = Promise.withResolvers();
      try {
        if (!t2.onPassword) throw wrapReason(e3);
        const updatePassword = (e4) => {
          e4 instanceof Error ? this.#Pr.reject(e4) : this.#Pr.resolve({ password: e4 });
        };
        t2.onPassword(updatePassword, e3.code);
      } catch (e4) {
        this.#Pr.reject(e4);
      }
      return this.#Pr.promise;
    }), e2.on("DataLoaded", (e3) => {
      t2.onProgress?.({ loaded: e3.length, total: e3.length }), this.downloadInfoCapability.resolve(e3);
    }), e2.on("StartRenderPage", (e3) => {
      if (this.destroyed) return;
      this.#Or.get(e3.pageIndex)._startRenderPage(e3.transparency, e3.cacheKey);
    }), e2.on("commonobj", ([t3, i2, n2]) => {
      if (this.destroyed) return null;
      if (this.commonObjs.has(t3)) return null;
      switch (i2) {
        case "Font":
          if ("error" in n2) {
            const e3 = n2.error;
            warn(`Error during font loading: ${e3}`), this.commonObjs.resolve(t3, e3);
            break;
          }
          const a2 = new FontInfo2(n2), s2 = this._params.pdfBug && globalThis.FontInspector?.enabled ? (e3, t4) => globalThis.FontInspector.fontAdded(e3, t4) : null, r2 = new FontFaceObject(a2, s2, n2.extra, n2.charProcOperatorList);
          this.fontLoader.bind(r2).catch(() => e2.sendWithPromise("FontFallback", { id: t3 })).finally(() => {
            !r2.fontExtraProperties && r2.data && r2.clearData(), this.commonObjs.resolve(t3, r2);
          });
          break;
        case "CopyLocalImage":
          const { imageRef: o2 } = n2;
          assert(o2, "The imageRef must be defined.");
          for (const e3 of this.#Or.values()) for (const [, i3] of e3.objs) if (i3?.ref === o2) return i3.dataLen ? (this.commonObjs.resolve(t3, structuredClone(i3)), i3.dataLen) : null;
          break;
        case "FontPath":
        case "Image":
        case "Pattern":
          this.commonObjs.resolve(t3, n2);
          break;
        default:
          throw new Error(`Got unknown common object type ${i2}`);
      }
      return null;
    }), e2.on("obj", ([e3, t3, i2, n2]) => {
      if (this.destroyed) return;
      const a2 = this.#Or.get(t3);
      if (!a2.objs.has(e3)) if (0 !== a2._intentStates.size) switch (i2) {
        case "Image":
        case "Pattern":
          a2.objs.resolve(e3, n2);
          break;
        default:
          throw new Error(`Got unknown object type ${i2}`);
      }
      else n2?.bitmap?.close();
    }), e2.on("DocProgress", (e3) => {
      this.destroyed || t2.onProgress?.({ loaded: e3.loaded, total: e3.total });
    }), e2.on("FetchBinaryData", async (e3) => {
      if (this.destroyed) throw new Error("Worker was destroyed.");
      const t3 = this[e3.type];
      if (!t3) throw new Error(`${e3.type} not initialized, see the \`useWorkerFetch\` parameter.`);
      return t3.fetch(e3);
    });
  }
  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }
  saveDocument() {
    this.annotationStorage.size <= 0 && warn("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
    const { map: e2, transfer: t2 } = this.annotationStorage.serializable;
    return this.messageHandler.sendWithPromise("SaveDocument", { isPureXfa: !!this._htmlForXfa, numPages: this._numPages, annotationStorage: e2, filename: this._fullReader?.filename ?? null }, t2).finally(() => {
      this.annotationStorage.resetModified();
    });
  }
  getPage(e2) {
    if (!Number.isInteger(e2) || e2 <= 0 || e2 > this._numPages) return Promise.reject(new Error("Invalid page request."));
    const t2 = e2 - 1, i2 = this.#Ze.get(t2);
    if (i2) return i2;
    const n2 = this.messageHandler.sendWithPromise("GetPage", { pageIndex: t2 }).then((i3) => {
      if (this.destroyed) throw new Error("Transport destroyed");
      i3.refStr && this.#_r.set(i3.refStr, e2);
      const n3 = new PDFPageProxy(t2, i3, this, this._params.pdfBug);
      return this.#Or.set(t2, n3), n3;
    });
    return this.#Ze.set(t2, n2), n2;
  }
  getPageIndex(e2) {
    return isRefProxy(e2) ? this.messageHandler.sendWithPromise("GetPageIndex", { num: e2.num, gen: e2.gen }) : Promise.reject(new Error("Invalid pageIndex request."));
  }
  getAnnotations(e2, t2) {
    return this.messageHandler.sendWithPromise("GetAnnotations", { pageIndex: e2, intent: t2 });
  }
  getFieldObjects() {
    return this.#Rr("GetFieldObjects");
  }
  hasJSActions() {
    return this.#Rr("HasJSActions");
  }
  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }
  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }
  getDestination(e2) {
    return "string" != typeof e2 ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", { id: e2 });
  }
  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }
  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }
  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }
  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }
  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }
  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }
  getAnnotationsByType(e2, t2) {
    return this.messageHandler.sendWithPromise("GetAnnotationsByType", { types: e2, pageIndexesToSkip: t2 });
  }
  getDocJSActions() {
    return this.#Rr("GetDocJSActions");
  }
  getPageJSActions(e2) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", { pageIndex: e2 });
  }
  getStructTree(e2) {
    return this.messageHandler.sendWithPromise("GetStructTree", { pageIndex: e2 });
  }
  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }
  getOptionalContentConfig(e2) {
    return this.#Rr("GetOptionalContentConfig").then((t2) => new OptionalContentConfig(t2, e2));
  }
  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }
  getMetadata() {
    const e2 = "GetMetadata", t2 = this.#Dr.get(e2);
    if (t2) return t2;
    const i2 = this.messageHandler.sendWithPromise(e2, null).then((e3) => ({ info: e3[0], metadata: e3[1] ? new Metadata(e3[1]) : null, contentDispositionFilename: this._fullReader?.filename ?? null, contentLength: this._fullReader?.contentLength ?? null }));
    return this.#Dr.set(e2, i2), i2;
  }
  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }
  async startCleanup(e2 = false) {
    if (!this.destroyed) {
      await this.messageHandler.sendWithPromise("Cleanup", null);
      for (const e3 of this.#Or.values()) {
        if (!e3.cleanup()) throw new Error(`startCleanup: Page ${e3.pageNumber} is currently rendering.`);
      }
      this.commonObjs.clear(), e2 || this.fontLoader.clear(), this.#Dr.clear(), this.filterFactory.destroy(true), TextLayer.cleanup();
    }
  }
  cachedPageNumber(e2) {
    if (!isRefProxy(e2)) return null;
    const t2 = 0 === e2.gen ? `${e2.num}R` : `${e2.num}R${e2.gen}`;
    return this.#_r.get(t2) ?? null;
  }
}
class RenderTask {
  #Br = null;
  onContinue = null;
  onError = null;
  constructor(e2) {
    this.#Br = e2;
  }
  get promise() {
    return this.#Br.capability.promise;
  }
  cancel(e2 = 0) {
    this.#Br.cancel(null, e2);
  }
  get separateAnnots() {
    const { separateAnnots: e2 } = this.#Br.operatorList;
    if (!e2) return false;
    const { annotationCanvasMap: t2 } = this.#Br;
    return e2.form || e2.canvas && t2?.size > 0;
  }
}
class InternalRenderTask {
  #Nr = null;
  static #Lr = /* @__PURE__ */ new WeakSet();
  constructor({ callback: e2, params: t2, objs: i2, commonObjs: n2, annotationCanvasMap: a2, operatorList: s2, pageIndex: r2, canvasFactory: o2, filterFactory: l2, useRequestAnimationFrame: c2 = false, pdfBug: h2 = false, pageColors: d2 = null, enableHWA: u2 = false, operationsFilter: g2 = null }) {
    this.callback = e2, this.params = t2, this.objs = i2, this.commonObjs = n2, this.annotationCanvasMap = a2, this.operatorListIdx = null, this.operatorList = s2, this._pageIndex = r2, this.canvasFactory = o2, this.filterFactory = l2, this._pdfBug = h2, this.pageColors = d2, this.running = false, this.graphicsReadyCallback = null, this.graphicsReady = false, this._useRequestAnimationFrame = true === c2 && "undefined" != typeof window, this.cancelled = false, this.capability = Promise.withResolvers(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = t2.canvas, this._canvasContext = t2.canvas ? null : t2.canvasContext, this._enableHWA = u2, this._dependencyTracker = t2.dependencyTracker, this._operationsFilter = g2;
  }
  get completed() {
    return this.capability.promise.catch(function() {
    });
  }
  initializeGraphics({ transparency: e2 = false, optionalContentConfig: t2 }) {
    if (this.cancelled) return;
    if (this._canvas) {
      if (InternalRenderTask.#Lr.has(this._canvas)) throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
      InternalRenderTask.#Lr.add(this._canvas);
    }
    this._pdfBug && globalThis.StepperManager?.enabled && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
    const { viewport: i2, transform: n2, background: a2, dependencyTracker: s2 } = this.params, r2 = this._canvasContext || this._canvas.getContext("2d", { alpha: false, willReadFrequently: !this._enableHWA });
    this.gfx = new CanvasGraphics(r2, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: t2 }, this.annotationCanvasMap, this.pageColors, s2), this.gfx.beginDrawing({ transform: n2, viewport: i2, transparency: e2, background: a2 }), this.operatorListIdx = 0, this.graphicsReady = true, this.graphicsReadyCallback?.();
  }
  cancel(e2 = null, t2 = 0) {
    this.running = false, this.cancelled = true, this.gfx?.endDrawing(), this.#Nr && (window.cancelAnimationFrame(this.#Nr), this.#Nr = null), InternalRenderTask.#Lr.delete(this._canvas), e2 ||= new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, t2), this.callback(e2), this.task.onError?.(e2);
  }
  operatorListChanged() {
    this.graphicsReady ? (this.gfx.dependencyTracker?.growOperationsCount(this.operatorList.fnArray.length), this.stepper?.updateOperatorList(this.operatorList), this.running || this._continue()) : this.graphicsReadyCallback ||= this._continueBound;
  }
  _continue() {
    this.running = true, this.cancelled || (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
  }
  _scheduleNext() {
    this._useRequestAnimationFrame ? this.#Nr = window.requestAnimationFrame(() => {
      this.#Nr = null, this._nextBound().catch(this._cancelBound);
    }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
  }
  async _next() {
    this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper, this._operationsFilter), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = false, this.operatorList.lastChunk && (this.gfx.endDrawing(), InternalRenderTask.#Lr.delete(this._canvas), this.callback())));
  }
}
const lh = "5.4.296", hh = "f56dc8601";
class ColorPicker {
  #Ur = null;
  #jr = null;
  #$r;
  #Hr = null;
  #Xr = false;
  #qr = false;
  #ft = null;
  #zr;
  #Wr = null;
  #Tt = null;
  static #Gr = null;
  static get _keyboardManager() {
    return shadow(this, "_keyboardManager", new KeyboardManager([[["Escape", "mac+Escape"], ColorPicker.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], ColorPicker.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], ColorPicker.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], ColorPicker.prototype._moveToPrevious], [["Home", "mac+Home"], ColorPicker.prototype._moveToBeginning], [["End", "mac+End"], ColorPicker.prototype._moveToEnd]]));
  }
  constructor({ editor: e2 = null, uiManager: t2 = null }) {
    e2 ? (this.#qr = false, this.#ft = e2) : this.#qr = true, this.#Tt = e2?._uiManager || t2, this.#zr = this.#Tt._eventBus, this.#$r = e2?.color?.toUpperCase() || this.#Tt?.highlightColors.values().next().value || "#FFFF98", ColorPicker.#Gr ||= Object.freeze({ blue: "pdfjs-editor-colorpicker-blue", green: "pdfjs-editor-colorpicker-green", pink: "pdfjs-editor-colorpicker-pink", red: "pdfjs-editor-colorpicker-red", yellow: "pdfjs-editor-colorpicker-yellow" });
  }
  renderButton() {
    const e2 = this.#Ur = document.createElement("button");
    e2.className = "colorPicker", e2.tabIndex = "0", e2.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button"), e2.ariaHasPopup = "true", this.#ft && (e2.ariaControls = `${this.#ft.id}_colorpicker_dropdown`);
    const t2 = this.#Tt._signal;
    e2.addEventListener("click", this.#Vr.bind(this), { signal: t2 }), e2.addEventListener("keydown", this.#Kr.bind(this), { signal: t2 });
    const i2 = this.#jr = document.createElement("span");
    return i2.className = "swatch", i2.ariaHidden = "true", i2.style.backgroundColor = this.#$r, e2.append(i2), e2;
  }
  renderMainDropdown() {
    const e2 = this.#Hr = this.#Yr();
    return e2.ariaOrientation = "horizontal", e2.ariaLabelledBy = "highlightColorPickerLabel", e2;
  }
  #Yr() {
    const e2 = document.createElement("div"), t2 = this.#Tt._signal;
    e2.addEventListener("contextmenu", noContextMenu, { signal: t2 }), e2.className = "dropdown", e2.role = "listbox", e2.ariaMultiSelectable = "false", e2.ariaOrientation = "vertical", e2.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown"), this.#ft && (e2.id = `${this.#ft.id}_colorpicker_dropdown`);
    for (const [i2, n2] of this.#Tt.highlightColors) {
      const a2 = document.createElement("button");
      a2.tabIndex = "0", a2.role = "option", a2.setAttribute("data-color", n2), a2.title = i2, a2.setAttribute("data-l10n-id", ColorPicker.#Gr[i2]);
      const s2 = document.createElement("span");
      a2.append(s2), s2.className = "swatch", s2.style.backgroundColor = n2, a2.ariaSelected = n2 === this.#$r, a2.addEventListener("click", this.#Jr.bind(this, n2), { signal: t2 }), e2.append(a2);
    }
    return e2.addEventListener("keydown", this.#Kr.bind(this), { signal: t2 }), e2;
  }
  #Jr(e2, t2) {
    t2.stopPropagation(), this.#zr.dispatch("switchannotationeditorparams", { source: this, type: Xl.HIGHLIGHT_COLOR, value: e2 }), this.updateColor(e2);
  }
  _colorSelectFromKeyboard(e2) {
    if (e2.target === this.#Ur) return void this.#Vr(e2);
    const t2 = e2.target.getAttribute("data-color");
    t2 && this.#Jr(t2, e2);
  }
  _moveToNext(e2) {
    this.#Zr ? e2.target !== this.#Ur ? e2.target.nextSibling?.focus() : this.#Hr.firstChild?.focus() : this.#Vr(e2);
  }
  _moveToPrevious(e2) {
    e2.target !== this.#Hr?.firstChild && e2.target !== this.#Ur ? (this.#Zr || this.#Vr(e2), e2.target.previousSibling?.focus()) : this.#Zr && this._hideDropdownFromKeyboard();
  }
  _moveToBeginning(e2) {
    this.#Zr ? this.#Hr.firstChild?.focus() : this.#Vr(e2);
  }
  _moveToEnd(e2) {
    this.#Zr ? this.#Hr.lastChild?.focus() : this.#Vr(e2);
  }
  #Kr(e2) {
    ColorPicker._keyboardManager.exec(this, e2);
  }
  #Vr(e2) {
    if (this.#Zr) return void this.hideDropdown();
    if (this.#Xr = 0 === e2.detail, this.#Wr || (this.#Wr = new AbortController(), window.addEventListener("pointerdown", this.#xt.bind(this), { signal: this.#Tt.combinedSignal(this.#Wr) })), this.#Ur.ariaExpanded = "true", this.#Hr) return void this.#Hr.classList.remove("hidden");
    const t2 = this.#Hr = this.#Yr();
    this.#Ur.append(t2);
  }
  #xt(e2) {
    this.#Hr?.contains(e2.target) || this.hideDropdown();
  }
  hideDropdown() {
    this.#Hr?.classList.add("hidden"), this.#Ur.ariaExpanded = "false", this.#Wr?.abort(), this.#Wr = null;
  }
  get #Zr() {
    return this.#Hr && !this.#Hr.classList.contains("hidden");
  }
  _hideDropdownFromKeyboard() {
    this.#qr || (this.#Zr ? (this.hideDropdown(), this.#Ur.focus({ preventScroll: true, focusVisible: this.#Xr })) : this.#ft?.unselect());
  }
  updateColor(e2) {
    if (this.#jr && (this.#jr.style.backgroundColor = e2), !this.#Hr) return;
    const t2 = this.#Tt.highlightColors.values();
    for (const i2 of this.#Hr.children) i2.ariaSelected = t2.next().value === e2.toUpperCase();
  }
  destroy() {
    this.#Ur?.remove(), this.#Ur = null, this.#jr = null, this.#Hr?.remove(), this.#Hr = null;
  }
}
class BasicColorPicker {
  #Qr = null;
  #ft = null;
  #Tt = null;
  static #Gr = null;
  constructor(e2) {
    this.#ft = e2, this.#Tt = e2._uiManager, BasicColorPicker.#Gr ||= Object.freeze({ freetext: "pdfjs-editor-color-picker-free-text-input", ink: "pdfjs-editor-color-picker-ink-input" });
  }
  renderButton() {
    if (this.#Qr) return this.#Qr;
    const { editorType: e2, colorType: t2, colorValue: i2 } = this.#ft, n2 = this.#Qr = document.createElement("input");
    return n2.type = "color", n2.value = i2 || "#000000", n2.className = "basicColorPicker", n2.tabIndex = 0, n2.setAttribute("data-l10n-id", BasicColorPicker.#Gr[e2]), n2.addEventListener("input", () => {
      this.#Tt.updateParams(t2, n2.value);
    }, { signal: this.#Tt._signal }), n2;
  }
  update(e2) {
    this.#Qr && (this.#Qr.value = e2);
  }
  destroy() {
    this.#Qr?.remove(), this.#Qr = null;
  }
  hideDropdown() {
  }
}
function makeColorComp(e2) {
  return Math.floor(255 * Math.max(0, Math.min(1, e2))).toString(16).padStart(2, "0");
}
function scaleAndClamp(e2) {
  return Math.max(0, Math.min(255, 255 * e2));
}
class ColorConverters {
  static CMYK_G([e2, t2, i2, n2]) {
    return ["G", 1 - Math.min(1, 0.3 * e2 + 0.59 * i2 + 0.11 * t2 + n2)];
  }
  static G_CMYK([e2]) {
    return ["CMYK", 0, 0, 0, 1 - e2];
  }
  static G_RGB([e2]) {
    return ["RGB", e2, e2, e2];
  }
  static G_rgb([e2]) {
    return [e2 = scaleAndClamp(e2), e2, e2];
  }
  static G_HTML([e2]) {
    const t2 = makeColorComp(e2);
    return `#${t2}${t2}${t2}`;
  }
  static RGB_G([e2, t2, i2]) {
    return ["G", 0.3 * e2 + 0.59 * t2 + 0.11 * i2];
  }
  static RGB_rgb(e2) {
    return e2.map(scaleAndClamp);
  }
  static RGB_HTML(e2) {
    return `#${e2.map(makeColorComp).join("")}`;
  }
  static T_HTML() {
    return "#00000000";
  }
  static T_rgb() {
    return [null];
  }
  static CMYK_RGB([e2, t2, i2, n2]) {
    return ["RGB", 1 - Math.min(1, e2 + n2), 1 - Math.min(1, i2 + n2), 1 - Math.min(1, t2 + n2)];
  }
  static CMYK_rgb([e2, t2, i2, n2]) {
    return [scaleAndClamp(1 - Math.min(1, e2 + n2)), scaleAndClamp(1 - Math.min(1, i2 + n2)), scaleAndClamp(1 - Math.min(1, t2 + n2))];
  }
  static CMYK_HTML(e2) {
    const t2 = this.CMYK_RGB(e2).slice(1);
    return this.RGB_HTML(t2);
  }
  static RGB_CMYK([e2, t2, i2]) {
    const n2 = 1 - e2, a2 = 1 - t2, s2 = 1 - i2;
    return ["CMYK", n2, a2, s2, Math.min(n2, a2, s2)];
  }
}
class BaseSVGFactory {
  create(e2, t2, i2 = false) {
    if (e2 <= 0 || t2 <= 0) throw new Error("Invalid SVG dimensions");
    const n2 = this._createSVG("svg:svg");
    return n2.setAttribute("version", "1.1"), i2 || (n2.setAttribute("width", `${e2}px`), n2.setAttribute("height", `${t2}px`)), n2.setAttribute("preserveAspectRatio", "none"), n2.setAttribute("viewBox", `0 0 ${e2} ${t2}`), n2;
  }
  createElement(e2) {
    if ("string" != typeof e2) throw new Error("Invalid SVG element type");
    return this._createSVG(e2);
  }
  _createSVG(e2) {
    unreachable("Abstract method `_createSVG` called.");
  }
}
class DOMSVGFactory extends BaseSVGFactory {
  _createSVG(e2) {
    return document.createElementNS(bc, e2);
  }
}
const dh = /* @__PURE__ */ new WeakSet(), uh = 60 * (/* @__PURE__ */ new Date()).getTimezoneOffset() * 1e3;
class AnnotationElementFactory {
  static create(e2) {
    switch (e2.data.annotationType) {
      case Zl.LINK:
        return new LinkAnnotationElement(e2);
      case Zl.TEXT:
        return new TextAnnotationElement(e2);
      case Zl.WIDGET:
        switch (e2.data.fieldType) {
          case "Tx":
            return new TextWidgetAnnotationElement(e2);
          case "Btn":
            return e2.data.radioButton ? new RadioButtonWidgetAnnotationElement(e2) : e2.data.checkBox ? new CheckboxWidgetAnnotationElement(e2) : new PushButtonWidgetAnnotationElement(e2);
          case "Ch":
            return new ChoiceWidgetAnnotationElement(e2);
          case "Sig":
            return new SignatureWidgetAnnotationElement(e2);
        }
        return new WidgetAnnotationElement(e2);
      case Zl.POPUP:
        return new PopupAnnotationElement(e2);
      case Zl.FREETEXT:
        return new FreeTextAnnotationElement(e2);
      case Zl.LINE:
        return new LineAnnotationElement(e2);
      case Zl.SQUARE:
        return new SquareAnnotationElement(e2);
      case Zl.CIRCLE:
        return new CircleAnnotationElement(e2);
      case Zl.POLYLINE:
        return new PolylineAnnotationElement(e2);
      case Zl.CARET:
        return new CaretAnnotationElement(e2);
      case Zl.INK:
        return new InkAnnotationElement(e2);
      case Zl.POLYGON:
        return new PolygonAnnotationElement(e2);
      case Zl.HIGHLIGHT:
        return new HighlightAnnotationElement(e2);
      case Zl.UNDERLINE:
        return new UnderlineAnnotationElement(e2);
      case Zl.SQUIGGLY:
        return new SquigglyAnnotationElement(e2);
      case Zl.STRIKEOUT:
        return new StrikeOutAnnotationElement(e2);
      case Zl.STAMP:
        return new StampAnnotationElement(e2);
      case Zl.FILEATTACHMENT:
        return new FileAttachmentAnnotationElement(e2);
      default:
        return new AnnotationElement(e2);
    }
  }
}
class AnnotationElement {
  #eo = null;
  #to = false;
  #io = null;
  constructor(e2, { isRenderable: t2 = false, ignoreBorder: i2 = false, createQuadrilaterals: n2 = false } = {}) {
    this.isRenderable = t2, this.data = e2.data, this.layer = e2.layer, this.linkService = e2.linkService, this.downloadManager = e2.downloadManager, this.imageResourcesPath = e2.imageResourcesPath, this.renderForms = e2.renderForms, this.svgFactory = e2.svgFactory, this.annotationStorage = e2.annotationStorage, this.enableComment = e2.enableComment, this.enableScripting = e2.enableScripting, this.hasJSActions = e2.hasJSActions, this._fieldObjects = e2.fieldObjects, this.parent = e2.parent, t2 && (this.container = this._createContainer(i2)), n2 && this._createQuadrilaterals();
  }
  static _hasPopupData({ contentsObj: e2, richText: t2 }) {
    return !(!e2?.str && !t2?.str);
  }
  get _isEditable() {
    return this.data.isEditable;
  }
  get hasPopupData() {
    return AnnotationElement._hasPopupData(this.data) || this.enableComment && !!this.commentText;
  }
  get commentData() {
    const { data: e2 } = this, t2 = this.annotationStorage?.getEditor(e2.id);
    return t2 ? t2.getData() : e2;
  }
  get hasCommentButton() {
    return this.enableComment && this.hasPopupElement;
  }
  get commentButtonPosition() {
    const e2 = this.annotationStorage?.getEditor(this.data.id);
    if (e2) return e2.commentButtonPositionInPage;
    const { quadPoints: t2, inkLists: i2, rect: n2 } = this.data;
    let a2 = -1 / 0, s2 = -1 / 0;
    if (t2?.length >= 8) {
      for (let e3 = 0; e3 < t2.length; e3 += 8) t2[e3 + 1] > s2 ? (s2 = t2[e3 + 1], a2 = t2[e3 + 2]) : t2[e3 + 1] === s2 && (a2 = Math.max(a2, t2[e3 + 2]));
      return [a2, s2];
    }
    if (i2?.length >= 1) {
      for (const e3 of i2) for (let t3 = 0, i3 = e3.length; t3 < i3; t3 += 2) e3[t3 + 1] > s2 ? (s2 = e3[t3 + 1], a2 = e3[t3]) : e3[t3 + 1] === s2 && (a2 = Math.max(a2, e3[t3]));
      if (a2 !== 1 / 0) return [a2, s2];
    }
    return n2 ? [n2[2], n2[3]] : null;
  }
  _normalizePoint(e2) {
    const { page: { view: t2 }, viewport: { rawDims: { pageWidth: i2, pageHeight: n2, pageX: a2, pageY: s2 } } } = this.parent;
    return e2[1] = t2[3] - e2[1] + t2[1], e2[0] = 100 * (e2[0] - a2) / i2, e2[1] = 100 * (e2[1] - s2) / n2, e2;
  }
  get commentText() {
    const { data: e2 } = this;
    return this.annotationStorage.getRawValue(`${$l}${e2.id}`)?.popup?.contents || e2.contentsObj?.str || "";
  }
  set commentText(e2) {
    const { data: t2 } = this, i2 = { deleted: !e2, contents: e2 || "" };
    this.annotationStorage.updateEditor(t2.id, { popup: i2 }) || this.annotationStorage.setValue(`${$l}${t2.id}`, { id: t2.id, annotationType: t2.annotationType, pageIndex: this.parent.page._pageIndex, popup: i2, popupRef: t2.popupRef, modificationDate: /* @__PURE__ */ new Date() }), e2 || this.removePopup();
  }
  removePopup() {
    (this.#io?.popup || this.popup)?.remove(), this.#io = this.popup = null;
  }
  updateEdited(e2) {
    if (!this.container) return;
    e2.rect && (this.#eo ||= { rect: this.data.rect.slice(0) });
    const { rect: t2, popup: i2 } = e2;
    t2 && this.#no(t2);
    let n2 = this.#io?.popup || this.popup;
    !n2 && i2?.text && (this._createPopup(i2), n2 = this.#io.popup), n2 && (n2.updateEdited(e2), i2?.deleted && (n2.remove(), this.#io = null, this.popup = null));
  }
  resetEdited() {
    this.#eo && (this.#no(this.#eo.rect), this.#io?.popup.resetEdited(), this.#eo = null);
  }
  #no(e2) {
    const { container: { style: t2 }, data: { rect: i2, rotation: n2 }, parent: { viewport: { rawDims: { pageWidth: a2, pageHeight: s2, pageX: r2, pageY: o2 } } } } = this;
    i2?.splice(0, 4, ...e2), t2.left = 100 * (e2[0] - r2) / a2 + "%", t2.top = 100 * (s2 - e2[3] + o2) / s2 + "%", 0 === n2 ? (t2.width = 100 * (e2[2] - e2[0]) / a2 + "%", t2.height = 100 * (e2[3] - e2[1]) / s2 + "%") : this.setRotation(n2);
  }
  _createContainer(e2) {
    const { data: t2, parent: { page: i2, viewport: n2 } } = this, a2 = document.createElement("section");
    a2.setAttribute("data-annotation-id", t2.id), this instanceof WidgetAnnotationElement || this instanceof LinkAnnotationElement || (a2.tabIndex = 0);
    const { style: s2 } = a2;
    if (s2.zIndex = this.parent.zIndex, this.parent.zIndex += 2, t2.alternativeText && (a2.title = t2.alternativeText), t2.noRotate && a2.classList.add("norotate"), !t2.rect || this instanceof PopupAnnotationElement) {
      const { rotation: e3 } = t2;
      return t2.hasOwnCanvas || 0 === e3 || this.setRotation(e3, a2), a2;
    }
    const { width: r2, height: o2 } = this;
    if (!e2 && t2.borderStyle.width > 0) {
      s2.borderWidth = `${t2.borderStyle.width}px`;
      const e3 = t2.borderStyle.horizontalCornerRadius, i3 = t2.borderStyle.verticalCornerRadius;
      if (e3 > 0 || i3 > 0) {
        const t3 = `calc(${e3}px * var(--total-scale-factor)) / calc(${i3}px * var(--total-scale-factor))`;
        s2.borderRadius = t3;
      } else if (this instanceof RadioButtonWidgetAnnotationElement) {
        const e4 = `calc(${r2}px * var(--total-scale-factor)) / calc(${o2}px * var(--total-scale-factor))`;
        s2.borderRadius = e4;
      }
      switch (t2.borderStyle.style) {
        case Ql:
          s2.borderStyle = "solid";
          break;
        case ec:
          s2.borderStyle = "dashed";
          break;
        case tc:
          warn("Unimplemented border style: beveled");
          break;
        case ic:
          warn("Unimplemented border style: inset");
          break;
        case nc:
          s2.borderBottomStyle = "solid";
      }
      const n3 = t2.borderColor || null;
      n3 ? (this.#to = true, s2.borderColor = Util.makeHexColor(0 | n3[0], 0 | n3[1], 0 | n3[2])) : s2.borderWidth = 0;
    }
    const l2 = Util.normalizeRect([t2.rect[0], i2.view[3] - t2.rect[1] + i2.view[1], t2.rect[2], i2.view[3] - t2.rect[3] + i2.view[1]]), { pageWidth: c2, pageHeight: h2, pageX: d2, pageY: u2 } = n2.rawDims;
    s2.left = 100 * (l2[0] - d2) / c2 + "%", s2.top = 100 * (l2[1] - u2) / h2 + "%";
    const { rotation: g2 } = t2;
    return t2.hasOwnCanvas || 0 === g2 ? (s2.width = 100 * r2 / c2 + "%", s2.height = 100 * o2 / h2 + "%") : this.setRotation(g2, a2), a2;
  }
  setRotation(e2, t2 = this.container) {
    if (!this.data.rect) return;
    const { pageWidth: i2, pageHeight: n2 } = this.parent.viewport.rawDims;
    let { width: a2, height: s2 } = this;
    e2 % 180 != 0 && ([a2, s2] = [s2, a2]), t2.style.width = 100 * a2 / i2 + "%", t2.style.height = 100 * s2 / n2 + "%", t2.setAttribute("data-main-rotation", (360 - e2) % 360);
  }
  get _commonActions() {
    const setColor = (e2, t2, i2) => {
      const n2 = i2.detail[e2], a2 = n2[0], s2 = n2.slice(1);
      i2.target.style[t2] = ColorConverters[`${a2}_HTML`](s2), this.annotationStorage.setValue(this.data.id, { [t2]: ColorConverters[`${a2}_rgb`](s2) });
    };
    return shadow(this, "_commonActions", { display: (e2) => {
      const { display: t2 } = e2.detail, i2 = t2 % 2 == 1;
      this.container.style.visibility = i2 ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, { noView: i2, noPrint: 1 === t2 || 2 === t2 });
    }, print: (e2) => {
      this.annotationStorage.setValue(this.data.id, { noPrint: !e2.detail.print });
    }, hidden: (e2) => {
      const { hidden: t2 } = e2.detail;
      this.container.style.visibility = t2 ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, { noPrint: t2, noView: t2 });
    }, focus: (e2) => {
      setTimeout(() => e2.target.focus({ preventScroll: false }), 0);
    }, userName: (e2) => {
      e2.target.title = e2.detail.userName;
    }, readonly: (e2) => {
      e2.target.disabled = e2.detail.readonly;
    }, required: (e2) => {
      this._setRequired(e2.target, e2.detail.required);
    }, bgColor: (e2) => {
      setColor("bgColor", "backgroundColor", e2);
    }, fillColor: (e2) => {
      setColor("fillColor", "backgroundColor", e2);
    }, fgColor: (e2) => {
      setColor("fgColor", "color", e2);
    }, textColor: (e2) => {
      setColor("textColor", "color", e2);
    }, borderColor: (e2) => {
      setColor("borderColor", "borderColor", e2);
    }, strokeColor: (e2) => {
      setColor("strokeColor", "borderColor", e2);
    }, rotation: (e2) => {
      const t2 = e2.detail.rotation;
      this.setRotation(t2), this.annotationStorage.setValue(this.data.id, { rotation: t2 });
    } });
  }
  _dispatchEventFromSandbox(e2, t2) {
    const i2 = this._commonActions;
    for (const n2 of Object.keys(t2.detail)) {
      const a2 = e2[n2] || i2[n2];
      a2?.(t2);
    }
  }
  _setDefaultPropertiesFromJS(e2) {
    if (!this.enableScripting) return;
    const t2 = this.annotationStorage.getRawValue(this.data.id);
    if (!t2) return;
    const i2 = this._commonActions;
    for (const [n2, a2] of Object.entries(t2)) {
      const s2 = i2[n2];
      if (s2) {
        s2({ detail: { [n2]: a2 }, target: e2 }), delete t2[n2];
      }
    }
  }
  _createQuadrilaterals() {
    if (!this.container) return;
    const { quadPoints: e2 } = this.data;
    if (!e2) return;
    const [t2, i2, n2, a2] = this.data.rect.map((e3) => Math.fround(e3));
    if (8 === e2.length) {
      const [s3, r3, o3, l3] = e2.subarray(2, 6);
      if (n2 === s3 && a2 === r3 && t2 === o3 && i2 === l3) return;
    }
    const { style: s2 } = this.container;
    let r2;
    if (this.#to) {
      const { borderColor: e3, borderWidth: t3 } = s2;
      s2.borderWidth = 0, r2 = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${e3}" stroke-width="${t3}">`], this.container.classList.add("hasBorder");
    }
    const o2 = n2 - t2, l2 = a2 - i2, { svgFactory: c2 } = this, h2 = c2.createElement("svg");
    h2.classList.add("quadrilateralsContainer"), h2.setAttribute("width", 0), h2.setAttribute("height", 0), h2.role = "none";
    const d2 = c2.createElement("defs");
    h2.append(d2);
    const u2 = c2.createElement("clipPath"), g2 = `clippath_${this.data.id}`;
    u2.setAttribute("id", g2), u2.setAttribute("clipPathUnits", "objectBoundingBox"), d2.append(u2);
    for (let i3 = 2, n3 = e2.length; i3 < n3; i3 += 8) {
      const n4 = e2[i3], s3 = e2[i3 + 1], h3 = e2[i3 + 2], d3 = e2[i3 + 3], g3 = c2.createElement("rect"), f2 = (h3 - t2) / o2, p2 = (a2 - s3) / l2, m2 = (n4 - h3) / o2, b2 = (s3 - d3) / l2;
      g3.setAttribute("x", f2), g3.setAttribute("y", p2), g3.setAttribute("width", m2), g3.setAttribute("height", b2), u2.append(g3), r2?.push(`<rect vector-effect="non-scaling-stroke" x="${f2}" y="${p2}" width="${m2}" height="${b2}"/>`);
    }
    this.#to && (r2.push("</g></svg>')"), s2.backgroundImage = r2.join("")), this.container.append(h2), this.container.style.clipPath = `url(#${g2})`;
  }
  _createPopup(e2 = null) {
    const { data: t2 } = this;
    let i2, n2;
    e2 ? (i2 = { str: e2.text }, n2 = e2.date) : (i2 = t2.contentsObj, n2 = t2.modificationDate);
    const a2 = this.#io = new PopupAnnotationElement({ data: { color: t2.color, titleObj: t2.titleObj, modificationDate: n2, contentsObj: i2, richText: t2.richText, parentRect: t2.rect, borderStyle: 0, id: `popup_${t2.id}`, rotation: t2.rotation, noRotate: true }, linkService: this.linkService, parent: this.parent, elements: [this] });
    this.parent._commentManager || this.parent.div.append(a2.render());
  }
  get hasPopupElement() {
    return !!(this.#io || this.popup || this.data.popupRef);
  }
  get extraPopupElement() {
    return this.#io;
  }
  render() {
    unreachable("Abstract method `AnnotationElement.render` called");
  }
  _getElementsByName(e2, t2 = null) {
    const i2 = [];
    if (this._fieldObjects) {
      const n2 = this._fieldObjects[e2];
      if (n2) for (const { page: e3, id: a2, exportValues: s2 } of n2) {
        if (-1 === e3) continue;
        if (a2 === t2) continue;
        const n3 = "string" == typeof s2 ? s2 : null, r2 = document.querySelector(`[data-element-id="${a2}"]`);
        !r2 || dh.has(r2) ? i2.push({ id: a2, exportValue: n3, domElement: r2 }) : warn(`_getElementsByName - element not allowed: ${a2}`);
      }
      return i2;
    }
    for (const n2 of document.getElementsByName(e2)) {
      const { exportValue: e3 } = n2, a2 = n2.getAttribute("data-element-id");
      a2 !== t2 && (dh.has(n2) && i2.push({ id: a2, exportValue: e3, domElement: n2 }));
    }
    return i2;
  }
  show() {
    this.container && (this.container.hidden = false), this.popup?.maybeShow();
  }
  hide() {
    this.container && (this.container.hidden = true), this.popup?.forceHide();
  }
  getElementsToTriggerPopup() {
    return this.container;
  }
  addHighlightArea() {
    const e2 = this.getElementsToTriggerPopup();
    if (Array.isArray(e2)) for (const t2 of e2) t2.classList.add("highlightArea");
    else e2.classList.add("highlightArea");
  }
  _editOnDoubleClick() {
    if (!this._isEditable) return;
    const { annotationEditorType: e2, data: { id: t2 } } = this;
    this.container.addEventListener("dblclick", () => {
      this.linkService.eventBus?.dispatch("switchannotationeditormode", { source: this, mode: e2, editId: t2, mustEnterInEditMode: true });
    });
  }
  get width() {
    return this.data.rect[2] - this.data.rect[0];
  }
  get height() {
    return this.data.rect[3] - this.data.rect[1];
  }
}
class EditorAnnotationElement extends AnnotationElement {
  constructor(e2) {
    super(e2, { isRenderable: true, ignoreBorder: true }), this.editor = e2.editor;
  }
  render() {
    return this.container.className = "editorAnnotation", this.container;
  }
  createOrUpdatePopup() {
    const { editor: e2 } = this;
    e2.hasComment && (this._createPopup(e2.comment), this.extraPopupElement.popup.renderCommentButton());
  }
  get hasCommentButton() {
    return this.enableComment && this.editor.hasComment;
  }
  get commentButtonPosition() {
    return this.editor.commentButtonPositionInPage;
  }
  get commentText() {
    return this.editor.comment.text;
  }
  set commentText(e2) {
    this.editor.comment = e2, e2 || this.removePopup();
  }
  get commentData() {
    return this.editor.getData();
  }
  remove() {
    this.container.remove(), this.container = null, this.removePopup();
  }
}
class LinkAnnotationElement extends AnnotationElement {
  constructor(e2, t2 = null) {
    super(e2, { isRenderable: true, ignoreBorder: !!t2?.ignoreBorder, createQuadrilaterals: true }), this.isTooltipOnly = e2.data.isTooltipOnly;
  }
  render() {
    const { data: e2, linkService: t2 } = this, i2 = document.createElement("a");
    i2.setAttribute("data-element-id", e2.id);
    let n2 = false;
    return e2.url ? (t2.addLinkAttributes(i2, e2.url, e2.newWindow), n2 = true) : e2.action ? (this._bindNamedAction(i2, e2.action, e2.overlaidText), n2 = true) : e2.attachment ? (this.#ao(i2, e2.attachment, e2.overlaidText, e2.attachmentDest), n2 = true) : e2.setOCGState ? (this.#so(i2, e2.setOCGState, e2.overlaidText), n2 = true) : e2.dest ? (this._bindLink(i2, e2.dest, e2.overlaidText), n2 = true) : (e2.actions && (e2.actions.Action || e2.actions["Mouse Up"] || e2.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(i2, e2), n2 = true), e2.resetForm ? (this._bindResetFormAction(i2, e2.resetForm), n2 = true) : this.isTooltipOnly && !n2 && (this._bindLink(i2, ""), n2 = true)), this.container.classList.add("linkAnnotation"), n2 && this.container.append(i2), this.container;
  }
  #ro() {
    this.container.setAttribute("data-internal-link", "");
  }
  _bindLink(e2, t2, i2 = "") {
    e2.href = this.linkService.getDestinationHash(t2), e2.onclick = () => (t2 && this.linkService.goToDestination(t2), false), (t2 || "" === t2) && this.#ro(), i2 && (e2.title = i2);
  }
  _bindNamedAction(e2, t2, i2 = "") {
    e2.href = this.linkService.getAnchorUrl(""), e2.onclick = () => (this.linkService.executeNamedAction(t2), false), i2 && (e2.title = i2), this.#ro();
  }
  #ao(e2, t2, i2 = "", n2 = null) {
    e2.href = this.linkService.getAnchorUrl(""), t2.description ? e2.title = t2.description : i2 && (e2.title = i2), e2.onclick = () => (this.downloadManager?.openOrDownloadData(t2.content, t2.filename, n2), false), this.#ro();
  }
  #so(e2, t2, i2 = "") {
    e2.href = this.linkService.getAnchorUrl(""), e2.onclick = () => (this.linkService.executeSetOCGState(t2), false), i2 && (e2.title = i2), this.#ro();
  }
  _bindJSAction(e2, t2) {
    e2.href = this.linkService.getAnchorUrl("");
    const i2 = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
    for (const n2 of Object.keys(t2.actions)) {
      const a2 = i2.get(n2);
      a2 && (e2[a2] = () => (this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t2.id, name: n2 } }), false));
    }
    t2.overlaidText && (e2.title = t2.overlaidText), e2.onclick || (e2.onclick = () => false), this.#ro();
  }
  _bindResetFormAction(e2, t2) {
    const i2 = e2.onclick;
    if (i2 || (e2.href = this.linkService.getAnchorUrl("")), this.#ro(), !this._fieldObjects) return warn('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), void (i2 || (e2.onclick = () => false));
    e2.onclick = () => {
      i2?.();
      const { fields: e3, refs: n2, include: a2 } = t2, s2 = [];
      if (0 !== e3.length || 0 !== n2.length) {
        const t3 = new Set(n2);
        for (const i3 of e3) {
          const e4 = this._fieldObjects[i3] || [];
          for (const { id: i4 } of e4) t3.add(i4);
        }
        for (const e4 of Object.values(this._fieldObjects)) for (const i3 of e4) t3.has(i3.id) === a2 && s2.push(i3);
      } else for (const e4 of Object.values(this._fieldObjects)) s2.push(...e4);
      const r2 = this.annotationStorage, o2 = [];
      for (const e4 of s2) {
        const { id: t3 } = e4;
        switch (o2.push(t3), e4.type) {
          case "text": {
            const i4 = e4.defaultValue || "";
            r2.setValue(t3, { value: i4 });
            break;
          }
          case "checkbox":
          case "radiobutton": {
            const i4 = e4.defaultValue === e4.exportValues;
            r2.setValue(t3, { value: i4 });
            break;
          }
          case "combobox":
          case "listbox": {
            const i4 = e4.defaultValue || "";
            r2.setValue(t3, { value: i4 });
            break;
          }
          default:
            continue;
        }
        const i3 = document.querySelector(`[data-element-id="${t3}"]`);
        i3 && (dh.has(i3) ? i3.dispatchEvent(new Event("resetform")) : warn(`_bindResetFormAction - element not allowed: ${t3}`));
      }
      return this.enableScripting && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: "app", ids: o2, name: "ResetForm" } }), false;
    };
  }
}
class TextAnnotationElement extends AnnotationElement {
  constructor(e2) {
    super(e2, { isRenderable: true });
  }
  render() {
    this.container.classList.add("textAnnotation");
    const e2 = document.createElement("img");
    return e2.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", e2.setAttribute("data-l10n-id", "pdfjs-text-annotation-type"), e2.setAttribute("data-l10n-args", JSON.stringify({ type: this.data.name })), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(e2), this.container;
  }
}
class WidgetAnnotationElement extends AnnotationElement {
  render() {
    return this.container;
  }
  showElementAndHideCanvas(e2) {
    this.data.hasOwnCanvas && ("CANVAS" === e2.previousSibling?.nodeName && (e2.previousSibling.hidden = true), e2.hidden = false);
  }
  _getKeyModifier(e2) {
    return util_FeatureTest.platform.isMac ? e2.metaKey : e2.ctrlKey;
  }
  _setEventListener(e2, t2, i2, n2, a2) {
    i2.includes("mouse") ? e2.addEventListener(i2, (e3) => {
      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: this.data.id, name: n2, value: a2(e3), shift: e3.shiftKey, modifier: this._getKeyModifier(e3) } });
    }) : e2.addEventListener(i2, (e3) => {
      if ("blur" === i2) {
        if (!t2.focused || !e3.relatedTarget) return;
        t2.focused = false;
      } else if ("focus" === i2) {
        if (t2.focused) return;
        t2.focused = true;
      }
      a2 && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: this.data.id, name: n2, value: a2(e3) } });
    });
  }
  _setEventListeners(e2, t2, i2, n2) {
    for (const [a2, s2] of i2) ("Action" === s2 || this.data.actions?.[s2]) && ("Focus" !== s2 && "Blur" !== s2 || (t2 ||= { focused: false }), this._setEventListener(e2, t2, a2, s2, n2), "Focus" !== s2 || this.data.actions?.Blur ? "Blur" !== s2 || this.data.actions?.Focus || this._setEventListener(e2, t2, "focus", "Focus", null) : this._setEventListener(e2, t2, "blur", "Blur", null));
  }
  _setBackgroundColor(e2) {
    const t2 = this.data.backgroundColor || null;
    e2.style.backgroundColor = null === t2 ? "transparent" : Util.makeHexColor(t2[0], t2[1], t2[2]);
  }
  _setTextStyle(e2) {
    const t2 = ["left", "center", "right"], { fontColor: i2 } = this.data.defaultAppearanceData, n2 = this.data.defaultAppearanceData.fontSize || 9, a2 = e2.style;
    let s2;
    const roundToOneDecimal = (e3) => Math.round(10 * e3) / 10;
    if (this.data.multiLine) {
      const e3 = Math.abs(this.data.rect[3] - this.data.rect[1] - 2), t3 = e3 / (Math.round(e3 / (El * n2)) || 1);
      s2 = Math.min(n2, roundToOneDecimal(t3 / El));
    } else {
      const e3 = Math.abs(this.data.rect[3] - this.data.rect[1] - 2);
      s2 = Math.min(n2, roundToOneDecimal(e3 / El));
    }
    a2.fontSize = `calc(${s2}px * var(--total-scale-factor))`, a2.color = Util.makeHexColor(i2[0], i2[1], i2[2]), null !== this.data.textAlignment && (a2.textAlign = t2[this.data.textAlignment]);
  }
  _setRequired(e2, t2) {
    t2 ? e2.setAttribute("required", true) : e2.removeAttribute("required"), e2.setAttribute("aria-required", t2);
  }
}
class TextWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(e2) {
    super(e2, { isRenderable: e2.renderForms || e2.data.hasOwnCanvas || !e2.data.hasAppearance && !!e2.data.fieldValue });
  }
  setPropertyOnSiblings(e2, t2, i2, n2) {
    const a2 = this.annotationStorage;
    for (const s2 of this._getElementsByName(e2.name, e2.id)) s2.domElement && (s2.domElement[t2] = i2), a2.setValue(s2.id, { [n2]: i2 });
  }
  render() {
    const e2 = this.annotationStorage, t2 = this.data.id;
    this.container.classList.add("textWidgetAnnotation");
    let i2 = null;
    if (this.renderForms) {
      const n2 = e2.getValue(t2, { value: this.data.fieldValue });
      let a2 = n2.value || "";
      const s2 = e2.getValue(t2, { charLimit: this.data.maxLen }).charLimit;
      s2 && a2.length > s2 && (a2 = a2.slice(0, s2));
      let r2 = n2.formattedValue || this.data.textContent?.join("\n") || null;
      r2 && this.data.comb && (r2 = r2.replaceAll(/\s+/g, ""));
      const o2 = { userValue: a2, formattedValue: r2, lastCommittedValue: null, commitKey: 1, focused: false };
      this.data.multiLine ? (i2 = document.createElement("textarea"), i2.textContent = r2 ?? a2, this.data.doNotScroll && (i2.style.overflowY = "hidden")) : (i2 = document.createElement("input"), i2.type = this.data.password ? "password" : "text", i2.setAttribute("value", r2 ?? a2), this.data.doNotScroll && (i2.style.overflowX = "hidden")), this.data.hasOwnCanvas && (i2.hidden = true), dh.add(i2), i2.setAttribute("data-element-id", t2), i2.disabled = this.data.readOnly, i2.name = this.data.fieldName, i2.tabIndex = 0;
      const { datetimeFormat: l2, datetimeType: c2, timeStep: h2 } = this.data, d2 = !!c2 && this.enableScripting;
      l2 && (i2.title = l2), this._setRequired(i2, this.data.required), s2 && (i2.maxLength = s2), i2.addEventListener("input", (n3) => {
        e2.setValue(t2, { value: n3.target.value }), this.setPropertyOnSiblings(i2, "value", n3.target.value, "value"), o2.formattedValue = null;
      }), i2.addEventListener("resetform", (e3) => {
        const t3 = this.data.defaultFieldValue ?? "";
        i2.value = o2.userValue = t3, o2.formattedValue = null;
      });
      let blurListener = (e3) => {
        const { formattedValue: t3 } = o2;
        null != t3 && (e3.target.value = t3), e3.target.scrollLeft = 0;
      };
      if (this.enableScripting && this.hasJSActions) {
        i2.addEventListener("focus", (e3) => {
          if (o2.focused) return;
          const { target: t3 } = e3;
          if (d2 && (t3.type = c2, h2 && (t3.step = h2)), o2.userValue) {
            const e4 = o2.userValue;
            if (d2) if ("time" === c2) {
              const i3 = new Date(e4), n4 = [i3.getHours(), i3.getMinutes(), i3.getSeconds()];
              t3.value = n4.map((e5) => e5.toString().padStart(2, "0")).join(":");
            } else t3.value = new Date(e4 - uh).toISOString().split("date" === c2 ? "T" : ".", 1)[0];
            else t3.value = e4;
          }
          o2.lastCommittedValue = t3.value, o2.commitKey = 1, this.data.actions?.Focus || (o2.focused = true);
        }), i2.addEventListener("updatefromsandbox", (i3) => {
          this.showElementAndHideCanvas(i3.target);
          const n4 = { value(i4) {
            o2.userValue = i4.detail.value ?? "", d2 || e2.setValue(t2, { value: o2.userValue.toString() }), i4.target.value = o2.userValue;
          }, formattedValue(i4) {
            const { formattedValue: n5 } = i4.detail;
            o2.formattedValue = n5, null != n5 && i4.target !== document.activeElement && (i4.target.value = n5);
            const a3 = { formattedValue: n5 };
            d2 && (a3.value = n5), e2.setValue(t2, a3);
          }, selRange(e3) {
            e3.target.setSelectionRange(...e3.detail.selRange);
          }, charLimit: (i4) => {
            const { charLimit: n5 } = i4.detail, { target: a3 } = i4;
            if (0 === n5) return void a3.removeAttribute("maxLength");
            a3.setAttribute("maxLength", n5);
            let s3 = o2.userValue;
            !s3 || s3.length <= n5 || (s3 = s3.slice(0, n5), a3.value = o2.userValue = s3, e2.setValue(t2, { value: s3 }), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t2, name: "Keystroke", value: s3, willCommit: true, commitKey: 1, selStart: a3.selectionStart, selEnd: a3.selectionEnd } }));
          } };
          this._dispatchEventFromSandbox(n4, i3);
        }), i2.addEventListener("keydown", (e3) => {
          o2.commitKey = 1;
          let i3 = -1;
          if ("Escape" === e3.key ? i3 = 0 : "Enter" !== e3.key || this.data.multiLine ? "Tab" === e3.key && (o2.commitKey = 3) : i3 = 2, -1 === i3) return;
          const { value: n4 } = e3.target;
          o2.lastCommittedValue !== n4 && (o2.lastCommittedValue = n4, o2.userValue = n4, this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t2, name: "Keystroke", value: n4, willCommit: true, commitKey: i3, selStart: e3.target.selectionStart, selEnd: e3.target.selectionEnd } }));
        });
        const n3 = blurListener;
        blurListener = null, i2.addEventListener("blur", (e3) => {
          if (!o2.focused || !e3.relatedTarget) return;
          this.data.actions?.Blur || (o2.focused = false);
          const { target: i3 } = e3;
          let { value: a3 } = i3;
          if (d2) {
            if (a3 && "time" === c2) {
              const e4 = a3.split(":").map((e5) => parseInt(e5, 10));
              a3 = new Date(2e3, 0, 1, e4[0], e4[1], e4[2] || 0).valueOf(), i3.step = "";
            } else a3.includes("T") || (a3 = `${a3}T00:00`), a3 = new Date(a3).valueOf();
            i3.type = "text";
          }
          o2.userValue = a3, o2.lastCommittedValue !== a3 && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t2, name: "Keystroke", value: a3, willCommit: true, commitKey: o2.commitKey, selStart: e3.target.selectionStart, selEnd: e3.target.selectionEnd } }), n3(e3);
        }), this.data.actions?.Keystroke && i2.addEventListener("beforeinput", (e3) => {
          o2.lastCommittedValue = null;
          const { data: i3, target: n4 } = e3, { value: a3, selectionStart: s3, selectionEnd: r3 } = n4;
          let l3 = s3, c3 = r3;
          switch (e3.inputType) {
            case "deleteWordBackward": {
              const e4 = a3.substring(0, s3).match(/\w*[^\w]*$/);
              e4 && (l3 -= e4[0].length);
              break;
            }
            case "deleteWordForward": {
              const e4 = a3.substring(s3).match(/^[^\w]*\w*/);
              e4 && (c3 += e4[0].length);
              break;
            }
            case "deleteContentBackward":
              s3 === r3 && (l3 -= 1);
              break;
            case "deleteContentForward":
              s3 === r3 && (c3 += 1);
          }
          e3.preventDefault(), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t2, name: "Keystroke", value: a3, change: i3 || "", willCommit: false, selStart: l3, selEnd: c3 } });
        }), this._setEventListeners(i2, o2, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (e3) => e3.target.value);
      }
      if (blurListener && i2.addEventListener("blur", blurListener), this.data.comb) {
        const e3 = (this.data.rect[2] - this.data.rect[0]) / s2;
        i2.classList.add("comb"), i2.style.letterSpacing = `calc(${e3}px * var(--total-scale-factor) - 1ch)`;
      }
    } else i2 = document.createElement("div"), i2.textContent = this.data.fieldValue, i2.style.verticalAlign = "middle", i2.style.display = "table-cell", this.data.hasOwnCanvas && (i2.hidden = true);
    return this._setTextStyle(i2), this._setBackgroundColor(i2), this._setDefaultPropertiesFromJS(i2), this.container.append(i2), this.container;
  }
}
class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(e2) {
    super(e2, { isRenderable: !!e2.data.hasOwnCanvas });
  }
}
class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(e2) {
    super(e2, { isRenderable: e2.renderForms });
  }
  render() {
    const e2 = this.annotationStorage, t2 = this.data, i2 = t2.id;
    let n2 = e2.getValue(i2, { value: t2.exportValue === t2.fieldValue }).value;
    "string" == typeof n2 && (n2 = "Off" !== n2, e2.setValue(i2, { value: n2 })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
    const a2 = document.createElement("input");
    return dh.add(a2), a2.setAttribute("data-element-id", i2), a2.disabled = t2.readOnly, this._setRequired(a2, this.data.required), a2.type = "checkbox", a2.name = t2.fieldName, n2 && a2.setAttribute("checked", true), a2.setAttribute("exportValue", t2.exportValue), a2.tabIndex = 0, a2.addEventListener("change", (n3) => {
      const { name: a3, checked: s2 } = n3.target;
      for (const n4 of this._getElementsByName(a3, i2)) {
        const i3 = s2 && n4.exportValue === t2.exportValue;
        n4.domElement && (n4.domElement.checked = i3), e2.setValue(n4.id, { value: i3 });
      }
      e2.setValue(i2, { value: s2 });
    }), a2.addEventListener("resetform", (e3) => {
      const i3 = t2.defaultFieldValue || "Off";
      e3.target.checked = i3 === t2.exportValue;
    }), this.enableScripting && this.hasJSActions && (a2.addEventListener("updatefromsandbox", (t3) => {
      const n3 = { value(t4) {
        t4.target.checked = "Off" !== t4.detail.value, e2.setValue(i2, { value: t4.target.checked });
      } };
      this._dispatchEventFromSandbox(n3, t3);
    }), this._setEventListeners(a2, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (e3) => e3.target.checked)), this._setBackgroundColor(a2), this._setDefaultPropertiesFromJS(a2), this.container.append(a2), this.container;
  }
}
class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(e2) {
    super(e2, { isRenderable: e2.renderForms });
  }
  render() {
    this.container.classList.add("buttonWidgetAnnotation", "radioButton");
    const e2 = this.annotationStorage, t2 = this.data, i2 = t2.id;
    let n2 = e2.getValue(i2, { value: t2.fieldValue === t2.buttonValue }).value;
    if ("string" == typeof n2 && (n2 = n2 !== t2.buttonValue, e2.setValue(i2, { value: n2 })), n2) for (const n3 of this._getElementsByName(t2.fieldName, i2)) e2.setValue(n3.id, { value: false });
    const a2 = document.createElement("input");
    if (dh.add(a2), a2.setAttribute("data-element-id", i2), a2.disabled = t2.readOnly, this._setRequired(a2, this.data.required), a2.type = "radio", a2.name = t2.fieldName, n2 && a2.setAttribute("checked", true), a2.tabIndex = 0, a2.addEventListener("change", (t3) => {
      const { name: n3, checked: a3 } = t3.target;
      for (const t4 of this._getElementsByName(n3, i2)) e2.setValue(t4.id, { value: false });
      e2.setValue(i2, { value: a3 });
    }), a2.addEventListener("resetform", (e3) => {
      const i3 = t2.defaultFieldValue;
      e3.target.checked = null != i3 && i3 === t2.buttonValue;
    }), this.enableScripting && this.hasJSActions) {
      const n3 = t2.buttonValue;
      a2.addEventListener("updatefromsandbox", (t3) => {
        const a3 = { value: (t4) => {
          const a4 = n3 === t4.detail.value;
          for (const n4 of this._getElementsByName(t4.target.name)) {
            const t5 = a4 && n4.id === i2;
            n4.domElement && (n4.domElement.checked = t5), e2.setValue(n4.id, { value: t5 });
          }
        } };
        this._dispatchEventFromSandbox(a3, t3);
      }), this._setEventListeners(a2, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (e3) => e3.target.checked);
    }
    return this._setBackgroundColor(a2), this._setDefaultPropertiesFromJS(a2), this.container.append(a2), this.container;
  }
}
class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
  constructor(e2) {
    super(e2, { ignoreBorder: e2.data.hasAppearance });
  }
  render() {
    const e2 = super.render();
    e2.classList.add("buttonWidgetAnnotation", "pushButton");
    const t2 = e2.lastChild;
    return this.enableScripting && this.hasJSActions && t2 && (this._setDefaultPropertiesFromJS(t2), t2.addEventListener("updatefromsandbox", (e3) => {
      this._dispatchEventFromSandbox({}, e3);
    })), e2;
  }
}
class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(e2) {
    super(e2, { isRenderable: e2.renderForms });
  }
  render() {
    this.container.classList.add("choiceWidgetAnnotation");
    const e2 = this.annotationStorage, t2 = this.data.id, i2 = e2.getValue(t2, { value: this.data.fieldValue }), n2 = document.createElement("select");
    dh.add(n2), n2.setAttribute("data-element-id", t2), n2.disabled = this.data.readOnly, this._setRequired(n2, this.data.required), n2.name = this.data.fieldName, n2.tabIndex = 0;
    let a2 = this.data.combo && this.data.options.length > 0;
    this.data.combo || (n2.size = this.data.options.length, this.data.multiSelect && (n2.multiple = true)), n2.addEventListener("resetform", (e3) => {
      const t3 = this.data.defaultFieldValue;
      for (const e4 of n2.options) e4.selected = e4.value === t3;
    });
    for (const e3 of this.data.options) {
      const t3 = document.createElement("option");
      t3.textContent = e3.displayValue, t3.value = e3.exportValue, i2.value.includes(e3.exportValue) && (t3.setAttribute("selected", true), a2 = false), n2.append(t3);
    }
    let s2 = null;
    if (a2) {
      const e3 = document.createElement("option");
      e3.value = " ", e3.setAttribute("hidden", true), e3.setAttribute("selected", true), n2.prepend(e3), s2 = () => {
        e3.remove(), n2.removeEventListener("input", s2), s2 = null;
      }, n2.addEventListener("input", s2);
    }
    const getValue = (e3) => {
      const t3 = e3 ? "value" : "textContent", { options: i3, multiple: a3 } = n2;
      return a3 ? Array.prototype.filter.call(i3, (e4) => e4.selected).map((e4) => e4[t3]) : -1 === i3.selectedIndex ? null : i3[i3.selectedIndex][t3];
    };
    let r2 = getValue(false);
    const getItems = (e3) => {
      const t3 = e3.target.options;
      return Array.prototype.map.call(t3, (e4) => ({ displayValue: e4.textContent, exportValue: e4.value }));
    };
    return this.enableScripting && this.hasJSActions ? (n2.addEventListener("updatefromsandbox", (i3) => {
      const a3 = { value(i4) {
        s2?.();
        const a4 = i4.detail.value, o2 = new Set(Array.isArray(a4) ? a4 : [a4]);
        for (const e3 of n2.options) e3.selected = o2.has(e3.value);
        e2.setValue(t2, { value: getValue(true) }), r2 = getValue(false);
      }, multipleSelection(e3) {
        n2.multiple = true;
      }, remove(i4) {
        const a4 = n2.options, s3 = i4.detail.remove;
        if (a4[s3].selected = false, n2.remove(s3), a4.length > 0) {
          -1 === Array.prototype.findIndex.call(a4, (e3) => e3.selected) && (a4[0].selected = true);
        }
        e2.setValue(t2, { value: getValue(true), items: getItems(i4) }), r2 = getValue(false);
      }, clear(i4) {
        for (; 0 !== n2.length; ) n2.remove(0);
        e2.setValue(t2, { value: null, items: [] }), r2 = getValue(false);
      }, insert(i4) {
        const { index: a4, displayValue: s3, exportValue: o2 } = i4.detail.insert, l2 = n2.children[a4], c2 = document.createElement("option");
        c2.textContent = s3, c2.value = o2, l2 ? l2.before(c2) : n2.append(c2), e2.setValue(t2, { value: getValue(true), items: getItems(i4) }), r2 = getValue(false);
      }, items(i4) {
        const { items: a4 } = i4.detail;
        for (; 0 !== n2.length; ) n2.remove(0);
        for (const e3 of a4) {
          const { displayValue: t3, exportValue: i5 } = e3, a5 = document.createElement("option");
          a5.textContent = t3, a5.value = i5, n2.append(a5);
        }
        n2.options.length > 0 && (n2.options[0].selected = true), e2.setValue(t2, { value: getValue(true), items: getItems(i4) }), r2 = getValue(false);
      }, indices(i4) {
        const n3 = new Set(i4.detail.indices);
        for (const e3 of i4.target.options) e3.selected = n3.has(e3.index);
        e2.setValue(t2, { value: getValue(true) }), r2 = getValue(false);
      }, editable(e3) {
        e3.target.disabled = !e3.detail.editable;
      } };
      this._dispatchEventFromSandbox(a3, i3);
    }), n2.addEventListener("input", (i3) => {
      const n3 = getValue(true), a3 = getValue(false);
      e2.setValue(t2, { value: n3 }), i3.preventDefault(), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: t2, name: "Keystroke", value: r2, change: a3, changeEx: n3, willCommit: false, commitKey: 1, keyDown: false } });
    }), this._setEventListeners(n2, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (e3) => e3.target.value)) : n2.addEventListener("input", function(i3) {
      e2.setValue(t2, { value: getValue(true) });
    }), this.data.combo && this._setTextStyle(n2), this._setBackgroundColor(n2), this._setDefaultPropertiesFromJS(n2), this.container.append(n2), this.container;
  }
}
class PopupAnnotationElement extends AnnotationElement {
  constructor(e2) {
    const { data: t2, elements: i2, parent: n2 } = e2, a2 = !!n2._commentManager;
    if (super(e2, { isRenderable: !a2 && AnnotationElement._hasPopupData(t2) }), this.elements = i2, a2 && AnnotationElement._hasPopupData(t2)) {
      const e3 = this.popup = this.#oo();
      for (const t3 of i2) t3.popup = e3;
    } else this.popup = null;
  }
  #oo() {
    return new PopupElement({ container: this.container, color: this.data.color, titleObj: this.data.titleObj, modificationDate: this.data.modificationDate || this.data.creationDate, contentsObj: this.data.contentsObj, richText: this.data.richText, rect: this.data.rect, parentRect: this.data.parentRect || null, parent: this.parent, elements: this.elements, open: this.data.open, commentManager: this.parent._commentManager });
  }
  render() {
    const { container: e2 } = this;
    e2.classList.add("popupAnnotation"), e2.role = "comment";
    const t2 = this.popup = this.#oo(), i2 = [];
    for (const e3 of this.elements) e3.popup = t2, e3.container.ariaHasPopup = "dialog", i2.push(e3.data.id), e3.addHighlightArea();
    return this.container.setAttribute("aria-controls", i2.map((e3) => `${mc}${e3}`).join(",")), this.container;
  }
}
class PopupElement {
  #Vt = null;
  #lo = this.#Kr.bind(this);
  #co = this.#ho.bind(this);
  #do = this.#uo.bind(this);
  #go = this.#fo.bind(this);
  #po = null;
  #Mi = null;
  #mo = null;
  #bo = null;
  #yo = null;
  #wo = null;
  #Ao = null;
  #xo = false;
  #So = null;
  #vo = null;
  #Nt = null;
  #Co = null;
  #ko = null;
  #xn = null;
  #To = null;
  #yn = null;
  #Fo = null;
  #eo = null;
  #Io = false;
  #Eo = null;
  #Mo = null;
  constructor({ container: e2, color: t2, elements: i2, titleObj: n2, modificationDate: a2, contentsObj: s2, richText: r2, parent: o2, rect: l2, parentRect: c2, open: h2, commentManager: d2 = null }) {
    this.#Mi = e2, this.#Fo = n2, this.#mo = s2, this.#yn = r2, this.#wo = o2, this.#po = t2, this.#To = l2, this.#Ao = c2, this.#yo = i2, this.#Vt = d2, this.#Eo = i2[0], this.#bo = PDFDateString.toDateObject(a2), this.trigger = i2.flatMap((e3) => e3.getElementsToTriggerPopup()), d2 ? this.renderCommentButton() : (this.#Do(), this.#Mi.hidden = true, h2 && this.#fo());
  }
  #Do() {
    if (this.#vo) return;
    this.#vo = new AbortController();
    const { signal: e2 } = this.#vo;
    for (const t2 of this.trigger) t2.addEventListener("click", this.#go, { signal: e2 }), t2.addEventListener("pointerenter", this.#do, { signal: e2 }), t2.addEventListener("pointerleave", this.#co, { signal: e2 }), t2.classList.add("popupTriggerArea");
    for (const t2 of this.#yo) t2.container?.addEventListener("keydown", this.#lo, { signal: e2 });
  }
  #Oo() {
    const e2 = this.#yo.find((e3) => e3.hasCommentButton);
    e2 && (this.#ko = e2._normalizePoint(e2.commentButtonPosition));
  }
  renderCommentButton() {
    if (this.#Co) return;
    if (this.#ko || this.#Oo(), !this.#ko) return;
    const { signal: e2 } = this.#vo = new AbortController(), t2 = !!this.#Eo.extraPopupElement, togglePopup = () => {
      this.#Vt.toggleCommentPopup(this, true, void 0, !t2);
    }, showPopup = () => {
      this.#Vt.toggleCommentPopup(this, false, true, !t2);
    }, hidePopup = () => {
      this.#Vt.toggleCommentPopup(this, false, false);
    };
    if (t2) {
      this.#Co = this.#Eo.container;
      for (const t3 of this.trigger) t3.ariaHasPopup = "dialog", t3.ariaControls = "commentPopup", t3.addEventListener("keydown", this.#lo, { signal: e2 }), t3.addEventListener("click", togglePopup, { signal: e2 }), t3.addEventListener("pointerenter", showPopup, { signal: e2 }), t3.addEventListener("pointerleave", hidePopup, { signal: e2 }), t3.classList.add("popupTriggerArea");
    } else {
      const t3 = this.#Co = document.createElement("button");
      t3.className = "annotationCommentButton";
      const i2 = this.#Eo.container;
      t3.style.zIndex = i2.style.zIndex + 1, t3.tabIndex = 0, t3.ariaHasPopup = "dialog", t3.ariaControls = "commentPopup", t3.setAttribute("data-l10n-id", "pdfjs-show-comment-button"), this.#_o(), this.#Po(), t3.addEventListener("keydown", this.#lo, { signal: e2 }), t3.addEventListener("click", togglePopup, { signal: e2 }), t3.addEventListener("pointerenter", showPopup, { signal: e2 }), t3.addEventListener("pointerleave", hidePopup, { signal: e2 }), i2.after(t3);
    }
  }
  #Po() {
    if (this.#Eo.extraPopupElement && !this.#Eo.editor) return;
    this.renderCommentButton();
    const [e2, t2] = this.#ko, { style: i2 } = this.#Co;
    i2.left = `calc(${e2}%)`, i2.top = `calc(${t2}% - var(--comment-button-dim))`;
  }
  #_o() {
    this.#Eo.extraPopupElement || (this.renderCommentButton(), this.#Co.style.backgroundColor = this.commentButtonColor || "");
  }
  get commentButtonColor() {
    const { color: e2, opacity: t2 } = this.#Eo.commentData;
    return e2 ? this.#wo._commentManager.makeCommentColor(e2, t2) : null;
  }
  focusCommentButton() {
    setTimeout(() => {
      this.#Co?.focus();
    }, 0);
  }
  getData() {
    const { richText: e2, color: t2, opacity: i2, creationDate: n2, modificationDate: a2 } = this.#Eo.commentData;
    return { contentsObj: { str: this.comment }, richText: e2, color: t2, opacity: i2, creationDate: n2, modificationDate: a2 };
  }
  get elementBeforePopup() {
    return this.#Co;
  }
  get comment() {
    return this.#Mo ||= this.#Eo.commentText, this.#Mo;
  }
  set comment(e2) {
    e2 !== this.comment && (this.#Eo.commentText = this.#Mo = e2);
  }
  get parentBoundingClientRect() {
    return this.#Eo.layer.getBoundingClientRect();
  }
  setCommentButtonStates({ selected: e2, hasPopup: t2 }) {
    this.#Co && (this.#Co.classList.toggle("selected", e2), this.#Co.ariaExpanded = t2);
  }
  setSelectedCommentButton(e2) {
    this.#Co.classList.toggle("selected", e2);
  }
  get commentPopupPosition() {
    if (this.#xn) return this.#xn;
    const { x: e2, y: t2, height: i2 } = this.#Co.getBoundingClientRect(), { x: n2, y: a2, width: s2, height: r2 } = this.#Eo.layer.getBoundingClientRect();
    return [(e2 - n2) / s2, (t2 + i2 - a2) / r2];
  }
  set commentPopupPosition(e2) {
    this.#xn = e2;
  }
  hasDefaultPopupPosition() {
    return null === this.#xn;
  }
  get commentButtonPosition() {
    return this.#ko;
  }
  get commentButtonWidth() {
    return this.#Co.getBoundingClientRect().width / this.parentBoundingClientRect.width;
  }
  editComment(e2) {
    const [t2, i2] = this.#xn || this.commentButtonPosition.map((e3) => e3 / 100), n2 = this.parentBoundingClientRect, { x: a2, y: s2, width: r2, height: o2 } = n2;
    this.#Vt.showDialog(null, this, a2 + t2 * r2, s2 + i2 * o2, { ...e2, parentDimensions: n2 });
  }
  render() {
    if (this.#So) return;
    const e2 = this.#So = document.createElement("div");
    if (e2.className = "popup", this.#po) {
      const t3 = e2.style.outlineColor = Util.makeHexColor(...this.#po);
      e2.style.backgroundColor = `color-mix(in srgb, ${t3} 30%, white)`;
    }
    const t2 = document.createElement("span");
    if (t2.className = "header", this.#Fo?.str) {
      const e3 = document.createElement("span");
      e3.className = "title", t2.append(e3), { dir: e3.dir, str: e3.textContent } = this.#Fo;
    }
    if (e2.append(t2), this.#bo) {
      const e3 = document.createElement("time");
      e3.className = "popupDate", e3.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string"), e3.setAttribute("data-l10n-args", JSON.stringify({ dateObj: this.#bo.valueOf() })), e3.dateTime = this.#bo.toISOString(), t2.append(e3);
    }
    renderRichText({ html: this.#Ro || this.#mo.str, dir: this.#mo?.dir, className: "popupContent" }, e2), this.#Mi.append(e2);
  }
  get #Ro() {
    const e2 = this.#yn, t2 = this.#mo;
    return !e2?.str || t2?.str && t2.str !== e2.str ? null : this.#yn.html || null;
  }
  get #Bo() {
    return this.#Ro?.attributes?.style?.fontSize || 0;
  }
  get #No() {
    return this.#Ro?.attributes?.style?.color || null;
  }
  #Lo(e2) {
    const t2 = [], i2 = { str: e2, html: { name: "div", attributes: { dir: "auto" }, children: [{ name: "p", children: t2 }] } }, n2 = { style: { color: this.#No, fontSize: this.#Bo ? `calc(${this.#Bo}px * var(--total-scale-factor))` : "" } };
    for (const i3 of e2.split("\n")) t2.push({ name: "span", value: i3, attributes: n2 });
    return i2;
  }
  #Kr(e2) {
    e2.altKey || e2.shiftKey || e2.ctrlKey || e2.metaKey || ("Enter" === e2.key || "Escape" === e2.key && this.#xo) && this.#fo();
  }
  updateEdited({ rect: e2, popup: t2, deleted: i2 }) {
    if (this.#Vt) return i2 ? (this.remove(), this.#Mo = null) : t2 && (t2.deleted ? this.remove() : (this.#_o(), this.#Mo = t2.text)), void (e2 && (this.#ko = null, this.#Oo(), this.#Po()));
    i2 || t2?.deleted ? this.remove() : (this.#Do(), this.#eo ||= { contentsObj: this.#mo, richText: this.#yn }, e2 && (this.#Nt = null), t2 && t2.text && (this.#yn = this.#Lo(t2.text), this.#bo = PDFDateString.toDateObject(t2.date), this.#mo = null), this.#So?.remove(), this.#So = null);
  }
  resetEdited() {
    this.#eo && ({ contentsObj: this.#mo, richText: this.#yn } = this.#eo, this.#eo = null, this.#So?.remove(), this.#So = null, this.#Nt = null);
  }
  remove() {
    if (this.#vo?.abort(), this.#vo = null, this.#So?.remove(), this.#So = null, this.#Io = false, this.#xo = false, this.#Co?.remove(), this.#Co = null, this.trigger) for (const e2 of this.trigger) e2.classList.remove("popupTriggerArea");
  }
  #Uo() {
    if (null !== this.#Nt) return;
    const { page: { view: e2 }, viewport: { rawDims: { pageWidth: t2, pageHeight: i2, pageX: n2, pageY: a2 } } } = this.#wo;
    let s2 = !!this.#Ao, r2 = s2 ? this.#Ao : this.#To;
    for (const e3 of this.#yo) if (!r2 || null !== Util.intersect(e3.data.rect, r2)) {
      r2 = e3.data.rect, s2 = true;
      break;
    }
    const o2 = Util.normalizeRect([r2[0], e2[3] - r2[1] + e2[1], r2[2], e2[3] - r2[3] + e2[1]]), l2 = s2 ? r2[2] - r2[0] + 5 : 0, c2 = o2[0] + l2, h2 = o2[1];
    this.#Nt = [100 * (c2 - n2) / t2, 100 * (h2 - a2) / i2];
    const { style: d2 } = this.#Mi;
    d2.left = `${this.#Nt[0]}%`, d2.top = `${this.#Nt[1]}%`;
  }
  #fo() {
    this.#Vt ? this.#Vt.toggleCommentPopup(this, false) : (this.#xo = !this.#xo, this.#xo ? (this.#uo(), this.#Mi.addEventListener("click", this.#go), this.#Mi.addEventListener("keydown", this.#lo)) : (this.#ho(), this.#Mi.removeEventListener("click", this.#go), this.#Mi.removeEventListener("keydown", this.#lo)));
  }
  #uo() {
    this.#So || this.render(), this.isVisible ? this.#xo && this.#Mi.classList.add("focused") : (this.#Uo(), this.#Mi.hidden = false, this.#Mi.style.zIndex = parseInt(this.#Mi.style.zIndex) + 1e3);
  }
  #ho() {
    this.#Mi.classList.remove("focused"), !this.#xo && this.isVisible && (this.#Mi.hidden = true, this.#Mi.style.zIndex = parseInt(this.#Mi.style.zIndex) - 1e3);
  }
  forceHide() {
    this.#Io = this.isVisible, this.#Io && (this.#Mi.hidden = true);
  }
  maybeShow() {
    this.#Vt || (this.#Do(), this.#Io && (this.#So || this.#uo(), this.#Io = false, this.#Mi.hidden = false));
  }
  get isVisible() {
    return !this.#Vt && false === this.#Mi.hidden;
  }
}
class FreeTextAnnotationElement extends AnnotationElement {
  constructor(e2) {
    super(e2, { isRenderable: true, ignoreBorder: true }), this.textContent = e2.data.textContent, this.textPosition = e2.data.textPosition, this.annotationEditorType = Hl.FREETEXT;
  }
  render() {
    if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
      const e2 = document.createElement("div");
      e2.classList.add("annotationTextContent"), e2.setAttribute("role", "comment");
      for (const t2 of this.textContent) {
        const i2 = document.createElement("span");
        i2.textContent = t2, e2.append(i2);
      }
      this.container.append(e2);
    }
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
  }
}
class LineAnnotationElement extends AnnotationElement {
  #jo = null;
  constructor(e2) {
    super(e2, { isRenderable: true, ignoreBorder: true });
  }
  render() {
    this.container.classList.add("lineAnnotation");
    const { data: e2, width: t2, height: i2 } = this, n2 = this.svgFactory.create(t2, i2, true), a2 = this.#jo = this.svgFactory.createElement("svg:line");
    return a2.setAttribute("x1", e2.rect[2] - e2.lineCoordinates[0]), a2.setAttribute("y1", e2.rect[3] - e2.lineCoordinates[1]), a2.setAttribute("x2", e2.rect[2] - e2.lineCoordinates[2]), a2.setAttribute("y2", e2.rect[3] - e2.lineCoordinates[3]), a2.setAttribute("stroke-width", e2.borderStyle.width || 1), a2.setAttribute("stroke", "transparent"), a2.setAttribute("fill", "transparent"), n2.append(a2), this.container.append(n2), !e2.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return this.#jo;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class SquareAnnotationElement extends AnnotationElement {
  #$o = null;
  constructor(e2) {
    super(e2, { isRenderable: true, ignoreBorder: true });
  }
  render() {
    this.container.classList.add("squareAnnotation");
    const { data: e2, width: t2, height: i2 } = this, n2 = this.svgFactory.create(t2, i2, true), a2 = e2.borderStyle.width, s2 = this.#$o = this.svgFactory.createElement("svg:rect");
    return s2.setAttribute("x", a2 / 2), s2.setAttribute("y", a2 / 2), s2.setAttribute("width", t2 - a2), s2.setAttribute("height", i2 - a2), s2.setAttribute("stroke-width", a2 || 1), s2.setAttribute("stroke", "transparent"), s2.setAttribute("fill", "transparent"), n2.append(s2), this.container.append(n2), !e2.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return this.#$o;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class CircleAnnotationElement extends AnnotationElement {
  #Ho = null;
  constructor(e2) {
    super(e2, { isRenderable: true, ignoreBorder: true });
  }
  render() {
    this.container.classList.add("circleAnnotation");
    const { data: e2, width: t2, height: i2 } = this, n2 = this.svgFactory.create(t2, i2, true), a2 = e2.borderStyle.width, s2 = this.#Ho = this.svgFactory.createElement("svg:ellipse");
    return s2.setAttribute("cx", t2 / 2), s2.setAttribute("cy", i2 / 2), s2.setAttribute("rx", t2 / 2 - a2 / 2), s2.setAttribute("ry", i2 / 2 - a2 / 2), s2.setAttribute("stroke-width", a2 || 1), s2.setAttribute("stroke", "transparent"), s2.setAttribute("fill", "transparent"), n2.append(s2), this.container.append(n2), !e2.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return this.#Ho;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class PolylineAnnotationElement extends AnnotationElement {
  #Xo = null;
  constructor(e2) {
    super(e2, { isRenderable: true, ignoreBorder: true }), this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const { data: { rect: e2, vertices: t2, borderStyle: i2, popupRef: n2 }, width: a2, height: s2 } = this;
    if (!t2) return this.container;
    const r2 = this.svgFactory.create(a2, s2, true);
    let o2 = [];
    for (let i3 = 0, n3 = t2.length; i3 < n3; i3 += 2) {
      const n4 = t2[i3] - e2[0], a3 = e2[3] - t2[i3 + 1];
      o2.push(`${n4},${a3}`);
    }
    o2 = o2.join(" ");
    const l2 = this.#Xo = this.svgFactory.createElement(this.svgElementName);
    return l2.setAttribute("points", o2), l2.setAttribute("stroke-width", i2.width || 1), l2.setAttribute("stroke", "transparent"), l2.setAttribute("fill", "transparent"), r2.append(l2), this.container.append(r2), !n2 && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return this.#Xo;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class PolygonAnnotationElement extends PolylineAnnotationElement {
  constructor(e2) {
    super(e2), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
  }
}
class CaretAnnotationElement extends AnnotationElement {
  constructor(e2) {
    super(e2, { isRenderable: true, ignoreBorder: true });
  }
  render() {
    return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
}
class InkAnnotationElement extends AnnotationElement {
  #qo = null;
  #zo = [];
  constructor(e2) {
    super(e2, { isRenderable: true, ignoreBorder: true }), this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = "InkHighlight" === this.data.it ? Hl.HIGHLIGHT : Hl.INK;
  }
  #Wo(e2, t2) {
    switch (e2) {
      case 90:
        return { transform: `rotate(90) translate(${-t2[0]},${t2[1]}) scale(1,-1)`, width: t2[3] - t2[1], height: t2[2] - t2[0] };
      case 180:
        return { transform: `rotate(180) translate(${-t2[2]},${t2[1]}) scale(1,-1)`, width: t2[2] - t2[0], height: t2[3] - t2[1] };
      case 270:
        return { transform: `rotate(270) translate(${-t2[2]},${t2[3]}) scale(1,-1)`, width: t2[3] - t2[1], height: t2[2] - t2[0] };
      default:
        return { transform: `translate(${-t2[0]},${t2[3]}) scale(1,-1)`, width: t2[2] - t2[0], height: t2[3] - t2[1] };
    }
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const { data: { rect: e2, rotation: t2, inkLists: i2, borderStyle: n2, popupRef: a2 } } = this, { transform: s2, width: r2, height: o2 } = this.#Wo(t2, e2), l2 = this.svgFactory.create(r2, o2, true), c2 = this.#qo = this.svgFactory.createElement("svg:g");
    l2.append(c2), c2.setAttribute("stroke-width", n2.width || 1), c2.setAttribute("stroke-linecap", "round"), c2.setAttribute("stroke-linejoin", "round"), c2.setAttribute("stroke-miterlimit", 10), c2.setAttribute("stroke", "transparent"), c2.setAttribute("fill", "transparent"), c2.setAttribute("transform", s2);
    for (let e3 = 0, t3 = i2.length; e3 < t3; e3++) {
      const t4 = this.svgFactory.createElement(this.svgElementName);
      this.#zo.push(t4), t4.setAttribute("points", i2[e3].join(",")), c2.append(t4);
    }
    return !a2 && this.hasPopupData && this._createPopup(), this.container.append(l2), this._editOnDoubleClick(), this.container;
  }
  updateEdited(e2) {
    super.updateEdited(e2);
    const { thickness: t2, points: i2, rect: n2 } = e2, a2 = this.#qo;
    if (t2 >= 0 && a2.setAttribute("stroke-width", t2 || 1), i2) for (let e3 = 0, t3 = this.#zo.length; e3 < t3; e3++) this.#zo[e3].setAttribute("points", i2[e3].join(","));
    if (n2) {
      const { transform: e3, width: t3, height: i3 } = this.#Wo(this.data.rotation, n2);
      a2.parentElement.setAttribute("viewBox", `0 0 ${t3} ${i3}`), a2.setAttribute("transform", e3);
    }
  }
  getElementsToTriggerPopup() {
    return this.#zo;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class HighlightAnnotationElement extends AnnotationElement {
  constructor(e2) {
    super(e2, { isRenderable: true, ignoreBorder: true, createQuadrilaterals: true }), this.annotationEditorType = Hl.HIGHLIGHT;
  }
  render() {
    const { data: { overlaidText: e2, popupRef: t2 } } = this;
    if (!t2 && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this._editOnDoubleClick(), e2) {
      const t3 = document.createElement("mark");
      t3.classList.add("overlaidText"), t3.textContent = e2, this.container.append(t3);
    }
    return this.container;
  }
}
class UnderlineAnnotationElement extends AnnotationElement {
  constructor(e2) {
    super(e2, { isRenderable: true, ignoreBorder: true, createQuadrilaterals: true });
  }
  render() {
    const { data: { overlaidText: e2, popupRef: t2 } } = this;
    if (!t2 && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), e2) {
      const t3 = document.createElement("u");
      t3.classList.add("overlaidText"), t3.textContent = e2, this.container.append(t3);
    }
    return this.container;
  }
}
class SquigglyAnnotationElement extends AnnotationElement {
  constructor(e2) {
    super(e2, { isRenderable: true, ignoreBorder: true, createQuadrilaterals: true });
  }
  render() {
    const { data: { overlaidText: e2, popupRef: t2 } } = this;
    if (!t2 && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), e2) {
      const t3 = document.createElement("u");
      t3.classList.add("overlaidText"), t3.textContent = e2, this.container.append(t3);
    }
    return this.container;
  }
}
class StrikeOutAnnotationElement extends AnnotationElement {
  constructor(e2) {
    super(e2, { isRenderable: true, ignoreBorder: true, createQuadrilaterals: true });
  }
  render() {
    const { data: { overlaidText: e2, popupRef: t2 } } = this;
    if (!t2 && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), e2) {
      const t3 = document.createElement("s");
      t3.classList.add("overlaidText"), t3.textContent = e2, this.container.append(t3);
    }
    return this.container;
  }
}
class StampAnnotationElement extends AnnotationElement {
  constructor(e2) {
    super(e2, { isRenderable: true, ignoreBorder: true }), this.annotationEditorType = Hl.STAMP;
  }
  render() {
    return this.container.classList.add("stampAnnotation"), this.container.setAttribute("role", "img"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
  }
}
class FileAttachmentAnnotationElement extends AnnotationElement {
  #Go = null;
  constructor(e2) {
    super(e2, { isRenderable: true });
    const { file: t2 } = this.data;
    this.filename = t2.filename, this.content = t2.content, this.linkService.eventBus?.dispatch("fileattachmentannotation", { source: this, ...t2 });
  }
  render() {
    this.container.classList.add("fileAttachmentAnnotation");
    const { container: e2, data: t2 } = this;
    let i2;
    t2.hasAppearance || 0 === t2.fillAlpha ? i2 = document.createElement("div") : (i2 = document.createElement("img"), i2.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(t2.name) ? "paperclip" : "pushpin"}.svg`, t2.fillAlpha && t2.fillAlpha < 1 && (i2.style = `filter: opacity(${Math.round(100 * t2.fillAlpha)}%);`)), i2.addEventListener("dblclick", this.#Vo.bind(this)), this.#Go = i2;
    const { isMac: n2 } = util_FeatureTest.platform;
    return e2.addEventListener("keydown", (e3) => {
      "Enter" === e3.key && (n2 ? e3.metaKey : e3.ctrlKey) && this.#Vo();
    }), !t2.popupRef && this.hasPopupData ? this._createPopup() : i2.classList.add("popupTriggerArea"), e2.append(i2), e2;
  }
  getElementsToTriggerPopup() {
    return this.#Go;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
  #Vo() {
    this.downloadManager?.openOrDownloadData(this.content, this.filename);
  }
}
class AnnotationLayer {
  #Ko = null;
  #Yo = null;
  #zt = null;
  #Jo = /* @__PURE__ */ new Map();
  #Zo = null;
  #Qo = null;
  constructor({ div: e2, accessibilityManager: t2, annotationCanvasMap: i2, annotationEditorUIManager: n2, page: a2, viewport: s2, structTreeLayer: r2, commentManager: o2, linkService: l2, annotationStorage: c2 }) {
    this.div = e2, this.#Ko = t2, this.#Yo = i2, this.#Zo = r2 || null, this.#Qo = l2 || null, this.#zt = c2 || new AnnotationStorage(), this.page = a2, this.viewport = s2, this.zIndex = 0, this._annotationEditorUIManager = n2, this._commentManager = o2 || null;
  }
  hasEditableAnnotations() {
    return this.#Jo.size > 0;
  }
  async #el(e2, t2, i2) {
    const n2 = e2.firstChild || e2, a2 = n2.id = `${mc}${t2}`, s2 = await this.#Zo?.getAriaAttributes(a2);
    if (s2) for (const [e3, t3] of s2) n2.setAttribute(e3, t3);
    i2 ? i2.at(-1).container.after(e2) : (this.div.append(e2), this.#Ko?.moveElementInDOM(this.div, e2, n2, false));
  }
  async render(e2) {
    const { annotations: t2 } = e2, i2 = this.div;
    setLayerDimensions(i2, this.viewport);
    const n2 = /* @__PURE__ */ new Map(), a2 = { data: null, layer: i2, linkService: this.#Qo, downloadManager: e2.downloadManager, imageResourcesPath: e2.imageResourcesPath || "", renderForms: false !== e2.renderForms, svgFactory: new DOMSVGFactory(), annotationStorage: this.#zt, enableComment: true === e2.enableComment, enableScripting: true === e2.enableScripting, hasJSActions: e2.hasJSActions, fieldObjects: e2.fieldObjects, parent: this, elements: null };
    for (const e3 of t2) {
      if (e3.noHTML) continue;
      const t3 = e3.annotationType === Zl.POPUP;
      if (t3) {
        const t4 = n2.get(e3.id);
        if (!t4) continue;
        a2.elements = t4;
      } else if (e3.rect[2] === e3.rect[0] || e3.rect[3] === e3.rect[1]) continue;
      a2.data = e3;
      const i3 = AnnotationElementFactory.create(a2);
      if (!i3.isRenderable) continue;
      if (!t3 && e3.popupRef) {
        const t4 = n2.get(e3.popupRef);
        t4 ? t4.push(i3) : n2.set(e3.popupRef, [i3]);
      }
      const s2 = i3.render();
      e3.hidden && (s2.style.visibility = "hidden"), await this.#el(s2, e3.id, a2.elements), i3.extraPopupElement?.popup?.renderCommentButton(), i3._isEditable && (this.#Jo.set(i3.data.id, i3), this._annotationEditorUIManager?.renderAnnotationElement(i3));
    }
    this.#tl();
  }
  async addLinkAnnotations(e2) {
    const t2 = { data: null, layer: this.div, linkService: this.#Qo, svgFactory: new DOMSVGFactory(), parent: this };
    for (const i2 of e2) {
      i2.borderStyle ||= AnnotationLayer._defaultBorderStyle, t2.data = i2;
      const e3 = AnnotationElementFactory.create(t2);
      if (!e3.isRenderable) continue;
      const n2 = e3.render();
      await this.#el(n2, i2.id, null);
    }
  }
  update({ viewport: e2 }) {
    const t2 = this.div;
    this.viewport = e2, setLayerDimensions(t2, { rotation: e2.rotation }), this.#tl(), t2.hidden = false;
  }
  #tl() {
    if (!this.#Yo) return;
    const e2 = this.div;
    for (const [t2, i2] of this.#Yo) {
      const n2 = e2.querySelector(`[data-annotation-id="${t2}"]`);
      if (!n2) continue;
      i2.className = "annotationContent";
      const { firstChild: a2 } = n2;
      a2 ? "CANVAS" === a2.nodeName ? a2.replaceWith(i2) : a2.classList.contains("annotationContent") ? a2.after(i2) : a2.before(i2) : n2.append(i2);
      const s2 = this.#Jo.get(t2);
      s2 && (s2._hasNoCanvas ? (this._annotationEditorUIManager?.setMissingCanvas(t2, n2.id, i2), s2._hasNoCanvas = false) : s2.canvas = i2);
    }
    this.#Yo.clear();
  }
  getEditableAnnotations() {
    return Array.from(this.#Jo.values());
  }
  getEditableAnnotation(e2) {
    return this.#Jo.get(e2);
  }
  addFakeAnnotation(e2) {
    const { div: t2 } = this, { id: i2, rotation: n2 } = e2, a2 = new EditorAnnotationElement({ data: { id: i2, rect: e2.getPDFRect(), rotation: n2 }, editor: e2, layer: t2, parent: this, enableComment: !!this._commentManager, linkService: this.#Qo, annotationStorage: this.#zt }), s2 = a2.render();
    return t2.append(s2), this.#Ko?.moveElementInDOM(t2, s2, s2, false), a2.createOrUpdatePopup(), a2;
  }
  static get _defaultBorderStyle() {
    return shadow(this, "_defaultBorderStyle", Object.freeze({ width: 1, rawWidth: 1, style: Ql, dashArray: [3], horizontalCornerRadius: 0, verticalCornerRadius: 0 }));
  }
}
const gh = /\r\n?|\n/g;
class FreeTextEditor extends AnnotationEditor {
  #il = "";
  #nl = `${this.id}-editor`;
  #al = null;
  #Bo;
  _colorPicker = null;
  static _freeTextDefaultContent = "";
  static _internalPadding = 0;
  static _defaultColor = null;
  static _defaultFontSize = 10;
  static get _keyboardManager() {
    const e2 = FreeTextEditor.prototype, arrowChecker = (e3) => e3.isEmpty(), t2 = AnnotationEditorUIManager.TRANSLATE_SMALL, i2 = AnnotationEditorUIManager.TRANSLATE_BIG;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], e2.commitOrRemove, { bubbles: true }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], e2.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], e2._translateEmpty, { args: [-t2, 0], checker: arrowChecker }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e2._translateEmpty, { args: [-i2, 0], checker: arrowChecker }], [["ArrowRight", "mac+ArrowRight"], e2._translateEmpty, { args: [t2, 0], checker: arrowChecker }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e2._translateEmpty, { args: [i2, 0], checker: arrowChecker }], [["ArrowUp", "mac+ArrowUp"], e2._translateEmpty, { args: [0, -t2], checker: arrowChecker }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e2._translateEmpty, { args: [0, -i2], checker: arrowChecker }], [["ArrowDown", "mac+ArrowDown"], e2._translateEmpty, { args: [0, t2], checker: arrowChecker }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e2._translateEmpty, { args: [0, i2], checker: arrowChecker }]]));
  }
  static _type = "freetext";
  static _editorType = Hl.FREETEXT;
  constructor(e2) {
    super({ ...e2, name: "freeTextEditor" }), this.color = e2.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor, this.#Bo = e2.fontSize || FreeTextEditor._defaultFontSize, this.annotationElementId || this._uiManager.a11yAlert("pdfjs-editor-freetext-added-alert");
  }
  static initialize(e2, t2) {
    AnnotationEditor.initialize(e2, t2);
    const i2 = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(i2.getPropertyValue("--freetext-padding"));
  }
  static updateDefaultParams(e2, t2) {
    switch (e2) {
      case Xl.FREETEXT_SIZE:
        FreeTextEditor._defaultFontSize = t2;
        break;
      case Xl.FREETEXT_COLOR:
        FreeTextEditor._defaultColor = t2;
    }
  }
  updateParams(e2, t2) {
    switch (e2) {
      case Xl.FREETEXT_SIZE:
        this.#sl(t2);
        break;
      case Xl.FREETEXT_COLOR:
        this.#_o(t2);
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[Xl.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [Xl.FREETEXT_COLOR, FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor]];
  }
  get propertiesToUpdate() {
    return [[Xl.FREETEXT_SIZE, this.#Bo], [Xl.FREETEXT_COLOR, this.color]];
  }
  get toolbarButtons() {
    return this._colorPicker ||= new BasicColorPicker(this), [["colorPicker", this._colorPicker]];
  }
  get colorType() {
    return Xl.FREETEXT_COLOR;
  }
  #sl(e2) {
    const setFontsize = (e3) => {
      this.editorDiv.style.fontSize = `calc(${e3}px * var(--total-scale-factor))`, this.translate(0, -(e3 - this.#Bo) * this.parentScale), this.#Bo = e3, this.#rl();
    }, t2 = this.#Bo;
    this.addCommands({ cmd: setFontsize.bind(this, e2), undo: setFontsize.bind(this, t2), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: Xl.FREETEXT_SIZE, overwriteIfSameType: true, keepUndo: true });
  }
  onUpdatedColor() {
    this.editorDiv.style.color = this.color, this._colorPicker?.update(this.color), super.onUpdatedColor();
  }
  #_o(e2) {
    const setColor = (e3) => {
      this.color = e3, this.onUpdatedColor();
    }, t2 = this.color;
    this.addCommands({ cmd: setColor.bind(this, e2), undo: setColor.bind(this, t2), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: Xl.FREETEXT_COLOR, overwriteIfSameType: true, keepUndo: true });
  }
  _translateEmpty(e2, t2) {
    this._uiManager.translateSelectedEditors(e2, t2, true);
  }
  getInitialTranslation() {
    const e2 = this.parentScale;
    return [-FreeTextEditor._internalPadding * e2, -(FreeTextEditor._internalPadding + this.#Bo) * e2];
  }
  rebuild() {
    this.parent && (super.rebuild(), null !== this.div && (this.isAttachedToDOM || this.parent.add(this)));
  }
  enableEditMode() {
    if (!super.enableEditMode()) return false;
    this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = true, this._isDraggable = false, this.div.removeAttribute("aria-activedescendant"), this.#al = new AbortController();
    const e2 = this._uiManager.combinedSignal(this.#al);
    return this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), { signal: e2 }), this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), { signal: e2 }), this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), { signal: e2 }), this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), { signal: e2 }), this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), { signal: e2 }), true;
  }
  disableEditMode() {
    return !!super.disableEditMode() && (this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = false, this.div.setAttribute("aria-activedescendant", this.#nl), this._isDraggable = true, this.#al?.abort(), this.#al = null, this.div.focus({ preventScroll: true }), this.isEditing = false, this.parent.div.classList.add("freetextEditing"), true);
  }
  focusin(e2) {
    this._focusEventsAllowed && (super.focusin(e2), e2.target !== this.editorDiv && this.editorDiv.focus());
  }
  onceAdded(e2) {
    this.width || (this.enableEditMode(), e2 && this.editorDiv.focus(), this._initialOptions?.isCentered && this.center(), this._initialOptions = null);
  }
  isEmpty() {
    return !this.editorDiv || "" === this.editorDiv.innerText.trim();
  }
  remove() {
    this.isEditing = false, this.parent && (this.parent.setEditingState(true), this.parent.div.classList.add("freetextEditing")), super.remove();
  }
  #ol() {
    const e2 = [];
    this.editorDiv.normalize();
    let t2 = null;
    for (const i2 of this.editorDiv.childNodes) t2?.nodeType === Node.TEXT_NODE && "BR" === i2.nodeName || (e2.push(FreeTextEditor.#ll(i2)), t2 = i2);
    return e2.join("\n");
  }
  #rl() {
    const [e2, t2] = this.parentDimensions;
    let i2;
    if (this.isAttachedToDOM) i2 = this.div.getBoundingClientRect();
    else {
      const { currentLayer: e3, div: t3 } = this, n2 = t3.style.display, a2 = t3.classList.contains("hidden");
      t3.classList.remove("hidden"), t3.style.display = "hidden", e3.div.append(this.div), i2 = t3.getBoundingClientRect(), t3.remove(), t3.style.display = n2, t3.classList.toggle("hidden", a2);
    }
    this.rotation % 180 == this.parentRotation % 180 ? (this.width = i2.width / e2, this.height = i2.height / t2) : (this.width = i2.height / e2, this.height = i2.width / t2), this.fixAndSetPosition();
  }
  commit() {
    if (!this.isInEditMode()) return;
    super.commit(), this.disableEditMode();
    const e2 = this.#il, t2 = this.#il = this.#ol().trimEnd();
    if (e2 === t2) return;
    const setText = (e3) => {
      this.#il = e3, e3 ? (this.#cl(), this._uiManager.rebuild(this), this.#rl()) : this.remove();
    };
    this.addCommands({ cmd: () => {
      setText(t2);
    }, undo: () => {
      setText(e2);
    }, mustExec: false }), this.#rl();
  }
  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }
  enterInEditMode() {
    this.enableEditMode(), this.editorDiv.focus();
  }
  keydown(e2) {
    e2.target === this.div && "Enter" === e2.key && (this.enterInEditMode(), e2.preventDefault());
  }
  editorDivKeydown(e2) {
    FreeTextEditor._keyboardManager.exec(this, e2);
  }
  editorDivFocus(e2) {
    this.isEditing = true;
  }
  editorDivBlur(e2) {
    this.isEditing = false;
  }
  editorDivInput(e2) {
    this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
  }
  disableEditing() {
    this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
  }
  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", true);
  }
  get canChangeContent() {
    return true;
  }
  render() {
    if (this.div) return this.div;
    let e2, t2;
    (this._isCopy || this.annotationElementId) && (e2 = this.x, t2 = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", this.#nl), this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text2"), this.editorDiv.setAttribute("data-l10n-attrs", "default-content"), this.enableEditing(), this.editorDiv.contentEditable = true;
    const { style: i2 } = this.editorDiv;
    if (i2.fontSize = `calc(${this.#Bo}px * var(--total-scale-factor))`, i2.color = this.color, this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), this._isCopy || this.annotationElementId) {
      const [i3, n2] = this.parentDimensions;
      if (this.annotationElementId) {
        const { position: a2 } = this._initialData;
        let [s2, r2] = this.getInitialTranslation();
        [s2, r2] = this.pageTranslationToScreen(s2, r2);
        const [o2, l2] = this.pageDimensions, [c2, h2] = this.pageTranslation;
        let d2, u2;
        switch (this.rotation) {
          case 0:
            d2 = e2 + (a2[0] - c2) / o2, u2 = t2 + this.height - (a2[1] - h2) / l2;
            break;
          case 90:
            d2 = e2 + (a2[0] - c2) / o2, u2 = t2 - (a2[1] - h2) / l2, [s2, r2] = [r2, -s2];
            break;
          case 180:
            d2 = e2 - this.width + (a2[0] - c2) / o2, u2 = t2 - (a2[1] - h2) / l2, [s2, r2] = [-s2, -r2];
            break;
          case 270:
            d2 = e2 + (a2[0] - c2 - this.height * l2) / o2, u2 = t2 + (a2[1] - h2 - this.width * o2) / l2, [s2, r2] = [-r2, s2];
        }
        this.setAt(d2 * i3, u2 * n2, s2, r2);
      } else this._moveAfterPaste(e2, t2);
      this.#cl(), this._isDraggable = true, this.editorDiv.contentEditable = false;
    } else this._isDraggable = false, this.editorDiv.contentEditable = true;
    return this.div;
  }
  static #ll(e2) {
    return (e2.nodeType === Node.TEXT_NODE ? e2.nodeValue : e2.innerText).replaceAll(gh, "");
  }
  editorDivPaste(e2) {
    const t2 = e2.clipboardData || window.clipboardData, { types: i2 } = t2;
    if (1 === i2.length && "text/plain" === i2[0]) return;
    e2.preventDefault();
    const n2 = FreeTextEditor.#hl(t2.getData("text") || "").replaceAll(gh, "\n");
    if (!n2) return;
    const a2 = window.getSelection();
    if (!a2.rangeCount) return;
    this.editorDiv.normalize(), a2.deleteFromDocument();
    const s2 = a2.getRangeAt(0);
    if (!n2.includes("\n")) return s2.insertNode(document.createTextNode(n2)), this.editorDiv.normalize(), void a2.collapseToStart();
    const { startContainer: r2, startOffset: o2 } = s2, l2 = [], c2 = [];
    if (r2.nodeType === Node.TEXT_NODE) {
      const e3 = r2.parentElement;
      if (c2.push(r2.nodeValue.slice(o2).replaceAll(gh, "")), e3 !== this.editorDiv) {
        let t3 = l2;
        for (const i3 of this.editorDiv.childNodes) i3 !== e3 ? t3.push(FreeTextEditor.#ll(i3)) : t3 = c2;
      }
      l2.push(r2.nodeValue.slice(0, o2).replaceAll(gh, ""));
    } else if (r2 === this.editorDiv) {
      let e3 = l2, t3 = 0;
      for (const i3 of this.editorDiv.childNodes) t3++ === o2 && (e3 = c2), e3.push(FreeTextEditor.#ll(i3));
    }
    this.#il = `${l2.join("\n")}${n2}${c2.join("\n")}`, this.#cl();
    const h2 = new Range();
    let d2 = Math.sumPrecise(l2.map((e3) => e3.length));
    for (const { firstChild: e3 } of this.editorDiv.childNodes) if (e3.nodeType === Node.TEXT_NODE) {
      const t3 = e3.nodeValue.length;
      if (d2 <= t3) {
        h2.setStart(e3, d2), h2.setEnd(e3, d2);
        break;
      }
      d2 -= t3;
    }
    a2.removeAllRanges(), a2.addRange(h2);
  }
  #cl() {
    if (this.editorDiv.replaceChildren(), this.#il) for (const e2 of this.#il.split("\n")) {
      const t2 = document.createElement("div");
      t2.append(e2 ? document.createTextNode(e2) : document.createElement("br")), this.editorDiv.append(t2);
    }
  }
  #dl() {
    return this.#il.replaceAll(" ", " ");
  }
  static #hl(e2) {
    return e2.replaceAll(" ", " ");
  }
  get contentDiv() {
    return this.editorDiv;
  }
  getPDFRect() {
    const e2 = FreeTextEditor._internalPadding * this.parentScale;
    return this.getRect(e2, e2);
  }
  static async deserialize(e2, t2, i2) {
    let n2 = null;
    if (e2 instanceof FreeTextAnnotationElement) {
      const { data: { defaultAppearanceData: { fontSize: t3, fontColor: i3 }, rect: a3, rotation: s2, id: r2, popupRef: o2, richText: l2, contentsObj: c2, creationDate: h2, modificationDate: d2 }, textContent: u2, textPosition: g2, parent: { page: { pageNumber: f2 } } } = e2;
      if (!u2 || 0 === u2.length) return null;
      n2 = e2 = { annotationType: Hl.FREETEXT, color: Array.from(i3), fontSize: t3, value: u2.join("\n"), position: g2, pageIndex: f2 - 1, rect: a3.slice(0), rotation: s2, annotationElementId: r2, id: r2, deleted: false, popupRef: o2, comment: c2?.str || null, richText: l2, creationDate: h2, modificationDate: d2 };
    }
    const a2 = await super.deserialize(e2, t2, i2);
    return a2.#Bo = e2.fontSize, a2.color = Util.makeHexColor(...e2.color), a2.#il = FreeTextEditor.#hl(e2.value), a2._initialData = n2, e2.comment && a2.setCommentData(e2), a2;
  }
  serialize(e2 = false) {
    if (this.isEmpty()) return null;
    if (this.deleted) return this.serializeDeleted();
    const t2 = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.color), i2 = Object.assign(super.serialize(e2), { color: t2, fontSize: this.#Bo, value: this.#dl() });
    return this.addComment(i2), e2 ? (i2.isCopy = true, i2) : this.annotationElementId && !this.#ul(i2) ? null : (i2.id = this.annotationElementId, i2);
  }
  #ul(e2) {
    const { value: t2, fontSize: i2, color: n2, pageIndex: a2 } = this._initialData;
    return this.hasEditedComment || this._hasBeenMoved || e2.value !== t2 || e2.fontSize !== i2 || e2.color.some((e3, t3) => e3 !== n2[t3]) || e2.pageIndex !== a2;
  }
  renderAnnotationElement(e2) {
    const t2 = super.renderAnnotationElement(e2);
    if (!t2) return null;
    const { style: i2 } = t2;
    i2.fontSize = `calc(${this.#Bo}px * var(--total-scale-factor))`, i2.color = this.color, t2.replaceChildren();
    for (const e3 of this.#il.split("\n")) {
      const i3 = document.createElement("div");
      i3.append(e3 ? document.createTextNode(e3) : document.createElement("br")), t2.append(i3);
    }
    return e2.updateEdited({ rect: this.getPDFRect(), popup: this._uiManager.hasCommentManager() || this.hasEditedComment ? this.comment : { text: this.#il } }), t2;
  }
  resetAnnotationElement(e2) {
    super.resetAnnotationElement(e2), e2.resetEdited();
  }
}
class Outline {
  static PRECISION = 1e-4;
  toSVGPath() {
    unreachable("Abstract method `toSVGPath` must be implemented.");
  }
  get box() {
    unreachable("Abstract getter `box` must be implemented.");
  }
  serialize(e2, t2) {
    unreachable("Abstract method `serialize` must be implemented.");
  }
  static _rescale(e2, t2, i2, n2, a2, s2) {
    s2 ||= new Float32Array(e2.length);
    for (let r2 = 0, o2 = e2.length; r2 < o2; r2 += 2) s2[r2] = t2 + e2[r2] * n2, s2[r2 + 1] = i2 + e2[r2 + 1] * a2;
    return s2;
  }
  static _rescaleAndSwap(e2, t2, i2, n2, a2, s2) {
    s2 ||= new Float32Array(e2.length);
    for (let r2 = 0, o2 = e2.length; r2 < o2; r2 += 2) s2[r2] = t2 + e2[r2 + 1] * n2, s2[r2 + 1] = i2 + e2[r2] * a2;
    return s2;
  }
  static _translate(e2, t2, i2, n2) {
    n2 ||= new Float32Array(e2.length);
    for (let a2 = 0, s2 = e2.length; a2 < s2; a2 += 2) n2[a2] = t2 + e2[a2], n2[a2 + 1] = i2 + e2[a2 + 1];
    return n2;
  }
  static svgRound(e2) {
    return Math.round(1e4 * e2);
  }
  static _normalizePoint(e2, t2, i2, n2, a2) {
    switch (a2) {
      case 90:
        return [1 - t2 / i2, e2 / n2];
      case 180:
        return [1 - e2 / i2, 1 - t2 / n2];
      case 270:
        return [t2 / i2, 1 - e2 / n2];
      default:
        return [e2 / i2, t2 / n2];
    }
  }
  static _normalizePagePoint(e2, t2, i2) {
    switch (i2) {
      case 90:
        return [1 - t2, e2];
      case 180:
        return [1 - e2, 1 - t2];
      case 270:
        return [t2, 1 - e2];
      default:
        return [e2, t2];
    }
  }
  static createBezierPoints(e2, t2, i2, n2, a2, s2) {
    return [(e2 + 5 * i2) / 6, (t2 + 5 * n2) / 6, (5 * i2 + a2) / 6, (5 * n2 + s2) / 6, (i2 + a2) / 2, (n2 + s2) / 2];
  }
}
class FreeDrawOutliner {
  #gl;
  #fl = [];
  #pl;
  #ml;
  #bl = [];
  #yl = new Float32Array(18);
  #wl;
  #Al;
  #xl;
  #Sl;
  #vl;
  #Cl;
  #kl = [];
  static #Tl = 8;
  static #Fl = 2;
  static #Il = FreeDrawOutliner.#Tl + FreeDrawOutliner.#Fl;
  constructor({ x: e2, y: t2 }, i2, n2, a2, s2, r2 = 0) {
    this.#gl = i2, this.#Cl = a2 * n2, this.#ml = s2, this.#yl.set([NaN, NaN, NaN, NaN, e2, t2], 6), this.#pl = r2, this.#Sl = FreeDrawOutliner.#Tl * n2, this.#xl = FreeDrawOutliner.#Il * n2, this.#vl = n2, this.#kl.push(e2, t2);
  }
  isEmpty() {
    return isNaN(this.#yl[8]);
  }
  #El() {
    const e2 = this.#yl.subarray(4, 6), t2 = this.#yl.subarray(16, 18), [i2, n2, a2, s2] = this.#gl;
    return [(this.#wl + (e2[0] - t2[0]) / 2 - i2) / a2, (this.#Al + (e2[1] - t2[1]) / 2 - n2) / s2, (this.#wl + (t2[0] - e2[0]) / 2 - i2) / a2, (this.#Al + (t2[1] - e2[1]) / 2 - n2) / s2];
  }
  add({ x: e2, y: t2 }) {
    this.#wl = e2, this.#Al = t2;
    const [i2, n2, a2, s2] = this.#gl;
    let [r2, o2, l2, c2] = this.#yl.subarray(8, 12);
    const h2 = e2 - l2, d2 = t2 - c2, u2 = Math.hypot(h2, d2);
    if (u2 < this.#xl) return false;
    const g2 = u2 - this.#Sl, f2 = g2 / u2, p2 = f2 * h2, m2 = f2 * d2;
    let b2 = r2, y2 = o2;
    r2 = l2, o2 = c2, l2 += p2, c2 += m2, this.#kl?.push(e2, t2);
    const w2 = p2 / g2, x2 = -m2 / g2 * this.#Cl, S2 = w2 * this.#Cl;
    if (this.#yl.set(this.#yl.subarray(2, 8), 0), this.#yl.set([l2 + x2, c2 + S2], 4), this.#yl.set(this.#yl.subarray(14, 18), 12), this.#yl.set([l2 - x2, c2 - S2], 16), isNaN(this.#yl[6])) return 0 === this.#bl.length && (this.#yl.set([r2 + x2, o2 + S2], 2), this.#bl.push(NaN, NaN, NaN, NaN, (r2 + x2 - i2) / a2, (o2 + S2 - n2) / s2), this.#yl.set([r2 - x2, o2 - S2], 14), this.#fl.push(NaN, NaN, NaN, NaN, (r2 - x2 - i2) / a2, (o2 - S2 - n2) / s2)), this.#yl.set([b2, y2, r2, o2, l2, c2], 6), !this.isEmpty();
    this.#yl.set([b2, y2, r2, o2, l2, c2], 6);
    return Math.abs(Math.atan2(y2 - o2, b2 - r2) - Math.atan2(m2, p2)) < Math.PI / 2 ? ([r2, o2, l2, c2] = this.#yl.subarray(2, 6), this.#bl.push(NaN, NaN, NaN, NaN, ((r2 + l2) / 2 - i2) / a2, ((o2 + c2) / 2 - n2) / s2), [r2, o2, b2, y2] = this.#yl.subarray(14, 18), this.#fl.push(NaN, NaN, NaN, NaN, ((b2 + r2) / 2 - i2) / a2, ((y2 + o2) / 2 - n2) / s2), true) : ([b2, y2, r2, o2, l2, c2] = this.#yl.subarray(0, 6), this.#bl.push(((b2 + 5 * r2) / 6 - i2) / a2, ((y2 + 5 * o2) / 6 - n2) / s2, ((5 * r2 + l2) / 6 - i2) / a2, ((5 * o2 + c2) / 6 - n2) / s2, ((r2 + l2) / 2 - i2) / a2, ((o2 + c2) / 2 - n2) / s2), [l2, c2, r2, o2, b2, y2] = this.#yl.subarray(12, 18), this.#fl.push(((b2 + 5 * r2) / 6 - i2) / a2, ((y2 + 5 * o2) / 6 - n2) / s2, ((5 * r2 + l2) / 6 - i2) / a2, ((5 * o2 + c2) / 6 - n2) / s2, ((r2 + l2) / 2 - i2) / a2, ((o2 + c2) / 2 - n2) / s2), true);
  }
  toSVGPath() {
    if (this.isEmpty()) return "";
    const e2 = this.#bl, t2 = this.#fl;
    if (isNaN(this.#yl[6]) && !this.isEmpty()) return this.#Ml();
    const i2 = [];
    i2.push(`M${e2[4]} ${e2[5]}`);
    for (let t3 = 6; t3 < e2.length; t3 += 6) isNaN(e2[t3]) ? i2.push(`L${e2[t3 + 4]} ${e2[t3 + 5]}`) : i2.push(`C${e2[t3]} ${e2[t3 + 1]} ${e2[t3 + 2]} ${e2[t3 + 3]} ${e2[t3 + 4]} ${e2[t3 + 5]}`);
    this.#Dl(i2);
    for (let e3 = t2.length - 6; e3 >= 6; e3 -= 6) isNaN(t2[e3]) ? i2.push(`L${t2[e3 + 4]} ${t2[e3 + 5]}`) : i2.push(`C${t2[e3]} ${t2[e3 + 1]} ${t2[e3 + 2]} ${t2[e3 + 3]} ${t2[e3 + 4]} ${t2[e3 + 5]}`);
    return this.#Ol(i2), i2.join(" ");
  }
  #Ml() {
    const [e2, t2, i2, n2] = this.#gl, [a2, s2, r2, o2] = this.#El();
    return `M${(this.#yl[2] - e2) / i2} ${(this.#yl[3] - t2) / n2} L${(this.#yl[4] - e2) / i2} ${(this.#yl[5] - t2) / n2} L${a2} ${s2} L${r2} ${o2} L${(this.#yl[16] - e2) / i2} ${(this.#yl[17] - t2) / n2} L${(this.#yl[14] - e2) / i2} ${(this.#yl[15] - t2) / n2} Z`;
  }
  #Ol(e2) {
    const t2 = this.#fl;
    e2.push(`L${t2[4]} ${t2[5]} Z`);
  }
  #Dl(e2) {
    const [t2, i2, n2, a2] = this.#gl, s2 = this.#yl.subarray(4, 6), r2 = this.#yl.subarray(16, 18), [o2, l2, c2, h2] = this.#El();
    e2.push(`L${(s2[0] - t2) / n2} ${(s2[1] - i2) / a2} L${o2} ${l2} L${c2} ${h2} L${(r2[0] - t2) / n2} ${(r2[1] - i2) / a2}`);
  }
  newFreeDrawOutline(e2, t2, i2, n2, a2, s2) {
    return new FreeDrawOutline(e2, t2, i2, n2, a2, s2);
  }
  getOutlines() {
    const e2 = this.#bl, t2 = this.#fl, i2 = this.#yl, [n2, a2, s2, r2] = this.#gl, o2 = new Float32Array((this.#kl?.length ?? 0) + 2);
    for (let e3 = 0, t3 = o2.length - 2; e3 < t3; e3 += 2) o2[e3] = (this.#kl[e3] - n2) / s2, o2[e3 + 1] = (this.#kl[e3 + 1] - a2) / r2;
    if (o2[o2.length - 2] = (this.#wl - n2) / s2, o2[o2.length - 1] = (this.#Al - a2) / r2, isNaN(i2[6]) && !this.isEmpty()) return this.#_l(o2);
    const l2 = new Float32Array(this.#bl.length + 24 + this.#fl.length);
    let c2 = e2.length;
    for (let t3 = 0; t3 < c2; t3 += 2) isNaN(e2[t3]) ? l2[t3] = l2[t3 + 1] = NaN : (l2[t3] = e2[t3], l2[t3 + 1] = e2[t3 + 1]);
    c2 = this.#Pl(l2, c2);
    for (let e3 = t2.length - 6; e3 >= 6; e3 -= 6) for (let i3 = 0; i3 < 6; i3 += 2) isNaN(t2[e3 + i3]) ? (l2[c2] = l2[c2 + 1] = NaN, c2 += 2) : (l2[c2] = t2[e3 + i3], l2[c2 + 1] = t2[e3 + i3 + 1], c2 += 2);
    return this.#Rl(l2, c2), this.newFreeDrawOutline(l2, o2, this.#gl, this.#vl, this.#pl, this.#ml);
  }
  #_l(e2) {
    const t2 = this.#yl, [i2, n2, a2, s2] = this.#gl, [r2, o2, l2, c2] = this.#El(), h2 = new Float32Array(36);
    return h2.set([NaN, NaN, NaN, NaN, (t2[2] - i2) / a2, (t2[3] - n2) / s2, NaN, NaN, NaN, NaN, (t2[4] - i2) / a2, (t2[5] - n2) / s2, NaN, NaN, NaN, NaN, r2, o2, NaN, NaN, NaN, NaN, l2, c2, NaN, NaN, NaN, NaN, (t2[16] - i2) / a2, (t2[17] - n2) / s2, NaN, NaN, NaN, NaN, (t2[14] - i2) / a2, (t2[15] - n2) / s2], 0), this.newFreeDrawOutline(h2, e2, this.#gl, this.#vl, this.#pl, this.#ml);
  }
  #Rl(e2, t2) {
    const i2 = this.#fl;
    return e2.set([NaN, NaN, NaN, NaN, i2[4], i2[5]], t2), t2 + 6;
  }
  #Pl(e2, t2) {
    const i2 = this.#yl.subarray(4, 6), n2 = this.#yl.subarray(16, 18), [a2, s2, r2, o2] = this.#gl, [l2, c2, h2, d2] = this.#El();
    return e2.set([NaN, NaN, NaN, NaN, (i2[0] - a2) / r2, (i2[1] - s2) / o2, NaN, NaN, NaN, NaN, l2, c2, NaN, NaN, NaN, NaN, h2, d2, NaN, NaN, NaN, NaN, (n2[0] - a2) / r2, (n2[1] - s2) / o2], t2), t2 + 24;
  }
}
class FreeDrawOutline extends Outline {
  #gl;
  #Bl = new Float32Array(4);
  #pl;
  #ml;
  #kl;
  #vl;
  #Nl;
  constructor(e2, t2, i2, n2, a2, s2) {
    super(), this.#Nl = e2, this.#kl = t2, this.#gl = i2, this.#vl = n2, this.#pl = a2, this.#ml = s2, this.firstPoint = [NaN, NaN], this.lastPoint = [NaN, NaN], this.#Ll(s2);
    const [r2, o2, l2, c2] = this.#Bl;
    for (let t3 = 0, i3 = e2.length; t3 < i3; t3 += 2) e2[t3] = (e2[t3] - r2) / l2, e2[t3 + 1] = (e2[t3 + 1] - o2) / c2;
    for (let e3 = 0, i3 = t2.length; e3 < i3; e3 += 2) t2[e3] = (t2[e3] - r2) / l2, t2[e3 + 1] = (t2[e3 + 1] - o2) / c2;
  }
  toSVGPath() {
    const e2 = [`M${this.#Nl[4]} ${this.#Nl[5]}`];
    for (let t2 = 6, i2 = this.#Nl.length; t2 < i2; t2 += 6) isNaN(this.#Nl[t2]) ? e2.push(`L${this.#Nl[t2 + 4]} ${this.#Nl[t2 + 5]}`) : e2.push(`C${this.#Nl[t2]} ${this.#Nl[t2 + 1]} ${this.#Nl[t2 + 2]} ${this.#Nl[t2 + 3]} ${this.#Nl[t2 + 4]} ${this.#Nl[t2 + 5]}`);
    return e2.push("Z"), e2.join(" ");
  }
  serialize([e2, t2, i2, n2], a2) {
    const s2 = i2 - e2, r2 = n2 - t2;
    let o2, l2;
    switch (a2) {
      case 0:
        o2 = Outline._rescale(this.#Nl, e2, n2, s2, -r2), l2 = Outline._rescale(this.#kl, e2, n2, s2, -r2);
        break;
      case 90:
        o2 = Outline._rescaleAndSwap(this.#Nl, e2, t2, s2, r2), l2 = Outline._rescaleAndSwap(this.#kl, e2, t2, s2, r2);
        break;
      case 180:
        o2 = Outline._rescale(this.#Nl, i2, t2, -s2, r2), l2 = Outline._rescale(this.#kl, i2, t2, -s2, r2);
        break;
      case 270:
        o2 = Outline._rescaleAndSwap(this.#Nl, i2, n2, -s2, -r2), l2 = Outline._rescaleAndSwap(this.#kl, i2, n2, -s2, -r2);
    }
    return { outline: Array.from(o2), points: [Array.from(l2)] };
  }
  #Ll(e2) {
    const t2 = this.#Nl;
    let i2 = t2[4], n2 = t2[5];
    const a2 = [i2, n2, i2, n2];
    let s2 = i2, r2 = n2, o2 = i2, l2 = n2;
    const c2 = e2 ? Math.max : Math.min, h2 = new Float32Array(4);
    for (let e3 = 6, d3 = t2.length; e3 < d3; e3 += 6) {
      const d4 = t2[e3 + 4], u2 = t2[e3 + 5];
      isNaN(t2[e3]) ? (Util.pointBoundingBox(d4, u2, a2), r2 > u2 ? (s2 = d4, r2 = u2) : r2 === u2 && (s2 = c2(s2, d4)), l2 < u2 ? (o2 = d4, l2 = u2) : l2 === u2 && (o2 = c2(o2, d4))) : (h2[0] = h2[1] = 1 / 0, h2[2] = h2[3] = -1 / 0, Util.bezierBoundingBox(i2, n2, ...t2.slice(e3, e3 + 6), h2), Util.rectBoundingBox(h2[0], h2[1], h2[2], h2[3], a2), r2 > h2[1] ? (s2 = h2[0], r2 = h2[1]) : r2 === h2[1] && (s2 = c2(s2, h2[0])), l2 < h2[3] ? (o2 = h2[2], l2 = h2[3]) : l2 === h2[3] && (o2 = c2(o2, h2[2]))), i2 = d4, n2 = u2;
    }
    const d2 = this.#Bl;
    d2[0] = a2[0] - this.#pl, d2[1] = a2[1] - this.#pl, d2[2] = a2[2] - a2[0] + 2 * this.#pl, d2[3] = a2[3] - a2[1] + 2 * this.#pl, this.firstPoint = [s2, r2], this.lastPoint = [o2, l2];
  }
  get box() {
    return this.#Bl;
  }
  newOutliner(e2, t2, i2, n2, a2, s2 = 0) {
    return new FreeDrawOutliner(e2, t2, i2, n2, a2, s2);
  }
  getNewOutline(e2, t2) {
    const [i2, n2, a2, s2] = this.#Bl, [r2, o2, l2, c2] = this.#gl, h2 = a2 * l2, d2 = s2 * c2, u2 = i2 * l2 + r2, g2 = n2 * c2 + o2, f2 = this.newOutliner({ x: this.#kl[0] * h2 + u2, y: this.#kl[1] * d2 + g2 }, this.#gl, this.#vl, e2, this.#ml, t2 ?? this.#pl);
    for (let e3 = 2; e3 < this.#kl.length; e3 += 2) f2.add({ x: this.#kl[e3] * h2 + u2, y: this.#kl[e3 + 1] * d2 + g2 });
    return f2.getOutlines();
  }
}
class HighlightOutliner {
  #gl;
  #Ul;
  #jl;
  #$l = [];
  #Hl = [];
  constructor(e2, t2 = 0, i2 = 0, n2 = true) {
    const a2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], s2 = 1e-4;
    for (const { x: i3, y: n3, width: r3, height: o3 } of e2) {
      const e3 = Math.floor((i3 - t2) / s2) * s2, l3 = Math.ceil((i3 + r3 + t2) / s2) * s2, c3 = Math.floor((n3 - t2) / s2) * s2, h3 = Math.ceil((n3 + o3 + t2) / s2) * s2, d3 = [e3, c3, h3, true], u3 = [l3, c3, h3, false];
      this.#$l.push(d3, u3), Util.rectBoundingBox(e3, c3, l3, h3, a2);
    }
    const r2 = a2[2] - a2[0] + 2 * i2, o2 = a2[3] - a2[1] + 2 * i2, l2 = a2[0] - i2, c2 = a2[1] - i2;
    let h2 = n2 ? -1 / 0 : 1 / 0, d2 = 1 / 0;
    const u2 = this.#$l.at(n2 ? -1 : -2), g2 = [u2[0], u2[2]];
    for (const e3 of this.#$l) {
      const [t3, i3, a3, s3] = e3;
      !s3 && n2 ? i3 < d2 ? (d2 = i3, h2 = t3) : i3 === d2 && (h2 = Math.max(h2, t3)) : s3 && !n2 && (i3 < d2 ? (d2 = i3, h2 = t3) : i3 === d2 && (h2 = Math.min(h2, t3))), e3[0] = (t3 - l2) / r2, e3[1] = (i3 - c2) / o2, e3[2] = (a3 - c2) / o2;
    }
    this.#gl = new Float32Array([l2, c2, r2, o2]), this.#Ul = [h2, d2], this.#jl = g2;
  }
  getOutlines() {
    this.#$l.sort((e3, t2) => e3[0] - t2[0] || e3[1] - t2[1] || e3[2] - t2[2]);
    const e2 = [];
    for (const t2 of this.#$l) t2[3] ? (e2.push(...this.#Xl(t2)), this.#ql(t2)) : (this.#zl(t2), e2.push(...this.#Xl(t2)));
    return this.#Wl(e2);
  }
  #Wl(e2) {
    const t2 = [], i2 = /* @__PURE__ */ new Set();
    for (const i3 of e2) {
      const [e3, n3, a3] = i3;
      t2.push([e3, n3, i3], [e3, a3, i3]);
    }
    t2.sort((e3, t3) => e3[1] - t3[1] || e3[0] - t3[0]);
    for (let e3 = 0, n3 = t2.length; e3 < n3; e3 += 2) {
      const n4 = t2[e3][2], a3 = t2[e3 + 1][2];
      n4.push(a3), a3.push(n4), i2.add(n4), i2.add(a3);
    }
    const n2 = [];
    let a2;
    for (; i2.size > 0; ) {
      const e3 = i2.values().next().value;
      let [t3, s2, r2, o2, l2] = e3;
      i2.delete(e3);
      let c2 = t3, h2 = s2;
      for (a2 = [t3, r2], n2.push(a2); ; ) {
        let e4;
        if (i2.has(o2)) e4 = o2;
        else {
          if (!i2.has(l2)) break;
          e4 = l2;
        }
        i2.delete(e4), [t3, s2, r2, o2, l2] = e4, c2 !== t3 && (a2.push(c2, h2, t3, h2 === s2 ? s2 : r2), c2 = t3), h2 = h2 === s2 ? r2 : s2;
      }
      a2.push(c2, h2);
    }
    return new HighlightOutline(n2, this.#gl, this.#Ul, this.#jl);
  }
  #Gl(e2) {
    const t2 = this.#Hl;
    let i2 = 0, n2 = t2.length - 1;
    for (; i2 <= n2; ) {
      const a2 = i2 + n2 >> 1, s2 = t2[a2][0];
      if (s2 === e2) return a2;
      s2 < e2 ? i2 = a2 + 1 : n2 = a2 - 1;
    }
    return n2 + 1;
  }
  #ql([, e2, t2]) {
    const i2 = this.#Gl(e2);
    this.#Hl.splice(i2, 0, [e2, t2]);
  }
  #zl([, e2, t2]) {
    const i2 = this.#Gl(e2);
    for (let n2 = i2; n2 < this.#Hl.length; n2++) {
      const [i3, a2] = this.#Hl[n2];
      if (i3 !== e2) break;
      if (i3 === e2 && a2 === t2) return void this.#Hl.splice(n2, 1);
    }
    for (let n2 = i2 - 1; n2 >= 0; n2--) {
      const [i3, a2] = this.#Hl[n2];
      if (i3 !== e2) break;
      if (i3 === e2 && a2 === t2) return void this.#Hl.splice(n2, 1);
    }
  }
  #Xl(e2) {
    const [t2, i2, n2] = e2, a2 = [[t2, i2, n2]], s2 = this.#Gl(n2);
    for (let e3 = 0; e3 < s2; e3++) {
      const [i3, n3] = this.#Hl[e3];
      for (let e4 = 0, s3 = a2.length; e4 < s3; e4++) {
        const [, r2, o2] = a2[e4];
        if (!(n3 <= r2 || o2 <= i3)) if (r2 >= i3) if (o2 > n3) a2[e4][1] = n3;
        else {
          if (1 === s3) return [];
          a2.splice(e4, 1), e4--, s3--;
        }
        else a2[e4][2] = i3, o2 > n3 && a2.push([t2, n3, o2]);
      }
    }
    return a2;
  }
}
class HighlightOutline extends Outline {
  #gl;
  #Vl;
  constructor(e2, t2, i2, n2) {
    super(), this.#Vl = e2, this.#gl = t2, this.firstPoint = i2, this.lastPoint = n2;
  }
  toSVGPath() {
    const e2 = [];
    for (const t2 of this.#Vl) {
      let [i2, n2] = t2;
      e2.push(`M${i2} ${n2}`);
      for (let a2 = 2; a2 < t2.length; a2 += 2) {
        const s2 = t2[a2], r2 = t2[a2 + 1];
        s2 === i2 ? (e2.push(`V${r2}`), n2 = r2) : r2 === n2 && (e2.push(`H${s2}`), i2 = s2);
      }
      e2.push("Z");
    }
    return e2.join(" ");
  }
  serialize([e2, t2, i2, n2], a2) {
    const s2 = [], r2 = i2 - e2, o2 = n2 - t2;
    for (const t3 of this.#Vl) {
      const i3 = new Array(t3.length);
      for (let a3 = 0; a3 < t3.length; a3 += 2) i3[a3] = e2 + t3[a3] * r2, i3[a3 + 1] = n2 - t3[a3 + 1] * o2;
      s2.push(i3);
    }
    return s2;
  }
  get box() {
    return this.#gl;
  }
  get classNamesForOutlining() {
    return ["highlightOutline"];
  }
}
class FreeHighlightOutliner extends FreeDrawOutliner {
  newFreeDrawOutline(e2, t2, i2, n2, a2, s2) {
    return new FreeHighlightOutline(e2, t2, i2, n2, a2, s2);
  }
}
class FreeHighlightOutline extends FreeDrawOutline {
  newOutliner(e2, t2, i2, n2, a2, s2 = 0) {
    return new FreeHighlightOutliner(e2, t2, i2, n2, a2, s2);
  }
}
class HighlightEditor extends AnnotationEditor {
  #Kl = null;
  #Yl = 0;
  #Jl;
  #Zl = null;
  #gt = null;
  #Ql = null;
  #ec = null;
  #tc = 0;
  #ic = null;
  #nc = null;
  #Mt = null;
  #ac = false;
  #Ul = null;
  #jl = null;
  #sc = null;
  #_e = "";
  #Cl;
  #rc = "";
  static _defaultColor = null;
  static _defaultOpacity = 1;
  static _defaultThickness = 12;
  static _type = "highlight";
  static _editorType = Hl.HIGHLIGHT;
  static _freeHighlightId = -1;
  static _freeHighlight = null;
  static _freeHighlightClipId = "";
  static get _keyboardManager() {
    const e2 = HighlightEditor.prototype;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], e2._moveCaret, { args: [0] }], [["ArrowRight", "mac+ArrowRight"], e2._moveCaret, { args: [1] }], [["ArrowUp", "mac+ArrowUp"], e2._moveCaret, { args: [2] }], [["ArrowDown", "mac+ArrowDown"], e2._moveCaret, { args: [3] }]]));
  }
  constructor(e2) {
    super({ ...e2, name: "highlightEditor" }), this.color = e2.color || HighlightEditor._defaultColor, this.#Cl = e2.thickness || HighlightEditor._defaultThickness, this.opacity = e2.opacity || HighlightEditor._defaultOpacity, this.#Jl = e2.boxes || null, this.#rc = e2.methodOfCreation || "", this.#_e = e2.text || "", this._isDraggable = false, this.defaultL10nId = "pdfjs-editor-highlight-editor", e2.highlightId > -1 ? (this.#ac = true, this.#oc(e2), this.#lc()) : this.#Jl && (this.#Kl = e2.anchorNode, this.#Yl = e2.anchorOffset, this.#ec = e2.focusNode, this.#tc = e2.focusOffset, this.#cc(), this.#lc(), this.rotate(this.rotation)), this.annotationElementId || this._uiManager.a11yAlert("pdfjs-editor-highlight-added-alert");
  }
  get telemetryInitialData() {
    return { action: "added", type: this.#ac ? "free_highlight" : "highlight", color: this._uiManager.getNonHCMColorName(this.color), thickness: this.#Cl, methodOfCreation: this.#rc };
  }
  get telemetryFinalData() {
    return { type: "highlight", color: this._uiManager.getNonHCMColorName(this.color) };
  }
  static computeTelemetryFinalData(e2) {
    return { numberOfColors: e2.get("color").size };
  }
  #cc() {
    const e2 = new HighlightOutliner(this.#Jl, 1e-3);
    this.#nc = e2.getOutlines(), [this.x, this.y, this.width, this.height] = this.#nc.box;
    const t2 = new HighlightOutliner(this.#Jl, 25e-4, 1e-3, "ltr" === this._uiManager.direction);
    this.#Ql = t2.getOutlines();
    const { firstPoint: i2 } = this.#nc;
    this.#Ul = [(i2[0] - this.x) / this.width, (i2[1] - this.y) / this.height];
    const { lastPoint: n2 } = this.#Ql;
    this.#jl = [(n2[0] - this.x) / this.width, (n2[1] - this.y) / this.height];
  }
  #oc({ highlightOutlines: e2, highlightId: t2, clipPathId: i2 }) {
    this.#nc = e2;
    if (this.#Ql = e2.getNewOutline(this.#Cl / 2 + 1.5, 25e-4), t2 >= 0) this.#Mt = t2, this.#Zl = i2, this.parent.drawLayer.finalizeDraw(t2, { bbox: e2.box, path: { d: e2.toSVGPath() } }), this.#sc = this.parent.drawLayer.drawOutline({ rootClass: { highlightOutline: true, free: true }, bbox: this.#Ql.box, path: { d: this.#Ql.toSVGPath() } }, true);
    else if (this.parent) {
      const t3 = this.parent.viewport.rotation;
      this.parent.drawLayer.updateProperties(this.#Mt, { bbox: HighlightEditor.#hc(this.#nc.box, (t3 - this.rotation + 360) % 360), path: { d: e2.toSVGPath() } }), this.parent.drawLayer.updateProperties(this.#sc, { bbox: HighlightEditor.#hc(this.#Ql.box, t3), path: { d: this.#Ql.toSVGPath() } });
    }
    const [n2, a2, s2, r2] = e2.box;
    switch (this.rotation) {
      case 0:
        this.x = n2, this.y = a2, this.width = s2, this.height = r2;
        break;
      case 90: {
        const [e3, t3] = this.parentDimensions;
        this.x = a2, this.y = 1 - n2, this.width = s2 * t3 / e3, this.height = r2 * e3 / t3;
        break;
      }
      case 180:
        this.x = 1 - n2, this.y = 1 - a2, this.width = s2, this.height = r2;
        break;
      case 270: {
        const [e3, t3] = this.parentDimensions;
        this.x = 1 - a2, this.y = n2, this.width = s2 * t3 / e3, this.height = r2 * e3 / t3;
        break;
      }
    }
    const { firstPoint: o2 } = e2;
    this.#Ul = [(o2[0] - n2) / s2, (o2[1] - a2) / r2];
    const { lastPoint: l2 } = this.#Ql;
    this.#jl = [(l2[0] - n2) / s2, (l2[1] - a2) / r2];
  }
  static initialize(e2, t2) {
    AnnotationEditor.initialize(e2, t2), HighlightEditor._defaultColor ||= t2.highlightColors?.values().next().value || "#fff066";
  }
  static updateDefaultParams(e2, t2) {
    switch (e2) {
      case Xl.HIGHLIGHT_COLOR:
        HighlightEditor._defaultColor = t2;
        break;
      case Xl.HIGHLIGHT_THICKNESS:
        HighlightEditor._defaultThickness = t2;
    }
  }
  translateInPage(e2, t2) {
  }
  get toolbarPosition() {
    return this.#jl;
  }
  get commentButtonPosition() {
    return this.#Ul;
  }
  updateParams(e2, t2) {
    switch (e2) {
      case Xl.HIGHLIGHT_COLOR:
        this.#_o(t2);
        break;
      case Xl.HIGHLIGHT_THICKNESS:
        this.#dc(t2);
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[Xl.HIGHLIGHT_COLOR, HighlightEditor._defaultColor], [Xl.HIGHLIGHT_THICKNESS, HighlightEditor._defaultThickness]];
  }
  get propertiesToUpdate() {
    return [[Xl.HIGHLIGHT_COLOR, this.color || HighlightEditor._defaultColor], [Xl.HIGHLIGHT_THICKNESS, this.#Cl || HighlightEditor._defaultThickness], [Xl.HIGHLIGHT_FREE, this.#ac]];
  }
  onUpdatedColor() {
    this.parent?.drawLayer.updateProperties(this.#Mt, { root: { fill: this.color, "fill-opacity": this.opacity } }), this.#gt?.updateColor(this.color), super.onUpdatedColor();
  }
  #_o(e2) {
    const setColorAndOpacity = (e3, t3) => {
      this.color = e3, this.opacity = t3, this.onUpdatedColor();
    }, t2 = this.color, i2 = this.opacity;
    this.addCommands({ cmd: setColorAndOpacity.bind(this, e2, HighlightEditor._defaultOpacity), undo: setColorAndOpacity.bind(this, t2, i2), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: Xl.HIGHLIGHT_COLOR, overwriteIfSameType: true, keepUndo: true }), this._reportTelemetry({ action: "color_changed", color: this._uiManager.getNonHCMColorName(e2) }, true);
  }
  #dc(e2) {
    const t2 = this.#Cl, setThickness = (e3) => {
      this.#Cl = e3, this.#uc(e3);
    };
    this.addCommands({ cmd: setThickness.bind(this, e2), undo: setThickness.bind(this, t2), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: Xl.INK_THICKNESS, overwriteIfSameType: true, keepUndo: true }), this._reportTelemetry({ action: "thickness_changed", thickness: e2 }, true);
  }
  get toolbarButtons() {
    if (this._uiManager.highlightColors) {
      return [["colorPicker", this.#gt = new ColorPicker({ editor: this })]];
    }
    return super.toolbarButtons;
  }
  disableEditing() {
    super.disableEditing(), this.div.classList.toggle("disabled", true);
  }
  enableEditing() {
    super.enableEditing(), this.div.classList.toggle("disabled", false);
  }
  fixAndSetPosition() {
    return super.fixAndSetPosition(this.#gc());
  }
  getBaseTranslation() {
    return [0, 0];
  }
  getRect(e2, t2) {
    return super.getRect(e2, t2, this.#gc());
  }
  onceAdded(e2) {
    this.annotationElementId || this.parent.addUndoableEditor(this), e2 && this.div.focus();
  }
  remove() {
    this.#fc(), this._reportTelemetry({ action: "deleted" }), super.remove();
  }
  rebuild() {
    this.parent && (super.rebuild(), null !== this.div && (this.#lc(), this.isAttachedToDOM || this.parent.add(this)));
  }
  setParent(e2) {
    let t2 = false;
    this.parent && !e2 ? this.#fc() : e2 && (this.#lc(e2), t2 = !this.parent && this.div?.classList.contains("selectedEditor")), super.setParent(e2), this.show(this._isVisible), t2 && this.select();
  }
  #uc(e2) {
    this.#ac && (this.#oc({ highlightOutlines: this.#nc.getNewOutline(e2 / 2) }), this.fixAndSetPosition(), this.setDims(this.width, this.height));
  }
  #fc() {
    null !== this.#Mt && this.parent && (this.parent.drawLayer.remove(this.#Mt), this.#Mt = null, this.parent.drawLayer.remove(this.#sc), this.#sc = null);
  }
  #lc(e2 = this.parent) {
    null === this.#Mt && ({ id: this.#Mt, clipPathId: this.#Zl } = e2.drawLayer.draw({ bbox: this.#nc.box, root: { viewBox: "0 0 1 1", fill: this.color, "fill-opacity": this.opacity }, rootClass: { highlight: true, free: this.#ac }, path: { d: this.#nc.toSVGPath() } }, false, true), this.#sc = e2.drawLayer.drawOutline({ rootClass: { highlightOutline: true, free: this.#ac }, bbox: this.#Ql.box, path: { d: this.#Ql.toSVGPath() } }, this.#ac), this.#ic && (this.#ic.style.clipPath = this.#Zl));
  }
  static #hc([e2, t2, i2, n2], a2) {
    switch (a2) {
      case 90:
        return [1 - t2 - n2, e2, n2, i2];
      case 180:
        return [1 - e2 - i2, 1 - t2 - n2, i2, n2];
      case 270:
        return [t2, 1 - e2 - i2, n2, i2];
    }
    return [e2, t2, i2, n2];
  }
  rotate(e2) {
    const { drawLayer: t2 } = this.parent;
    let i2;
    this.#ac ? (e2 = (e2 - this.rotation + 360) % 360, i2 = HighlightEditor.#hc(this.#nc.box, e2)) : i2 = HighlightEditor.#hc([this.x, this.y, this.width, this.height], e2), t2.updateProperties(this.#Mt, { bbox: i2, root: { "data-main-rotation": e2 } }), t2.updateProperties(this.#sc, { bbox: HighlightEditor.#hc(this.#Ql.box, e2), root: { "data-main-rotation": e2 } });
  }
  render() {
    if (this.div) return this.div;
    const e2 = super.render();
    this.#_e && (e2.setAttribute("aria-label", this.#_e), e2.setAttribute("role", "mark")), this.#ac ? e2.classList.add("free") : this.div.addEventListener("keydown", this.#pc.bind(this), { signal: this._uiManager._signal });
    const t2 = this.#ic = document.createElement("div");
    return e2.append(t2), t2.setAttribute("aria-hidden", "true"), t2.className = "internal", t2.style.clipPath = this.#Zl, this.setDims(this.width, this.height), bindEvents(this, this.#ic, ["pointerover", "pointerleave"]), this.enableEditing(), e2;
  }
  pointerover() {
    this.isSelected || this.parent?.drawLayer.updateProperties(this.#sc, { rootClass: { hovered: true } });
  }
  pointerleave() {
    this.isSelected || this.parent?.drawLayer.updateProperties(this.#sc, { rootClass: { hovered: false } });
  }
  #pc(e2) {
    HighlightEditor._keyboardManager.exec(this, e2);
  }
  _moveCaret(e2) {
    switch (this.parent.unselect(this), e2) {
      case 0:
      case 2:
        this.#mc(true);
        break;
      case 1:
      case 3:
        this.#mc(false);
    }
  }
  #mc(e2) {
    if (!this.#Kl) return;
    const t2 = window.getSelection();
    e2 ? t2.setPosition(this.#Kl, this.#Yl) : t2.setPosition(this.#ec, this.#tc);
  }
  select() {
    super.select(), this.#sc && this.parent?.drawLayer.updateProperties(this.#sc, { rootClass: { hovered: false, selected: true } });
  }
  unselect() {
    super.unselect(), this.#sc && (this.parent?.drawLayer.updateProperties(this.#sc, { rootClass: { selected: false } }), this.#ac || this.#mc(false));
  }
  get _mustFixPosition() {
    return !this.#ac;
  }
  show(e2 = this._isVisible) {
    super.show(e2), this.parent && (this.parent.drawLayer.updateProperties(this.#Mt, { rootClass: { hidden: !e2 } }), this.parent.drawLayer.updateProperties(this.#sc, { rootClass: { hidden: !e2 } }));
  }
  #gc() {
    return this.#ac ? this.rotation : 0;
  }
  #bc() {
    if (this.#ac) return null;
    const [e2, t2] = this.pageDimensions, [i2, n2] = this.pageTranslation, a2 = this.#Jl, s2 = new Float32Array(8 * a2.length);
    let r2 = 0;
    for (const { x: o2, y: l2, width: c2, height: h2 } of a2) {
      const a3 = o2 * e2 + i2, d2 = (1 - l2) * t2 + n2;
      s2[r2] = s2[r2 + 4] = a3, s2[r2 + 1] = s2[r2 + 3] = d2, s2[r2 + 2] = s2[r2 + 6] = a3 + c2 * e2, s2[r2 + 5] = s2[r2 + 7] = d2 - h2 * t2, r2 += 8;
    }
    return s2;
  }
  #yc(e2) {
    return this.#nc.serialize(e2, this.#gc());
  }
  static startHighlighting(e2, t2, { target: i2, x: n2, y: a2 }) {
    const { x: s2, y: r2, width: o2, height: l2 } = i2.getBoundingClientRect(), c2 = new AbortController(), h2 = e2.combinedSignal(c2), pointerUpCallback = (t3) => {
      c2.abort(), this.#wc(e2, t3);
    };
    window.addEventListener("blur", pointerUpCallback, { signal: h2 }), window.addEventListener("pointerup", pointerUpCallback, { signal: h2 }), window.addEventListener("pointerdown", stopEvent, { capture: true, passive: false, signal: h2 }), window.addEventListener("contextmenu", noContextMenu, { signal: h2 }), i2.addEventListener("pointermove", this.#Ac.bind(this, e2), { signal: h2 }), this._freeHighlight = new FreeHighlightOutliner({ x: n2, y: a2 }, [s2, r2, o2, l2], e2.scale, this._defaultThickness / 2, t2, 1e-3), { id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = e2.drawLayer.draw({ bbox: [0, 0, 1, 1], root: { viewBox: "0 0 1 1", fill: this._defaultColor, "fill-opacity": this._defaultOpacity }, rootClass: { highlight: true, free: true }, path: { d: this._freeHighlight.toSVGPath() } }, true, true);
  }
  static #Ac(e2, t2) {
    this._freeHighlight.add(t2) && e2.drawLayer.updateProperties(this._freeHighlightId, { path: { d: this._freeHighlight.toSVGPath() } });
  }
  static #wc(e2, t2) {
    this._freeHighlight.isEmpty() ? e2.drawLayer.remove(this._freeHighlightId) : e2.createAndAddNewEditor(t2, false, { highlightId: this._freeHighlightId, highlightOutlines: this._freeHighlight.getOutlines(), clipPathId: this._freeHighlightClipId, methodOfCreation: "main_toolbar" }), this._freeHighlightId = -1, this._freeHighlight = null, this._freeHighlightClipId = "";
  }
  static async deserialize(e2, t2, i2) {
    let n2 = null;
    if (e2 instanceof HighlightAnnotationElement) {
      const { data: { quadPoints: t3, rect: i3, rotation: a3, id: s3, color: r3, opacity: o3, popupRef: l3, richText: c3, contentsObj: h3, creationDate: d3, modificationDate: u3 }, parent: { page: { pageNumber: g2 } } } = e2;
      n2 = e2 = { annotationType: Hl.HIGHLIGHT, color: Array.from(r3), opacity: o3, quadPoints: t3, boxes: null, pageIndex: g2 - 1, rect: i3.slice(0), rotation: a3, annotationElementId: s3, id: s3, deleted: false, popupRef: l3, richText: c3, comment: h3?.str || null, creationDate: d3, modificationDate: u3 };
    } else if (e2 instanceof InkAnnotationElement) {
      const { data: { inkLists: t3, rect: i3, rotation: a3, id: s3, color: r3, borderStyle: { rawWidth: o3 }, popupRef: l3, richText: c3, contentsObj: h3, creationDate: d3, modificationDate: u3 }, parent: { page: { pageNumber: g2 } } } = e2;
      n2 = e2 = { annotationType: Hl.HIGHLIGHT, color: Array.from(r3), thickness: o3, inkLists: t3, boxes: null, pageIndex: g2 - 1, rect: i3.slice(0), rotation: a3, annotationElementId: s3, id: s3, deleted: false, popupRef: l3, richText: c3, comment: h3?.str || null, creationDate: d3, modificationDate: u3 };
    }
    const { color: a2, quadPoints: s2, inkLists: r2, opacity: o2 } = e2, l2 = await super.deserialize(e2, t2, i2);
    l2.color = Util.makeHexColor(...a2), l2.opacity = o2 || 1, r2 && (l2.#Cl = e2.thickness), l2._initialData = n2, e2.comment && l2.setCommentData(e2);
    const [c2, h2] = l2.pageDimensions, [d2, u2] = l2.pageTranslation;
    if (s2) {
      const e3 = l2.#Jl = [];
      for (let t3 = 0; t3 < s2.length; t3 += 8) e3.push({ x: (s2[t3] - d2) / c2, y: 1 - (s2[t3 + 1] - u2) / h2, width: (s2[t3 + 2] - s2[t3]) / c2, height: (s2[t3 + 1] - s2[t3 + 5]) / h2 });
      l2.#cc(), l2.#lc(), l2.rotate(l2.rotation);
    } else if (r2) {
      l2.#ac = true;
      const e3 = r2[0], i3 = { x: e3[0] - d2, y: h2 - (e3[1] - u2) }, n3 = new FreeHighlightOutliner(i3, [0, 0, c2, h2], 1, l2.#Cl / 2, true, 1e-3);
      for (let t3 = 0, a4 = e3.length; t3 < a4; t3 += 2) i3.x = e3[t3] - d2, i3.y = h2 - (e3[t3 + 1] - u2), n3.add(i3);
      const { id: a3, clipPathId: s3 } = t2.drawLayer.draw({ bbox: [0, 0, 1, 1], root: { viewBox: "0 0 1 1", fill: l2.color, "fill-opacity": l2._defaultOpacity }, rootClass: { highlight: true, free: true }, path: { d: n3.toSVGPath() } }, true, true);
      l2.#oc({ highlightOutlines: n3.getOutlines(), highlightId: a3, clipPathId: s3 }), l2.#lc(), l2.rotate(l2.parentRotation);
    }
    return l2;
  }
  serialize(e2 = false) {
    if (this.isEmpty() || e2) return null;
    if (this.deleted) return this.serializeDeleted();
    const t2 = AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color)), i2 = super.serialize(e2);
    return Object.assign(i2, { color: t2, opacity: this.opacity, thickness: this.#Cl, quadPoints: this.#bc(), outlines: this.#yc(i2.rect) }), this.addComment(i2), this.annotationElementId && !this.#ul(i2) ? null : (i2.id = this.annotationElementId, i2);
  }
  #ul(e2) {
    const { color: t2 } = this._initialData;
    return this.hasEditedComment || e2.color.some((e3, i2) => e3 !== t2[i2]);
  }
  renderAnnotationElement(e2) {
    return this.deleted ? (e2.hide(), null) : (e2.updateEdited({ rect: this.getPDFRect(), popup: this.comment }), null);
  }
  static canCreateNewEmptyEditor() {
    return false;
  }
}
class DrawingOptions {
  #xc = /* @__PURE__ */ Object.create(null);
  updateProperty(e2, t2) {
    this[e2] = t2, this.updateSVGProperty(e2, t2);
  }
  updateProperties(e2) {
    if (e2) for (const [t2, i2] of Object.entries(e2)) t2.startsWith("_") || this.updateProperty(t2, i2);
  }
  updateSVGProperty(e2, t2) {
    this.#xc[e2] = t2;
  }
  toSVGProperties() {
    const e2 = this.#xc;
    return this.#xc = /* @__PURE__ */ Object.create(null), { root: e2 };
  }
  reset() {
    this.#xc = /* @__PURE__ */ Object.create(null);
  }
  updateAll(e2 = this) {
    this.updateProperties(e2);
  }
  clone() {
    unreachable("Not implemented");
  }
}
class DrawingEditor extends AnnotationEditor {
  #Sc = null;
  #vc;
  _colorPicker = null;
  _drawId = null;
  static _currentDrawId = -1;
  static _currentParent = null;
  static #Cc = null;
  static #kc = null;
  static #Tc = null;
  static #Fc = NaN;
  static #Ic = null;
  static #Ec = null;
  static #Mc = NaN;
  static _INNER_MARGIN = 3;
  constructor(e2) {
    super(e2), this.#vc = e2.mustBeCommitted || false, this._addOutlines(e2);
  }
  onUpdatedColor() {
    this._colorPicker?.update(this.color), super.onUpdatedColor();
  }
  _addOutlines(e2) {
    e2.drawOutlines && (this.#Dc(e2), this.#lc());
  }
  #Dc({ drawOutlines: e2, drawId: t2, drawingOptions: i2 }) {
    this.#Sc = e2, this._drawingOptions ||= i2, this.annotationElementId || this._uiManager.a11yAlert(`pdfjs-editor-${this.editorType}-added-alert`), t2 >= 0 ? (this._drawId = t2, this.parent.drawLayer.finalizeDraw(t2, e2.defaultProperties)) : this._drawId = this.#Oc(e2, this.parent), this.#_c(e2.box);
  }
  #Oc(e2, t2) {
    const { id: i2 } = t2.drawLayer.draw(DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), e2.defaultSVGProperties), false, false);
    return i2;
  }
  static _mergeSVGProperties(e2, t2) {
    const i2 = new Set(Object.keys(e2));
    for (const [n2, a2] of Object.entries(t2)) i2.has(n2) ? Object.assign(e2[n2], a2) : e2[n2] = a2;
    return e2;
  }
  static getDefaultDrawingOptions(e2) {
    unreachable("Not implemented");
  }
  static get typesMap() {
    unreachable("Not implemented");
  }
  static get isDrawer() {
    return true;
  }
  static get supportMultipleDrawings() {
    return false;
  }
  static updateDefaultParams(e2, t2) {
    const i2 = this.typesMap.get(e2);
    i2 && this._defaultDrawingOptions.updateProperty(i2, t2), this._currentParent && (DrawingEditor.#Cc.updateProperty(i2, t2), this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties()));
  }
  updateParams(e2, t2) {
    const i2 = this.constructor.typesMap.get(e2);
    i2 && this._updateProperty(e2, i2, t2);
  }
  static get defaultPropertiesToUpdate() {
    const e2 = [], t2 = this._defaultDrawingOptions;
    for (const [i2, n2] of this.typesMap) e2.push([i2, t2[n2]]);
    return e2;
  }
  get propertiesToUpdate() {
    const e2 = [], { _drawingOptions: t2 } = this;
    for (const [i2, n2] of this.constructor.typesMap) e2.push([i2, t2[n2]]);
    return e2;
  }
  _updateProperty(e2, t2, i2) {
    const n2 = this._drawingOptions, a2 = n2[t2], setter = (i3) => {
      n2.updateProperty(t2, i3);
      const a3 = this.#Sc.updateProperty(t2, i3);
      a3 && this.#_c(a3), this.parent?.drawLayer.updateProperties(this._drawId, n2.toSVGProperties()), e2 === this.colorType && this.onUpdatedColor();
    };
    this.addCommands({ cmd: setter.bind(this, i2), undo: setter.bind(this, a2), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: true, type: e2, overwriteIfSameType: true, keepUndo: true });
  }
  _onResizing() {
    this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#Sc.getPathResizingSVGProperties(this.#Pc()), { bbox: this.#Rc() }));
  }
  _onResized() {
    this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#Sc.getPathResizedSVGProperties(this.#Pc()), { bbox: this.#Rc() }));
  }
  _onTranslating(e2, t2) {
    this.parent?.drawLayer.updateProperties(this._drawId, { bbox: this.#Rc() });
  }
  _onTranslated() {
    this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#Sc.getPathTranslatedSVGProperties(this.#Pc(), this.parentDimensions), { bbox: this.#Rc() }));
  }
  _onStartDragging() {
    this.parent?.drawLayer.updateProperties(this._drawId, { rootClass: { moving: true } });
  }
  _onStopDragging() {
    this.parent?.drawLayer.updateProperties(this._drawId, { rootClass: { moving: false } });
  }
  commit() {
    super.commit(), this.disableEditMode(), this.disableEditing();
  }
  disableEditing() {
    super.disableEditing(), this.div.classList.toggle("disabled", true);
  }
  enableEditing() {
    super.enableEditing(), this.div.classList.toggle("disabled", false);
  }
  getBaseTranslation() {
    return [0, 0];
  }
  get isResizable() {
    return true;
  }
  onceAdded(e2) {
    this.annotationElementId || this.parent.addUndoableEditor(this), this._isDraggable = true, this.#vc && (this.#vc = false, this.commit(), this.parent.setSelected(this), e2 && this.isOnScreen && this.div.focus());
  }
  remove() {
    this.#fc(), super.remove();
  }
  rebuild() {
    this.parent && (super.rebuild(), null !== this.div && (this.#lc(), this.#_c(this.#Sc.box), this.isAttachedToDOM || this.parent.add(this)));
  }
  setParent(e2) {
    let t2 = false;
    this.parent && !e2 ? (this._uiManager.removeShouldRescale(this), this.#fc()) : e2 && (this._uiManager.addShouldRescale(this), this.#lc(e2), t2 = !this.parent && this.div?.classList.contains("selectedEditor")), super.setParent(e2), t2 && this.select();
  }
  #fc() {
    null !== this._drawId && this.parent && (this.parent.drawLayer.remove(this._drawId), this._drawId = null, this._drawingOptions.reset());
  }
  #lc(e2 = this.parent) {
    null !== this._drawId && this.parent === e2 || (null === this._drawId ? (this._drawingOptions.updateAll(), this._drawId = this.#Oc(this.#Sc, e2)) : this.parent.drawLayer.updateParent(this._drawId, e2.drawLayer));
  }
  #Bc([e2, t2, i2, n2]) {
    const { parentDimensions: [a2, s2], rotation: r2 } = this;
    switch (r2) {
      case 90:
        return [t2, 1 - e2, i2 * (s2 / a2), n2 * (a2 / s2)];
      case 180:
        return [1 - e2, 1 - t2, i2, n2];
      case 270:
        return [1 - t2, e2, i2 * (s2 / a2), n2 * (a2 / s2)];
      default:
        return [e2, t2, i2, n2];
    }
  }
  #Pc() {
    const { x: e2, y: t2, width: i2, height: n2, parentDimensions: [a2, s2], rotation: r2 } = this;
    switch (r2) {
      case 90:
        return [1 - t2, e2, i2 * (a2 / s2), n2 * (s2 / a2)];
      case 180:
        return [1 - e2, 1 - t2, i2, n2];
      case 270:
        return [t2, 1 - e2, i2 * (a2 / s2), n2 * (s2 / a2)];
      default:
        return [e2, t2, i2, n2];
    }
  }
  #_c(e2) {
    [this.x, this.y, this.width, this.height] = this.#Bc(e2), this.div && (this.fixAndSetPosition(), this.setDims()), this._onResized();
  }
  #Rc() {
    const { x: e2, y: t2, width: i2, height: n2, rotation: a2, parentRotation: s2, parentDimensions: [r2, o2] } = this;
    switch ((4 * a2 + s2) / 90) {
      case 1:
        return [1 - t2 - n2, e2, n2, i2];
      case 2:
        return [1 - e2 - i2, 1 - t2 - n2, i2, n2];
      case 3:
        return [t2, 1 - e2 - i2, n2, i2];
      case 4:
        return [e2, t2 - i2 * (r2 / o2), n2 * (o2 / r2), i2 * (r2 / o2)];
      case 5:
        return [1 - t2, e2, i2 * (r2 / o2), n2 * (o2 / r2)];
      case 6:
        return [1 - e2 - n2 * (o2 / r2), 1 - t2, n2 * (o2 / r2), i2 * (r2 / o2)];
      case 7:
        return [t2 - i2 * (r2 / o2), 1 - e2 - n2 * (o2 / r2), i2 * (r2 / o2), n2 * (o2 / r2)];
      case 8:
        return [e2 - i2, t2 - n2, i2, n2];
      case 9:
        return [1 - t2, e2 - i2, n2, i2];
      case 10:
        return [1 - e2, 1 - t2, i2, n2];
      case 11:
        return [t2 - n2, 1 - e2, n2, i2];
      case 12:
        return [e2 - n2 * (o2 / r2), t2, n2 * (o2 / r2), i2 * (r2 / o2)];
      case 13:
        return [1 - t2 - i2 * (r2 / o2), e2 - n2 * (o2 / r2), i2 * (r2 / o2), n2 * (o2 / r2)];
      case 14:
        return [1 - e2, 1 - t2 - i2 * (r2 / o2), n2 * (o2 / r2), i2 * (r2 / o2)];
      case 15:
        return [t2, 1 - e2, i2 * (r2 / o2), n2 * (o2 / r2)];
      default:
        return [e2, t2, i2, n2];
    }
  }
  rotate() {
    this.parent && this.parent.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties({ bbox: this.#Rc() }, this.#Sc.updateRotation((this.parentRotation - this.rotation + 360) % 360)));
  }
  onScaleChanging() {
    this.parent && this.#_c(this.#Sc.updateParentDimensions(this.parentDimensions, this.parent.scale));
  }
  static onScaleChangingWhenDrawing() {
  }
  render() {
    if (this.div) return this.div;
    let e2, t2;
    this._isCopy && (e2 = this.x, t2 = this.y);
    const i2 = super.render();
    i2.classList.add("draw");
    const n2 = document.createElement("div");
    return i2.append(n2), n2.setAttribute("aria-hidden", "true"), n2.className = "internal", this.setDims(), this._uiManager.addShouldRescale(this), this.disableEditing(), this._isCopy && this._moveAfterPaste(e2, t2), i2;
  }
  static createDrawerInstance(e2, t2, i2, n2, a2) {
    unreachable("Not implemented");
  }
  static startDrawing(e2, t2, i2, n2) {
    const { target: a2, offsetX: s2, offsetY: r2, pointerId: o2, pointerType: l2 } = n2;
    if (DrawingEditor.#Ic && DrawingEditor.#Ic !== l2) return;
    const { viewport: { rotation: c2 } } = e2, { width: h2, height: d2 } = a2.getBoundingClientRect(), u2 = DrawingEditor.#kc = new AbortController(), g2 = e2.combinedSignal(u2);
    DrawingEditor.#Fc ||= o2, DrawingEditor.#Ic ??= l2, window.addEventListener("pointerup", (e3) => {
      DrawingEditor.#Fc === e3.pointerId ? this._endDraw(e3) : DrawingEditor.#Ec?.delete(e3.pointerId);
    }, { signal: g2 }), window.addEventListener("pointercancel", (e3) => {
      DrawingEditor.#Fc === e3.pointerId ? this._currentParent.endDrawingSession() : DrawingEditor.#Ec?.delete(e3.pointerId);
    }, { signal: g2 }), window.addEventListener("pointerdown", (e3) => {
      DrawingEditor.#Ic === e3.pointerType && ((DrawingEditor.#Ec ||= /* @__PURE__ */ new Set()).add(e3.pointerId), DrawingEditor.#Cc.isCancellable() && (DrawingEditor.#Cc.removeLastElement(), DrawingEditor.#Cc.isEmpty() ? this._currentParent.endDrawingSession(true) : this._endDraw(null)));
    }, { capture: true, passive: false, signal: g2 }), window.addEventListener("contextmenu", noContextMenu, { signal: g2 }), a2.addEventListener("pointermove", this._drawMove.bind(this), { signal: g2 }), a2.addEventListener("touchmove", (e3) => {
      e3.timeStamp === DrawingEditor.#Mc && stopEvent(e3);
    }, { signal: g2 }), e2.toggleDrawing(), t2._editorUndoBar?.hide(), DrawingEditor.#Cc ? e2.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#Cc.startNew(s2, r2, h2, d2, c2)) : (t2.updateUIForDefaultProperties(this), DrawingEditor.#Cc = this.createDrawerInstance(s2, r2, h2, d2, c2), DrawingEditor.#Tc = this.getDefaultDrawingOptions(), this._currentParent = e2, { id: this._currentDrawId } = e2.drawLayer.draw(this._mergeSVGProperties(DrawingEditor.#Tc.toSVGProperties(), DrawingEditor.#Cc.defaultSVGProperties), true, false));
  }
  static _drawMove(e2) {
    if (DrawingEditor.#Mc = -1, !DrawingEditor.#Cc) return;
    const { offsetX: t2, offsetY: i2, pointerId: n2 } = e2;
    DrawingEditor.#Fc === n2 && (DrawingEditor.#Ec?.size >= 1 ? this._endDraw(e2) : (this._currentParent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#Cc.add(t2, i2)), DrawingEditor.#Mc = e2.timeStamp, stopEvent(e2)));
  }
  static _cleanup(e2) {
    e2 && (this._currentDrawId = -1, this._currentParent = null, DrawingEditor.#Cc = null, DrawingEditor.#Tc = null, DrawingEditor.#Ic = null, DrawingEditor.#Mc = NaN), DrawingEditor.#kc && (DrawingEditor.#kc.abort(), DrawingEditor.#kc = null, DrawingEditor.#Fc = NaN, DrawingEditor.#Ec = null);
  }
  static _endDraw(e2) {
    const t2 = this._currentParent;
    if (t2) {
      if (t2.toggleDrawing(true), this._cleanup(false), e2?.target === t2.div && t2.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#Cc.end(e2.offsetX, e2.offsetY)), this.supportMultipleDrawings) {
        const e3 = DrawingEditor.#Cc, i2 = this._currentDrawId, n2 = e3.getLastElement();
        return void t2.addCommands({ cmd: () => {
          t2.drawLayer.updateProperties(i2, e3.setLastElement(n2));
        }, undo: () => {
          t2.drawLayer.updateProperties(i2, e3.removeLastElement());
        }, mustExec: false, type: Xl.DRAW_STEP });
      }
      this.endDrawing(false);
    }
  }
  static endDrawing(e2) {
    const t2 = this._currentParent;
    if (!t2) return null;
    if (t2.toggleDrawing(true), t2.cleanUndoStack(Xl.DRAW_STEP), !DrawingEditor.#Cc.isEmpty()) {
      const { pageDimensions: [i2, n2], scale: a2 } = t2, s2 = t2.createAndAddNewEditor({ offsetX: 0, offsetY: 0 }, false, { drawId: this._currentDrawId, drawOutlines: DrawingEditor.#Cc.getOutlines(i2 * a2, n2 * a2, a2, this._INNER_MARGIN), drawingOptions: DrawingEditor.#Tc, mustBeCommitted: !e2 });
      return this._cleanup(true), s2;
    }
    return t2.drawLayer.remove(this._currentDrawId), this._cleanup(true), null;
  }
  createDrawingOptions(e2) {
  }
  static deserializeDraw(e2, t2, i2, n2, a2, s2) {
    unreachable("Not implemented");
  }
  static async deserialize(e2, t2, i2) {
    const { rawDims: { pageWidth: n2, pageHeight: a2, pageX: s2, pageY: r2 } } = t2.viewport, o2 = this.deserializeDraw(s2, r2, n2, a2, this._INNER_MARGIN, e2), l2 = await super.deserialize(e2, t2, i2);
    return l2.createDrawingOptions(e2), l2.#Dc({ drawOutlines: o2 }), l2.#lc(), l2.onScaleChanging(), l2.rotate(), l2;
  }
  serializeDraw(e2) {
    const [t2, i2] = this.pageTranslation, [n2, a2] = this.pageDimensions;
    return this.#Sc.serialize([t2, i2, n2, a2], e2);
  }
  renderAnnotationElement(e2) {
    return e2.updateEdited({ rect: this.getPDFRect() }), null;
  }
  static canCreateNewEmptyEditor() {
    return false;
  }
}
class InkDrawOutliner {
  #yl = new Float64Array(6);
  #jo;
  #Nc;
  #Ks;
  #Cl;
  #kl;
  #Lc = "";
  #Uc = 0;
  #Vl = new InkDrawOutline();
  #jc;
  #$c;
  constructor(e2, t2, i2, n2, a2, s2) {
    this.#jc = i2, this.#$c = n2, this.#Ks = a2, this.#Cl = s2, [e2, t2] = this.#Hc(e2, t2);
    const r2 = this.#jo = [NaN, NaN, NaN, NaN, e2, t2];
    this.#kl = [e2, t2], this.#Nc = [{ line: r2, points: this.#kl }], this.#yl.set(r2, 0);
  }
  updateProperty(e2, t2) {
    "stroke-width" === e2 && (this.#Cl = t2);
  }
  #Hc(e2, t2) {
    return Outline._normalizePoint(e2, t2, this.#jc, this.#$c, this.#Ks);
  }
  isEmpty() {
    return !this.#Nc || 0 === this.#Nc.length;
  }
  isCancellable() {
    return this.#kl.length <= 10;
  }
  add(e2, t2) {
    [e2, t2] = this.#Hc(e2, t2);
    const [i2, n2, a2, s2] = this.#yl.subarray(2, 6), r2 = e2 - a2, o2 = t2 - s2;
    return Math.hypot(this.#jc * r2, this.#$c * o2) <= 2 ? null : (this.#kl.push(e2, t2), isNaN(i2) ? (this.#yl.set([a2, s2, e2, t2], 2), this.#jo.push(NaN, NaN, NaN, NaN, e2, t2), { path: { d: this.toSVGPath() } }) : (isNaN(this.#yl[0]) && this.#jo.splice(6, 6), this.#yl.set([i2, n2, a2, s2, e2, t2], 0), this.#jo.push(...Outline.createBezierPoints(i2, n2, a2, s2, e2, t2)), { path: { d: this.toSVGPath() } }));
  }
  end(e2, t2) {
    const i2 = this.add(e2, t2);
    return i2 || (2 === this.#kl.length ? { path: { d: this.toSVGPath() } } : null);
  }
  startNew(e2, t2, i2, n2, a2) {
    this.#jc = i2, this.#$c = n2, this.#Ks = a2, [e2, t2] = this.#Hc(e2, t2);
    const s2 = this.#jo = [NaN, NaN, NaN, NaN, e2, t2];
    this.#kl = [e2, t2];
    const r2 = this.#Nc.at(-1);
    return r2 && (r2.line = new Float32Array(r2.line), r2.points = new Float32Array(r2.points)), this.#Nc.push({ line: s2, points: this.#kl }), this.#yl.set(s2, 0), this.#Uc = 0, this.toSVGPath(), null;
  }
  getLastElement() {
    return this.#Nc.at(-1);
  }
  setLastElement(e2) {
    return this.#Nc ? (this.#Nc.push(e2), this.#jo = e2.line, this.#kl = e2.points, this.#Uc = 0, { path: { d: this.toSVGPath() } }) : this.#Vl.setLastElement(e2);
  }
  removeLastElement() {
    if (!this.#Nc) return this.#Vl.removeLastElement();
    this.#Nc.pop(), this.#Lc = "";
    for (let e2 = 0, t2 = this.#Nc.length; e2 < t2; e2++) {
      const { line: t3, points: i2 } = this.#Nc[e2];
      this.#jo = t3, this.#kl = i2, this.#Uc = 0, this.toSVGPath();
    }
    return { path: { d: this.#Lc } };
  }
  toSVGPath() {
    const e2 = Outline.svgRound(this.#jo[4]), t2 = Outline.svgRound(this.#jo[5]);
    if (2 === this.#kl.length) return this.#Lc = `${this.#Lc} M ${e2} ${t2} Z`, this.#Lc;
    if (this.#kl.length <= 6) {
      const i3 = this.#Lc.lastIndexOf("M");
      this.#Lc = `${this.#Lc.slice(0, i3)} M ${e2} ${t2}`, this.#Uc = 6;
    }
    if (4 === this.#kl.length) {
      const e3 = Outline.svgRound(this.#jo[10]), t3 = Outline.svgRound(this.#jo[11]);
      return this.#Lc = `${this.#Lc} L ${e3} ${t3}`, this.#Uc = 12, this.#Lc;
    }
    const i2 = [];
    0 === this.#Uc && (i2.push(`M ${e2} ${t2}`), this.#Uc = 6);
    for (let e3 = this.#Uc, t3 = this.#jo.length; e3 < t3; e3 += 6) {
      const [t4, n2, a2, s2, r2, o2] = this.#jo.slice(e3, e3 + 6).map(Outline.svgRound);
      i2.push(`C${t4} ${n2} ${a2} ${s2} ${r2} ${o2}`);
    }
    return this.#Lc += i2.join(" "), this.#Uc = this.#jo.length, this.#Lc;
  }
  getOutlines(e2, t2, i2, n2) {
    const a2 = this.#Nc.at(-1);
    return a2.line = new Float32Array(a2.line), a2.points = new Float32Array(a2.points), this.#Vl.build(this.#Nc, e2, t2, i2, this.#Ks, this.#Cl, n2), this.#yl = null, this.#jo = null, this.#Nc = null, this.#Lc = null, this.#Vl;
  }
  get defaultSVGProperties() {
    return { root: { viewBox: "0 0 10000 10000" }, rootClass: { draw: true }, bbox: [0, 0, 1, 1] };
  }
}
class InkDrawOutline extends Outline {
  #Bl;
  #Xc = 0;
  #pl;
  #Nc;
  #jc;
  #$c;
  #qc;
  #Ks;
  #Cl;
  build(e2, t2, i2, n2, a2, s2, r2) {
    this.#jc = t2, this.#$c = i2, this.#qc = n2, this.#Ks = a2, this.#Cl = s2, this.#pl = r2 ?? 0, this.#Nc = e2, this.#zc();
  }
  get thickness() {
    return this.#Cl;
  }
  setLastElement(e2) {
    return this.#Nc.push(e2), { path: { d: this.toSVGPath() } };
  }
  removeLastElement() {
    return this.#Nc.pop(), { path: { d: this.toSVGPath() } };
  }
  toSVGPath() {
    const e2 = [];
    for (const { line: t2 } of this.#Nc) if (e2.push(`M${Outline.svgRound(t2[4])} ${Outline.svgRound(t2[5])}`), 6 !== t2.length) if (12 === t2.length && isNaN(t2[6])) e2.push(`L${Outline.svgRound(t2[10])} ${Outline.svgRound(t2[11])}`);
    else for (let i2 = 6, n2 = t2.length; i2 < n2; i2 += 6) {
      const [n3, a2, s2, r2, o2, l2] = t2.subarray(i2, i2 + 6).map(Outline.svgRound);
      e2.push(`C${n3} ${a2} ${s2} ${r2} ${o2} ${l2}`);
    }
    else e2.push("Z");
    return e2.join("");
  }
  serialize([e2, t2, i2, n2], a2) {
    const s2 = [], r2 = [], [o2, l2, c2, h2] = this.#Wc();
    let d2, u2, g2, f2, p2, m2, b2, y2, w2;
    switch (this.#Ks) {
      case 0:
        w2 = Outline._rescale, d2 = e2, u2 = t2 + n2, g2 = i2, f2 = -n2, p2 = e2 + o2 * i2, m2 = t2 + (1 - l2 - h2) * n2, b2 = e2 + (o2 + c2) * i2, y2 = t2 + (1 - l2) * n2;
        break;
      case 90:
        w2 = Outline._rescaleAndSwap, d2 = e2, u2 = t2, g2 = i2, f2 = n2, p2 = e2 + l2 * i2, m2 = t2 + o2 * n2, b2 = e2 + (l2 + h2) * i2, y2 = t2 + (o2 + c2) * n2;
        break;
      case 180:
        w2 = Outline._rescale, d2 = e2 + i2, u2 = t2, g2 = -i2, f2 = n2, p2 = e2 + (1 - o2 - c2) * i2, m2 = t2 + l2 * n2, b2 = e2 + (1 - o2) * i2, y2 = t2 + (l2 + h2) * n2;
        break;
      case 270:
        w2 = Outline._rescaleAndSwap, d2 = e2 + i2, u2 = t2 + n2, g2 = -i2, f2 = -n2, p2 = e2 + (1 - l2 - h2) * i2, m2 = t2 + (1 - o2 - c2) * n2, b2 = e2 + (1 - l2) * i2, y2 = t2 + (1 - o2) * n2;
    }
    for (const { line: e3, points: t3 } of this.#Nc) s2.push(w2(e3, d2, u2, g2, f2, a2 ? new Array(e3.length) : null)), r2.push(w2(t3, d2, u2, g2, f2, a2 ? new Array(t3.length) : null));
    return { lines: s2, points: r2, rect: [p2, m2, b2, y2] };
  }
  static deserialize(e2, t2, i2, n2, a2, { paths: { lines: s2, points: r2 }, rotation: o2, thickness: l2 }) {
    const c2 = [];
    let h2, d2, u2, g2, f2;
    switch (o2) {
      case 0:
        f2 = Outline._rescale, h2 = -e2 / i2, d2 = t2 / n2 + 1, u2 = 1 / i2, g2 = -1 / n2;
        break;
      case 90:
        f2 = Outline._rescaleAndSwap, h2 = -t2 / n2, d2 = -e2 / i2, u2 = 1 / n2, g2 = 1 / i2;
        break;
      case 180:
        f2 = Outline._rescale, h2 = e2 / i2 + 1, d2 = -t2 / n2, u2 = -1 / i2, g2 = 1 / n2;
        break;
      case 270:
        f2 = Outline._rescaleAndSwap, h2 = t2 / n2 + 1, d2 = e2 / i2 + 1, u2 = -1 / n2, g2 = -1 / i2;
    }
    if (!s2) {
      s2 = [];
      for (const e3 of r2) {
        const t3 = e3.length;
        if (2 === t3) {
          s2.push(new Float32Array([NaN, NaN, NaN, NaN, e3[0], e3[1]]));
          continue;
        }
        if (4 === t3) {
          s2.push(new Float32Array([NaN, NaN, NaN, NaN, e3[0], e3[1], NaN, NaN, NaN, NaN, e3[2], e3[3]]));
          continue;
        }
        const i3 = new Float32Array(3 * (t3 - 2));
        s2.push(i3);
        let [n3, a3, r3, o3] = e3.subarray(0, 4);
        i3.set([NaN, NaN, NaN, NaN, n3, a3], 0);
        for (let s3 = 4; s3 < t3; s3 += 2) {
          const t4 = e3[s3], l3 = e3[s3 + 1];
          i3.set(Outline.createBezierPoints(n3, a3, r3, o3, t4, l3), 3 * (s3 - 2)), [n3, a3, r3, o3] = [r3, o3, t4, l3];
        }
      }
    }
    for (let e3 = 0, t3 = s2.length; e3 < t3; e3++) c2.push({ line: f2(s2[e3].map((e4) => e4 ?? NaN), h2, d2, u2, g2), points: f2(r2[e3].map((e4) => e4 ?? NaN), h2, d2, u2, g2) });
    const p2 = new this.prototype.constructor();
    return p2.build(c2, i2, n2, 1, o2, l2, a2), p2;
  }
  #Gc(e2 = this.#Cl) {
    const t2 = this.#pl + e2 / 2 * this.#qc;
    return this.#Ks % 180 == 0 ? [t2 / this.#jc, t2 / this.#$c] : [t2 / this.#$c, t2 / this.#jc];
  }
  #Wc() {
    const [e2, t2, i2, n2] = this.#Bl, [a2, s2] = this.#Gc(0);
    return [e2 + a2, t2 + s2, i2 - 2 * a2, n2 - 2 * s2];
  }
  #zc() {
    const e2 = this.#Bl = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
    for (const { line: t3 } of this.#Nc) {
      if (t3.length <= 12) {
        for (let i4 = 4, n3 = t3.length; i4 < n3; i4 += 6) Util.pointBoundingBox(t3[i4], t3[i4 + 1], e2);
        continue;
      }
      let i3 = t3[4], n2 = t3[5];
      for (let a2 = 6, s2 = t3.length; a2 < s2; a2 += 6) {
        const [s3, r2, o2, l2, c2, h2] = t3.subarray(a2, a2 + 6);
        Util.bezierBoundingBox(i3, n2, s3, r2, o2, l2, c2, h2, e2), i3 = c2, n2 = h2;
      }
    }
    const [t2, i2] = this.#Gc();
    e2[0] = MathClamp(e2[0] - t2, 0, 1), e2[1] = MathClamp(e2[1] - i2, 0, 1), e2[2] = MathClamp(e2[2] + t2, 0, 1), e2[3] = MathClamp(e2[3] + i2, 0, 1), e2[2] -= e2[0], e2[3] -= e2[1];
  }
  get box() {
    return this.#Bl;
  }
  updateProperty(e2, t2) {
    return "stroke-width" === e2 ? this.#dc(t2) : null;
  }
  #dc(e2) {
    const [t2, i2] = this.#Gc();
    this.#Cl = e2;
    const [n2, a2] = this.#Gc(), [s2, r2] = [n2 - t2, a2 - i2], o2 = this.#Bl;
    return o2[0] -= s2, o2[1] -= r2, o2[2] += 2 * s2, o2[3] += 2 * r2, o2;
  }
  updateParentDimensions([e2, t2], i2) {
    const [n2, a2] = this.#Gc();
    this.#jc = e2, this.#$c = t2, this.#qc = i2;
    const [s2, r2] = this.#Gc(), o2 = s2 - n2, l2 = r2 - a2, c2 = this.#Bl;
    return c2[0] -= o2, c2[1] -= l2, c2[2] += 2 * o2, c2[3] += 2 * l2, c2;
  }
  updateRotation(e2) {
    return this.#Xc = e2, { path: { transform: this.rotationTransform } };
  }
  get viewBox() {
    return this.#Bl.map(Outline.svgRound).join(" ");
  }
  get defaultProperties() {
    const [e2, t2] = this.#Bl;
    return { root: { viewBox: this.viewBox }, path: { "transform-origin": `${Outline.svgRound(e2)} ${Outline.svgRound(t2)}` } };
  }
  get rotationTransform() {
    const [, , e2, t2] = this.#Bl;
    let i2 = 0, n2 = 0, a2 = 0, s2 = 0, r2 = 0, o2 = 0;
    switch (this.#Xc) {
      case 90:
        n2 = t2 / e2, a2 = -e2 / t2, r2 = e2;
        break;
      case 180:
        i2 = -1, s2 = -1, r2 = e2, o2 = t2;
        break;
      case 270:
        n2 = -t2 / e2, a2 = e2 / t2, o2 = t2;
        break;
      default:
        return "";
    }
    return `matrix(${i2} ${n2} ${a2} ${s2} ${Outline.svgRound(r2)} ${Outline.svgRound(o2)})`;
  }
  getPathResizingSVGProperties([e2, t2, i2, n2]) {
    const [a2, s2] = this.#Gc(), [r2, o2, l2, c2] = this.#Bl;
    if (Math.abs(l2 - a2) <= Outline.PRECISION || Math.abs(c2 - s2) <= Outline.PRECISION) {
      const a3 = e2 + i2 / 2 - (r2 + l2 / 2), s3 = t2 + n2 / 2 - (o2 + c2 / 2);
      return { path: { "transform-origin": `${Outline.svgRound(e2)} ${Outline.svgRound(t2)}`, transform: `${this.rotationTransform} translate(${a3} ${s3})` } };
    }
    const h2 = (i2 - 2 * a2) / (l2 - 2 * a2), d2 = (n2 - 2 * s2) / (c2 - 2 * s2), u2 = l2 / i2, g2 = c2 / n2;
    return { path: { "transform-origin": `${Outline.svgRound(r2)} ${Outline.svgRound(o2)}`, transform: `${this.rotationTransform} scale(${u2} ${g2}) translate(${Outline.svgRound(a2)} ${Outline.svgRound(s2)}) scale(${h2} ${d2}) translate(${Outline.svgRound(-a2)} ${Outline.svgRound(-s2)})` } };
  }
  getPathResizedSVGProperties([e2, t2, i2, n2]) {
    const [a2, s2] = this.#Gc(), r2 = this.#Bl, [o2, l2, c2, h2] = r2;
    if (r2[0] = e2, r2[1] = t2, r2[2] = i2, r2[3] = n2, Math.abs(c2 - a2) <= Outline.PRECISION || Math.abs(h2 - s2) <= Outline.PRECISION) {
      const a3 = e2 + i2 / 2 - (o2 + c2 / 2), s3 = t2 + n2 / 2 - (l2 + h2 / 2);
      for (const { line: e3, points: t3 } of this.#Nc) Outline._translate(e3, a3, s3, e3), Outline._translate(t3, a3, s3, t3);
      return { root: { viewBox: this.viewBox }, path: { "transform-origin": `${Outline.svgRound(e2)} ${Outline.svgRound(t2)}`, transform: this.rotationTransform || null, d: this.toSVGPath() } };
    }
    const d2 = (i2 - 2 * a2) / (c2 - 2 * a2), u2 = (n2 - 2 * s2) / (h2 - 2 * s2), g2 = -d2 * (o2 + a2) + e2 + a2, f2 = -u2 * (l2 + s2) + t2 + s2;
    if (1 !== d2 || 1 !== u2 || 0 !== g2 || 0 !== f2) for (const { line: e3, points: t3 } of this.#Nc) Outline._rescale(e3, g2, f2, d2, u2, e3), Outline._rescale(t3, g2, f2, d2, u2, t3);
    return { root: { viewBox: this.viewBox }, path: { "transform-origin": `${Outline.svgRound(e2)} ${Outline.svgRound(t2)}`, transform: this.rotationTransform || null, d: this.toSVGPath() } };
  }
  getPathTranslatedSVGProperties([e2, t2], i2) {
    const [n2, a2] = i2, s2 = this.#Bl, r2 = e2 - s2[0], o2 = t2 - s2[1];
    if (this.#jc === n2 && this.#$c === a2) for (const { line: e3, points: t3 } of this.#Nc) Outline._translate(e3, r2, o2, e3), Outline._translate(t3, r2, o2, t3);
    else {
      const e3 = this.#jc / n2, t3 = this.#$c / a2;
      this.#jc = n2, this.#$c = a2;
      for (const { line: i3, points: n3 } of this.#Nc) Outline._rescale(i3, r2, o2, e3, t3, i3), Outline._rescale(n3, r2, o2, e3, t3, n3);
      s2[2] *= e3, s2[3] *= t3;
    }
    return s2[0] = e2, s2[1] = t2, { root: { viewBox: this.viewBox }, path: { d: this.toSVGPath(), "transform-origin": `${Outline.svgRound(e2)} ${Outline.svgRound(t2)}` } };
  }
  get defaultSVGProperties() {
    const e2 = this.#Bl;
    return { root: { viewBox: this.viewBox }, rootClass: { draw: true }, path: { d: this.toSVGPath(), "transform-origin": `${Outline.svgRound(e2[0])} ${Outline.svgRound(e2[1])}`, transform: this.rotationTransform || null }, bbox: e2 };
  }
}
class InkDrawingOptions extends DrawingOptions {
  constructor(e2) {
    super(), this._viewParameters = e2, super.updateProperties({ fill: "none", stroke: AnnotationEditor._defaultLineColor, "stroke-opacity": 1, "stroke-width": 1, "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-miterlimit": 10 });
  }
  updateSVGProperty(e2, t2) {
    "stroke-width" === e2 && (t2 ??= this["stroke-width"], t2 *= this._viewParameters.realScale), super.updateSVGProperty(e2, t2);
  }
  clone() {
    const e2 = new InkDrawingOptions(this._viewParameters);
    return e2.updateAll(this), e2;
  }
}
class InkEditor extends DrawingEditor {
  static _type = "ink";
  static _editorType = Hl.INK;
  static _defaultDrawingOptions = null;
  constructor(e2) {
    super({ ...e2, name: "inkEditor" }), this._willKeepAspectRatio = true, this.defaultL10nId = "pdfjs-editor-ink-editor";
  }
  static initialize(e2, t2) {
    AnnotationEditor.initialize(e2, t2), this._defaultDrawingOptions = new InkDrawingOptions(t2.viewParameters);
  }
  static getDefaultDrawingOptions(e2) {
    const t2 = this._defaultDrawingOptions.clone();
    return t2.updateProperties(e2), t2;
  }
  static get supportMultipleDrawings() {
    return true;
  }
  static get typesMap() {
    return shadow(this, "typesMap", /* @__PURE__ */ new Map([[Xl.INK_THICKNESS, "stroke-width"], [Xl.INK_COLOR, "stroke"], [Xl.INK_OPACITY, "stroke-opacity"]]));
  }
  static createDrawerInstance(e2, t2, i2, n2, a2) {
    return new InkDrawOutliner(e2, t2, i2, n2, a2, this._defaultDrawingOptions["stroke-width"]);
  }
  static deserializeDraw(e2, t2, i2, n2, a2, s2) {
    return InkDrawOutline.deserialize(e2, t2, i2, n2, a2, s2);
  }
  static async deserialize(e2, t2, i2) {
    let n2 = null;
    if (e2 instanceof InkAnnotationElement) {
      const { data: { inkLists: t3, rect: i3, rotation: a3, id: s2, color: r2, opacity: o2, borderStyle: { rawWidth: l2 }, popupRef: c2, richText: h2, contentsObj: d2, creationDate: u2, modificationDate: g2 }, parent: { page: { pageNumber: f2 } } } = e2;
      n2 = e2 = { annotationType: Hl.INK, color: Array.from(r2), thickness: l2, opacity: o2, paths: { points: t3 }, boxes: null, pageIndex: f2 - 1, rect: i3.slice(0), rotation: a3, annotationElementId: s2, id: s2, deleted: false, popupRef: c2, richText: h2, comment: d2?.str || null, creationDate: u2, modificationDate: g2 };
    }
    const a2 = await super.deserialize(e2, t2, i2);
    return a2._initialData = n2, e2.comment && a2.setCommentData(e2), a2;
  }
  get toolbarButtons() {
    return this._colorPicker ||= new BasicColorPicker(this), [["colorPicker", this._colorPicker]];
  }
  get colorType() {
    return Xl.INK_COLOR;
  }
  get color() {
    return this._drawingOptions.stroke;
  }
  get opacity() {
    return this._drawingOptions["stroke-opacity"];
  }
  onScaleChanging() {
    if (!this.parent) return;
    super.onScaleChanging();
    const { _drawId: e2, _drawingOptions: t2, parent: i2 } = this;
    t2.updateSVGProperty("stroke-width"), i2.drawLayer.updateProperties(e2, t2.toSVGProperties());
  }
  static onScaleChangingWhenDrawing() {
    const e2 = this._currentParent;
    e2 && (super.onScaleChangingWhenDrawing(), this._defaultDrawingOptions.updateSVGProperty("stroke-width"), e2.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties()));
  }
  createDrawingOptions({ color: e2, thickness: t2, opacity: i2 }) {
    this._drawingOptions = InkEditor.getDefaultDrawingOptions({ stroke: Util.makeHexColor(...e2), "stroke-width": t2, "stroke-opacity": i2 });
  }
  serialize(e2 = false) {
    if (this.isEmpty()) return null;
    if (this.deleted) return this.serializeDeleted();
    const { lines: t2, points: i2 } = this.serializeDraw(e2), { _drawingOptions: { stroke: n2, "stroke-opacity": a2, "stroke-width": s2 } } = this, r2 = Object.assign(super.serialize(e2), { color: AnnotationEditor._colorManager.convert(n2), opacity: a2, thickness: s2, paths: { lines: t2, points: i2 } });
    return this.addComment(r2), e2 ? (r2.isCopy = true, r2) : this.annotationElementId && !this.#ul(r2) ? null : (r2.id = this.annotationElementId, r2);
  }
  #ul(e2) {
    const { color: t2, thickness: i2, opacity: n2, pageIndex: a2 } = this._initialData;
    return this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized || e2.color.some((e3, i3) => e3 !== t2[i3]) || e2.thickness !== i2 || e2.opacity !== n2 || e2.pageIndex !== a2;
  }
  renderAnnotationElement(e2) {
    if (this.deleted) return e2.hide(), null;
    const { points: t2, rect: i2 } = this.serializeDraw(false);
    return e2.updateEdited({ rect: i2, thickness: this._drawingOptions["stroke-width"], points: t2, popup: this.comment }), null;
  }
}
class ContourDrawOutline extends InkDrawOutline {
  toSVGPath() {
    let e2 = super.toSVGPath();
    return e2.endsWith("Z") || (e2 += "Z"), e2;
  }
}
class SignatureExtractor {
  static #Vc = { maxDim: 512, sigmaSFactor: 0.02, sigmaR: 25, kernelSize: 16 };
  static #Kc(e2, t2, i2, n2) {
    return n2 -= t2, 0 === (i2 -= e2) ? n2 > 0 ? 0 : 4 : 1 === i2 ? n2 + 6 : 2 - n2;
  }
  static #Yc = new Int32Array([0, 1, -1, 1, -1, 0, -1, -1, 0, -1, 1, -1, 1, 0, 1, 1]);
  static #Jc(e2, t2, i2, n2, a2, s2, r2) {
    const o2 = this.#Kc(i2, n2, a2, s2);
    for (let a3 = 0; a3 < 8; a3++) {
      const s3 = (-a3 + o2 - r2 + 16) % 8;
      if (0 !== e2[(i2 + this.#Yc[2 * s3]) * t2 + (n2 + this.#Yc[2 * s3 + 1])]) return s3;
    }
    return -1;
  }
  static #Zc(e2, t2, i2, n2, a2, s2, r2) {
    const o2 = this.#Kc(i2, n2, a2, s2);
    for (let a3 = 0; a3 < 8; a3++) {
      const s3 = (a3 + o2 + r2 + 16) % 8;
      if (0 !== e2[(i2 + this.#Yc[2 * s3]) * t2 + (n2 + this.#Yc[2 * s3 + 1])]) return s3;
    }
    return -1;
  }
  static #Qc(e2, t2, i2, n2) {
    const a2 = e2.length, s2 = new Int32Array(a2);
    for (let t3 = 0; t3 < a2; t3++) s2[t3] = e2[t3] <= n2 ? 1 : 0;
    for (let e3 = 1; e3 < i2 - 1; e3++) s2[e3 * t2] = s2[e3 * t2 + t2 - 1] = 0;
    for (let e3 = 0; e3 < t2; e3++) s2[e3] = s2[t2 * i2 - 1 - e3] = 0;
    let r2, o2 = 1;
    const l2 = [];
    for (let e3 = 1; e3 < i2 - 1; e3++) {
      r2 = 1;
      for (let i3 = 1; i3 < t2 - 1; i3++) {
        const n3 = e3 * t2 + i3, a3 = s2[n3];
        if (0 === a3) continue;
        let c2 = e3, h2 = i3;
        if (1 === a3 && 0 === s2[n3 - 1]) o2 += 1, h2 -= 1;
        else {
          if (!(a3 >= 1 && 0 === s2[n3 + 1])) {
            1 !== a3 && (r2 = Math.abs(a3));
            continue;
          }
          o2 += 1, h2 += 1, a3 > 1 && (r2 = a3);
        }
        const d2 = [i3, e3], u2 = h2 === i3 + 1, g2 = { isHole: u2, points: d2, id: o2, parent: 0 };
        let f2;
        l2.push(g2);
        for (const e4 of l2) if (e4.id === r2) {
          f2 = e4;
          break;
        }
        f2 ? f2.isHole ? g2.parent = u2 ? f2.parent : r2 : g2.parent = u2 ? r2 : f2.parent : g2.parent = u2 ? r2 : 0;
        const p2 = this.#Jc(s2, t2, e3, i3, c2, h2, 0);
        if (-1 === p2) {
          s2[n3] = -o2, 1 !== s2[n3] && (r2 = Math.abs(s2[n3]));
          continue;
        }
        let m2 = this.#Yc[2 * p2], b2 = this.#Yc[2 * p2 + 1];
        const y2 = e3 + m2, w2 = i3 + b2;
        c2 = y2, h2 = w2;
        let x2 = e3, S2 = i3;
        for (; ; ) {
          const a4 = this.#Zc(s2, t2, x2, S2, c2, h2, 1);
          m2 = this.#Yc[2 * a4], b2 = this.#Yc[2 * a4 + 1];
          const l3 = x2 + m2, u3 = S2 + b2;
          d2.push(u3, l3);
          const g3 = x2 * t2 + S2;
          if (0 === s2[g3 + 1] ? s2[g3] = -o2 : 1 === s2[g3] && (s2[g3] = o2), l3 === e3 && u3 === i3 && x2 === y2 && S2 === w2) {
            1 !== s2[n3] && (r2 = Math.abs(s2[n3]));
            break;
          }
          c2 = x2, h2 = S2, x2 = l3, S2 = u3;
        }
      }
    }
    return l2;
  }
  static #eh(e2, t2, i2, n2) {
    if (i2 - t2 <= 4) {
      for (let a3 = t2; a3 < i2 - 2; a3 += 2) n2.push(e2[a3], e2[a3 + 1]);
      return;
    }
    const a2 = e2[t2], s2 = e2[t2 + 1], r2 = e2[i2 - 4] - a2, o2 = e2[i2 - 3] - s2, l2 = Math.hypot(r2, o2), c2 = r2 / l2, h2 = o2 / l2, d2 = c2 * s2 - h2 * a2, u2 = o2 / r2, g2 = 1 / l2, f2 = Math.atan(u2), p2 = Math.cos(f2), m2 = Math.sin(f2), b2 = g2 * (Math.abs(p2) + Math.abs(m2)), y2 = g2 * (1 - b2 + b2 ** 2), w2 = Math.max(Math.atan(Math.abs(m2 + p2) * y2), Math.atan(Math.abs(m2 - p2) * y2));
    let x2 = 0, S2 = t2;
    for (let n3 = t2 + 2; n3 < i2 - 2; n3 += 2) {
      const t3 = Math.abs(d2 - c2 * e2[n3 + 1] + h2 * e2[n3]);
      t3 > x2 && (S2 = n3, x2 = t3);
    }
    x2 > (l2 * w2) ** 2 ? (this.#eh(e2, t2, S2 + 2, n2), this.#eh(e2, S2, i2, n2)) : n2.push(a2, s2);
  }
  static #th(e2) {
    const t2 = [], i2 = e2.length;
    return this.#eh(e2, 0, i2, t2), t2.push(e2[i2 - 2], e2[i2 - 1]), t2.length <= 4 ? null : t2;
  }
  static #ih(e2, t2, i2, n2, a2, s2) {
    const r2 = new Float32Array(s2 ** 2), o2 = -2 * n2 ** 2, l2 = s2 >> 1;
    for (let e3 = 0; e3 < s2; e3++) {
      const t3 = (e3 - l2) ** 2;
      for (let i3 = 0; i3 < s2; i3++) r2[e3 * s2 + i3] = Math.exp((t3 + (i3 - l2) ** 2) / o2);
    }
    const c2 = new Float32Array(256), h2 = -2 * a2 ** 2;
    for (let e3 = 0; e3 < 256; e3++) c2[e3] = Math.exp(e3 ** 2 / h2);
    const d2 = e2.length, u2 = new Uint8Array(d2), g2 = new Uint32Array(256);
    for (let n3 = 0; n3 < i2; n3++) for (let a3 = 0; a3 < t2; a3++) {
      const o3 = n3 * t2 + a3, h3 = e2[o3];
      let d3 = 0, f2 = 0;
      for (let o4 = 0; o4 < s2; o4++) {
        const u3 = n3 + o4 - l2;
        if (!(u3 < 0 || u3 >= i2)) for (let i3 = 0; i3 < s2; i3++) {
          const n4 = a3 + i3 - l2;
          if (n4 < 0 || n4 >= t2) continue;
          const g3 = e2[u3 * t2 + n4], p2 = r2[o4 * s2 + i3] * c2[Math.abs(g3 - h3)];
          d3 += g3 * p2, f2 += p2;
        }
      }
      g2[u2[o3] = Math.round(d3 / f2)]++;
    }
    return [u2, g2];
  }
  static #nh(e2) {
    const t2 = new Uint32Array(256);
    for (const i2 of e2) t2[i2]++;
    return t2;
  }
  static #ah(e2) {
    const t2 = e2.length, i2 = new Uint8ClampedArray(t2 >> 2);
    let n2 = -1 / 0, a2 = 1 / 0;
    for (let t3 = 0, s3 = i2.length; t3 < s3; t3++) {
      const s4 = i2[t3] = e2[t3 << 2];
      n2 = Math.max(n2, s4), a2 = Math.min(a2, s4);
    }
    const s2 = 255 / (n2 - a2);
    for (let e3 = 0, t3 = i2.length; e3 < t3; e3++) i2[e3] = (i2[e3] - a2) * s2;
    return i2;
  }
  static #sh(e2) {
    let t2, i2 = -1 / 0, n2 = -1 / 0;
    const a2 = e2.findIndex((e3) => 0 !== e3);
    let s2 = a2, r2 = a2;
    for (t2 = a2; t2 < 256; t2++) {
      const a3 = e2[t2];
      a3 > i2 && (t2 - s2 > n2 && (n2 = t2 - s2, r2 = t2 - 1), i2 = a3, s2 = t2);
    }
    for (t2 = r2 - 1; t2 >= 0 && !(e2[t2] > e2[t2 + 1]); t2--) ;
    return t2;
  }
  static #rh(e2) {
    const t2 = e2, { width: i2, height: n2 } = e2, { maxDim: a2 } = this.#Vc;
    let s2 = i2, r2 = n2;
    if (i2 > a2 || n2 > a2) {
      let o3 = i2, l3 = n2, c2 = Math.log2(Math.max(i2, n2) / a2);
      const h2 = Math.floor(c2);
      c2 = c2 === h2 ? h2 - 1 : h2;
      for (let i3 = 0; i3 < c2; i3++) {
        s2 = Math.ceil(o3 / 2), r2 = Math.ceil(l3 / 2);
        const i4 = new OffscreenCanvas(s2, r2);
        i4.getContext("2d").drawImage(e2, 0, 0, o3, l3, 0, 0, s2, r2), o3 = s2, l3 = r2, e2 !== t2 && e2.close(), e2 = i4.transferToImageBitmap();
      }
      const d2 = Math.min(a2 / s2, a2 / r2);
      s2 = Math.round(s2 * d2), r2 = Math.round(r2 * d2);
    }
    const o2 = new OffscreenCanvas(s2, r2).getContext("2d", { willReadFrequently: true });
    o2.fillStyle = "white", o2.fillRect(0, 0, s2, r2), o2.filter = "grayscale(1)", o2.drawImage(e2, 0, 0, e2.width, e2.height, 0, 0, s2, r2);
    const l2 = o2.getImageData(0, 0, s2, r2).data;
    return [this.#ah(l2), s2, r2];
  }
  static extractContoursFromText(e2, { fontFamily: t2, fontStyle: i2, fontWeight: n2 }, a2, s2, r2, o2) {
    let l2 = new OffscreenCanvas(1, 1), c2 = l2.getContext("2d", { alpha: false });
    const h2 = c2.font = `${i2} ${n2} 200px ${t2}`, { actualBoundingBoxLeft: d2, actualBoundingBoxRight: u2, actualBoundingBoxAscent: g2, actualBoundingBoxDescent: f2, fontBoundingBoxAscent: p2, fontBoundingBoxDescent: m2, width: b2 } = c2.measureText(e2), y2 = 1.5, w2 = Math.ceil(Math.max(Math.abs(d2) + Math.abs(u2) || 0, b2) * y2), x2 = Math.ceil(Math.max(Math.abs(g2) + Math.abs(f2) || 200, Math.abs(p2) + Math.abs(m2) || 200) * y2);
    l2 = new OffscreenCanvas(w2, x2), c2 = l2.getContext("2d", { alpha: true, willReadFrequently: true }), c2.font = h2, c2.filter = "grayscale(1)", c2.fillStyle = "white", c2.fillRect(0, 0, w2, x2), c2.fillStyle = "black", c2.fillText(e2, 0.5 * w2 / 2, 1.5 * x2 / 2);
    const S2 = this.#ah(c2.getImageData(0, 0, w2, x2).data), v2 = this.#nh(S2), C2 = this.#sh(v2), k2 = this.#Qc(S2, w2, x2, C2);
    return this.processDrawnLines({ lines: { curves: k2, width: w2, height: x2 }, pageWidth: a2, pageHeight: s2, rotation: r2, innerMargin: o2, mustSmooth: true, areContours: true });
  }
  static process(e2, t2, i2, n2, a2) {
    const [s2, r2, o2] = this.#rh(e2), [l2, c2] = this.#ih(s2, r2, o2, Math.hypot(r2, o2) * this.#Vc.sigmaSFactor, this.#Vc.sigmaR, this.#Vc.kernelSize), h2 = this.#sh(c2), d2 = this.#Qc(l2, r2, o2, h2);
    return this.processDrawnLines({ lines: { curves: d2, width: r2, height: o2 }, pageWidth: t2, pageHeight: i2, rotation: n2, innerMargin: a2, mustSmooth: true, areContours: true });
  }
  static processDrawnLines({ lines: e2, pageWidth: t2, pageHeight: i2, rotation: n2, innerMargin: a2, mustSmooth: s2, areContours: r2 }) {
    n2 % 180 != 0 && ([t2, i2] = [i2, t2]);
    const { curves: o2, width: l2, height: c2 } = e2, h2 = e2.thickness ?? 0, d2 = [], u2 = Math.min(t2 / l2, i2 / c2), g2 = u2 / t2, f2 = u2 / i2, p2 = [];
    for (const { points: e3 } of o2) {
      const t3 = s2 ? this.#th(e3) : e3;
      if (!t3) continue;
      p2.push(t3);
      const i3 = t3.length, n3 = new Float32Array(i3), a3 = new Float32Array(3 * (2 === i3 ? 2 : i3 - 2));
      if (d2.push({ line: a3, points: n3 }), 2 === i3) {
        n3[0] = t3[0] * g2, n3[1] = t3[1] * f2, a3.set([NaN, NaN, NaN, NaN, n3[0], n3[1]], 0);
        continue;
      }
      let [r3, o3, l3, c3] = t3;
      r3 *= g2, o3 *= f2, l3 *= g2, c3 *= f2, n3.set([r3, o3, l3, c3], 0), a3.set([NaN, NaN, NaN, NaN, r3, o3], 0);
      for (let e4 = 4; e4 < i3; e4 += 2) {
        const i4 = n3[e4] = t3[e4] * g2, s3 = n3[e4 + 1] = t3[e4 + 1] * f2;
        a3.set(Outline.createBezierPoints(r3, o3, l3, c3, i4, s3), 3 * (e4 - 2)), [r3, o3, l3, c3] = [l3, c3, i4, s3];
      }
    }
    if (0 === d2.length) return null;
    const m2 = r2 ? new ContourDrawOutline() : new InkDrawOutline();
    return m2.build(d2, t2, i2, 1, n2, r2 ? 0 : h2, a2), { outline: m2, newCurves: p2, areContours: r2, thickness: h2, width: l2, height: c2 };
  }
  static async compressSignature({ outlines: e2, areContours: t2, thickness: i2, width: n2, height: a2 }) {
    let s2, r2 = 1 / 0, o2 = -1 / 0, l2 = 0;
    for (const t3 of e2) {
      l2 += t3.length;
      for (let e3 = 2, i3 = t3.length; e3 < i3; e3++) {
        const i4 = t3[e3] - t3[e3 - 2];
        r2 = Math.min(r2, i4), o2 = Math.max(o2, i4);
      }
    }
    s2 = r2 >= -128 && o2 <= 127 ? Int8Array : r2 >= -32768 && o2 <= 32767 ? Int16Array : Int32Array;
    const c2 = e2.length, h2 = 8 + 3 * c2, d2 = new Uint32Array(h2);
    let u2 = 0;
    d2[u2++] = h2 * Uint32Array.BYTES_PER_ELEMENT + (l2 - 2 * c2) * s2.BYTES_PER_ELEMENT, d2[u2++] = 0, d2[u2++] = n2, d2[u2++] = a2, d2[u2++] = t2 ? 0 : 1, d2[u2++] = Math.max(0, Math.floor(i2 ?? 0)), d2[u2++] = c2, d2[u2++] = s2.BYTES_PER_ELEMENT;
    for (const t3 of e2) d2[u2++] = t3.length - 2, d2[u2++] = t3[0], d2[u2++] = t3[1];
    const g2 = new CompressionStream("deflate-raw"), f2 = g2.writable.getWriter();
    await f2.ready, f2.write(d2);
    const p2 = s2.prototype.constructor;
    for (const t3 of e2) {
      const e3 = new p2(t3.length - 2);
      for (let i3 = 2, n3 = t3.length; i3 < n3; i3++) e3[i3 - 2] = t3[i3] - t3[i3 - 2];
      f2.write(e3);
    }
    f2.close();
    const m2 = await new Response(g2.readable).arrayBuffer();
    return toBase64Util(new Uint8Array(m2));
  }
  static async decompressSignature(e2) {
    try {
      const i2 = (t2 = e2, Uint8Array.fromBase64 ? Uint8Array.fromBase64(t2) : stringToBytes(atob(t2))), { readable: n2, writable: a2 } = new DecompressionStream("deflate-raw"), s2 = a2.getWriter();
      await s2.ready, s2.write(i2).then(async () => {
        await s2.ready, await s2.close();
      }).catch(() => {
      });
      let r2 = null, o2 = 0;
      for await (const e3 of n2) r2 ||= new Uint8Array(new Uint32Array(e3.buffer, 0, 4)[0]), r2.set(e3, o2), o2 += e3.length;
      const l2 = new Uint32Array(r2.buffer, 0, r2.length >> 2), c2 = l2[1];
      if (0 !== c2) throw new Error(`Invalid version: ${c2}`);
      const h2 = l2[2], d2 = l2[3], u2 = 0 === l2[4], g2 = l2[5], f2 = l2[6], p2 = l2[7], m2 = [], b2 = (8 + 3 * f2) * Uint32Array.BYTES_PER_ELEMENT;
      let y2;
      switch (p2) {
        case Int8Array.BYTES_PER_ELEMENT:
          y2 = new Int8Array(r2.buffer, b2);
          break;
        case Int16Array.BYTES_PER_ELEMENT:
          y2 = new Int16Array(r2.buffer, b2);
          break;
        case Int32Array.BYTES_PER_ELEMENT:
          y2 = new Int32Array(r2.buffer, b2);
      }
      o2 = 0;
      for (let e3 = 0; e3 < f2; e3++) {
        const t3 = l2[3 * e3 + 8], i3 = new Float32Array(t3 + 2);
        m2.push(i3);
        for (let t4 = 0; t4 < 2; t4++) i3[t4] = l2[3 * e3 + 8 + t4 + 1];
        for (let e4 = 0; e4 < t3; e4++) i3[e4 + 2] = i3[e4] + y2[o2++];
      }
      return { areContours: u2, thickness: g2, outlines: m2, width: h2, height: d2 };
    } catch (e3) {
      return warn(`decompressSignature: ${e3}`), null;
    }
    var t2;
  }
}
class SignatureOptions extends DrawingOptions {
  constructor() {
    super(), super.updateProperties({ fill: AnnotationEditor._defaultLineColor, "stroke-width": 0 });
  }
  clone() {
    const e2 = new SignatureOptions();
    return e2.updateAll(this), e2;
  }
}
class DrawnSignatureOptions extends InkDrawingOptions {
  constructor(e2) {
    super(e2), super.updateProperties({ stroke: AnnotationEditor._defaultLineColor, "stroke-width": 1 });
  }
  clone() {
    const e2 = new DrawnSignatureOptions(this._viewParameters);
    return e2.updateAll(this), e2;
  }
}
class SignatureEditor extends DrawingEditor {
  #oh = false;
  #lh = null;
  #ch = null;
  #hh = null;
  static _type = "signature";
  static _editorType = Hl.SIGNATURE;
  static _defaultDrawingOptions = null;
  constructor(e2) {
    super({ ...e2, mustBeCommitted: true, name: "signatureEditor" }), this._willKeepAspectRatio = true, this.#ch = e2.signatureData || null, this.#lh = null, this.defaultL10nId = "pdfjs-editor-signature-editor1";
  }
  static initialize(e2, t2) {
    AnnotationEditor.initialize(e2, t2), this._defaultDrawingOptions = new SignatureOptions(), this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(t2.viewParameters);
  }
  static getDefaultDrawingOptions(e2) {
    const t2 = this._defaultDrawingOptions.clone();
    return t2.updateProperties(e2), t2;
  }
  static get supportMultipleDrawings() {
    return false;
  }
  static get typesMap() {
    return shadow(this, "typesMap", /* @__PURE__ */ new Map());
  }
  static get isDrawer() {
    return false;
  }
  get telemetryFinalData() {
    return { type: "signature", hasDescription: !!this.#lh };
  }
  static computeTelemetryFinalData(e2) {
    const t2 = e2.get("hasDescription");
    return { hasAltText: t2.get(true) ?? 0, hasNoAltText: t2.get(false) ?? 0 };
  }
  get isResizable() {
    return true;
  }
  onScaleChanging() {
    null !== this._drawId && super.onScaleChanging();
  }
  render() {
    if (this.div) return this.div;
    let e2, t2;
    const { _isCopy: i2 } = this;
    if (i2 && (this._isCopy = false, e2 = this.x, t2 = this.y), super.render(), null === this._drawId) if (this.#ch) {
      const { lines: e3, mustSmooth: t3, areContours: i3, description: n2, uuid: a2, heightInPage: s2 } = this.#ch, { rawDims: { pageWidth: r2, pageHeight: o2 }, rotation: l2 } = this.parent.viewport, c2 = SignatureExtractor.processDrawnLines({ lines: e3, pageWidth: r2, pageHeight: o2, rotation: l2, innerMargin: SignatureEditor._INNER_MARGIN, mustSmooth: t3, areContours: i3 });
      this.addSignature(c2, s2, n2, a2);
    } else this.div.setAttribute("data-l10n-args", JSON.stringify({ description: "" })), this.div.hidden = true, this._uiManager.getSignature(this);
    else this.div.setAttribute("data-l10n-args", JSON.stringify({ description: this.#lh || "" }));
    return i2 && (this._isCopy = true, this._moveAfterPaste(e2, t2)), this.div;
  }
  setUuid(e2) {
    this.#hh = e2, this.addEditToolbar();
  }
  getUuid() {
    return this.#hh;
  }
  get description() {
    return this.#lh;
  }
  set description(e2) {
    this.#lh = e2, this.div && (this.div.setAttribute("data-l10n-args", JSON.stringify({ description: e2 })), super.addEditToolbar().then((t2) => {
      t2?.updateEditSignatureButton(e2);
    }));
  }
  getSignaturePreview() {
    const { newCurves: e2, areContours: t2, thickness: i2, width: n2, height: a2 } = this.#ch, s2 = Math.max(n2, a2);
    return { areContours: t2, outline: SignatureExtractor.processDrawnLines({ lines: { curves: e2.map((e3) => ({ points: e3 })), thickness: i2, width: n2, height: a2 }, pageWidth: s2, pageHeight: s2, rotation: 0, innerMargin: 0, mustSmooth: false, areContours: t2 }).outline };
  }
  get toolbarButtons() {
    return this._uiManager.signatureManager ? [["editSignature", this._uiManager.signatureManager]] : super.toolbarButtons;
  }
  addSignature(e2, t2, i2, n2) {
    const { x: a2, y: s2 } = this, { outline: r2 } = this.#ch = e2;
    let o2;
    this.#oh = r2 instanceof ContourDrawOutline, this.description = i2, this.#oh ? o2 = SignatureEditor.getDefaultDrawingOptions() : (o2 = SignatureEditor._defaultDrawnSignatureOptions.clone(), o2.updateProperties({ "stroke-width": r2.thickness })), this._addOutlines({ drawOutlines: r2, drawingOptions: o2 });
    const [, l2] = this.pageDimensions;
    let c2 = t2 / l2;
    c2 = c2 >= 1 ? 0.5 : c2, this.width *= c2 / this.height, this.width >= 1 && (c2 *= 0.9 / this.width, this.width = 0.9), this.height = c2, this.setDims(), this.x = a2, this.y = s2, this.center(), this._onResized(), this.onScaleChanging(), this.rotate(), this._uiManager.addToAnnotationStorage(this), this.setUuid(n2), this._reportTelemetry({ action: "pdfjs.signature.inserted", data: { hasBeenSaved: !!n2, hasDescription: !!i2 } }), this.div.hidden = false;
  }
  getFromImage(e2) {
    const { rawDims: { pageWidth: t2, pageHeight: i2 }, rotation: n2 } = this.parent.viewport;
    return SignatureExtractor.process(e2, t2, i2, n2, SignatureEditor._INNER_MARGIN);
  }
  getFromText(e2, t2) {
    const { rawDims: { pageWidth: i2, pageHeight: n2 }, rotation: a2 } = this.parent.viewport;
    return SignatureExtractor.extractContoursFromText(e2, t2, i2, n2, a2, SignatureEditor._INNER_MARGIN);
  }
  getDrawnSignature(e2) {
    const { rawDims: { pageWidth: t2, pageHeight: i2 }, rotation: n2 } = this.parent.viewport;
    return SignatureExtractor.processDrawnLines({ lines: e2, pageWidth: t2, pageHeight: i2, rotation: n2, innerMargin: SignatureEditor._INNER_MARGIN, mustSmooth: false, areContours: false });
  }
  createDrawingOptions({ areContours: e2, thickness: t2 }) {
    e2 ? this._drawingOptions = SignatureEditor.getDefaultDrawingOptions() : (this._drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone(), this._drawingOptions.updateProperties({ "stroke-width": t2 }));
  }
  serialize(e2 = false) {
    if (this.isEmpty()) return null;
    const { lines: t2, points: i2 } = this.serializeDraw(e2), { _drawingOptions: { "stroke-width": n2 } } = this, a2 = Object.assign(super.serialize(e2), { isSignature: true, areContours: this.#oh, color: [0, 0, 0], thickness: this.#oh ? 0 : n2 });
    return this.addComment(a2), e2 ? (a2.paths = { lines: t2, points: i2 }, a2.uuid = this.#hh, a2.isCopy = true) : a2.lines = t2, this.#lh && (a2.accessibilityData = { type: "Figure", alt: this.#lh }), a2;
  }
  static deserializeDraw(e2, t2, i2, n2, a2, s2) {
    return s2.areContours ? ContourDrawOutline.deserialize(e2, t2, i2, n2, a2, s2) : InkDrawOutline.deserialize(e2, t2, i2, n2, a2, s2);
  }
  static async deserialize(e2, t2, i2) {
    const n2 = await super.deserialize(e2, t2, i2);
    return n2.#oh = e2.areContours, n2.description = e2.accessibilityData?.alt || "", n2.#hh = e2.uuid, n2;
  }
}
class StampEditor extends AnnotationEditor {
  #dh = null;
  #uh = null;
  #gh = null;
  #fh = null;
  #ph = null;
  #mh = "";
  #bh = null;
  #yh = false;
  #wh = null;
  #Ah = false;
  #xh = false;
  static _type = "stamp";
  static _editorType = Hl.STAMP;
  constructor(e2) {
    super({ ...e2, name: "stampEditor" }), this.#fh = e2.bitmapUrl, this.#ph = e2.bitmapFile, this.defaultL10nId = "pdfjs-editor-stamp-editor";
  }
  static initialize(e2, t2) {
    AnnotationEditor.initialize(e2, t2);
  }
  static isHandlingMimeForPasting(e2) {
    return yc.includes(e2);
  }
  static paste(e2, t2) {
    t2.pasteEditor({ mode: Hl.STAMP }, { bitmapFile: e2.getAsFile() });
  }
  altTextFinish() {
    this._uiManager.useNewAltTextFlow && (this.div.hidden = false), super.altTextFinish();
  }
  get telemetryFinalData() {
    return { type: "stamp", hasAltText: !!this.altTextData?.altText };
  }
  static computeTelemetryFinalData(e2) {
    const t2 = e2.get("hasAltText");
    return { hasAltText: t2.get(true) ?? 0, hasNoAltText: t2.get(false) ?? 0 };
  }
  #Sh(e2, t2 = false) {
    e2 ? (this.#dh = e2.bitmap, t2 || (this.#uh = e2.id, this.#Ah = e2.isSvg), e2.file && (this.#mh = e2.file.name), this.#vh()) : this.remove();
  }
  #Ch() {
    if (this.#gh = null, this._uiManager.enableWaiting(false), this.#bh) if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#dh) this.addEditToolbar().then(() => {
      this._editToolbar.hide(), this._uiManager.editAltText(this, true);
    });
    else {
      if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#dh) {
        this._reportTelemetry({ action: "pdfjs.image.image_added", data: { alt_text_modal: false, alt_text_type: "empty" } });
        try {
          this.mlGuessAltText();
        } catch {
        }
      }
      this.div.focus();
    }
  }
  async mlGuessAltText(e2 = null, t2 = true) {
    if (this.hasAltTextData()) return null;
    const { mlManager: i2 } = this._uiManager;
    if (!i2) throw new Error("No ML.");
    if (!await i2.isEnabledFor("altText")) throw new Error("ML isn't enabled for alt text.");
    const { data: n2, width: a2, height: s2 } = e2 || this.copyCanvas(null, null, true).imageData, r2 = await i2.guess({ name: "altText", request: { data: n2, width: a2, height: s2, channels: n2.length / (a2 * s2) } });
    if (!r2) throw new Error("No response from the AI service.");
    if (r2.error) throw new Error("Error from the AI service.");
    if (r2.cancel) return null;
    if (!r2.output) throw new Error("No valid response from the AI service.");
    const o2 = r2.output;
    return await this.setGuessedAltText(o2), t2 && !this.hasAltTextData() && (this.altTextData = { alt: o2, decorative: false }), o2;
  }
  #kh() {
    if (this.#uh) return this._uiManager.enableWaiting(true), void this._uiManager.imageManager.getFromId(this.#uh).then((e3) => this.#Sh(e3, true)).finally(() => this.#Ch());
    if (this.#fh) {
      const e3 = this.#fh;
      return this.#fh = null, this._uiManager.enableWaiting(true), void (this.#gh = this._uiManager.imageManager.getFromUrl(e3).then((e4) => this.#Sh(e4)).finally(() => this.#Ch()));
    }
    if (this.#ph) {
      const e3 = this.#ph;
      return this.#ph = null, this._uiManager.enableWaiting(true), void (this.#gh = this._uiManager.imageManager.getFromFile(e3).then((e4) => this.#Sh(e4)).finally(() => this.#Ch()));
    }
    const e2 = document.createElement("input");
    e2.type = "file", e2.accept = yc.join(",");
    const t2 = this._uiManager._signal;
    this.#gh = new Promise((i2) => {
      e2.addEventListener("change", async () => {
        if (e2.files && 0 !== e2.files.length) {
          this._uiManager.enableWaiting(true);
          const t3 = await this._uiManager.imageManager.getFromFile(e2.files[0]);
          this._reportTelemetry({ action: "pdfjs.image.image_selected", data: { alt_text_modal: this._uiManager.useNewAltTextFlow } }), this.#Sh(t3);
        } else this.remove();
        i2();
      }, { signal: t2 }), e2.addEventListener("cancel", () => {
        this.remove(), i2();
      }, { signal: t2 });
    }).finally(() => this.#Ch()), e2.click();
  }
  remove() {
    this.#uh && (this.#dh = null, this._uiManager.imageManager.deleteId(this.#uh), this.#bh?.remove(), this.#bh = null, this.#wh && (clearTimeout(this.#wh), this.#wh = null)), super.remove();
  }
  rebuild() {
    this.parent ? (super.rebuild(), null !== this.div && (this.#uh && null === this.#bh && this.#kh(), this.isAttachedToDOM || this.parent.add(this))) : this.#uh && this.#kh();
  }
  onceAdded(e2) {
    this._isDraggable = true, e2 && this.div.focus();
  }
  isEmpty() {
    return !(this.#gh || this.#dh || this.#fh || this.#ph || this.#uh || this.#yh);
  }
  get toolbarButtons() {
    return [["altText", this.createAltText()]];
  }
  get isResizable() {
    return true;
  }
  render() {
    if (this.div) return this.div;
    let e2, t2;
    return this._isCopy && (e2 = this.x, t2 = this.y), super.render(), this.div.hidden = true, this.createAltText(), this.#yh || (this.#dh ? this.#vh() : this.#kh()), this._isCopy && this._moveAfterPaste(e2, t2), this._uiManager.addShouldRescale(this), this.div;
  }
  setCanvas(e2, t2) {
    const { id: i2, bitmap: n2 } = this._uiManager.imageManager.getFromCanvas(e2, t2);
    t2.remove(), i2 && this._uiManager.imageManager.isValidId(i2) && (this.#uh = i2, n2 && (this.#dh = n2), this.#yh = false, this.#vh());
  }
  _onResized() {
    this.onScaleChanging();
  }
  onScaleChanging() {
    if (!this.parent) return;
    null !== this.#wh && clearTimeout(this.#wh);
    this.#wh = setTimeout(() => {
      this.#wh = null, this.#Th();
    }, 200);
  }
  #vh() {
    const { div: e2 } = this;
    let { width: t2, height: i2 } = this.#dh;
    const [n2, a2] = this.pageDimensions, s2 = 0.75;
    if (this.width) t2 = this.width * n2, i2 = this.height * a2;
    else if (t2 > s2 * n2 || i2 > s2 * a2) {
      const e3 = Math.min(s2 * n2 / t2, s2 * a2 / i2);
      t2 *= e3, i2 *= e3;
    }
    this._uiManager.enableWaiting(false);
    const r2 = this.#bh = document.createElement("canvas");
    r2.setAttribute("role", "img"), this.addContainer(r2), this.width = t2 / n2, this.height = i2 / a2, this.setDims(), this._initialOptions?.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && !this.annotationElementId || (e2.hidden = false), this.#Th(), this.#xh || (this.parent.addUndoableEditor(this), this.#xh = true), this._reportTelemetry({ action: "inserted_image" }), this.#mh && this.div.setAttribute("aria-description", this.#mh), this.annotationElementId || this._uiManager.a11yAlert("pdfjs-editor-stamp-added-alert");
  }
  copyCanvas(e2, t2, i2 = false) {
    e2 || (e2 = 224);
    const { width: n2, height: a2 } = this.#dh, s2 = new OutputScale();
    let r2 = this.#dh, o2 = n2, l2 = a2, c2 = null;
    if (t2) {
      if (n2 > t2 || a2 > t2) {
        const e4 = Math.min(t2 / n2, t2 / a2);
        o2 = Math.floor(n2 * e4), l2 = Math.floor(a2 * e4);
      }
      c2 = document.createElement("canvas");
      const e3 = c2.width = Math.ceil(o2 * s2.sx), i3 = c2.height = Math.ceil(l2 * s2.sy);
      this.#Ah || (r2 = this.#Fh(e3, i3));
      const h3 = c2.getContext("2d");
      h3.filter = this._uiManager.hcmFilter;
      let d2 = "white", u2 = "#cfcfd8";
      "none" !== this._uiManager.hcmFilter ? u2 = "black" : ColorScheme.isDarkMode && (d2 = "#8f8f9d", u2 = "#42414d");
      const g2 = 15, f2 = g2 * s2.sx, p2 = g2 * s2.sy, m2 = new OffscreenCanvas(2 * f2, 2 * p2), b2 = m2.getContext("2d");
      b2.fillStyle = d2, b2.fillRect(0, 0, 2 * f2, 2 * p2), b2.fillStyle = u2, b2.fillRect(0, 0, f2, p2), b2.fillRect(f2, p2, f2, p2), h3.fillStyle = h3.createPattern(m2, "repeat"), h3.fillRect(0, 0, e3, i3), h3.drawImage(r2, 0, 0, r2.width, r2.height, 0, 0, e3, i3);
    }
    let h2 = null;
    if (i2) {
      let t3, i3;
      if (s2.symmetric && r2.width < e2 && r2.height < e2) t3 = r2.width, i3 = r2.height;
      else if (r2 = this.#dh, n2 > e2 || a2 > e2) {
        const s3 = Math.min(e2 / n2, e2 / a2);
        t3 = Math.floor(n2 * s3), i3 = Math.floor(a2 * s3), this.#Ah || (r2 = this.#Fh(t3, i3));
      }
      const o3 = new OffscreenCanvas(t3, i3).getContext("2d", { willReadFrequently: true });
      o3.drawImage(r2, 0, 0, r2.width, r2.height, 0, 0, t3, i3), h2 = { width: t3, height: i3, data: o3.getImageData(0, 0, t3, i3).data };
    }
    return { canvas: c2, width: o2, height: l2, imageData: h2 };
  }
  #Fh(e2, t2) {
    const { width: i2, height: n2 } = this.#dh;
    let a2 = i2, s2 = n2, r2 = this.#dh;
    for (; a2 > 2 * e2 || s2 > 2 * t2; ) {
      const i3 = a2, n3 = s2;
      a2 > 2 * e2 && (a2 = a2 >= 16384 ? Math.floor(a2 / 2) - 1 : Math.ceil(a2 / 2)), s2 > 2 * t2 && (s2 = s2 >= 16384 ? Math.floor(s2 / 2) - 1 : Math.ceil(s2 / 2));
      const o2 = new OffscreenCanvas(a2, s2);
      o2.getContext("2d").drawImage(r2, 0, 0, i3, n3, 0, 0, a2, s2), r2 = o2.transferToImageBitmap();
    }
    return r2;
  }
  #Th() {
    const [e2, t2] = this.parentDimensions, { width: i2, height: n2 } = this, a2 = new OutputScale(), s2 = Math.ceil(i2 * e2 * a2.sx), r2 = Math.ceil(n2 * t2 * a2.sy), o2 = this.#bh;
    if (!o2 || o2.width === s2 && o2.height === r2) return;
    o2.width = s2, o2.height = r2;
    const l2 = this.#Ah ? this.#dh : this.#Fh(s2, r2), c2 = o2.getContext("2d");
    c2.filter = this._uiManager.hcmFilter, c2.drawImage(l2, 0, 0, l2.width, l2.height, 0, 0, s2, r2);
  }
  #Ih(e2) {
    if (e2) {
      if (this.#Ah) {
        const e4 = this._uiManager.imageManager.getSvgUrl(this.#uh);
        if (e4) return e4;
      }
      const e3 = document.createElement("canvas");
      ({ width: e3.width, height: e3.height } = this.#dh);
      return e3.getContext("2d").drawImage(this.#dh, 0, 0), e3.toDataURL();
    }
    if (this.#Ah) {
      const [e3, t2] = this.pageDimensions, i2 = Math.round(this.width * e3 * PixelsPerInch.PDF_TO_CSS_UNITS), n2 = Math.round(this.height * t2 * PixelsPerInch.PDF_TO_CSS_UNITS), a2 = new OffscreenCanvas(i2, n2);
      return a2.getContext("2d").drawImage(this.#dh, 0, 0, this.#dh.width, this.#dh.height, 0, 0, i2, n2), a2.transferToImageBitmap();
    }
    return structuredClone(this.#dh);
  }
  static async deserialize(e2, t2, i2) {
    let n2 = null, a2 = false;
    if (e2 instanceof StampAnnotationElement) {
      const { data: { rect: s3, rotation: r3, id: o3, structParent: l3, popupRef: c3, richText: h3, contentsObj: d3, creationDate: u3, modificationDate: g3 }, container: f2, parent: { page: { pageNumber: p2 } }, canvas: m2 } = e2;
      let b2, y2;
      m2 ? (delete e2.canvas, { id: b2, bitmap: y2 } = i2.imageManager.getFromCanvas(f2.id, m2), m2.remove()) : (a2 = true, e2._hasNoCanvas = true);
      const w2 = (await t2._structTree.getAriaAttributes(`${mc}${o3}`))?.get("aria-label") || "";
      n2 = e2 = { annotationType: Hl.STAMP, bitmapId: b2, bitmap: y2, pageIndex: p2 - 1, rect: s3.slice(0), rotation: r3, annotationElementId: o3, id: o3, deleted: false, accessibilityData: { decorative: false, altText: w2 }, isSvg: false, structParent: l3, popupRef: c3, richText: h3, comment: d3?.str || null, creationDate: u3, modificationDate: g3 };
    }
    const s2 = await super.deserialize(e2, t2, i2), { rect: r2, bitmap: o2, bitmapUrl: l2, bitmapId: c2, isSvg: h2, accessibilityData: d2 } = e2;
    a2 ? (i2.addMissingCanvas(e2.id, s2), s2.#yh = true) : c2 && i2.imageManager.isValidId(c2) ? (s2.#uh = c2, o2 && (s2.#dh = o2)) : s2.#fh = l2, s2.#Ah = h2;
    const [u2, g2] = s2.pageDimensions;
    return s2.width = (r2[2] - r2[0]) / u2, s2.height = (r2[3] - r2[1]) / g2, d2 && (s2.altTextData = d2), s2._initialData = n2, e2.comment && s2.setCommentData(e2), s2.#xh = !!n2, s2;
  }
  serialize(e2 = false, t2 = null) {
    if (this.isEmpty()) return null;
    if (this.deleted) return this.serializeDeleted();
    const i2 = Object.assign(super.serialize(e2), { bitmapId: this.#uh, isSvg: this.#Ah });
    if (this.addComment(i2), e2) return i2.bitmapUrl = this.#Ih(true), i2.accessibilityData = this.serializeAltText(true), i2.isCopy = true, i2;
    const { decorative: n2, altText: a2 } = this.serializeAltText(false);
    if (!n2 && a2 && (i2.accessibilityData = { type: "Figure", alt: a2 }), this.annotationElementId) {
      const e3 = this.#ul(i2);
      return e3.isSame ? null : (e3.isSameAltText ? delete i2.accessibilityData : i2.accessibilityData.structParent = this._initialData.structParent ?? -1, i2.id = this.annotationElementId, delete i2.bitmapId, i2);
    }
    if (null === t2) return i2;
    t2.stamps ||= /* @__PURE__ */ new Map();
    const s2 = this.#Ah ? (i2.rect[2] - i2.rect[0]) * (i2.rect[3] - i2.rect[1]) : null;
    if (t2.stamps.has(this.#uh)) {
      if (this.#Ah) {
        const e3 = t2.stamps.get(this.#uh);
        s2 > e3.area && (e3.area = s2, e3.serialized.bitmap.close(), e3.serialized.bitmap = this.#Ih(false));
      }
    } else t2.stamps.set(this.#uh, { area: s2, serialized: i2 }), i2.bitmap = this.#Ih(false);
    return i2;
  }
  #ul(e2) {
    const { pageIndex: t2, accessibilityData: { altText: i2 } } = this._initialData, n2 = e2.pageIndex === t2, a2 = (e2.accessibilityData?.alt || "") === i2;
    return { isSame: !this.hasEditedComment && !this._hasBeenMoved && !this._hasBeenResized && n2 && a2, isSameAltText: a2 };
  }
  renderAnnotationElement(e2) {
    return this.deleted ? (e2.hide(), null) : (e2.updateEdited({ rect: this.getPDFRect(), popup: this.comment }), null);
  }
}
class AnnotationEditorLayer {
  #Ko;
  #Eh = false;
  #Mh = null;
  #Dh = null;
  #Oh = null;
  #_h = /* @__PURE__ */ new Map();
  #Ph = false;
  #Rh = false;
  #Bh = false;
  #Nh = null;
  #Lh = null;
  #Uh = null;
  #jh = null;
  #$h = null;
  #Hh = -1;
  #Tt;
  static _initialized = false;
  static #ei = new Map([FreeTextEditor, InkEditor, StampEditor, HighlightEditor, SignatureEditor].map((e2) => [e2._editorType, e2]));
  constructor({ uiManager: e2, pageIndex: t2, div: i2, structTreeLayer: n2, accessibilityManager: a2, annotationLayer: s2, drawLayer: r2, textLayer: o2, viewport: l2, l10n: c2 }) {
    const h2 = [...AnnotationEditorLayer.#ei.values()];
    if (!AnnotationEditorLayer._initialized) {
      AnnotationEditorLayer._initialized = true;
      for (const t3 of h2) t3.initialize(c2, e2);
    }
    e2.registerEditorTypes(h2), this.#Tt = e2, this.pageIndex = t2, this.div = i2, this.#Ko = a2, this.#Mh = s2, this.viewport = l2, this.#Uh = o2, this.drawLayer = r2, this._structTree = n2, this.#Tt.addLayer(this);
  }
  get isEmpty() {
    return 0 === this.#_h.size;
  }
  get isInvisible() {
    return this.isEmpty && this.#Tt.getMode() === Hl.NONE;
  }
  updateToolbar(e2) {
    this.#Tt.updateToolbar(e2);
  }
  updateMode(e2 = this.#Tt.getMode()) {
    switch (this.#Xh(), e2) {
      case Hl.NONE:
        return this.div.classList.toggle("nonEditing", true), this.disableTextSelection(), this.togglePointerEvents(false), this.toggleAnnotationLayerPointerEvents(true), void this.disableClick();
      case Hl.INK:
        this.disableTextSelection(), this.togglePointerEvents(true), this.enableClick();
        break;
      case Hl.HIGHLIGHT:
        this.enableTextSelection(), this.togglePointerEvents(false), this.disableClick();
        break;
      default:
        this.disableTextSelection(), this.togglePointerEvents(true), this.enableClick();
    }
    this.toggleAnnotationLayerPointerEvents(false);
    const { classList: t2 } = this.div;
    if (t2.toggle("nonEditing", false), e2 === Hl.POPUP) t2.toggle("commentEditing", true);
    else {
      t2.toggle("commentEditing", false);
      for (const i2 of AnnotationEditorLayer.#ei.values()) t2.toggle(`${i2._type}Editing`, e2 === i2._editorType);
    }
    this.div.hidden = false;
  }
  hasTextLayer(e2) {
    return e2 === this.#Uh?.div;
  }
  setEditingState(e2) {
    this.#Tt.setEditingState(e2);
  }
  addCommands(e2) {
    this.#Tt.addCommands(e2);
  }
  cleanUndoStack(e2) {
    this.#Tt.cleanUndoStack(e2);
  }
  toggleDrawing(e2 = false) {
    this.div.classList.toggle("drawing", !e2);
  }
  togglePointerEvents(e2 = false) {
    this.div.classList.toggle("disabled", !e2);
  }
  toggleAnnotationLayerPointerEvents(e2 = false) {
    this.#Mh?.div.classList.toggle("disabled", !e2);
  }
  get #qh() {
    return 0 !== this.#_h.size ? this.#_h.values() : this.#Tt.getEditors(this.pageIndex);
  }
  async enable() {
    this.#Bh = true, this.div.tabIndex = 0, this.togglePointerEvents(true), this.div.classList.toggle("nonEditing", false), this.#$h?.abort(), this.#$h = null;
    const e2 = /* @__PURE__ */ new Set();
    for (const t3 of this.#qh) t3.enableEditing(), t3.show(true), t3.annotationElementId && (this.#Tt.removeChangedExistingAnnotation(t3), e2.add(t3.annotationElementId));
    const t2 = this.#Mh;
    if (t2) for (const i2 of t2.getEditableAnnotations()) {
      if (i2.hide(), this.#Tt.isDeletedAnnotationElement(i2.data.id)) continue;
      if (e2.has(i2.data.id)) continue;
      const t3 = await this.deserialize(i2);
      t3 && (this.addOrRebuild(t3), t3.enableEditing());
    }
    this.#Bh = false, this.#Tt._eventBus.dispatch("editorsrendered", { source: this, pageNumber: this.pageIndex + 1 });
  }
  disable() {
    if (this.#Rh = true, this.div.tabIndex = -1, this.togglePointerEvents(false), this.div.classList.toggle("nonEditing", true), this.#Uh && !this.#$h) {
      this.#$h = new AbortController();
      const e3 = this.#Tt.combinedSignal(this.#$h);
      this.#Uh.div.addEventListener("pointerdown", (e4) => {
        const { clientX: t3, clientY: i2, timeStamp: n2 } = e4;
        if (n2 - this.#Hh > 500) return void (this.#Hh = n2);
        this.#Hh = -1;
        const { classList: a2 } = this.div;
        a2.toggle("getElements", true);
        const s2 = document.elementsFromPoint(t3, i2);
        if (a2.toggle("getElements", false), !this.div.contains(s2[0])) return;
        let r2;
        const o2 = new RegExp(`^${$l}[0-9]+$`);
        for (const e5 of s2) if (o2.test(e5.id)) {
          r2 = e5.id;
          break;
        }
        if (!r2) return;
        const l2 = this.#_h.get(r2);
        null === l2?.annotationElementId && (e4.stopPropagation(), e4.preventDefault(), l2.dblclick(e4));
      }, { signal: e3, capture: true });
    }
    const e2 = this.#Mh;
    if (e2) {
      const t3 = /* @__PURE__ */ new Map(), i2 = /* @__PURE__ */ new Map();
      for (const n3 of this.#qh) n3.disableEditing(), n3.annotationElementId ? null === n3.serialize() ? (i2.set(n3.annotationElementId, n3), this.getEditableAnnotation(n3.annotationElementId)?.show(), n3.remove()) : t3.set(n3.annotationElementId, n3) : n3.updateFakeAnnotationElement(e2);
      const n2 = e2.getEditableAnnotations();
      for (const e3 of n2) {
        const { id: n3 } = e3.data;
        if (this.#Tt.isDeletedAnnotationElement(n3)) {
          e3.updateEdited({ deleted: true });
          continue;
        }
        let a2 = i2.get(n3);
        a2 ? (a2.resetAnnotationElement(e3), a2.show(false), e3.show()) : (a2 = t3.get(n3), a2 && (this.#Tt.addChangedExistingAnnotation(a2), a2.renderAnnotationElement(e3) && a2.show(false)), e3.show());
      }
    }
    this.#Xh(), this.isEmpty && (this.div.hidden = true);
    const { classList: t2 } = this.div;
    for (const e3 of AnnotationEditorLayer.#ei.values()) t2.remove(`${e3._type}Editing`);
    this.disableTextSelection(), this.toggleAnnotationLayerPointerEvents(true), this.#Rh = false;
  }
  getEditableAnnotation(e2) {
    return this.#Mh?.getEditableAnnotation(e2) || null;
  }
  setActiveEditor(e2) {
    this.#Tt.getActive() !== e2 && this.#Tt.setActiveEditor(e2);
  }
  enableTextSelection() {
    if (this.div.tabIndex = -1, this.#Uh?.div && !this.#jh) {
      this.#jh = new AbortController();
      const e2 = this.#Tt.combinedSignal(this.#jh);
      this.#Uh.div.addEventListener("pointerdown", this.#zh.bind(this), { signal: e2 }), this.#Uh.div.classList.add("highlighting");
    }
  }
  disableTextSelection() {
    this.div.tabIndex = 0, this.#Uh?.div && this.#jh && (this.#jh.abort(), this.#jh = null, this.#Uh.div.classList.remove("highlighting"));
  }
  #zh(e2) {
    this.#Tt.unselectAll();
    const { target: t2 } = e2;
    if (t2 === this.#Uh.div || ("img" === t2.getAttribute("role") || t2.classList.contains("endOfContent")) && this.#Uh.div.contains(t2)) {
      const { isMac: t3 } = util_FeatureTest.platform;
      if (0 !== e2.button || e2.ctrlKey && t3) return;
      this.#Tt.showAllEditors("highlight", true, true), this.#Uh.div.classList.add("free"), this.toggleDrawing(), HighlightEditor.startHighlighting(this, "ltr" === this.#Tt.direction, { target: this.#Uh.div, x: e2.x, y: e2.y }), this.#Uh.div.addEventListener("pointerup", () => {
        this.#Uh.div.classList.remove("free"), this.toggleDrawing(true);
      }, { once: true, signal: this.#Tt._signal }), e2.preventDefault();
    }
  }
  enableClick() {
    if (this.#Dh) return;
    this.#Dh = new AbortController();
    const e2 = this.#Tt.combinedSignal(this.#Dh);
    this.div.addEventListener("pointerdown", this.pointerdown.bind(this), { signal: e2 });
    const t2 = this.pointerup.bind(this);
    this.div.addEventListener("pointerup", t2, { signal: e2 }), this.div.addEventListener("pointercancel", t2, { signal: e2 });
  }
  disableClick() {
    this.#Dh?.abort(), this.#Dh = null;
  }
  attach(e2) {
    this.#_h.set(e2.id, e2);
    const { annotationElementId: t2 } = e2;
    t2 && this.#Tt.isDeletedAnnotationElement(t2) && this.#Tt.removeDeletedAnnotationElement(e2);
  }
  detach(e2) {
    this.#_h.delete(e2.id), this.#Ko?.removePointerInTextLayer(e2.contentDiv), !this.#Rh && e2.annotationElementId && this.#Tt.addDeletedAnnotationElement(e2);
  }
  remove(e2) {
    this.detach(e2), this.#Tt.removeEditor(e2), e2.div.remove(), e2.isAttachedToDOM = false;
  }
  changeParent(e2) {
    e2.parent !== this && (e2.parent && e2.annotationElementId && (this.#Tt.addDeletedAnnotationElement(e2.annotationElementId), AnnotationEditor.deleteAnnotationElement(e2), e2.annotationElementId = null), this.attach(e2), e2.parent?.detach(e2), e2.setParent(this), e2.div && e2.isAttachedToDOM && (e2.div.remove(), this.div.append(e2.div)));
  }
  add(e2) {
    if (e2.parent !== this || !e2.isAttachedToDOM) {
      if (this.changeParent(e2), this.#Tt.addEditor(e2), this.attach(e2), !e2.isAttachedToDOM) {
        const t2 = e2.render();
        this.div.append(t2), e2.isAttachedToDOM = true;
      }
      e2.fixAndSetPosition(), e2.onceAdded(!this.#Bh), this.#Tt.addToAnnotationStorage(e2), e2._reportTelemetry(e2.telemetryInitialData);
    }
  }
  moveEditorInDOM(e2) {
    if (!e2.isAttachedToDOM) return;
    const { activeElement: t2 } = document;
    e2.div.contains(t2) && !this.#Oh && (e2._focusEventsAllowed = false, this.#Oh = setTimeout(() => {
      this.#Oh = null, e2.div.contains(document.activeElement) ? e2._focusEventsAllowed = true : (e2.div.addEventListener("focusin", () => {
        e2._focusEventsAllowed = true;
      }, { once: true, signal: this.#Tt._signal }), t2.focus());
    }, 0)), e2._structTreeParentId = this.#Ko?.moveElementInDOM(this.div, e2.div, e2.contentDiv, true);
  }
  addOrRebuild(e2) {
    e2.needsToBeRebuilt() ? (e2.parent ||= this, e2.rebuild(), e2.show()) : this.add(e2);
  }
  addUndoableEditor(e2) {
    this.addCommands({ cmd: () => e2._uiManager.rebuild(e2), undo: () => {
      e2.remove();
    }, mustExec: false });
  }
  getEditorByUID(e2) {
    for (const t2 of this.#_h.values()) if (t2.uid === e2) return t2;
    return null;
  }
  getNextId() {
    return this.#Tt.getId();
  }
  get #Wh() {
    return AnnotationEditorLayer.#ei.get(this.#Tt.getMode());
  }
  combinedSignal(e2) {
    return this.#Tt.combinedSignal(e2);
  }
  #Gh(e2) {
    const t2 = this.#Wh;
    return t2 ? new t2.prototype.constructor(e2) : null;
  }
  canCreateNewEmptyEditor() {
    return this.#Wh?.canCreateNewEmptyEditor();
  }
  async pasteEditor(e2, t2) {
    this.updateToolbar(e2), await this.#Tt.updateMode(e2.mode);
    const { offsetX: i2, offsetY: n2 } = this.#Vh(), a2 = this.getNextId(), s2 = this.#Gh({ parent: this, id: a2, x: i2, y: n2, uiManager: this.#Tt, isCentered: true, ...t2 });
    s2 && this.add(s2);
  }
  async deserialize(e2) {
    return await AnnotationEditorLayer.#ei.get(e2.annotationType ?? e2.annotationEditorType)?.deserialize(e2, this, this.#Tt) || null;
  }
  createAndAddNewEditor(e2, t2, i2 = {}) {
    const n2 = this.getNextId(), a2 = this.#Gh({ parent: this, id: n2, x: e2.offsetX, y: e2.offsetY, uiManager: this.#Tt, isCentered: t2, ...i2 });
    return a2 && this.add(a2), a2;
  }
  get boundingClientRect() {
    return this.div.getBoundingClientRect();
  }
  #Vh() {
    const { x: e2, y: t2, width: i2, height: n2 } = this.boundingClientRect, a2 = Math.max(0, e2), s2 = Math.max(0, t2), r2 = (a2 + Math.min(window.innerWidth, e2 + i2)) / 2 - e2, o2 = (s2 + Math.min(window.innerHeight, t2 + n2)) / 2 - t2, [l2, c2] = this.viewport.rotation % 180 == 0 ? [r2, o2] : [o2, r2];
    return { offsetX: l2, offsetY: c2 };
  }
  addNewEditor(e2 = {}) {
    this.createAndAddNewEditor(this.#Vh(), true, e2);
  }
  setSelected(e2) {
    this.#Tt.setSelected(e2);
  }
  toggleSelected(e2) {
    this.#Tt.toggleSelected(e2);
  }
  unselect(e2) {
    this.#Tt.unselect(e2);
  }
  pointerup(e2) {
    const { isMac: t2 } = util_FeatureTest.platform;
    if (0 !== e2.button || e2.ctrlKey && t2) return;
    if (e2.target !== this.div) return;
    if (!this.#Ph) return;
    if (this.#Ph = false, this.#Wh?.isDrawer && this.#Wh.supportMultipleDrawings) return;
    if (!this.#Eh) return void (this.#Eh = true);
    const i2 = this.#Tt.getMode();
    i2 !== Hl.STAMP && i2 !== Hl.SIGNATURE ? this.createAndAddNewEditor(e2, false) : this.#Tt.unselectAll();
  }
  pointerdown(e2) {
    if (this.#Tt.getMode() === Hl.HIGHLIGHT && this.enableTextSelection(), this.#Ph) return void (this.#Ph = false);
    const { isMac: t2 } = util_FeatureTest.platform;
    if (0 !== e2.button || e2.ctrlKey && t2) return;
    if (e2.target !== this.div) return;
    if (this.#Ph = true, this.#Wh?.isDrawer) return void this.startDrawingSession(e2);
    const i2 = this.#Tt.getActive();
    this.#Eh = !i2 || i2.isEmpty();
  }
  startDrawingSession(e2) {
    if (this.div.focus({ preventScroll: true }), this.#Nh) return void this.#Wh.startDrawing(this, this.#Tt, false, e2);
    this.#Tt.setCurrentDrawingSession(this), this.#Nh = new AbortController();
    const t2 = this.#Tt.combinedSignal(this.#Nh);
    this.div.addEventListener("blur", ({ relatedTarget: e3 }) => {
      e3 && !this.div.contains(e3) && (this.#Lh = null, this.commitOrRemove());
    }, { signal: t2 }), this.#Wh.startDrawing(this, this.#Tt, false, e2);
  }
  pause(e2) {
    if (e2) {
      const { activeElement: e3 } = document;
      return void (this.div.contains(e3) && (this.#Lh = e3));
    }
    this.#Lh && setTimeout(() => {
      this.#Lh?.focus(), this.#Lh = null;
    }, 0);
  }
  endDrawingSession(e2 = false) {
    return this.#Nh ? (this.#Tt.setCurrentDrawingSession(null), this.#Nh.abort(), this.#Nh = null, this.#Lh = null, this.#Wh.endDrawing(e2)) : null;
  }
  findNewParent(e2, t2, i2) {
    const n2 = this.#Tt.findParent(t2, i2);
    return null !== n2 && n2 !== this && (n2.changeParent(e2), true);
  }
  commitOrRemove() {
    return !!this.#Nh && (this.endDrawingSession(), true);
  }
  onScaleChanging() {
    this.#Nh && this.#Wh.onScaleChangingWhenDrawing(this);
  }
  destroy() {
    this.commitOrRemove(), this.#Tt.getActive()?.parent === this && (this.#Tt.commitOrRemove(), this.#Tt.setActiveEditor(null)), this.#Oh && (clearTimeout(this.#Oh), this.#Oh = null);
    for (const e2 of this.#_h.values()) this.#Ko?.removePointerInTextLayer(e2.contentDiv), e2.setParent(null), e2.isAttachedToDOM = false, e2.div.remove();
    this.div = null, this.#_h.clear(), this.#Tt.removeLayer(this);
  }
  #Xh() {
    for (const e2 of this.#_h.values()) e2.isEmpty() && e2.remove();
  }
  render({ viewport: e2 }) {
    this.viewport = e2, setLayerDimensions(this.div, e2);
    for (const e3 of this.#Tt.getEditors(this.pageIndex)) this.add(e3), e3.rebuild();
    this.updateMode();
  }
  update({ viewport: e2 }) {
    this.#Tt.commitOrRemove(), this.#Xh();
    const t2 = this.viewport.rotation, i2 = e2.rotation;
    if (this.viewport = e2, setLayerDimensions(this.div, { rotation: i2 }), t2 !== i2) for (const e3 of this.#_h.values()) e3.rotate(i2);
  }
  get pageDimensions() {
    const { pageWidth: e2, pageHeight: t2 } = this.viewport.rawDims;
    return [e2, t2];
  }
  get scale() {
    return this.#Tt.viewParameters.realScale;
  }
}
class DrawLayer {
  #wo = null;
  #Kh = /* @__PURE__ */ new Map();
  #Yh = /* @__PURE__ */ new Map();
  static #Mt = 0;
  constructor({ pageIndex: e2 }) {
    this.pageIndex = e2;
  }
  setParent(e2) {
    if (this.#wo) {
      if (this.#wo !== e2) {
        if (this.#Kh.size > 0) for (const t2 of this.#Kh.values()) t2.remove(), e2.append(t2);
        this.#wo = e2;
      }
    } else this.#wo = e2;
  }
  static get _svgFactory() {
    return shadow(this, "_svgFactory", new DOMSVGFactory());
  }
  static #Jh(e2, [t2, i2, n2, a2]) {
    const { style: s2 } = e2;
    s2.top = 100 * i2 + "%", s2.left = 100 * t2 + "%", s2.width = 100 * n2 + "%", s2.height = 100 * a2 + "%";
  }
  #Zh() {
    const e2 = DrawLayer._svgFactory.create(1, 1, true);
    return this.#wo.append(e2), e2.setAttribute("aria-hidden", true), e2;
  }
  #Qh(e2, t2) {
    const i2 = DrawLayer._svgFactory.createElement("clipPath");
    e2.append(i2);
    const n2 = `clip_${t2}`;
    i2.setAttribute("id", n2), i2.setAttribute("clipPathUnits", "objectBoundingBox");
    const a2 = DrawLayer._svgFactory.createElement("use");
    return i2.append(a2), a2.setAttribute("href", `#${t2}`), a2.classList.add("clip"), n2;
  }
  #ed(e2, t2) {
    for (const [i2, n2] of Object.entries(t2)) null === n2 ? e2.removeAttribute(i2) : e2.setAttribute(i2, n2);
  }
  draw(e2, t2 = false, i2 = false) {
    const n2 = DrawLayer.#Mt++, a2 = this.#Zh(), s2 = DrawLayer._svgFactory.createElement("defs");
    a2.append(s2);
    const r2 = DrawLayer._svgFactory.createElement("path");
    s2.append(r2);
    const o2 = `path_p${this.pageIndex}_${n2}`;
    r2.setAttribute("id", o2), r2.setAttribute("vector-effect", "non-scaling-stroke"), t2 && this.#Yh.set(n2, r2);
    const l2 = i2 ? this.#Qh(s2, o2) : null, c2 = DrawLayer._svgFactory.createElement("use");
    return a2.append(c2), c2.setAttribute("href", `#${o2}`), this.updateProperties(a2, e2), this.#Kh.set(n2, a2), { id: n2, clipPathId: `url(#${l2})` };
  }
  drawOutline(e2, t2) {
    const i2 = DrawLayer.#Mt++, n2 = this.#Zh(), a2 = DrawLayer._svgFactory.createElement("defs");
    n2.append(a2);
    const s2 = DrawLayer._svgFactory.createElement("path");
    a2.append(s2);
    const r2 = `path_p${this.pageIndex}_${i2}`;
    let o2;
    if (s2.setAttribute("id", r2), s2.setAttribute("vector-effect", "non-scaling-stroke"), t2) {
      const e3 = DrawLayer._svgFactory.createElement("mask");
      a2.append(e3), o2 = `mask_p${this.pageIndex}_${i2}`, e3.setAttribute("id", o2), e3.setAttribute("maskUnits", "objectBoundingBox");
      const t3 = DrawLayer._svgFactory.createElement("rect");
      e3.append(t3), t3.setAttribute("width", "1"), t3.setAttribute("height", "1"), t3.setAttribute("fill", "white");
      const n3 = DrawLayer._svgFactory.createElement("use");
      e3.append(n3), n3.setAttribute("href", `#${r2}`), n3.setAttribute("stroke", "none"), n3.setAttribute("fill", "black"), n3.setAttribute("fill-rule", "nonzero"), n3.classList.add("mask");
    }
    const l2 = DrawLayer._svgFactory.createElement("use");
    n2.append(l2), l2.setAttribute("href", `#${r2}`), o2 && l2.setAttribute("mask", `url(#${o2})`);
    const c2 = l2.cloneNode();
    return n2.append(c2), l2.classList.add("mainOutline"), c2.classList.add("secondaryOutline"), this.updateProperties(n2, e2), this.#Kh.set(i2, n2), i2;
  }
  finalizeDraw(e2, t2) {
    this.#Yh.delete(e2), this.updateProperties(e2, t2);
  }
  updateProperties(e2, t2) {
    if (!t2) return;
    const { root: i2, bbox: n2, rootClass: a2, path: s2 } = t2, r2 = "number" == typeof e2 ? this.#Kh.get(e2) : e2;
    if (r2) {
      if (i2 && this.#ed(r2, i2), n2 && DrawLayer.#Jh(r2, n2), a2) {
        const { classList: e3 } = r2;
        for (const [t3, i3] of Object.entries(a2)) e3.toggle(t3, i3);
      }
      if (s2) {
        const e3 = r2.firstChild.firstChild;
        this.#ed(e3, s2);
      }
    }
  }
  updateParent(e2, t2) {
    if (t2 === this) return;
    const i2 = this.#Kh.get(e2);
    i2 && (t2.#wo.append(i2), this.#Kh.delete(e2), t2.#Kh.set(e2, i2));
  }
  remove(e2) {
    this.#Yh.delete(e2), null !== this.#wo && (this.#Kh.get(e2).remove(), this.#Kh.delete(e2));
  }
  destroy() {
    this.#wo = null;
    for (const e2 of this.#Kh.values()) e2.remove();
    this.#Kh.clear(), this.#Yh.clear();
  }
}
globalThis._pdfjsTestingUtils = { HighlightOutliner }, globalThis.pdfjsLib = { AbortException, AnnotationEditorLayer, AnnotationEditorParamsType: Xl, AnnotationEditorType: Hl, AnnotationEditorUIManager, AnnotationLayer, AnnotationMode: jl, AnnotationType: Zl, applyOpacity, build: hh, ColorPicker, createValidAbsoluteUrl, CSSConstants, DOMSVGFactory, DrawLayer, FeatureTest: util_FeatureTest, fetchData, findContrastColor, getDocument, getFilenameFromUrl, getPdfFilenameFromUrl, getRGB, getUuid, getXfaPageViewport, GlobalWorkerOptions, ImageKind: Jl, InvalidPDFException, isDataScheme, isPdfFile, isValidExplicitDest: Cc, MathClamp, noContextMenu, normalizeUnicode, OPS: sc, OutputScale, PasswordResponses: hc, PDFDataRangeTransport, PDFDateString, PDFWorker, PermissionFlag: ql, PixelsPerInch, RenderingCancelledException, renderRichText, ResponseException, setLayerDimensions, shadow, SignatureExtractor, stopEvent, SupportedImageMimeTypes: yc, TextLayer, TouchManager, updateUrlHash, Util, VerbosityLevel: ac, version: lh, XfaLayer };
export {
  AbortException,
  AnnotationEditorLayer,
  Xl as AnnotationEditorParamsType,
  Hl as AnnotationEditorType,
  AnnotationEditorUIManager,
  AnnotationLayer,
  jl as AnnotationMode,
  Zl as AnnotationType,
  CSSConstants,
  ColorPicker,
  DOMSVGFactory,
  DrawLayer,
  util_FeatureTest as FeatureTest,
  GlobalWorkerOptions,
  Jl as ImageKind,
  InvalidPDFException,
  MathClamp,
  sc as OPS,
  OutputScale,
  PDFDataRangeTransport,
  PDFDateString,
  PDFWorker,
  hc as PasswordResponses,
  ql as PermissionFlag,
  PixelsPerInch,
  RenderingCancelledException,
  ResponseException,
  SignatureExtractor,
  yc as SupportedImageMimeTypes,
  TextLayer,
  TouchManager,
  Util,
  ac as VerbosityLevel,
  XfaLayer,
  applyOpacity,
  hh as build,
  createValidAbsoluteUrl,
  fetchData,
  findContrastColor,
  getDocument,
  getFilenameFromUrl,
  getPdfFilenameFromUrl,
  getRGB,
  getUuid,
  getXfaPageViewport,
  isDataScheme,
  isPdfFile,
  Cc as isValidExplicitDest,
  noContextMenu,
  normalizeUnicode,
  renderRichText,
  setLayerDimensions,
  shadow,
  stopEvent,
  updateUrlHash,
  lh as version
};
